# -----------------------------------------------------------------------------------
# Version: 0.2.0 (Public Experimental Snapshot - 15th Release | May 17, 2025)
# -----------------------------------------------------------------------------------




import builtins

import os
import re
import tkinter as tk
from tkinter import ttk
from tkinter import font
from tkinter import messagebox, filedialog
from tkinter import scrolledtext

from PIL import Image, ImageTk
import concurrent.futures
import threading
import math
import subprocess
import sys
import glob
import time
import shutil
import psutil
import itertools
import json
from pathlib import Path
from datetime import datetime
import importlib.util
import functools
import zipfile
import gc
import inspect
import random
import traceback

#from memory_profiler import profile  

from collections import OrderedDict


import pydirectinput
import win32gui
import win32con
import win32api
import win32process

import win32com.client # For COM objects
import pythoncom       # For COM initialization/uninitialization
from win32com.shell import shell, shellcon # For getting Desktop path



import ctypes
import pywintypes

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler


from threading import Thread
import queue


from modules.config_processors import (
    run_configpicextractor_custom_integrated,
    run_mod_command_line_config_gen_custom_integrated,
    run_modify_output_good_integrated,
    process_lines,
    reorder_output_good
)

from modules.event_handlers import (
    ModZipEventHandler,
    CustomFileEventHandler
)

from modules.ui_helpers import (
    on_floating_window_unmapped,
    destroy_floating_button_window,
    hide_floating_window,
    show_floating_window,
    focus_config_viewer_from_floating_button,
    remember_floating_window_position,
    load_floating_window_position,
    save_floating_window_position,
    create_floating_button_window,
    on_floating_window_mapped,
    toggle_floating_window_visibility
)

from modules.resize_and_scroll import (
    throttled_resize,
    on_resize_complete,
    on_mousewheel_main,
    on_mousewheel_details,
    ease_out_quintic_modified_speed,
    start_scroll_debounce_timer_main_grid,
    on_scroll_debounce_complete_main_grid,
    on_scroll_debounce_complete_main_grid_unhide_mouse,
    is_descendant_of,
    start_smooth_scroll_main,
    start_smooth_scroll_details,
    animate_scroll_main,
    animate_scroll_details,
    calculate_columns_for_width,
    animate_scroll_search_results
)


from modules.colorchange import (
    create_color_picker_window,
)

# ------------------------------------------------------------
#  First time initialization
# ------------------------------------------------------------


def create_desktop_shortcut_pywin32(script_dir, bat_filename, shortcut_name, icon_filename=None, description=""):

    target_bat_path = script_dir / bat_filename
    shortcut_filename = f"{shortcut_name}.lnk"

    # --- Verify target .bat file exists ---
    if not target_bat_path.is_file():
        # Use a temporary root for messagebox if main one isn't ready
        temp_root = tk.Tk()
        temp_root.withdraw()
        # Attempt to set icon for the error messagebox
        icon_path_for_msgbox_str = None
        if icon_filename:
             icon_path_obj = script_dir / icon_filename
             if icon_path_obj.is_file():
                 icon_path_for_msgbox_str = str(icon_path_obj.resolve())
        if icon_path_for_msgbox_str:
            try:
                temp_root.iconbitmap(icon_path_for_msgbox_str)
            except tk.TclError:
                print(f"Warning: Could not set iconbitmap for error messagebox.")
        messagebox.showerror("Error", f"Target batch file not found:\n{target_bat_path}", parent=temp_root)
        temp_root.destroy()
        return False

    # --- Construct and verify icon path if provided ---
    icon_path = None
    icon_path_for_msgbox_str = None # Also store for internal messageboxes
    if icon_filename:
        icon_path_obj = script_dir / icon_filename # icon_filename is relative path like "data/icon.ico"
        if icon_path_obj.is_file():
            icon_path = str(icon_path_obj.resolve()) # Use absolute path for shortcut icon
            icon_path_for_msgbox_str = icon_path # Use same path for messagebox icon
            print(f"Using icon: {icon_path}")
        else:
            # Use a temporary root for messagebox
            temp_root = tk.Tk()
            temp_root.withdraw()
            # Set icon for this temporary root if possible (redundant here as icon wasn't found, but good practice)
            # We won't have icon_path_for_msgbox_str here if the file is missing
            messagebox.showwarning("Warning", f"Icon file not found:\n{icon_path_obj}\nShortcut will use default icon.", parent=temp_root)
            temp_root.destroy()
            # Keep icon_path as None

    try:
        # --- Get Desktop Path using COM ---
        try:
            pythoncom.CoInitialize()
            com_initialized_here = True
        except pythoncom.com_error: # Already initialized
            com_initialized_here = False

        try:
            desktop_path_str = shell.SHGetFolderPath(0, shellcon.CSIDL_DESKTOP, None, 0)
            desktop_path = Path(desktop_path_str)
            shortcut_path = str(desktop_path / shortcut_filename)

            print(f"Script Directory: {script_dir}")
            print(f"Target BAT Path: {target_bat_path}")
            print(f"Shortcut Path: {shortcut_path}")
            print(f"Working Directory: {str(script_dir)}")

            # --- Create Shortcut using COM ---
            shell_obj = win32com.client.Dispatch("WScript.Shell")
            shortcut = shell_obj.CreateShortcut(shortcut_path)
            shortcut.TargetPath = str(target_bat_path.resolve())
            shortcut.Arguments = ""
            shortcut.Description = description
            shortcut.WorkingDirectory = str(script_dir)
            shortcut.WindowStyle = 1

            if icon_path:
                shortcut.IconLocation = f"{icon_path},0"

            shortcut.Save()
            print("Shortcut created successfully.")
            return True
        except Exception as e:
            # Use a temporary root for messagebox
            temp_root = tk.Tk()
            temp_root.withdraw()
            # Attempt to set icon for the error messagebox
            if icon_path_for_msgbox_str:
                 try:
                     temp_root.iconbitmap(icon_path_for_msgbox_str)
                 except tk.TclError:
                     print(f"Warning: Could not set iconbitmap for error messagebox.")
            messagebox.showerror("Shortcut Error", f"Failed to create shortcut using COM:\n{e}", parent=temp_root)
            temp_root.destroy()
            return False
        finally:
            if com_initialized_here:
                pythoncom.CoUninitialize()

    except Exception as e:
        # Use a temporary root for messagebox
        temp_root = tk.Tk()
        temp_root.withdraw()
        # Attempt to set icon for the error messagebox
        if icon_path_for_msgbox_str:
             try:
                 temp_root.iconbitmap(icon_path_for_msgbox_str)
             except tk.TclError:
                 print(f"Warning: Could not set iconbitmap for error messagebox.")
        messagebox.showerror("Error", f"An unexpected error occurred:\n{e}", parent=temp_root)
        temp_root.destroy()
        return False



# NEW Helper function to scan for mod zip files
def scan_folders_for_mod_zips(folders_list):
    """
    Scans a list of folders for .zip files and returns a dictionary of {filepath: modification_timestamp}.
    """
    all_zip_files = {}
    extensions = ['.zip']
    for folder_path in folders_list: # Iterate through list of folders
        if not folder_path or not os.path.isdir(folder_path):
            continue # Skip invalid folders, but continue checking others
        for root, _, files in os.walk(folder_path):
            for file in files:
                if any(file.lower().endswith(ext) for ext in extensions):
                    filepath = os.path.join(root, file)
                    normalized_filepath = os.path.normpath(filepath).lower().replace('\\', '/') # Normalize path
                    try:
                        all_zip_files[normalized_filepath] = os.path.getmtime(filepath)
                        #print(f"DEBUG: scan_folders_for_mod_zips - Found ZIP: {filepath}, Timestamp: {all_zip_files[normalized_filepath]}") # DEBUG
                    except OSError: # Handle cases where file might be inaccessible
                        print(f"Warning: Could not get modification time for {filepath}. Skipping.")
    return all_zip_files



def scan_folder_for_watched_files(folder_path):
    """
    Recursively scans a folder, normalizes file paths to lowercase and forward slashes,
    and returns a dictionary of {normalized_filepath: modification_timestamp}.
    """
    file_list = {}
    if not folder_path or not os.path.isdir(folder_path):
        return file_list # Return empty dict for invalid folder

    extensions = ['.pc', '.png', '.jpg', '.jpeg']
    for root, _, files in os.walk(folder_path):
        for file in files:
            if any(file.lower().endswith(ext) for ext in extensions):
                filepath = os.path.join(root, file)
                normalized_filepath = os.path.normpath(filepath).lower().replace('\\', '/') # Normalize path
                try:
                    file_list[normalized_filepath] = os.path.getmtime(filepath)
                except OSError: # Handle cases where file might be inaccessible
                    print(f"Warning: Could not get modification time for {filepath}. Skipping.")
    return file_list


def regenerate_matches_files(app_instance, script_dir, config_info_folder):
    """
    Deletes matches.txt and matches_config.txt and regenerates them.

    Args:
        app_instance: An instance of the ConfigViewerApp class.  <--- NEW ARGUMENT
        script_dir: Path to the script's directory where matches.txt and matches_config.txt are located.
        config_info_folder: Path to the ConfigInfo folder containing JSON files, needed for regeneration.
    """
    matches_file_path = os.path.join(script_dir, "data/Matches.txt")
    matches_config_file_path = os.path.join(script_dir, "data/matches_config.txt")

    # Delete matches.txt if it exists
    if os.path.exists(matches_file_path):
        try:
            os.remove(matches_file_path)
            print(f"Deleted: {matches_file_path}")
        except Exception as e:
            print(f"Error deleting {matches_file_path}: {e}")
    else:
        print(f"{matches_file_path} does not exist, skipping deletion.")

    # Delete matches_config.txt if it exists
    if os.path.exists(matches_config_file_path):
        try:
            os.remove(matches_config_file_path)
            print(f"Deleted: {matches_config_file_path}")
        except Exception as e:
            print(f"Error deleting {matches_config_file_path}: {e}")
    else:
        print(f"{matches_config_file_path} does not exist, skipping deletion.")



# 1.  read_watcher_output function definition -  <-- PLACE THIS FIRST
# Modified read_watcher_output function (for Option 2)
# Modified read_watcher_output function (FULLY MANUAL parsing - NO configparser)
# Modified read_watcher_output function (for MOD ZIP FILES)
# ------------------------------------------------------------
# Modified read_watcher_output function (to include VanillaFiles)
# ------------------------------------------------------------
def read_watcher_output(file_path):
    """
    Reads WatcherOutput.txt, now also getting lists of mod zip files, vanilla zip files,
    and the last zip count.
    """
    check_mods, check_configs = False, False
    user_vehicles_files, config_pics_custom_files = {}, {}
    mods_files, repo_files, vanilla_files = {}, {}, {}
    last_zip_count = 0 # Initialize last zip count

    try:
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding="utf-8") as f:
                lines = f.readlines()

            settings_section_started, user_vehicles_section_started = False, False
            config_pics_custom_section_started, mods_files_section_started = False, False
            repo_files_section_started, vanilla_files_section_started = False, False
            zip_count_section_started = False # NEW: zip count section

            for line in lines:
                line = line.strip()

                if line.startswith("CheckMods:"):
                    check_mods = (line.split(":", 1)[1].strip().lower() == "true")
                elif line.startswith("CheckConfigs:"):
                    check_configs = (line.split(":", 1)[1].strip().lower() == "true")
                elif line == "[Settings]":
                    settings_section_started = True; user_vehicles_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False
                elif line == "[UserVehiclesFiles]":
                    user_vehicles_section_started = True; settings_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False
                elif line == "[ConfigPicsCustomFiles]":
                    config_pics_custom_section_started = True; settings_section_started = False; user_vehicles_section_started = False; mods_files_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False
                elif line == "[ModsFiles]":
                    mods_files_section_started = True; settings_section_started = False; user_vehicles_section_started = False; config_pics_custom_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False
                elif line == "[RepoFiles]":
                    repo_files_section_started = True; settings_section_started = False; user_vehicles_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False
                elif line == "[VanillaFiles]":
                    vanilla_files_section_started = True; settings_section_started = False; user_vehicles_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; repo_files_section_started = False; zip_count_section_started = False
                elif line == "[ZipCount]": # NEW: ZipCount Section Header
                    zip_count_section_started = True; settings_section_started = False; user_vehicles_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False
                elif line.startswith("["):
                    settings_section_started = False; user_vehicles_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False


                if user_vehicles_section_started:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        filepath, timestamp_str = parts[0].strip(), parts[1].strip()
                        try: user_vehicles_files[filepath] = float(timestamp_str)
                        except ValueError: print(f"Warning: Invalid timestamp format in UserVehiclesFiles line: {line}")
                elif config_pics_custom_section_started:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        filepath, timestamp_str = parts[0].strip(), parts[1].strip()
                        try: config_pics_custom_files[filepath] = float(timestamp_str)
                        except ValueError: print(f"Warning: Invalid timestamp format in ConfigPicsCustomFiles line: {line}")
                elif mods_files_section_started:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        filepath, timestamp_str = parts[0].strip(), parts[1].strip()
                        try: mods_files[filepath] = float(timestamp_str)
                        except ValueError: print(f"Warning: Invalid timestamp format in ModsFiles line: {line}")
                elif repo_files_section_started:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        filepath, timestamp_str = parts[0].strip(), parts[1].strip()
                        try: repo_files[filepath] = float(timestamp_str)
                        except ValueError: print(f"Warning: Invalid timestamp format in RepoFiles line: {line}")
                elif vanilla_files_section_started:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        filepath, timestamp_str = parts[0].strip(), parts[1].strip()
                        try: vanilla_files[filepath] = float(timestamp_str)
                        except ValueError: print(f"Warning: Invalid timestamp format in VanillaFiles line: {line}")
                elif zip_count_section_started: # NEW: ZipCount Section Parsing
                    try:
                        last_zip_count = int(line)
                    except ValueError:
                        print(f"Warning: Invalid zip count format in ZipCount line: {line}")

    except Exception as e:
        print(f"Error reading {file_path}: {e}. Using default settings and empty file lists.")

    return check_mods, check_configs, user_vehicles_files, config_pics_custom_files, mods_files, repo_files, vanilla_files, last_zip_count # Return last_zip_count


def write_watcher_output(file_path, check_mods, check_configs, user_vehicles_files, config_pics_custom_files, mods_files, repo_files, vanilla_files, zip_count):
    """
    Writes settings and file lists to WatcherOutput.txt, including vanilla zip file lists and zip count.
    """
    try:
        with open(file_path, "w", encoding="utf-8") as f:
            f.write("[Settings]\n")
            f.write(f"CheckMods = {str(check_mods).lower()}\n")
            f.write(f"CheckConfigs = {str(check_configs).lower()}\n")

            f.write("\n[UserVehiclesFiles]\n")
            sorted_user_vehicles_files = sorted(user_vehicles_files.items())
            for filepath, timestamp in sorted_user_vehicles_files:
                f.write(f"{filepath} = {timestamp}\n")

            f.write("\n[ConfigPicsCustomFiles]\n")
            sorted_config_pics_custom_files = sorted(config_pics_custom_files.items())
            for filepath, timestamp in sorted_config_pics_custom_files:
                f.write(f"{filepath} = {timestamp}\n")

            f.write("\n[ModsFiles]\n")
            sorted_mods_files = sorted(mods_files.items())
            for filepath, timestamp in sorted_mods_files:
                f.write(f"{filepath} = {timestamp}\n")

            f.write("\n[RepoFiles]\n")
            sorted_repo_files = sorted(repo_files.items())
            for filepath, timestamp in sorted_repo_files:
                f.write(f"{filepath} = {timestamp}\n")

            f.write("\n[VanillaFiles]\n")
            sorted_vanilla_files = sorted(vanilla_files.items())
            for filepath, timestamp in sorted_vanilla_files:
                f.write(f"{filepath} = {timestamp}\n")

            f.write("\n[ZipCount]\n") # NEW: ZipCount section
            f.write(str(zip_count) + "\n") # Write zip count


        print(f"Successfully wrote settings and file lists to {file_path} (including vanilla zip files and zip count)")
    except Exception as e:
        print(f"Error writing to {file_path}: {e}")




def cleanup_orphaned_mod_files_simplified(script_dir, mods_folder, repo_folder, vanilla_folder, config_pics_folder, config_info_folder, input_file):
    """
    Simplified function to identify and log orphaned AND non-orphaned files,
    including folder and file lists in the deletion log.

    Args:
        script_dir: Path to the script's directory.
        mods_folder: Path to the mods folder.
        repo_folder: Path to the repo folder.
        vanilla_folder: Path to the vanilla vehicles folder.
        config_pics_folder: Path to the ConfigPics folder.
        config_info_folder: Path to the ConfigInfo folder.
        input_file: Path to the outputGOOD.txt file.
    """

    print("\n--- STARTING SIMPLIFIED STARTUP CLEANUP FOR ORPHANED MOD FILES (VERBOSE LOG) ---")

    # 1. Get list of existing zip files from Mods, Repo, and Vanilla folders
    existing_zip_files = set()
    folders_to_check = {"Mods Folder": mods_folder, "Repo Folder": repo_folder, "Vanilla Folder": vanilla_folder} # For clearer logging

    log_file_path = os.path.join(script_dir, "data/orphaned_files_deletion_log.txt")
    with open(log_file_path, "w", encoding="utf-8") as log_file:
        log_file.write("--- START OF ORPHANED FILE CLEANUP LOG ---\n\n")

        log_file.write("--- Folders Being Checked for ZIP Files ---\n") # Folder List Header
        for folder_name, folder_path in folders_to_check.items(): # Log Folders and Paths
#            log_file.write(f"{folder_name}: {folder_path}\n")
            pass
            
        log_file.write("\n--- Existing ZIP Files in Folders ---\n") # Existing ZIPs Header
        for folder_name, folder_path in folders_to_check.items():
            folder_zip_files = []
            if folder_path and os.path.isdir(folder_path):
                for item in os.listdir(folder_path):
                    if item.lower().endswith(".zip") and os.path.isfile(os.path.join(folder_path, item)):
                        existing_zip_files.add(item) # Populate existing_zip_files set
                        folder_zip_files.append(item) # For folder-specific logging
#            log_file.write(f"{folder_name}: {folder_zip_files}\n") # Log files in each folder
#        log_file.write(f"\nCombined list of existing zip files (for internal use): {existing_zip_files}\n\n") # Log combined set for debug
        #print(f"DEBUG: Existing zip files found: {existing_zip_files}") # Console debug print


        orphaned_files_log = []
        kept_files_log = []

        if os.path.exists(input_file):
#            log_file.write("\n--- Processing outputGOOD.txt lines ---\n")
            with open(input_file, 'r', encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if "(package)" in line and "(config picture)" in line:
                        parts = line.split(" - ")
                        if len(parts) == 3:
                            zip_package_part = parts[0]
                            # --- DEFINITIVE CORRECTION: Re-assign the result of replace() to internal_folder_name ---
                            internal_folder_name = parts[1].strip().replace('"', '').replace(' (internal folder name)', '') # CORRECTED PARSING
                            config_picture_path_relative = parts[2].split("(config picture)")[0].strip().replace('"', '')

                            zip_file_name_from_output = zip_package_part.split(" (package)")[0].strip()
                            config_picture_filename = os.path.basename(config_picture_path_relative)
                            config_picture_filename_base = os.path.splitext(config_picture_filename)[0]

                            # Construct expected filenames (unchanged)
                            expected_config_pic_filename = f"vehicles--{internal_folder_name}_{zip_file_name_from_output.replace('.zip', '')}.zip--{config_picture_filename}"
                            expected_individual_info_filename = f"vehicles--INDIVIDUAL--{internal_folder_name}_{zip_file_name_from_output.replace('.zip', '')}.zip--info_info_{config_picture_filename_base}.json"
                            expected_generic_info_filename = f"vehicles--{internal_folder_name}_{zip_file_name_from_output.replace('.zip', '')}.zip--info.json"


#                            log_file.write(f"\n  Processing line from outputGOOD.txt: '{line}'\n")
#                            log_file.write(f"    - Zip from line: '{zip_file_name_from_output}'\n")

                            # 3. Check for ZIP file existence
                            if zip_file_name_from_output not in existing_zip_files:
                                # ZIP file is missing, these files are orphaned
                                reason_prefix = f"Orphaned - ZIP file '{zip_file_name_from_output}' NOT found in watched folders"
#                                log_file.write(f"    - ZIP '{zip_file_name_from_output}' NOT FOUND. Checking for orphaned files.\n")

                                # Check ConfigPics file
                                config_pic_filepath = os.path.join(config_pics_folder, expected_config_pic_filename)
                                print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking ConfigPic path: {config_pic_filepath}") # <-- DEBUG PRINT
                                if os.path.exists(config_pic_filepath):
                                    orphaned_files_log.append((config_pic_filepath, f"{reason_prefix} - ConfigPic, associated with ZIP: '{zip_file_name_from_output}'"))
                                    # **CORRECTED Log Message - Use variable: expected_config_pic_filename**
#                                    log_file.write(f"      - [ORPHANED] ConfigPic: {expected_config_pic_filename}\n")
                                else:
                                    # **CORRECTED Log Message - Use variable: expected_config_pic_filename**
#                                    log_file.write(f"      - [NOT FOUND] ConfigPic: {expected_config_pic_filename} (already missing)\n")
                                    pass
                                    
                                # Check ConfigInfo files
                                individual_info_filepath = os.path.join(config_info_folder, expected_individual_info_filename)
                                print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking Individual Info path: {individual_info_filepath}") # <-- DEBUG PRINT
                                if os.path.exists(individual_info_filepath):
                                    orphaned_files_log.append((individual_info_filepath, f"{reason_prefix} - Individual Info, associated with ZIP: '{zip_file_name_from_output}'"))

                                    # --- ADDED DEBUGGING PRINTS ---
                                    #print(f"DEBUG - Individual Info - config_picture_filename_base: {config_picture_filename_base}, type: {type(config_picture_filename_base)}") # Check value and type
                                    #print(f"DEBUG - Individual Info - expected_individual_info_filename: {expected_individual_info_filename}") # Check full constructed filename
                                    # --- END DEBUGGING PRINTS ---

                                    # Log Message (Corrected - using variables)
#                                    log_file.write(f"      - [ORPHANED] Individual Info: {expected_individual_info_filename}\n") # <-- LINE A
                                else:
                                    # --- ADDED DEBUGGING PRINTS ---
                                    #print(f"DEBUG - Individual Info (NOT FOUND) - config_picture_filename_base: {config_picture_filename_base}, type: {type(config_picture_filename_base)}") # Check value and type
                                    #print(f"DEBUG - Individual Info (NOT FOUND) - expected_individual_info_filename: {expected_individual_info_filename}") # Check full constructed filename
                                    # --- END DEBUGGING PRINTS ---

                                    # Log Message (Corrected - using variables)
                                    log_file.write(f"      - [NOT FOUND] Individual Info: {expected_individual_info_filename} (already missing)\n") # <-- LINE B

                                generic_info_filepath = os.path.join(config_info_folder, expected_generic_info_filename)
                                print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking Generic Info path: {generic_info_filepath}") # <-- DEBUG PRINT
                                if os.path.exists(generic_info_filepath):
                                    orphaned_files_log.append((generic_info_filepath, f"{reason_prefix} - Generic Info, associated with ZIP: '{zip_file_name_from_output}'"))
                                    # CORRECTED Log Message - Use variable: expected_generic_info_filename
#                                    log_file.write(f"      - [ORPHANED] Generic Info: {expected_generic_info_filename}\n")
                                    pass
                                    
                                else:
                                    # CORRECTED Log Message - Use variable: expected_generic_info_filename
#                                    log_file.write(f"      - [NOT FOUND] Generic Info: {expected_generic_info_filename} (already missing)\n")
                                    pass
                            else:
                                # ZIP file exists, these files are NOT orphaned, but log kept files
                                reason_prefix = f"Kept - ZIP file '{zip_file_name_from_output}' FOUND in watched folders"
#                                log_file.write(f"    - ZIP '{zip_file_name_from_output}' FOUND. Keeping associated files.\n")
                                pass
                                
                                # Check ConfigPics file
                                config_pic_filepath = os.path.join(config_pics_folder, expected_config_pic_filename)
                                #print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking ConfigPic path (kept file): {config_pic_filepath}") # <-- DEBUG PRINT - KEPT FILE CHECK
                                if os.path.exists(config_pic_filepath):
                                    kept_files_log.append((config_pic_filepath, f"{reason_prefix} - ConfigPic, associated with ZIP: '{zip_file_name_from_output}'"))
                                    # CORRECTED Log Message - Use variable: expected_config_pic_filename
#                                    log_file.write(f"      - [KEPT] ConfigPic: {expected_config_pic_filename}\n")
                                    pass    
                                else:
                                    # CORRECTED Log Message - Use variable: expected_config_pic_filename
#                                    log_file.write(f"      - [NOT FOUND] ConfigPic: {expected_config_pic_filename} (unexpectedly missing, but ZIP exists)\n")
                                    pass
                                    
                                # Check ConfigInfo files
                                individual_info_filepath = os.path.join(config_info_folder, expected_individual_info_filename)
                                #print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking Individual Info path (kept file): {individual_info_filepath}") # <-- DEBUG PRINT - KEPT FILE CHECK
                                if os.path.exists(individual_info_filepath):
                                    kept_files_log.append((individual_info_filepath, f"{reason_prefix} - Individual Info, associated with ZIP: '{zip_file_name_from_output}'"))
                                    # CORRECTED Log Message - Use variable: expected_individual_info_filename
#                                    log_file.write(f"      - [KEPT] Individual Info: {expected_individual_info_filename}\n")
                                    pass    
                                
                                else:
                                    # CORRECTED Log Message - Use variable: expected_individual_info_filename
#                                    log_file.write(f"      - [NOT FOUND] Individual Info: {expected_individual_info_filename} (unexpectedly missing, but ZIP exists)\n")
                                    pass
                                    
                                generic_info_filepath = os.path.join(config_info_folder, expected_generic_info_filename)
                                #print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking Generic Info path (kept file): {generic_info_filepath}") # <-- DEBUG PRINT - KEPT FILE CHECK
                                if os.path.exists(generic_info_filepath):
                                    kept_files_log.append((generic_info_filepath, f"{reason_prefix} - Generic Info, associated with ZIP: '{zip_file_name_from_output}'"))
                                    # Corrected Log Message - Use variable: expected_generic_info_filename
#                                    log_file.write(f"      - [KEPT] Generic Info: {expected_generic_info_filename}\n")
                                    pass
                                
                                else:
                                    # Corrected Log Message - Use variable: expected_generic_info_filename
#                                    log_file.write(f"      - [NOT FOUND] Generic Info: {expected_generic_info_filename} (unexpectedly missing, but ZIP exists)\n")
                                    pass
        
        else:
            log_file.write(f"Warning: {input_file} not found, skipping outputGOOD.txt processing.\n")


        # 4. Write deletion candidates AND kept files to log file
        if orphaned_files_log:
            log_file.write("\n--- Orphaned Files to be DELETED (Dry Run) ---\n")
            for filepath, reason in orphaned_files_log:
                log_file.write(f"File: {filepath}\nReason: {reason}\n\n")
                # 5. Comment out deletion (Dry Run - Logging only)
                try:
                    deleted_count = 0  # <--- Initialize deleted_count INSIDE try block, BEFORE os.remove
                    os.remove(filepath)
                    deleted_count += 1  # Increment AFTER successful deletion (though initialization already makes this redundant)
                    log_file.write(f"  [DELETED] {filepath}\n")
                except Exception as e:
                    log_file.write(f"  [ERROR deleting] {filepath} - {e}\n") # <-- ERROR LOG LINE - NO deleted_count HERE

        if kept_files_log:
#            log_file.write("\n--- Non-Orphaned Files (Kept) ---\n")
            pass
            
            for filepath, reason in kept_files_log:
#                log_file.write(f"File: {filepath}\nReason: {reason}\n\n")
                pass
                
                
        if not orphaned_files_log and not kept_files_log:
#            log_file.write("\nNo orphaned files found.\n")
            pass
        
        log_file.write("\n--- END OF ORPHANED FILE CLEANUP LOG ---\n") # Log file end marker

    print(f"DEBUG: Detailed log of orphaned and kept files (dry run) written to: {log_file_path}")

    if orphaned_files_log:
        print(f"Startup cleanup (simplified - dry run) completed. {len(orphaned_files_log)} orphaned files identified (deletion commented out).")
        print("--- SIMPLIFIED STARTUP CLEANUP FOR ORPHANED MOD FILES COMPLETED - deleting garbage (VERBOSE LOG) ---\n")
        return True
    else:
        print("Startup cleanup (simplified - dry run): No orphaned mod files found.")
        print("--- SIMPLIFIED STARTUP CLEANUP FOR ORPHANED MOD FILES COMPLETED - deleting garbage (VERBOSE LOG) ---\n") 
        return False 
            

def update_new_mods_txt_on_startup(script_dir):
    """
    Updates NewMods.txt with a list of ALL ZIP files from WatcherOutput.txt on startup.
    DEBUG PRINTS ADDED for troubleshooting.
    """
    new_mods_file = os.path.join(script_dir, "data/NewMods.txt")
    watcher_output_file = os.path.join(script_dir, "data/WatcherOutput.txt")

    print("\n--- DEBUG: update_new_mods_txt_on_startup() ENTRY ---") # DEBUG ENTRY

    try:
        # --- Always Delete existing NewMods.txt ---
        if os.path.exists(new_mods_file):
            print(f"DEBUG: NewMods.txt exists: {new_mods_file}") # DEBUG - File exists check
            try:
                os.remove(new_mods_file)
                print(f"DEBUG: Deleted existing NewMods.txt: {new_mods_file}") # Debug - Deletion success
            except OSError as e:
                print(f"Warning: Could not delete existing NewMods.txt: {new_mods_file}. Error: {e}") # Debug - Deletion warning
        else:
            print(f"DEBUG: NewMods.txt does not exist, will create: {new_mods_file}") # Debug - File does not exist

        # --- ALWAYS Populate from WatcherOutput.txt, includes vanilla zips ---
        print(f"DEBUG: Reading zip lists from WatcherOutput.txt: {watcher_output_file}") # DEBUG - Reading from WatcherOutput
        _, _, _, _, last_mods_files, last_repo_files, last_vanilla_files, _ = read_watcher_output(watcher_output_file)
        all_zip_files = set(last_mods_files.keys()) | set(last_repo_files.keys()) | set(last_vanilla_files.keys())  # Include vanilla
        newly_detected_zip_files = [os.path.basename(zip_path) for zip_path in all_zip_files]

        print(f"DEBUG: all_zip_files (count: {len(all_zip_files)})") # DEBUG - all_zip_files content
        print(f"DEBUG: newly_detected_zip_files (count: {len(newly_detected_zip_files)})") # DEBUG - newly_detected_zip_files content


        if newly_detected_zip_files: # Now uses the zip file list from WatcherOutput
            print(f"DEBUG: newly_detected_zip_files is NOT empty, proceeding to write NewMods.txt") # DEBUG - Not empty check
            print(f"DEBUG: Attempting to open NewMods.txt for writing: {new_mods_file}") # DEBUG - Before write open
            with open(new_mods_file, "w", encoding="utf-8") as f:
                print(f"DEBUG: NewMods.txt opened successfully for writing.") # DEBUG - After write open
                print(f"DEBUG: Writing {len(newly_detected_zip_files)} file names to NewMods.txt...") # DEBUG - Before write loop
                for file_name in newly_detected_zip_files:
                    f.write(f"{file_name}\n")
                    #print(f"  DEBUG: Wrote filename: {file_name}") # DEBUG - Write loop (can be verbose)
                print(f"DEBUG: Finished writing filenames to NewMods.txt.") # DEBUG - After write loop
            print(f"DEBUG: Created/Updated NewMods.txt with {len(newly_detected_zip_files)} mod(s) from WatcherOutput: {new_mods_file}")


        else:
            print("DEBUG: newly_detected_zip_files is empty (but using WatcherOutput data). No files to write to NewMods.txt.") # DEBUG - Empty list


    except Exception as e:
        print(f"ERROR: Error updating NewMods.txt: {e}") # ERROR - Exception
        print(f"  ERROR DETAILS: {e}") # ERROR - Exception details

    print("--- DEBUG: update_new_mods_txt_on_startup() EXIT ---\n") # DEBUG EXIT
        

def generate_data_subset_favorites(script_dir):
    """
    Generates data_subset_favorites.txt based on favorites.txt and data_subset.txt.
    """
    favorites_file_path = os.path.join(script_dir, "data/favorites.txt")
    data_subset_file_path = os.path.join(script_dir, "data/data_subset.txt")
    data_subset_favorites_file_path = os.path.join(script_dir, "data/data_subset_favorites.txt")

    if not os.path.exists(favorites_file_path):
        print(f"Warning: {favorites_file_path} not found. data_subset_favorites.txt will not be generated.")
        return

    if not os.path.exists(data_subset_file_path):
        print(f"Warning: {data_subset_file_path} not found. data_subset_favorites.txt will not be generated.")
        return

    favorite_configs = set()
    with open(favorites_file_path, 'r', encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if line:
                parts = line.split('|')
                if len(parts) == 2:
                    folder, config_pc = parts
                    config = config_pc.replace('.pc', '')
                    favorite_configs.add((folder.strip(), config.strip()))

    filtered_lines = []
    with open(data_subset_file_path, 'r', encoding="utf-8") as f_in, open(data_subset_favorites_file_path, 'w', encoding="utf-8") as f_out:
        for line in f_in:
            line = line.strip()
            if not line:
                continue

            parts = line.split('--')
            if len(parts) >= 3:  # Basic check to ensure line structure is somewhat valid
                folder_part = parts[1]
                config_name_part = parts[-1]  # Assuming config name is at the end
                config_name_base = os.path.splitext(config_name_part)[0] # Remove extension

                for fav_folder, fav_config in favorite_configs:
                    if fav_folder in folder_part and fav_config in config_name_base:
                        filtered_lines.append(line)
                        f_out.write(line + '\n') # Write to the output file immediately if match is found
                        break # Optimization: no need to check other favorites once a match is found for this line

    print(f"data_subset_favorites.txt generated with {len(filtered_lines)} lines.")
    
    
    
    
##############################################################
##############################################################
##############################################################



def generate_matches_txt(script_dir, config_info_folder):
    """
    Generates "Matches.txt" file with a list of JSON files and their content
    on startup if the file does not exist.

    Args:
        script_dir: Path to the script's directory.
        config_info_folder: Path to the ConfigInfo folder containing JSON files.
    """
    matches_file_path = os.path.join(script_dir, "data/Matches.txt")

    if not os.path.exists(matches_file_path):
        print("Matches.txt does not exist, creating it...")
        try:
            with open(matches_file_path, "w", encoding="utf-8") as matches_file:
                json_files = glob.glob(os.path.join(config_info_folder, "*.json"))
                for json_file in json_files:
                    filename = os.path.basename(json_file)
                    matches_file.write(f"{filename}\n")
                    try:
                        with open(json_file, "r", encoding="utf-8") as current_json_file:
                            content = current_json_file.read()
                            matches_file.write(content + "\n\n")
                    except Exception as e:
                        matches_file.write(f"Error reading content: {e}\n\n")
                print(f"Matches.txt file created at: {matches_file_path}")
        except Exception as e:
            print(f"Error creating Matches.txt: {e}")
    else:
        print("Matches.txt already exists, skipping creation.")






##############################################################
##############################################################
################################################################



class ConsoleWindow(tk.Toplevel):

    def __init__(self, master=None):
        super().__init__(master)

        if getattr(sys, 'frozen', False): # Check if running as a frozen executable (PyInstaller)
            self.script_dir = Path(os.path.dirname(sys.executable)) # Directory of the .exe
        else: # Running as a normal .py script
            self.script_dir = Path(__file__).parent # Directory of the .py script


        self.title("Console Output")
        self.geometry("1074x532")

        self.icon_path_str = str(self.script_dir / "data/icon.png")
        self.icon_image_ref = None # To hold PhotoImage reference to prevent GC

        if os.path.exists(self.icon_path_str):
            try:
                self.icon_image_ref = tk.PhotoImage(file=self.icon_path_str)
                self.iconphoto(False, self.icon_image_ref)
            except tk.TclError as e: 
                print(f"TclError setting icon for console window: {e}. Icon path: {self.icon_path_str}")
            except Exception as e: # Catch other potential errors during icon loading
                print(f"Error setting icon for console window: {e}. Icon path: {self.icon_path_str}")
        else:
            print(f"Icon file not found: {self.icon_path_str}")


        self.scrollbar = tk.Scrollbar(self)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.text_area = tk.Text(
            self,
            wrap="word",
            bg="black",          # Set background color to black
            fg="#FFFFFF",         # Set text color to white
            font=("Cascadia Mono", 12), # Set font to Courier New, size 12 (adjust size as needed)
            highlightthickness=0 # Remove highlight from inside the text area
        )
        self.text_area.pack(expand=True, fill="both")
        self.text_area.config(state=tk.DISABLED) # Make it read-only


        self.scrollbar.config(command=self.text_area.yview)

        # ---- New code for shortcuts ----
        self.shortcuts = []
        self.shortcuts_window_instance = None
        self.load_shortcuts()

        # Bind click on text_area to show shortcuts window
        self.text_area.bind("<Button-3>", self.show_shortcuts_window)
        # ---- End new code ----


    def write(self, text):
        self.text_area.config(state=tk.NORMAL) # Enable editing temporarily
        self.text_area.insert(tk.END, text)
        self.text_area.see(tk.END) # Autoscroll to the bottom
        self.text_area.config(state=tk.DISABLED) # Disable editing again

    # ---- New methods ----
    def load_shortcuts(self):
        self.shortcuts = []
        mod_manager_filename = "EllexiumModManager.py"
        mod_manager_path = self.script_dir / mod_manager_filename
        
        if not mod_manager_path.exists():
            print(f"{mod_manager_filename} not found at {mod_manager_path}")
            return

        parsing_shortcuts = False
        try:
            with open(mod_manager_path, 'r', encoding='utf-8') as f:
                for line in f:
                    stripped_line = line.strip()
                    if "### SHORTCUTS START HERE ###" in stripped_line:
                        parsing_shortcuts = True
                        continue
                    
                    if not parsing_shortcuts:
                        continue
                    
                    # Regex for lines like: self.master.bind_all("<Control-j>", lambda event: self.show_hidden_vehicles_window()) #debug
                    # It captures the key combination (e.g., "Control-j") and the function call part (e.g., "show_hidden_vehicles_window()")
                    match = re.search(r'self\.master\.bind_all\("<(.*?)>",\s*lambda\s+\w+:\s*self\.(.*?)\)\s*(?:#.*)?$', stripped_line)
                    if match:
                        key_combo_str = match.group(1)
                        function_call_part = match.group(2) 
                        function_call_display_str = f"self.{function_call_part}"
                        self.shortcuts.append((key_combo_str, function_call_display_str))
        except FileNotFoundError: # Should be caught by .exists(), but as a fallback.
             print(f"{mod_manager_filename} not found during open at {mod_manager_path}")
        except Exception as e:
            print(f"Error reading or parsing {mod_manager_filename}: {e}")

    def show_shortcuts_window(self, event=None): # event is passed from bind
        if self.shortcuts_window_instance and self.shortcuts_window_instance.winfo_exists():
            self.shortcuts_window_instance.destroy()
            self.shortcuts_window_instance = None 
        
        if not self.shortcuts:
            print("No shortcuts loaded or found to display.")
            return

        win = tk.Toplevel(self)
        win.title("Debug Shortcuts")
        self.shortcuts_window_instance = win 

        if os.path.exists(self.icon_path_str):
            try:
                # Ensure the PhotoImage object for the shortcut window's icon is stored
                # on an attribute of 'win' to prevent garbage collection if 'win' is passed around.
                win.shortcut_icon_image_ref = tk.PhotoImage(file=self.icon_path_str)
                win.iconphoto(False, win.shortcut_icon_image_ref)
            except tk.TclError as e:
                print(f"TclError setting icon for shortcuts window: {e}. Icon path: {self.icon_path_str}")
            except Exception as e:
                print(f"Error setting icon for shortcuts window: {e}. Icon path: {self.icon_path_str}")
        else:
            print(f"Icon file not found for shortcuts window (expected at {self.icon_path_str})")
        
        win.geometry("600x450") 

        canvas = tk.Canvas(win)
        scrollbar = tk.Scrollbar(win, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(
                scrollregion=canvas.bbox("all")
            )
        )

        canvas_window = canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        def on_canvas_configure(event_canvas): 
            canvas.itemconfig(canvas_window, width=event_canvas.width)
        canvas.bind("<Configure>", on_canvas_configure)

        # --- MOUSEWHEEL SCROLLING START ---
        def _on_mousewheel_shortcuts(event_mw):
            """Handles mousewheel scrolling for the shortcuts list canvas."""
            if sys.platform == "linux":
                if event_mw.num == 4: # Scroll up
                    canvas.yview_scroll(-1, "units")
                elif event_mw.num == 5: # Scroll down
                    canvas.yview_scroll(1, "units")
            elif sys.platform == "darwin": # macOS

                canvas.yview_scroll(-1 * event_mw.delta, "units")
            else: # Windows (and other platforms that might use delta)

                if event_mw.delta != 0: # Avoid division by zero if delta is 0 for some reason
                    canvas.yview_scroll(int(-1 * (event_mw.delta / 120)), "units")
        
        # Bind mousewheel events to the canvas and the scrollable frame
        # This allows scrolling when the mouse is over empty parts of the canvas or frame.
        for widget_to_bind in [canvas, scrollable_frame]:
            widget_to_bind.bind("<MouseWheel>", _on_mousewheel_shortcuts) # For Windows and MacOS
            widget_to_bind.bind("<Button-4>", _on_mousewheel_shortcuts)   # For Linux (scroll up)
            widget_to_bind.bind("<Button-5>", _on_mousewheel_shortcuts)   # For Linux (scroll down)
        # --- MOUSEWHEEL SCROLLING END ---

        for key_combo, func_call_display in self.shortcuts:
            btn_text = f"{key_combo}: {func_call_display}"
            button = tk.Button(scrollable_frame, text=btn_text, 
                               command=lambda k=key_combo: self.trigger_shortcut_action(k), 
                               anchor="w", justify="left")
            button.pack(pady=2, padx=5, fill="x")
            # --- Bind mousewheel to buttons as well ---
            # This ensures scrolling works when the mouse is directly over a button.
            button.bind("<MouseWheel>", _on_mousewheel_shortcuts)
            button.bind("<Button-4>", _on_mousewheel_shortcuts)
            button.bind("<Button-5>", _on_mousewheel_shortcuts)
            # --- End button bind ---

        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        win.protocol("WM_DELETE_WINDOW", self.on_shortcuts_window_close)

    def on_shortcuts_window_close(self):
        if self.shortcuts_window_instance:
            self.shortcuts_window_instance.destroy()
            self.shortcuts_window_instance = None

    def trigger_shortcut_action(self, key_combo_str):
        try:
            import pydirectinput
        except ImportError:
            print("FATAL: pydirectinput is not installed. This functionality requires it.")
            return

        modifiers_to_activate = []
        action_key_target = None
        
        key_parts = key_combo_str.split('-')
        
        action_key_raw = key_parts[-1] 

        for current_part_str in key_parts[:-1]: 
            part_lower = current_part_str.lower()
            if part_lower in ['control', 'ctrl']:
                modifiers_to_activate.append('ctrl')
            elif part_lower == 'alt':
                modifiers_to_activate.append('alt')
            elif part_lower == 'shift':
                modifiers_to_activate.append('shift')
            # Unknown modifier parts are silently ignored

        if len(action_key_raw) == 1 and action_key_raw.isupper(): 
            if 'shift' not in modifiers_to_activate: 
                modifiers_to_activate.append('shift')
            action_key_target = action_key_raw.lower() 
        else: 
            action_key_target = action_key_raw.lower()

        if not action_key_target: 
            print(f"Error: Could not determine valid action key for '{key_combo_str}'.")
            return

        try:
            for mod_key in modifiers_to_activate:
                pydirectinput.keyDown(mod_key)
            
            pydirectinput.press(action_key_target) # .press() is keyDown then keyUp

            for mod_key in reversed(modifiers_to_activate): # Release in reverse order
                pydirectinput.keyUp(mod_key)
            
        except Exception as e:
            print(f"Error during pydirectinput execution for '{key_combo_str}': {e}")






class KeyboardDiffHandler(FileSystemEventHandler):
    """
    Handles file system events for keyboard.diff using a timer-based
    debounce to process only after a period of inactivity.
    """
    def __init__(self, filepath, queue, parse_func):
        self.filepath = filepath
        self.queue = queue
        self.parse_func = parse_func
        self.debounce_timer = None
        # Wait this long after the *last* event before processing
        self.processing_delay = 0.2 # 200ms, adjust as needed

    def _schedule_processing(self):
        """Cancels any existing timer and schedules a new one."""
        # Cancel previous timer if it exists and hasn't run yet
        if self.debounce_timer and self.debounce_timer.is_alive():
            # print("DEBUG Handler: Cancelling previous timer.") # Optional debug
            self.debounce_timer.cancel()

        # Schedule the actual processing function
        # print(f"DEBUG Handler: Scheduling processing in {self.processing_delay}s") # Optional debug
        self.debounce_timer = threading.Timer(self.processing_delay, self._process_file_change)
        self.debounce_timer.start()

    def _process_file_change(self):
        """
        This function runs after the delay. It checks the final state
        of the file and queues the result.
        """
        print(f"DEBUG Handler: Timer expired, processing final state of {self.filepath}")
        # Check if file exists *now* and parse it
        new_binding = self.parse_func(self.filepath) # Parse func handles non-existence
        print(f"DEBUG Handler: Final parse result: {new_binding}")
        self.queue.put(new_binding)
        self.debounce_timer = None # Timer has finished

    # --- Event Handlers ---
    # All handlers now just call _schedule_processing

    def on_modified(self, event):
        if not event.is_directory and os.path.normpath(event.src_path) == self.filepath:
            print("DEBUG Handler: keyboard.diff got modified (scheduling process)")
            self._schedule_processing()

    def on_created(self, event):
        if not event.is_directory and os.path.normpath(event.src_path) == self.filepath:
            print("DEBUG Handler: keyboard.diff got created (scheduling process)")
            self._schedule_processing()

    def on_deleted(self, event):
        if not event.is_directory and os.path.normpath(event.src_path) == self.filepath:
            print("DEBUG Handler: keyboard.diff got deleted (scheduling process)")
            # Even on delete, we wait briefly to see if it's immediately recreated
            # The _process_file_change will handle the file not existing then.
            self._schedule_processing()

class SwitcherConfirmationHandler(FileSystemEventHandler):
    """
    Watches for creation/modification of the confirmation file,
    deletes it, and puts a message on a queue for the Tkinter thread.
    """
    # <<< MODIFIED __init__ >>>
    def __init__(self, filepath_to_watch, queue_to_notify):
        self.target_filepath = Path(filepath_to_watch).resolve()
        self.notify_queue = queue_to_notify # <<< Use the queue
        print(f"DEBUG Switcher Handler: Monitoring target: {self.target_filepath}")

    def _trigger_action(self):
        """Deletes the file and puts a message on the queue."""
        deleted_ok = False # Flag to check if deletion happened
        try:
            if self.target_filepath.is_file():
                print(f"DEBUG Switcher Handler: Change detected. Deleting {self.target_filepath}")
                os.remove(self.target_filepath)
                print(f"DEBUG Switcher Handler: File deleted.")
                deleted_ok = True
            # else:
            #     print(f"DEBUG Switcher Handler: Triggered, but file already deleted.")

        except FileNotFoundError:
             print(f"DEBUG Switcher Handler: File not found during delete attempt (likely already handled): {self.target_filepath}")
        except PermissionError:
             print(f"ERROR Switcher Handler: Permission denied trying to delete {self.target_filepath}")
        except OSError as e:
             print(f"ERROR Switcher Handler: OS error deleting file {self.target_filepath}: {e}")
        except Exception as e:
             print(f"ERROR Switcher Handler: Unexpected error during action: {e}")


        if deleted_ok or not self.target_filepath.exists(): # Check existence again just in case
            print(f"DEBUG Switcher Handler: Putting 'run_focus' message on queue.")
            self.notify_queue.put("run_focus") # Put a simple message


    def on_modified(self, event):
        if not event.is_directory:
            event_path = Path(event.src_path).resolve()
            if event_path == self.target_filepath:
                print(f"DEBUG Switcher Handler: on_modified triggered for target.")
                self._trigger_action()

    def on_created(self, event):
        if not event.is_directory:
            event_path = Path(event.src_path).resolve()
            if event_path == self.target_filepath:
                print(f"DEBUG Switcher Handler: on_created triggered for target.")
                self._trigger_action()

    def on_moved(self, event):
         if not event.is_directory:
            event_path = Path(event.dest_path).resolve() # Check the destination path
            if event_path == self.target_filepath:
                print(f"DEBUG Switcher Handler: on_moved triggered for target.")
                self._trigger_action()




class FadingToplevel(tk.Toplevel):
    def __init__(self, parent, app_instance,
                 fade_in_duration_ms=30, fade_in_steps=15,
                 fade_out_duration_ms=30, fade_out_steps=15,
                 fade_in_delay_ms=0, end_alpha=1.0,
                 **kwargs):
        """
        Initialize a Toplevel window with automatic fade-in (with optional delay)
        and fade-out on destroy.

        Args:
            parent: The parent widget (usually root).
            app_instance: A reference to the main application instance
                          that contains the _fade_window method.
            fade_in_duration_ms: Duration for the fade-in animation.
            fade_in_steps: Number of steps for the fade-in animation.
            fade_out_duration_ms: Duration for the fade-out animation.
            fade_out_steps: Number of steps for the fade-out animation.
            fade_in_delay_ms: Delay in milliseconds before the fade-in starts. # --- NEW ARG ---
            **kwargs: Arbitrary keyword arguments for tk.Toplevel.
        """
        super().__init__(parent, **kwargs)

        self._app_instance = app_instance
        self._original_destroy = super().destroy
        self._fade_in_duration = fade_in_duration_ms
        self._fade_in_steps = fade_in_steps
        self._fade_out_duration = fade_out_duration_ms
        self._fade_out_steps = fade_out_steps
        self._fade_in_delay_ms = fade_in_delay_ms
        self._faded_in = False
        self._fade_in_scheduled_job = None # To keep track of the after() job
        self.end_alpha = end_alpha

        try:
            self.wm_attributes('-alpha', 0.0)
        except tk.TclError as e:
            print(f"Warning: Could not set initial alpha to 0.0. Fading might not work: {e}")
            self._faded_in = True # Mark as faded in to skip the auto-fade-in

        if not self._faded_in:
            # Bind to the first <Configure> event which happens after geometry is set and window starts mapping
            # Use after_idle delays the bind slightly, sometimes helps ensure window is ready
            self.after_idle(lambda: self.bind('<Configure>', self._on_first_configure, add='+'))


    def _on_first_configure(self, event=None):
         """
         Handler for the first Configure event to trigger the fade-in process.
         Unbinds itself afterwards.
         """
         # Check if window still exists and fade-in hasn't been triggered yet
         if self.winfo_exists() and not self._faded_in:
              # Don't set _faded_in = True yet, it's set just before starting the fade/delay
              # Schedule the start of the fade-in process (could be immediate or delayed)
              self.after_idle(self._start_fade_in_process)

         # Unbind immediately after the first configure event occurs
         try:
             self.unbind('<Configure>', self._on_first_configure)
         except Exception:
             pass # Ignore if unbind fails


    def _start_fade_in_process(self):
        """Handles the delay before starting the actual fade-in animation."""
        if self.winfo_exists() and not self._faded_in:
            self._faded_in = True # Mark as triggered now to prevent double-starting

            if self._fade_in_delay_ms > 0:
                # --- SCHEDULE THE ACTUAL FADE AFTER THE DELAY ---
                self._fade_in_scheduled_job = self.after(self._fade_in_delay_ms, self._perform_actual_fade_in)
            else:
                # --- NO DELAY, PERFORM FADE IMMEDIATELY ---
                self._perform_actual_fade_in()
        # else: window was destroyed before this could run, or it already ran


    def _perform_actual_fade_in(self):
        """Starts the actual fade-in animation after any delay."""
        # Check again in case the window was destroyed during the delay
        if self.winfo_exists():
             # print(f"DEBUG: Starting actual fade-in for {self}...") # DEBUG
             # Start the fade-in animation from current alpha (should be 0.0) to 1.0
             self._app_instance._fade_window(
                 window=self,
                 start_alpha=self.attributes('-alpha'), # Start from current alpha
                 end_alpha=self.end_alpha,                         # Fade to opaque
                 duration_ms=self._fade_in_duration,
                 steps=self._fade_in_steps
             )
        # else: window was destroyed during the delay, nothing to fade


    def destroy(self, callback_after_fade=None):
        """
        Intercepts the destroy call to make the window topmost, fade it out,
        then call the original destroy method.
        """
        # If the window doesn't exist, just try to call the original destroy (might fail)
        if not self.winfo_exists():
            # If the window was destroyed before the fade-in delay or animation started,
            # make sure to cancel any scheduled job.
            if self._fade_in_scheduled_job:
                 self.after_cancel(self._fade_in_scheduled_job)
                 self._fade_in_scheduled_job = None

            try:
                self._original_destroy()
            except tk.TclError:
                pass
            if callback_after_fade:
                 try: callback_after_fade()
                 except Exception: pass
            return

        # --- Cancel any pending fade-in animation if destroy is called ---
        if self._fade_in_scheduled_job:
            # print("DEBUG: Destroy called during fade-in delay/animation, canceling job.") # DEBUG
            self.after_cancel(self._fade_in_scheduled_job)
            self._fade_in_scheduled_job = None
        # --- END: Cancel pending fade-in ---

        # --- Make the window topmost just before starting the fade-out ---
        try:
            self.wm_attributes('-topmost', True)
        except tk.TclError:
             pass


        def call_original_destroy_and_callback():
            if self.winfo_exists():
                try: self._original_destroy()
                except tk.TclError: pass
            if callback_after_fade:
                 try: callback_after_fade()
                 except Exception: pass

        # Start the fade-out animation
        # Ensure we start fade-out from the current alpha value
        current_alpha = 0.0
        try:
            current_alpha = self.attributes('-alpha')
        except tk.TclError:
            # If we can't get alpha, window might be shutting down, proceed assuming 0.0
            pass # Keep default 0.0 if attribute fails


        self._app_instance._fade_window(
            window=self,
            start_alpha=current_alpha, # Start from the actual current alpha
            end_alpha=0.0,
            duration_ms=self._fade_out_duration,
            steps=self._fade_out_steps,
            callback=call_original_destroy_and_callback
        )
        # The original self.destroy() is NOT called directly here.
        # It is called by the callback *after* the fade animation finishes.



# ------------------------------------------------------------
# ConfigViewerApp Class
# ------------------------------------------------------------
class ConfigViewerApp:

    def __init__(self, master, script_dir, input_file,
                 config_pics_folder, config_info_folder,
                 repo_folder, vehicles_content_folder, user_folder,
                 config_pics_custom_folder, hidden_txt_file, final_instantiation=False):
        

        if final_instantiation:
            final_instantiation_check = "FINAL INSTANTIATION CHECK: TRUE"
            self.final_instantiation = True

        else:
            final_instantiation_check = "FINAL INSTANTIATION CHECK: FALSE"
            self.final_instantiation = False

        print("\n--- DEBUG PRINTS in ConfigViewerApp.__init__() ENTRY ---") # Debug Entry
        print(f"DEBUG-INIT: ConfigViewerApp instance created - SELF OBJECT ID: {id(self)}")
        print(f"DEBUG-INIT: ConfigViewerApp {final_instantiation_check}") # <--- DEBUG PRINT in __init__
        print(f"DEBUG-INIT: Type of config_pics_custom_folder (received): {type(config_pics_custom_folder)}, Value: {config_pics_custom_folder}") # Debug - Check type in __init__
        print(f"DEBUG-INIT: Type of config_pics_folder (received): {type(config_pics_folder)}, Value: {config_pics_folder}") # Debug - Check type in __init__ - ADDED
        print(f"DEBUG-INIT: Type of config_info_folder (received): {type(config_info_folder)}, Value: {config_info_folder}") # Debug - Check type in __init__ - ADDED
        print(f"DEBUG-INIT: Type of repo_folder (received): {type(repo_folder)}, Value: {repo_folder}") # Debug - Check type in __init__ - ADDED
        print(f"DEBUG-INIT: Type of script_dir (received): {type(script_dir)}, Value: {script_dir}") # Debug - Check type in __init__ - ADDED


        self.master = master
        self.script_dir = script_dir
        self.input_file = input_file
        self.config_pics_folder = config_pics_folder
        self.config_info_folder = config_info_folder
        self.hidden_txt_file = hidden_txt_file



        self.cache_file_path = os.path.join(self.script_dir, "data", "config_processing_cache.json")


        self.main_window_title = "Ellexium's Advanced Vehicle Selector (ver. 0.2)"

        self.DEFAULT_IMAGE_PATH = os.path.join("data/MissingZipConfigPic.png")


        self.dev_mode_check = self.script_dir / "dev_mode.txt"
        
        if os.path.exists(self.dev_mode_check):
            self.dev_mode = True

            #if os.path.exists(self.cache_file_path):
            #    os.remove(self.cache_file_path)
            #    print(f"deleting cache on start due to dev mode being enabled")
        else:
            self.dev_mode = False



        self.show_scanning_window_count = 0 # Initialize the amount of times the window is called, the first couple of times it's called should have it be in the center of the screen, not the master
        self.show_scanning_window_currently_on_screen = False

        self.console_window = None
        self.original_stdout = sys.stdout
        self.original_stderr = sys.stderr
        self.is_console_visible = False

        self.ZIP_BASE_NAMES = [] 

        #if final_instantiation:
        self.setup_zip_base_names()


        scanning_win = None  # Initialize scanning_win





            
            
        self.SPAWN_QUEUE_FILE = "data/spawn_queue.lua"
        self.SPAWN_QUEUE_TRANSIENT_FILE = "data/Spawn_Queue_Transient.lua"
        self._last_spawned_brands = []

        self.repo_folder = repo_folder
        self.vehicles_content_folder = vehicles_content_folder
        self.user_folder = user_folder
        self.config_pics_custom_folder = config_pics_custom_folder

        self.data_subset_file = "data/data_subset.txt" # Initialize data_subset_file path
        self.data_subset_favorites_file = "data/data_subset_favorites.txt"
        

        self.matches_txt = "data/matches.txt"


        self.resize_scan_win = None

        scanning_win = None


        initial_scan_win_txt_file = os.path.join(script_dir, "data/initial_scan_win_text.txt")

        if os.path.exists(initial_scan_win_txt_file):
            print(f"{initial_scan_win_txt_file} exsts. Customizing initialization text.")
            # MAKE the text equal the contents of the text file here 
            try:
                with open(initial_scan_win_txt_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith("Loading Stage:"):
                            try:
                                # Extract the value after the colon
                                value_str = line.split(':', 1)[1].strip()

                                self.scanning_win = self.show_scanning_window(text=value_str)

                            except Exception as e:
                                    print(f"Error reading file {initial_scan_win_txt_file}: {e}. Using default initialization text.") 
        
            except Exception as e:
                print(f"Error opening file {initial_scan_win_txt_file}: {e}. Using default initialization text.") 


        else: 
            print(f"{initial_scan_win_txt_file} does not exist. Using default initialization text.") 
            self.scanning_win = self.show_scanning_window(text="Initializing...")


        if os.path.exists(initial_scan_win_txt_file):
            print(f"ConfigViewerApp __init__:  existing initial_scan_win.txt file at: {initial_scan_win_txt_file}")
            try:
                os.remove(initial_scan_win_txt_file) # Remove the file if it exists
                print(f"ConfigViewerApp __init__: removed existing initial_scan_win.txt file at: {initial_scan_win_txt_file}")
            except Exception as e:
                print(f"Error removing initial_scan_win.txt: {e}") 


        if final_instantiation:

            self.button_style_args = {
                "relief": tk.FLAT, # Flat buttons
                "borderwidth": 0,
                "bg": "#555555", # Default button background color (dark grey)
                "fg": "#FFFFFF",    # Default text color
                "activebackground": "#FFFFFF", # Clicked background - will be set dynamically
                "activeforeground": "black", # Clicked text color - will be set dynamically
                "highlightthickness": 0 # Remove highlight
            }

            self.restart_button_active_fg_color = "#FFFFFF"

            self.warning_color_sidebar = "#ff4747" # Store the warning colors
            self.warning_color_restart_button = "#ffa1a1"

            self._fade_animation_running_sidebar = False # Flags to track if animation is running
            self._fade_animation_running_restart = False

            self.default_sidebar_color = "#ffffff"  # Changed to hex code for white
            self.default_restart_color = "#ffffff"

            self.avoid_hiding_sidebar_temporarily = False
            self.cursor_landed_on_item = False

            self.pause_loading = False  # Initialize the pause_loading flag

            self.category_hidden_states = {} # Initialize category hidden states in __init__

            self.debounce_timer = None  # Initialize debounce timer attribute
            self.is_debouncing = False
            self.details_debounce_timer = None





            # Define resampling filter
            try:
                self.RESAMPLE_FILTER = Image.Resampling.LANCZOS  # For Pillow >= 10
            except AttributeError:
                self.RESAMPLE_FILTER = Image.LANCZOS


            self.main_grid_widget_cache = {}  # NEW: Cache for main grid item widgets - State-Aware Cache

            self.image_cache_capacity = 1500 # Example capacity - adjust as needed
            self.image_cache = OrderedDict() # Using OrderedDict for LRU

            self.image_load_locks = {} # To store locks per image path
            self._dict_lock = threading.Lock() # To protect access to image_load_locks dictionary
            self.cache_access_lock = threading.Lock() # New lock for image_cache


            # --- NEW: Eviction Batching ---
            self.eviction_count = 0
            self.eviction_batch_delay_ms = 4000 # Print summary every 4 seconds
            self.eviction_timer_running = False


            self.image_cache_pil = {}  # Cache to store PIL Images
            self.individual_info_cache = {}  # NEW: In-memory cache for individual info JSON data  <--- INSERT HERE
            self.full_data_cache = {} # NEW: Cache for full_data from load_data
            self.data_cache = [] 
            self.config_info_cache = {}
            self._view_all_data_cache = {} # NEW: Initialize cache for "View All" data

            
                

            

            self.highlight_images = {}  # Dictionary to store highlight images per widget
            self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=18)
            self.lock = threading.Lock()

            # Initialize image counts per category
            self.image_counts = {}


            # --- NEW: Disk Image Cache Directory --- # <---- INSERT HERE
            self.disk_image_cache_dir = os.path.join(self.script_dir, "data/image_cache_disk")
            if not os.path.exists(self.disk_image_cache_dir):
                os.makedirs(self.disk_image_cache_dir) # Create directory if it doesn't exist
            #disabling cache





            # Define the full path to the check file
            self.first_run_check_file_path = os.path.join(self.script_dir, "data/first_time_run_check_file.txt")

            if not os.path.exists(self.first_run_check_file_path):


                try:
                    with open(self.first_run_check_file_path, "w") as f:
                        f.write("CheckPassed")

                except IOError as e:
                    print(f"Error: Could not write to first run check file: {e}")


            else:

                print(f"Not first time run: {self.first_run_check_file_path} already exists.")

            # Details Window state
            self.details_window_closed = True
            self.details_window = None
            self.details_scrollable_frame = None
            self.details_canvas_sub = None
            self.details_pagination_bar = None  # For details pagination

            self.details_batch_retry_count = 0
            self.MAX_DETAILS_BATCH_RETRIES = 5

            self.details_window_should_open_in_favorites_mode = False

            self.no_configs_messagebox_condition = False

            # Dynamic bindings files and folders

            userfolder_root = os.path.dirname(os.path.dirname(self.script_dir))

            #self.userfolder_root_settings_folder = os.path.normpath(os.path.join(userfolder_root, "settings"))

            self.keyboard_diff_path = os.path.normpath(os.path.join(userfolder_root, "settings/inputmaps/keyboard.diff"))

            self.settings_json_file = os.path.normpath(os.path.join(userfolder_root, "settings/settings.json"))

            data_folder = self.script_dir / "data"
            self.switcher_confirmation_path = data_folder / "switcher_binding_confirmation_file.txt"





            self.main_search_entry_widget_focused_but_window_not_focus = False
            self.window_has_os_focus = False


            # Global Filters

            self.skip_perform_search = False
            self.ignore_keyrelease_after_focus_msec = 1200 # Milliseconds to ignore keys after focus
            self._ignore_keyrelease_timer_id = None # To store the timer ID

            
            self.filters_window = None
            self.current_tooltip_global_filter_window = None
            self.tooltip_global_filter_original_bg_color = None
            self.on_off_buttons_list = []
            self.numeric_criteria = ["Top Speed (km/h)", "Power", "0-100 km/h", "Off-Road Score", "Braking G"]
            self.filter_settings_file = "data/global_filter_settings.txt"
            self.configinfo_folder = "data/configinfo" # Define configinfo folder
            self.filter_output_file = "data/filter_results.txt" # Define output file for filter results
            self.data_subset_file = "data/data_subset.txt"
            
            self.search_results_window = None


            self.is_search_results_window_active = False

            self.is_search_results_window_active_bypass_flag = False
            
            self.is_search_results_window_closing = False #?? nothing uses this flag
            
            self.all_filters_all = True
            
            self.is_constraints_results_window_active = False 

            self.delayed_sort_by_install_date_or_favorites_category_toggle = False
            
        

            

            self.search_results_data = []          # Initialize data for search results window
            self.search_results_filtered_data = [] # Initialize filtered data for search results
            self.search_results_grouped_data = {}   # Initialize grouped data for search results
            
            
            self.widget_original_colors = {} # Example: {widget: {'bg': '#555555', 'fg': 'white'}}

            # --- Animation Parameters ---
            self.transition_duration_sec = 0.15 # Duration in seconds

            # --- General Animation State Tracking ---
            # Key: widget object, Value: dictionary of state info
            self.animation_states = {}

            #
            self.widget_animation_configs = {} # NEW: To store revert-to state and check_state
            self.actively_hovered_widgets = set()


            # init animation code

            self.loading_search_results_window = False

            # For pagination & searching in details
            self.details_data = []
            self.details_filtered_data = []
            self.details_page = 0
            self.items_per_page = 50  # (Still used in some fallback pagination logic)

            self.columns = None  # Initialize columns for main grid
            self.details_columns = None  # Initialize columns for details grid

            self.details_last_width = None
            self.details_last_height = None
            self.details_resize_timer = None

            # Keep track of main window size to prevent unnecessary reloads
            self.last_width = self.master.winfo_width()
            self.last_height = self.master.winfo_height()
            self.resize_timer = None

            # Flags for "Deleting..." flashing
            self.is_deleting = False
            self.deleting_color_flag = True
            self.deleting_label = None
            

            # Flags for details window "Deleting..."
            self.details_is_deleting = False
            self.details_deleting_color_flag = True
            self.details_deleting_label = None

            # Flags for "Editing Settings..."
            self.is_editing = False
            self.editing_color_flag = True
            self.editing_label = None



            # Sort by install date
            self.sort_by_install_date = False


            self.global_highlight_color = "#FFA500" # Hex code for orange  # you can swap this out for other stuff in the future, like for eg making this a setting, but not right now
                                   

            self.conwin = None

            # NEW: Define contrasting text color for persistent highlight
            self.PERSISTENT_TEXT_COLOR_ON_GLOBAL_HIGHLIGHT = "#FFFFFF" # White text on orange

            # NEW: Attributes to track last clicked items
            self.last_clicked_main_item_frame = None
            self.last_clicked_search_item_frame = None
            
            # Categorization mode
            self.categorization_mode = 'Type'  # Default


            # Switcher - Initialize settings_file_path **BEFORE loading settings**
            self.settings_file_path = os.path.join(script_dir, "data/MMSelectorSettings.txt") # <--- INITIALIZE settings_file_path HERE - CORRECT ORDER


            self.floating_window_last_position = None # Initialize to None, will be loaded or centered


            self.show_switcher_on_startup = False
            self.sort_by_install_date = False
            self.placeholder_settings = False                   # false means it should not show configs without their previews
            self.middle_click_settings = False                  # false means it should be added to the spawn queue by double clicking, true means middle clicking does that
            self.show_folder_settings = False
            self.jump_to_page_button_should_be_bottom = True    # true keeps the button at the bottom of the screen
            self.leave_config_window_open = False
            self.collapse_categories_by_default = False         # Initialize to False (Off) by default
            self.show_pinned_favorites_category = True

            self.default_categorization_mode = 'Type'

            # --- NEW: Font Size Setting ---
            # Stores the numeric value to add (0 for Default, 2 for Medium, 4 for Large)
            self.font_size_add = 0 # Default to 0 ('Default' size)

            self.font_size_changed_this_session = False


            print("DEBUG-INIT: Calling load_settings() NOW (BEFORE format_grouped_data)...") # Debug - Call Order - BEFORE
            self.load_settings() # Load settings AFTER initializations, BEFORE GUI setup - CORRECTED CALL ORDER
            print("DEBUG-INIT: load_settings() RETURNED.") # Debug - Call Order - BEFORE

            # --- Favorites Functionality --- called before format group data so the sorting works

            self.favorites_file_path = os.path.join(script_dir, "data/favorites.txt")
            self.favorite_configs = self.read_favorites()


            self.current_favorites_amount = 0
        
            self.unique_favorite_folder_count = self._count_unique_folders_in_favorites()
            print(f"DEBUG-INIT: Initial unique favorite folder count: {self.unique_favorite_folder_count}")
 


            self.original_data, self.original_full_data = self.load_data() # Load data NOW
            self.data = list(self.original_data)
            self.full_data = dict(self.original_full_data)
            self.grouped_data = self.format_grouped_data(self.data)




            self.main_grid_item_widgets = {} # Initialize dictionary to store widgets for main grid items

            
            
            print("DEBUG-INIT: format_grouped_data() RETURNED - AFTER load_settings()") # Debug - Call Order - AFTER
            # --------------------------------------------------------------------------------
            # MODIFICATION END - Load data AFTER GUI setup for testing
            # -------------------------------------------------------------------------------

            # --- NEW: Flag to track if all main grid images are cached ---
            self.all_main_grid_images_cached = False # Initialize to False

            # Added attributes for pausing/loading
            self.pause_loading = False
            self.loading_pause_timer = None

            # Added attributes for loading animation (main grid)
            self.loading_animation_running = False





            self.current_item_offset_in_category = 0
            self.total_items_for_display = 0
            # --------------------------------------
            # batch loading config
            # --------------------------------------
            # You can adjust these two variables to change how big each batch is
            # and how many milliseconds to wait between loading batches in the subgrid.
            self.details_batch_size = 25 # batches of

            self.details_batch_delay = 150 # schedule - time taken between each batch




            #self.main_grid_batch_sizes = [30, 30, 30, 30]
            self.main_grid_batch_sizes = [50]

            self.default_batch_size = 50 # this is after the last number specified in self.main_grid_batch_sizes

            self.grid_layout_split_value = 0 # number of widgets to be displayed on one page depending on the number of columns
            self.update_grid_layout_run = False


            # Flag for details "Loading..." animation
            self.details_loading_animation_running = False

            self.scroll_animation_duration = 600  # milliseconds for scroll animation
            self.scroll_animation_steps = 30      # Number of animation steps
            self.scroll_target_yview = None       # Target yview for smooth scrolling
            self.scroll_current_yview = None      # Starting yview for animation
            self.scroll_animation_timer = None     # Timer ID for animation
            self.scroll_delta_units = 0           # Store scroll delta in units instead of pixels

            self.auto_reopen_details_after_change = False # Initialize flag for auto-reopen (this doesn't work properly right now)




            self.min_throttle_ms = 16  # For slow drag (e.g., ~60 FPS updates)
            self.max_throttle_ms = 100 # For fast drag (e.g., ~10 FPS updates)

            self.speed_threshold_low = 50.0  # Pixels per second: below this, use min_throttle_ms SLOW 
            #MEDIUM IS BETWEEN THESE 
            self.speed_threshold_high = 300.0 # Pixels per second: above this, use max_throttle_ms FAST 
            self.min_delta_t_for_speed_calc = 0.001 # Seconds: minimum time diff for speed calc to avoid div by zero

            # For throttling scroll updates (you might already have these)
            self._scroll_pending = False
            self._throttled_after_id = None
            self._scroll_throttle_ms = self.min_throttle_ms # Initial throttle value


            # --- NEW: Dynamic Batch Sizes ---


            self.current_main_batch_index_in_sequence = 0



            #self.details_grid_batch_sizes = [30, 10, 10, 10] # You can customize these separately THIS IS NOT USED ?
            #self.current_details_batch_index_in_sequence = 0


            #this appears to be for the filter dropdowns
            self.scroll_animation_id = None
            self.scroll_target_y = 0
            self.scroll_start_y = 0
            self.scroll_duration = 200  # milliseconds for scroll animation (adjust as needed)
            self.scroll_start_time = 0


            ################### - details sidebar scrolling
            
            # --- NEW: State variables for sidebar text smooth scroll ---
            self.sidebar_text_scroll_animation_id = None
            self.sidebar_text_scroll_target_y = 0.0
            self.sidebar_text_scroll_start_y = 0.0
            self.sidebar_text_scroll_start_time = 0


            
            # --- NEW: State variables for sidebar text CUSTOM scrollbar ---
            self.custom_scrollbar_canvas_sidebar_text = None # Canvas for the scrollbar itself
            self.scrollbar_thumb_sidebar_text = None       # The rectangle (thumb)
            self.scrollbar_thumb_dragging_sidebar_text = False
            self.scrollbar_thumb_start_y_sidebar_text = 0
            self.scrollbar_mouse_start_y_sidebar_text = 0
            ####################

            self._scroll_throttle_ms = 60  # Adjust this value (e.g., 50ms = 20 FPS, 100ms = 10 FPS)
            self._scroll_pending = False
            self._throttled_after_id = None
            self._last_drag_y = 0 # Store the last mouse Y during drag
            self._last_thumb_y = 0 # Store the last thumb Y during drag



            self._cursor_controlled_by_us = False # Flag to track if we moved the cursor
            self._original_cursor_pos_screen = None # Stores (x, y) screen coordinates before we moved it
            self._cursor_lock_job_id = None        # Stores the ID of the after job that maintains the lock
            self._cursor_lock_target_pos_screen = None # Stores (x, y) screen coordinates where we moved the cursor
            
            self._interaction_blocked_by_us = False
            self._overlay_window = None
            self._original_master_focus = None # To restore focus

            self.cursor_restore_timer_id = None
            self.CURSOR_RESTORE_DELAY_MS = 300


            # --- NEW: Highlight Pause Debounce Timer ---
            self.highlight_pause_debounce_timer = None

            # --- NEW: Skipped UI Update Queues ---
            self.main_grid_skipped_updates_queue = []
            self.details_grid_skipped_updates_queue = []

            # --- NEW: Printing Control ---  <----------------------  INSERT HERE
            self.original_print = builtins.print # Store the original print function
            self.disable_printing = False # Flag to control printing

            # --- NEW: Scroll Pause for Hover Effects ---
            self.is_scrolling_main_grid = False # Initialize to False (not scrolling initially)
            self.scroll_debounce_delay = 600 # milliseconds for debounce delay (600ms after scroll stop)
            self.scroll_debounce_timer_id = None # To keep track of the debounce timer

            self.scroll_mouse_unhide_delay = 150
            self.scroll_mouse_unhide_timer_id = None

            self.matches_config_data = self.load_matches_config_data()

            self.details_pause_counter = 0




            self.filter_state = 0

            self.filter_options = [
                "View All",
                "Items with Config Preview Images [debug]",
                "Items Without Config Preview Images [debug]",
                "Only Mods",
                "Vanilla",
                "Favorites",
                "Unpacked Mods" #custom configurations are grouped into their relative zip file folders. this could be re-used for fully unpacked mods
            ]


            self.current_details_item_tooltip_window = None
            self.tooltip_debounce_timer = None  # For debouncing tooltip display
            self.tooltip_autodestroy_timer = None # For auto-destroying tooltip
            
            self.spawn_queue_window_was_open = False 


            self.use_disk_image_cache = False  # Set to False to disable disk image cache
            self.use_info_file_cache = False  # Set to False to disable info file cache

            self.omit_label = False  # Set to True to omit labels in the main grid

            self.items_to_be_hidden = False
            self.found_hidden_item = False
            self.main_grid_labels = [] # Initialize a list to store label widgets
            self.hidden_items_set = set() 


            self.new_button_label = None


            self.DEFAULT_SWITCH_DISPLAY_TEXT = "Ctrl+Y" 

            self.DEFAULT_SWITCH_BINDING = "<Control-y>"


            self.disable_hover_temporarily = False
            self.resizing_window = False
            self.window_was_resized = False
            self.window_was_resized_2 = False
            self.rebuilding_gui = False
            self.hide_main_grid_and_sidebar_start_passed = 0
            self.text_to_switch_back_to = None
            self.details_window_opened_before = False
            self.on_resize_complete_called = 0
            self.update_grid_layout_called_first_time = True
            self.window_size_changed_during_search_results_window = False
            self.details_page_before_resize = None # Variable to store page number during resize
            self.details_window_intentionally_closed = False
            self.window_size_changed_during_details_window = False
            self.search_results_window_on_screen = False

            self.favorites_amount_changed = False

            self.update_grid_after_size_rechange = False


            self.master.after_idle(self._store_initial_minsize)
            self._original_minsize = (1, 1) # Default fallback
            self._is_size_locked_by_us = False 


            self._last_normal_geometry = None # Stores "WxH+X+Y" string
            # Load geometry first (applies saved settings)



            self.apply_loaded_geometry()   
            self.master.after(100, self._track_normal_geometry)



            # Build GUI - CORRECTED CALL ORDER - CALL GUI SETUP **BEFORE** loading data
            self.details_window_is_favorites_filtered = False # Initialize to False (not favorites filtered initially)


            print("    ConfigViewerApp __init__ is calling setup_gui()")
            self.setup_gui() 

            self.category_list_button_clicked = False


            #setup_gui has initialize_data_and_grid, which calls  self.grouped_data = self.format_grouped_data and then populate_initial_grid()
            #-> popiulate_initial_grid calls perform_search, and then update grid layoutm and then  self.all_main_grid_images_cached = self.are_all_main_grid_images_cached()

            #self.read_favorites()


            self.details_sidebar_debounce_timer = None # Initialize debounce timer for details sidebar
            self.main_grid_sidebar_debounce_timer = None
            self.current_main_sidebar_item = None # To store the currently selected item in main grid sidebar




            # State for dynamic binding
            self.current_emm_bindings = [] # NEW: Store a list of active bindings
            #self.default_emm_binding = "<Control-y>" 

            self.binding_update_queue = queue.Queue()
            self.watchdog_observer = None
            self.watchdog_thread = None
            self._after_id_binding_check = None # To potentially cancel the after loop


            # Start the monitoring process
            self._start_keyboard_diff_monitoring()

            # Start the monitoring process for switch back
            self.switcher_observer = None # To hold the watchdog observer instance

            self.switcher_observer = None
            self.switcher_callback_queue = queue.Queue() # <<< ADD QUEUE
            self._after_id_switcher_check = None # <<< To cancel the after loop


            self._start_switcher_monitoring()



            # debugging shortcuts
            self.enable_debug_shortcuts = False


            self.is_config_viewer_focused = True # NEW: Track focus state - Start with Config Viewer focused
            

            self.details_sidebar_debounce_timer = None # Initialize debounce timer for details sidebar
            self.current_main_sidebar_item = None # To store the currently selected item in main grid sidebar

            print(f"config_pics_custom_folder: {self.config_pics_custom_folder}")  # Debugging print

            self.search_mode = "General"



            self.master.deiconify()

            # --------------------------------------------------------------------------------
            # HIDDEN WINDOW INITIALIZATION
            # -------------------------------------------------------------------------------

            # --- Hidden Vehicles Window Variables
            self.hidden_window = None  # Initialize hidden_window as None
            self.original_hidden_lines = []
            self.all_vehicles_data = self.load_hidden_vehicles_once() # Load all data ONCE in init
            self.hidden_vehicles_data = list(self.all_vehicles_data) # Initially display all
            self.hidden_window_search_after_id = None # For debouncing search
            self.vehicle_frames = [] # Initialize vehicle_frames
            self.hidden_window_search_DEBOUNCE_DELAY_MS = 300  # Debounce delay in milliseconds

            # Scrollbar variables - HIDDEN WINDOW
            self.hidden_window_custom_scrollbar_canvas_hidden = None # Will be created in create_widgets_hidden_window
            self.hidden_window_scrollbar_thumb_hidden = None # Will be created in create_widgets_hidden_window
            self.hidden_window_scrollbar_thumb_dragging_hidden = False
            self.hidden_window_scrollbar_thumb_start_y_hidden = 0
            self.hidden_window_scrollbar_mouse_start_y_hidden = 0
            self.hidden_window_scroll_animation_timer_hidden = None
            self.hidden_window_scroll_animation_id_hidden = None
            self.hidden_window_scroll_target_yview_hidden = 0.0
            self.hidden_window_scroll_start_y_hidden = 0.0
            self.hidden_window_scroll_start_time_hidden = 0
            self.hidden_window_scroll_duration = 200  # ms for smooth scroll animation - can be global if needed


            self.hidden_window_hidden_window_restart_button_active_fg_color = "#FFFFFF"
            self.hidden_window_warning_color_hidden_window_restart_button = "#ffa1a1"
            self._hidden_window_fade_animation_running_restart = False
            self.hidden_window_default_restart_color = "#ffffff"
            self.unhide_was_toggled_in_hidden_window = False

        # --------------------------------------------------------------------------------
        # HIDDEN WINDOW INITIALIZATION END 
        # -------------------------------------------------------------------------------

        self.scanning_window = scanning_win  # Initialize scanning_window attribute

        self.trigger_refresh_scanning_win = None
        self.warning_scanning_win = None

        # --------------------------------------------------------------------------------
        # --- Delete the stale backup folder that - final step
        # -------------------------------------------------------------------------------

        self.delete_backup_folder_on_startup()
        print("--- DEBUG PRINTS in ConfigViewerApp.__init__() EXIT ---\n") # Debug Exit


    def setup_zip_base_names(self):

        main_script_directory = os.path.dirname(os.path.abspath(sys.argv[0])) # Get the directory of the MAIN script
        txt_file_path = os.path.join(main_script_directory, "data/beamng_VANILLA_vehicles_folder.txt")

        try:
            with open(txt_file_path, 'r', encoding="utf-8") as f:
                vehicles_folder = f.readline().strip() # Read the first line and remove whitespace

            if not vehicles_folder:
                print(f"Warning: '{txt_file_path}' is empty or contains no path. ZIP_BASE_NAMES will remain empty.")
            elif not os.path.isdir(vehicles_folder):
                print(f"Warning: Path '{vehicles_folder}' from '{txt_file_path}' is not a valid directory. ZIP_BASE_NAMES will remain empty.")
            else:
                for filename in os.listdir(vehicles_folder):
                    if filename.lower().endswith(".zip"): # Check for .zip extension (case-insensitive)
                        base_name = os.path.splitext(filename)[0] # Get filename without extension
                        self.ZIP_BASE_NAMES.append(base_name)
                if not self.ZIP_BASE_NAMES:
                    print(f"Warning: No ZIP files found in '{vehicles_folder}'. ZIP_BASE_NAMES will remain empty.")
                else:
                    print(f"ZIP files found in '{vehicles_folder}': {self.ZIP_BASE_NAMES}") # Optional: Print found ZIP files

        except FileNotFoundError:
            print(f"Warning: File '{txt_file_path}' not found. ZIP_BASE_NAMES will remain empty.")
        except Exception as e: # Catch other potential errors during file reading or directory access
            print(f"An error occurred while processing '{txt_file_path}': {e}")
            print("ZIP_BASE_NAMES will remain empty.")



    def disable_prints(self):
        """Disables all print statements by replacing builtins.print with a no-op function."""
        if not self.disable_printing: # To prevent accidental repeated calls
            builtins.print = lambda *args, **kwargs: None # Replace print with a do-nothing function
            self.disable_printing = True
            print("Printing DISABLED.") #  This one will still print (using original_print in enable_prints if needed for feedback)

    def enable_prints(self):
        """Enables print statements by restoring the original builtins.print function."""
        if self.disable_printing: # To prevent accidental repeated calls
            builtins.print = self.original_print # Restore the original print function
            self.disable_printing = False
            print("Printing ENABLED.") # This one will now print as normal

    def preload_existing_files(self, folder_path: Path) -> set:
        """
        Preload existing files in the specified folder into a set for efficient lookup.
        
        Parameters:
        - folder_path: Path object representing the folder to preload.
        
        Returns:
        - A set containing the names of existing files in the folder.
        """
        return {file.name for file in folder_path.iterdir() if file.is_file()}
    
    # ------------------------------------------------------------
    # NEW: Integrated configpicextractor_CUSTOM functionality - DEBUGGING PRINTS ADDED - PATH CONVERSION FORCED
    # ------------------------------------------------------------
    def run_configpicextractor_custom_integrated(self): # <--- MODIFIED METHOD
        """
         Modified to call external function.
        """
        print("calling run_configpicextractor_custom_integrated from external file") # Debug
        run_configpicextractor_custom_integrated(self.script_dir, self.user_folder, self.config_pics_custom_folder)



    # ------------------------------------------------------------
    # Switcher
    # ------------------------------------------------------------
    
    
    def on_floating_window_unmapped(self, event=None):
      return on_floating_window_unmapped(self, event) # Call external function


    def destroy_floating_button_window(self):
       return destroy_floating_button_window(self) # Call external function

    def hide_floating_window(self):
       return hide_floating_window(self) # Call external function

    def show_floating_window(self):
      return show_floating_window(self) # Call external function

    def focus_config_viewer_from_floating_button(self):
        return focus_config_viewer_from_floating_button(self) # Call external function

    def remember_floating_window_position(self, event):
       return remember_floating_window_position(self, event) # Call external function

    def load_floating_window_position(self):
        return load_floating_window_position(self) # Call external function
    
    def save_floating_window_position(self):
        return save_floating_window_position(self) # Call external function

                
    # ----------------------------------------------
    # Added Methods for Handling Mouse Wheel Events
    # ----------------------------------------------
    def on_mousewheel_event(self):
        """Handle mouse wheel events to pause image loading."""
        self.pause_loading = True
        if self.loading_pause_timer:
            self.master.after_cancel(self.loading_pause_timer)
        # Resume loading after 200ms of no mouse wheel activity SCROLL DEBOUNCE
        self.loading_pause_timer = self.master.after(700, self.resume_loading)

    def resume_loading(self):
        """Resume image loading after pause. Processes skipped UI updates."""
        self.pause_loading = False
        self.loading_pause_timer = None
        print("Loading RESUMED (Mouse Wheel or Auto-Resume)") # Debug Print
        self.process_skipped_ui_updates() # Process skipped UI updates when resuming

    # --- NEW: Process Skipped UI Updates ---
    def process_skipped_ui_updates(self):
        """Processes queued UI updates that were skipped due to loading pause."""
        # print("Processing Skipped UI Updates...") # Debug Print

        # Process Main Grid skipped updates
        while self.main_grid_skipped_updates_queue:
            update_args = self.main_grid_skipped_updates_queue.pop(0) # FIFO queue
            self.master.after(0, lambda args=update_args: self.create_main_item_widgets(*args))
        # print(f"Processed {len(self.main_grid_skipped_updates_queue)} skipped Main Grid updates.") # Debug - Should be 0

        # Process Details Grid skipped updates
        while self.details_grid_skipped_updates_queue:
            update_args = self.details_grid_skipped_updates_queue.pop(0) # FIFO queue
            self.master.after(0, lambda args=update_args: self.create_details_item_widgets(*args))
        print(f"Processed {len(self.details_grid_skipped_updates_queue)} skipped Details Grid updates.") # Debug - Should be 0
        





    # ------------------------------------------------------------
    # NEW: We can trigger a custom config scan and refresh
    # ------------------------------------------------------------
    def trigger_custom_config_scan_and_refresh(self):
        """
        Pops up a small window saying 'Changes detected, scanning...',
        runs custom config scanning, then refreshes data AND CLEARS MAIN GRID CACHE.
        """
        print("\n--- ConfigViewerApp.trigger_custom_config_scan_and_refresh() ENTRY - DEBUG CHECK ---") # Debug - Entry Point - TRIGGER_CUSTOM_CONFIG_SCAN_AND_REFRESH
        scanning_win = self.show_scanning_window()

        # --- NEW: Clear main grid image cache BEFORE refresh ---
        print("Clearing Main Grid Cache before refresh...") # Debug Print
        self.clear_main_grid_cache() # Call the new cache clearing function
        print("Main Grid Cache Cleared.") # Debug Print

        # --- NEW: Close details window if it's open (as before) ---
        if self.details_window and not self.details_window_closed:


            print("Closing Details Window before refresh...")
            self.details_window_intentionally_closed = True
            self.on_details_window_close()
            print("Details Window Closed.")

        try:
            # Run the known function that scans custom configs
            print("Calling self.run_python_scripts_custom() ...") # Debug - Before Script Run
            self.run_python_scripts_custom()
            print("self.run_python_scripts_custom() RETURNED.") # Debug - After Script Run

            # Reload data
            print("Calling self.refresh_data_from_files() ...") # Debug - Before Data Refresh
            self.refresh_data_from_files()

            print("self.refresh_data_from_files() RETURNED.") # Debug - After Data Refresh
            

            # Refresh the UI
            print("Calling self.perform_search() ...") # Debug - Before Perform Search
            print("    trigger_custom_config_scan_and_refresh is calling self.perform_search() - and clearing the search bar")



            self.search_var.set("")
            time.sleep(1)
            self.perform_search()

            print("    trigger_custom_config_scan_and_refresh is calling self.update_grid_layout()")
            self.update_grid_layout()
            print("self.perform_search() RETURNED.") # Debug - After Perform Search
        except Exception as e:
            messagebox.showerror("Error", f"Error during scanning: {e}")
        finally:
            scanning_win.destroy()
            print("--- ConfigViewerApp.trigger_custom_config_scan_and_refresh() EXIT ---\n") # Debug - Exit Point




    def hide_main_grid_and_sidebar(self):
        """Callback for when the window resize is complete, now with first-call return logic."""
        if self.hide_main_grid_and_sidebar_start_passed == 1: # Check the number of times
            print("DEBUG: hide_main_grid_and_sidebar - First call detected. Returning immediately.")

            return  # Exit function on first call

        print("DEBUG: throttled_resize - Unpacking (hiding) widgets in scrollable_frame during resize...")
        for widget in self.scrollable_frame.winfo_children():
            widget.pack_forget()  # Use pack_forget to hide widgets
        print("DEBUG: throttled_resize - Main grid widgets unpacked (hidden).")


        print("DEBUG: throttled_resize - Unpacking (hiding) sidebar_frame during resize...")
        if self.sidebar_frame and self.sidebar_frame.winfo_ismapped(): # Check if it's packed before forgetting
            self.sidebar_frame.pack_forget()
        print("DEBUG: throttled_resize - sidebar_frame unpacked (hidden).")


    def show_main_grid_and_sidebar(self):
        """
        Makes the main vehicle grid (within scrollable_frame) and the sidebar_frame visible
        by repacking the sidebar and triggering a grid layout update.
        """
        print("--- DEBUG: ENTERING show_main_grid_and_sidebar ---")

        # 1. Show the Sidebar Frame
        # Check if sidebar_frame exists and is managed by pack
        try:
            if hasattr(self, 'sidebar_frame') and self.sidebar_frame:
                # Only pack it if it's not currently visible (mapped)
                if not self.sidebar_frame.winfo_ismapped():
                    print("DEBUG: show_main_grid_and_sidebar - Packing sidebar_frame...")
                    # Use the original pack options from setup_sidebar_frame
                    self.sidebar_frame.pack(side="right", fill="y", padx=(10, 0), pady=10,  expand=False)
                    # Re-apply pack_propagate setting just in case
                    self.sidebar_frame.pack_propagate(False)
                    print("DEBUG: show_main_grid_and_sidebar - sidebar_frame packed.")
                else:
                    print("DEBUG: show_main_grid_and_sidebar - sidebar_frame already visible.")
            else:
                print("DEBUG: show_main_grid_and_sidebar - self.sidebar_frame does not exist, cannot pack.")
        except Exception as e:
             print(f"ERROR packing sidebar in show_main_grid_and_sidebar: {e}")


        # 2. Show the Main Grid Content
        # We don't repack individual children here. Instead, we call update_grid_layout,
        # which is responsible for destroying old grid items and drawing the new ones
        # inside self.scrollable_frame based on current data/filters.
        try:
            print("DEBUG: show_main_grid_and_sidebar - Calling update_grid_layout to repopulate main grid...")
            # Ensure the scrollable_frame itself is visible. Usually it's packed in the main_frame
            # and doesn't get hidden, but check just in case. Assuming it's managed by pack.
            if hasattr(self, 'scrollable_frame') and self.scrollable_frame and self.scrollable_frame.winfo_manager() == 'pack':
                 if not self.scrollable_frame.winfo_ismapped():
                     # You'll need the original pack options for scrollable_frame here
                     # Example: self.scrollable_frame.pack(side="left", fill="both", expand=True)
                     print("WARNING: show_main_grid_and_sidebar - scrollable_frame was hidden, repacking. CHECK PACK OPTIONS.")
                     # Add the correct pack call for scrollable_frame if it can be hidden

                 # Now update its contents
                 self.update_grid_layout()
                 print("DEBUG: show_main_grid_and_sidebar - update_grid_layout called.")
            else:
                 print("DEBUG: show_main_grid_and_sidebar - self.scrollable_frame not found or not packed, skipping grid update call.")

        except Exception as e:
            print(f"ERROR calling update_grid_layout in show_main_grid_and_sidebar: {e}")

        print("--- DEBUG: EXITING show_main_grid_and_sidebar ---")

    
    # ----------------------------------------------------------------
    # NEW: For auto-removal in ConfigPicsCustom if user folder file is deleted
    # ----------------------------------------------------------------
    def remove_corresponding_custom_image(self, user_file_path):
        """
        Given something like .../vehicles/examplecar/example.png was deleted,
        remove 'vehicles--examplecar_user--example.png' if it exists in ConfigPicsCustom.
        Also works if user_file_path is .pc (just tries to remove matching .png/.jpg if it existed).
        """
        # We only proceed if user_file_path is inside the user folder
        if not self.user_folder or not user_file_path.lower().startswith(self.user_folder.lower()):
            return

        # Example: user_file_path = /User/Documents/BeamNG.drive/vehicles/examplecar/example.png
        # We want to parse out 'examplecar' and 'example'.
        folder_part, file_part = os.path.split(user_file_path)
        vehicle_folder = os.path.basename(folder_part)  # 'examplecar'
        base, ext = os.path.splitext(file_part)         # 'example', '.png'

        if not vehicle_folder or not base:
            return

        # Build the base name used in ConfigPicsCustom
        # e.g. vehicles--examplecar_user--example
        custom_prefix = f"vehicles--{vehicle_folder}_user--{base}"

        # We'll attempt .png, .jpg, .jpeg
        possible_extensions = [".png", ".jpg", ".jpeg"]
        for possible_ext in possible_extensions:
            candidate = custom_prefix + possible_ext
            candidate_path = os.path.join(self.config_pics_custom_folder, candidate)
            if os.path.exists(candidate_path):
                try:
                    os.remove(candidate_path)
                except Exception as e:
                    print(f"Error removing {candidate_path}: {e}")



        





    # ------------------------------------------------------------
    # Deleting... Flash Methods
    # ------------------------------------------------------------
    def toggle_deleting_text(self):
        if not self.is_deleting or not self.deleting_label:
            return
        self.deleting_label.config(fg="#FF0000" if self.deleting_color_flag else "black")
        self.deleting_color_flag = not self.deleting_color_flag
        self.master.after(500, self.toggle_deleting_text)

    def toggle_details_deleting_text(self):
        if not self.details_is_deleting or not self.details_deleting_label:
            return
        if self.details_deleting_label.winfo_exists(): # Check if label exists
            self.details_deleting_label.config(fg="#FF0000" if self.details_deleting_color_flag else "black")
            self.details_deleting_color_flag = not self.details_deleting_color_flag
            if self.details_window and not self.details_window_closed:
                self.details_window.after(500, self.toggle_details_deleting_text)

    # ------------------------------------------------------------
    # Editing Settings... Flash Methods
    # ------------------------------------------------------------
    def toggle_editing_text(self):
        if not self.is_editing or not self.editing_label:
            return
        self.editing_label.config(fg="green" if self.editing_color_flag else "black", text="Editing Settings...")
        self.editing_color_flag = not self.editing_color_flag
        self.master.after(500, self.toggle_editing_text)

    # ------------------------------------------------------------
    # Run python Scripts for Mods 
    # ------------------------------------------------------------
    def run_ahk_scripts_mods(self):
        """
        Runs the main function from mod_command_line_config_gen, 
        making it behave as if it's running from guitest.py's directory.
        """



        module_name = "mod_command_line_config_gen"
        module_path = os.path.join(self.script_dir, "modules", f"{module_name}.py")

        if not os.path.exists(module_path):
            messagebox.showerror("Script Not Found", f"Python script not found: {module_path}")
            self.master.destroy()
            return

        # Dynamically load the module
        spec = importlib.util.spec_from_file_location(module_name, module_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        original_working_directory = os.getcwd()
        try:
            os.chdir(self.script_dir)
            print(f"DEBUG: Changed working directory to: {os.getcwd()}")

            # --- Call module.main() FIRST to generate/update outputGOOD.txt ---
            module.main()
            print(f"Successfully executed main() function from '{module_name}.py'.")

            # --- >>> NEW: Call the reordering function <<< ---
            output_good_path = self.script_dir / "data" / "outputGOOD.txt"
            # Ensure ZIP_BASE_NAMES is ready (it should be from __init__)
            if hasattr(self, 'ZIP_BASE_NAMES'):
                reorder_output_good(output_good_path, self.ZIP_BASE_NAMES)
            else:
                print("WARNING: self.ZIP_BASE_NAMES not found, cannot reorder outputGOOD.txt.")
            # --- >>> END NEW CALL <<< ---

        except Exception as e:
            messagebox.showerror("Script Error", f"Error running main() function from '{module_name}.py' OR reordering outputGOOD.txt: {e}")
            self.master.destroy() # Consider if destroy is appropriate here
            return # Exit on error
        finally:
            os.chdir(original_working_directory)
            print(f"DEBUG: Restored working directory to: {os.getcwd()}")



            if self.final_instantiation:


                print("    run_ahk_scripts_mods is calling self.perform_search()")
                self.perform_search()
                self.canvas.yview_moveto(0)  # Reset scroll position to the top

                print("    run_ahk_scripts_mods is calling self.update_grid_layout()")          
                self.update_grid_layout()

                if hasattr(self, 'trigger_refresh_scanning_win') and self.trigger_refresh_scanning_win is not None:
                    try:
                        # Attempt to destroy it
                        self.trigger_refresh_scanning_win.destroy()
                    except tk.TclError as e:
                        # Handle cases where destroy might fail even if the object exists (e.g., widget already destroyed)
                        print(f"TclError while destroying trigger_refresh_scanning_win (might be already gone): {e}")
                    finally:
                        # Set the attribute to None afterwards to prevent trying to destroy it again
                        self.trigger_refresh_scanning_win = None



    def show_message(title, message):
        """Utility function to show a message box."""
        root = tk.Tk()
        root.withdraw()  # Hide the main window
        messagebox.showerror(title, message)
        root.destroy()
        


            
    # ------------------------------------------------------------
    # NEW: Integrated MOD_COMMAND_LINE_CONFIG_GEN_CUSTOM.py functionality - DEBUGGING ADDED (EXTREME) - PATHLIB IMPORTED
    # ------------------------------------------------------------
    def run_mod_command_line_config_gen_custom_integrated(self): # <--- MODIFIED METHOD
         """
        Modified to call external function.
        """
         print("calling run_mod_command_line_config_gen_custom_integrated from external file") # Debug
         run_mod_command_line_config_gen_custom_integrated(self.script_dir, self.user_folder, self.config_pics_folder)




    def run_python_scripts_custom(self): # MODIFIED - No more script path arguments
        python_scripts = [
            # "MOD_COMMAND_LINE_CONFIG_GEN_CUSTOM.py",  <--- REMOVED from list
            # "configpicextractor_CUSTOM.py",  <--- REMOVED from list
            # "modify_output_good.py",  <--- REMOVED from list
        ]
        
        python_executable = sys.executable


        # --- NEW: Call integrated MOD_COMMAND_LINE_CONFIG_GEN_CUSTOM functionality DIRECTLY ---
        try:
            print("Calling self.run_mod_command_line_config_gen_custom_integrated() ...") # Debug
            self.run_mod_command_line_config_gen_custom_integrated() # <--- DIRECT METHOD CALL - NO subprocess
            print("self.run_mod_command_line_config_gen_custom_integrated() RETURNED.") # Debug
        except Exception as e:
            messagebox.showerror("Error", f"Error running run_mod_command_line_config_gen_custom_integrated(): {e}")
            self.master.destroy()
            return
        # --- NEW: Call integrated MOD_COMMAND_LINE_CONFIG_GEN_CUSTOM functionality DIRECTLY ---

        # ############# CONFIG PIC EXTRACTOR ################# 

 

        # --- NEW: Call integrated modify_output_good functionality DIRECTLY ---
        try:
            print("Calling self.run_modify_output_good_integrated() ...") # Debug
            self.run_modify_output_good_integrated() # <--- DIRECT METHOD CALL - NO subprocess
            print("self.run_modify_output_good_integrated() RETURNED.") # Debug
        except Exception as e:
            messagebox.showerror("Error", f"Error running run_modify_output_good_integrated(): {e}")
            self.master.destroy()
            return
        # --- NEW: Call integrated modify_output_good functionality DIRECTLY ---

        try:
            print("Calling self.run_configpicextractor_custom_integrated() ...") # Debug
            self.run_configpicextractor_custom_integrated() # <--- DIRECT METHOD CALL - NO subprocess
            print("self.run_configpicextractor_custom_integrated() RETURNED.") # Debug
        except Exception as e:
            messagebox.showerror("Error", f"Error running run_configpicextractor_custom_integrated(): {e}")
            self.master.destroy()
            return
            
    # ------------------------------------------------------------
    # NEW: Integrated modify_output_good functionality
    # ------------------------------------------------------------
    def run_modify_output_good_integrated(self):
        return run_modify_output_good_integrated(self)


    # ------------------------------------------------------------
    # Extract Fallback Info from JSON
    # ------------------------------------------------------------


    def extract_fallback_info(self, filepath):
        """
        Extracts fallback information from a JSON file, now including "Author".
        """
        required_keys = [
            "Name", "Brand", "Country", "Type", "Body Style", "Years", "Derby Class",
            "Description", "Slogan", "default_pc", "Author"  # <-- ADDED "Author" to required keys
        ]
        extracted_info = {}

        try:
            with open(filepath, "r", encoding="utf-8") as file:
                file_content = file.read()
                for key in required_keys:
                    if key == "Years":
                       pattern = r'"Years"\s*:\s*([^\}]*)' # Capture until closing curly brace
                       match = re.search(pattern, file_content, re.IGNORECASE)
                       if match:
                           value_str = match.group(1)
                           numbers = re.findall(r'\d+', value_str) # Find ALL numbers
                           if numbers:
                               extracted_info[key] = " ".join(numbers)
                           else:
                                extracted_info[key] = ""
                    else:
                        pattern = rf'"{key}"\s*:\s*"([^"]*)"'
                        match = re.search(pattern, file_content, re.IGNORECASE)
                        if match:
                            extracted_info[key] = match.group(1)

        except Exception as e:
            print(f"Error processing {filepath}: {e}")
        return extracted_info
        





    # ------------------------------------------------------------
    # Find Fallback Info - THIS IS USED BY PROCESS LINES
    # ------------------------------------------------------------
    def find_fallback_info(self, picture_filename):
        lower_filename = picture_filename.lower()
        for base_name in self.ZIP_BASE_NAMES:
            if base_name in lower_filename:
                pattern = f"_{base_name}.json"
                for root, _, files in os.walk(self.config_info_folder):
                    for file in files:
                        if pattern in file.lower() and file.lower().endswith(".json"):
                            info_path = os.path.join(root, file)
                            info_data = self.extract_fallback_info(info_path)
                            if info_data:
                                return info_data
        return {}

    # ------------------------------------------------------------
    # Load Data
    # ------------------------------------------------------------

    def _load_cache(self):
        if os.path.exists(self.cache_file_path):
            print(f"Attempting to load data from cache: {self.cache_file_path}")
            try:
                with open(self.cache_file_path, 'r') as f:
                    cache_content = json.load(f)
                    # Basic validation: Check if keys exist
                    if 'data' in cache_content and 'full_data' in cache_content:
                        print("Cache loaded successfully.")
                        return cache_content['data'], cache_content['full_data']
                    else:
                        print("Cache file structure is invalid. Ignoring cache.")
                        return None, None
            except (json.JSONDecodeError, IOError, FileNotFoundError) as e:
                print(f"Failed to load cache file: {e}. Processing files normally.")
                # Optionally delete the corrupted cache file
                # try:
                #     os.remove(self.cache_file_path)
                # except OSError:
                #     pass
                return None, None
        else:
            print("Cache file not found. Processing files.")
            return None, None

    # --- Helper method to save data to cache ---
    def _save_cache(self, data, full_data):
        print(f"Saving data to cache: {self.cache_file_path}")
        try:
            # Ensure the cache directory exists
            cache_dir = os.path.dirname(self.cache_file_path)
            os.makedirs(cache_dir, exist_ok=True)

            cache_content = {
                'data': data,
                'full_data': full_data
            }
            with open(self.cache_file_path, 'w') as f:
                json.dump(cache_content, f, indent=4) # Use indent for readability
            print(f"Cache saved successfully.")
        except (IOError, TypeError) as e:
            print(f"Failed to save cache file: {e}")




    def _finalize_data_processing(self, full_data):
        """
        Takes the complete full_data dictionary and generates the final 'data'
        dictionary containing representative images for the main grid.
        NEW Prioritization: 1. Default Config, 2. First with Main Info, 3. Absolute First.
        ADDED: Debug print for expected main info path check.
        """
        print("\n--- _finalize_data_processing() STARTING (NEW Prioritization + Path Debug) ---") # Added Path Debug note
        data = {}
        missing_custom_pic_path = os.path.join(self.script_dir, "data/MissingCustomConfigPic.png")
        missing_zip_pic_path = os.path.join(self.script_dir, "data/MissingZipConfigPic.png")

        for folder_name, config_list in full_data.items():
            representative_image_path = None
            item_to_represent = None

            valid_config_list = [item for item in config_list if isinstance(item, (list, tuple)) and len(item) == 5]

            if not valid_config_list:
                print(f"Warning: No VALID configs found for folder '{folder_name}' during finalization. Skipping.")
                continue

            # Step 1: Check for Default Config
            first_valid_item_context = valid_config_list[0]
            item_source_zip_context = first_valid_item_context[2]
            default_config_item = self.find_default_config_item_details(valid_config_list, item_source_zip_context)

            if default_config_item:
                representative_image_path = default_config_item[0]
                item_to_represent = default_config_item
                #print(f"  Finalize - Folder: {folder_name} - Using DEFAULT config image: {os.path.basename(representative_image_path)}")
            else:
                # Step 2: Find First Config with Existing Main Info File
                #print(f"  Finalize - Folder: {folder_name} - Default config not found. Searching for first config with Main Info JSON...")
                found_with_main_info = False
                for item in valid_config_list:
                    pic_path, spawn_cmd, zip_file, info_data_item, folder_name_item = item

                    if zip_file == "user_custom_configs":
                        continue

                    expected_main_info_filename = f"vehicles--{folder_name_item}_{zip_file}--info.json"
                    expected_main_info_path = os.path.join(self.config_info_folder, expected_main_info_filename)

                    # --- >>> ADDED DEBUG PRINT HERE <<< ---
                    #print(f"    Checking for Main Info: '{expected_main_info_path}'")
                    # --- >>> END ADDED DEBUG PRINT <<< ---

                    if os.path.exists(expected_main_info_path):
                        representative_image_path = pic_path
                        item_to_represent = item
                        found_with_main_info = True
                        #print(f"  Finalize - Folder: {folder_name} - Found FIRST config with Main Info JSON: '{expected_main_info_filename}'. Using image: {os.path.basename(representative_image_path)}")
                        break

                # Step 3: Fallback to Absolute First Config
                if not found_with_main_info:
                    print(f"  Finalize - Folder: {folder_name} - No default found, in addition to No config with Main Info JSON found. Falling back to ABSOLUTE FIRST config.")
                    first_valid_item = valid_config_list[0]
                    representative_image_path = first_valid_item[0]
                    item_to_represent = first_valid_item

            # Final Check and Data Population (logic remains the same)
            if representative_image_path is None or not os.path.exists(representative_image_path):
                print(f"  Finalize - Folder: {folder_name} - Representative image path missing or invalid ('{representative_image_path}'). Using PLACEHOLDER.")
                item_source_for_placeholder = "unknown_source"
                if item_to_represent:
                    item_source_for_placeholder = item_to_represent[2]
                elif valid_config_list:
                     item_source_for_placeholder = valid_config_list[0][2]

                is_item_custom = item_source_for_placeholder == "user_custom_configs"
                representative_image_path = missing_custom_pic_path if is_item_custom else missing_zip_pic_path
                print(f"  Finalize - Folder: {folder_name} - Selected placeholder: {os.path.basename(representative_image_path)}")
                if item_to_represent is None and valid_config_list:
                    item_to_represent = valid_config_list[0]

            if item_to_represent:
                _, line_clean, current_zip_file_from_config, info_data, folder_name_from_config = item_to_represent

                if not isinstance(info_data, dict):
                    print(f"ERROR: Finalize - info_data in chosen representative item for '{folder_name}' is not a dict. Using default.")
                    info_data = {"Name": "Data Error", "Value": 0}
                if 'Value' not in info_data or not isinstance(info_data.get('Value'), (int, float)):
                    info_data['Value'] = 0

                data[folder_name] = [
                    representative_image_path,
                    line_clean,
                    current_zip_file_from_config,
                    info_data,
                    folder_name_from_config
                ]
            else:
                print(f"ERROR: Finalize - Could not determine a representative item for folder '{folder_name}'. Skipping.")

        print("--- _finalize_data_processing() FINISHED (NEW Prioritization + Path Debug) ---")
        return data



    def load_data(self):
        """
        Loads configuration data, utilizing a cache if available.
        If cache is missed, processes both regular and custom configs before saving.
        Handles placeholder settings and hidden folder filtering during processing.
        """
        print("\n--- ConfigViewerApp.load_data() ENTRY ---")



        # 1. --- Check Cache First ---
        # Note: self.cache_file_path should be defined in __init__
        # e.g., self.cache_file_path = os.path.join(self.script_dir, "data", "config_processing_cache.json")
        cached_data, cached_full_data = self._load_cache()
        if cached_data is not None and cached_full_data is not None:
            print("load_data - Cache HIT. Using cached data.")
            # Update internal state directly from cache
            self.full_data_cache = cached_full_data # Store the detailed config list cache
            # 'cached_data' is the dictionary for the main grid (representative images)
            # self.data_cache is expected to be a LIST of the values from that dictionary
            data_values = list(cached_data.values())

            # Apply subset filter immediately after loading from cache
            self.data_cache = self.apply_data_subset_filter(data_values)

            print(f"load_data - Loaded {len(cached_data)} main items (from cache dict), {len(self.data_cache)} after subset filter.")
            print(f"load_data - Loaded {len(self.full_data_cache)} full data groups from cache.")
            print("--- ConfigViewerApp.load_data() EXIT (from Cache) ---")
            # Return the format expected by the caller
            return list(self.data_cache), self.full_data_cache

        # 2. --- Cache MISS - Process Fresh ---
        print("load_data - Cache MISS. Processing files...")
        combined_full_data = {} # Initialize empty dict to accumulate results
        self.individual_info_files = {} # Reset if needed
        self.config_info_cache = {} # Reset cache

        # Define file paths
        regular_input_file_orig = self.input_file # Store original path if needed
        regular_input_file_processed = os.path.join(self.script_dir, "data/outputgood_PreviewsPresent.txt")
        custom_input_file = os.path.join(self.script_dir, "data/outputGOODcustom.txt")
        hidden_folders = self.get_hidden_folders() # Get hidden folders once

        # Determine which regular file to read based on settings
        file_to_read_regular = None
        if self.placeholder_settings:
            # If placeholder settings is TRUE, read the original unfiltered file
            file_to_read_regular = regular_input_file_orig
            print("load_data - Placeholder settings ON, reading original input file.")
        else:
            # If placeholder settings is FALSE, run the filter and read the filtered file
            try:
                print("load_data - Placeholder settings OFF, filtering outputgood...")
                self.filter_outputgood() # Assume this creates/updates outputgood_PreviewsPresent.txt
                file_to_read_regular = regular_input_file_processed
                print(f"load_data - Reading filtered file: {file_to_read_regular}")
            except Exception as e:
                print(f"ERROR: Failed during self.filter_outputgood(): {e}")
                # Fallback to original if filtering fails? Or skip?
                file_to_read_regular = regular_input_file_orig
                print(f"Warning: Falling back to reading original file: {file_to_read_regular}")


        # --- Process Regular Configs ---
        try:
            if file_to_read_regular and os.path.exists(file_to_read_regular):
                print(f"Processing regular data from: {file_to_read_regular}")
                with open(file_to_read_regular, "r", encoding="utf-8") as file:
                    lines = file.readlines()

                # Filter lines based on hidden folders
                filtered_lines = [
                    line for line in lines
                    if not any(
                        f"vehicles/{folder}/" in line.lower() or f"vehicles\\{folder}\\" in line.lower()
                        for folder in hidden_folders
                    )
                ]
                print(f"load_data - Processing {len(filtered_lines)} regular lines after hidden folder filter.")
                # Call the CORE processor, updating the combined dictionary
                combined_full_data = self.process_lines(filtered_lines, combined_full_data, is_custom=False)
            else:
                print(f"Warning: Regular input file not found or not determined: {file_to_read_regular}")
        except Exception as e:
            print(f"ERROR: Failed to process regular config file {file_to_read_regular}: {e}")


        # --- Process Custom Configs ---
        try:
            if os.path.exists(custom_input_file):
                print(f"Processing custom data from: {custom_input_file}")
                with open(custom_input_file, "r", encoding="utf-8") as file:
                    lines = file.readlines()

                # Filter lines based on hidden folders
                filtered_lines = [
                    line for line in lines
                    if not any(
                        # Adapt filter logic for custom file format if necessary
                        f"vehicles/{folder}/" in line.lower() or f"vehicles\\{folder}\\" in line.lower() or f"vehicles--{folder}" in line.lower()
                        for folder in hidden_folders
                    )
                ]
                print(f"load_data - Processing {len(filtered_lines)} custom lines after hidden folder filter.")
                # Call the CORE processor AGAIN, updating the SAME combined dictionary
                combined_full_data = self.process_lines(filtered_lines, combined_full_data, is_custom=True)
            else:
                print(f"Warning: Custom config file not found: {custom_input_file}")
        except Exception as e:
            print(f"ERROR: Failed to process custom config file {custom_input_file}: {e}")


        # --- Finalize and Save ---
        if not combined_full_data:
            print("ERROR: No data was processed from regular or custom files. Cannot finalize or save cache.")
            self.original_data = {} # Or potentially self.data_cache = []
            self.grouped_data = {} # Or potentially self.full_data_cache = {}
            print("--- ConfigViewerApp.load_data() EXIT (No Data Processed) ---")
            # Return empty but correctly structured data
            return [], {}

        print("load_data - Finalizing processed data...")
        # This creates the dictionary for the main grid (representative images)
        final_data_dict = self._finalize_data_processing(combined_full_data)

        print("load_data - Saving combined data to cache...")
        self._save_cache(final_data_dict, combined_full_data)

        # Update internal state
        self.full_data_cache = combined_full_data # Store detailed list
        data_values = list(final_data_dict.values()) # Get list of values for main grid

        # Apply subset filter AFTER processing and finalizing
        self.data_cache = self.apply_data_subset_filter(data_values)

        print(f"load_data - Processed {len(final_data_dict)} main items (before subset filter).")
        print(f"load_data - Processed {len(self.data_cache)} main items (after subset filter).")
        print(f"load_data - Processed {len(self.full_data_cache)} full data groups.")
        print("--- ConfigViewerApp.load_data() EXIT (Processed Fresh) ---")


        # Return the format expected by the caller
        return list(self.data_cache), self.full_data_cache




    def get_hidden_folders(self):
        hidden_folders = []
        hidden_file_path = os.path.join(self.script_dir, "data/Hidden.txt")
        if os.path.exists(hidden_file_path):
            with open(hidden_file_path, "r", encoding="utf-8") as f:
                for line in f:
                    parts = line.strip().split("|||")
                    if parts and parts[0].strip(): # Ensure there's a folder name and it's not empty
                        hidden_folders.append(parts[0].strip())
        return hidden_folders

    def filter_outputgood(self):
        """
        Filters outputgood.txt to remove lines containing "IMAGE_NOT_FOUND-USEMISSING"
        and the two lines following them.
        """

        outputgood_PreviewsPresent = os.path.join(self.script_dir, "data/outputgood_PreviewsPresent.txt")

        if not os.path.exists(self.input_file):
            print(f"Error: Input file '{self.input_file}' not found.")
            return

        filtered_lines = []
        skip_lines = 0
        try:
            with open(self.input_file, 'r', encoding="utf-8") as infile:
                for line in infile:
                    if skip_lines > 0:
                        skip_lines -= 1
                        continue  # Skip this line

                    if "IMAGE_NOT_FOUND-USEMISSING" in line:
                        skip_lines = 2  # Skip the next 2 lines as well
                        continue  # Skip the current line (containing the error)
                    else:
                        filtered_lines.append(line)

        except Exception as e:
            print(f"An error occurred while reading '{self.input_file}': {e}")
            return

        try:
            with open(outputgood_PreviewsPresent, 'w', encoding="utf-8") as outfile:
                outfile.writelines(filtered_lines)
            print(f"Filtered content written to '{outputgood_PreviewsPresent}'")

        except Exception as e:
            print(f"An error occurred while writing to '{outputgood_PreviewsPresent}': {e}")
    



        
    def populate_config_info_cache(self): # NEW FUNCTION - POPULATE CACHE
        """
        Populates the config info cache with data from all JSON files in configinfo folder.
        """
        print("\n--- populate_config_info_cache() ENTRY ---") # Debug Entry
        if not os.path.exists(self.config_info_folder):
            print(f"Warning: Configinfo folder '{self.config_info_folder}' not found, cache not populated.")
            return

        for filename in os.listdir(self.config_info_folder):
            if filename.endswith(".json"):
                filepath = os.path.join(self.config_info_folder, filename)
                try:
                    with open(filepath, 'r', encoding="utf-8") as f:
                        file_content = f.read()
                        self.config_info_cache[filename] = file_content # Cache the raw file content directly
                        #print(f"  DEBUG: Cached config info file: {filename}") # Debug - Cache Success
                except Exception as e:
                    print(f"Warning: Error reading config info file {filename}: {e}. File not cached.") # Debug - Cache Fail

        print(f"populate_config_info_cache - Cached {len(self.config_info_cache)} config info files.") # Debug - Cache Summary
        print("--- populate_config_info_cache() EXIT ---\n") # Debug Exit



    def find_individual_info_file(self, folder_name, zip_file_base_name, config_name):
        """
        Constructs and checks for the existence of an individual info file
        within the 'configinfo' directory relative to the script's location.
        Includes a fallback approach to handle tricky underscore cases.
        """
        try:
            # Determine the script's directory
            #script_dir = self.script_dir
            # Construct the path to the 'configinfo' folder
            #config_info_folder = os.path.join(script_dir, 'data/configinfo')

            # -- Original construction (unchanged) --
            individual_info_filename_1 = (
                f"vehicles--INDIVIDUAL--{folder_name}_{zip_file_base_name}.zip--info_info_{config_name}.json"
            )
            individual_info_path_1 = os.path.join(self.config_info_folder, individual_info_filename_1)
            # Debugging
            #print(f"DEBUG: Attempting original path: {individual_info_path_1}")

            if os.path.exists(individual_info_path_1):
                #print(f"DEBUG: Individual info file FOUND (original): {individual_info_path_1}")
                return individual_info_path_1

            # -- Fallback construction --
            # Handle cases where underscores might be causing issues
            fallback_combined = f"{folder_name}{'_' if folder_name and zip_file_base_name else ''}{zip_file_base_name}"
            individual_info_filename_2 = (
                f"vehicles--INDIVIDUAL--{fallback_combined}.zip--info_info_{config_name}.json"
            )
            individual_info_path_2 = os.path.join(self.config_info_folder, individual_info_filename_2)
            # Debugging
            #print(f"DEBUG: Attempting fallback path: {individual_info_path_2}")

            if os.path.exists(individual_info_path_2):
                #print(f"DEBUG: Individual info file FOUND (fallback): {individual_info_path_2}")
                return individual_info_path_2

            # If neither path exists, return None
            #print("DEBUG: Individual info file NOT FOUND at either path")
            return None

        except Exception as e:
            print(f"ERROR: Exception in find_individual_info_file: {e}")
            return None

    def extract_info_from_sidebar_image(self, picture_path):
        """
        Extracts the necessary information from the sidebar image filename
        to determine folder_name, zip_file_base_name, config_name.
        Returns a dictionary containing the extracted info, or None if extraction fails.
        """
        print(f"DEBUG: extract_info_from_sidebar_image - picture_path: {picture_path}")
        try:
            filename = os.path.basename(picture_path)
            print(f"  DEBUG: Filename extracted: {filename}")

            parts = filename.split('--')
            if len(parts) < 3:
                print("  DEBUG: Could not extract info from filename - unexpected format.")
                return None

            # If it's "vehicles--INDIVIDUAL--...", handle that separately (unchanged)
            if parts[1] == "INDIVIDUAL":
                folder_zip_part = parts[2].split("_", 1)[1]  # e.g. remove "INDIVIDUAL_" prefix
                folder_name = folder_zip_part.rsplit("_", 1)[0]
                zip_file_base_name = folder_zip_part.rsplit("_", 1)[1].replace(".zip", "")
                # --- MODIFIED: Extract config_name correctly ---
                config_name_with_ext = parts[3]  # Get the part with extension (e.g., "12.8L 6x4 Air(Low HP).jpg")
                config_name = os.path.splitext(config_name_with_ext)[0] # Remove extension, get "12.8L 6x4 Air(Low HP)"
                # --- MODIFIED: Extract config_name correctly ---


                print(f"  DEBUG: Extracted - folder_name: {folder_name}, zip_file_base_name: {zip_file_base_name}, config_name: {config_name}")
                return {
                    "folder_name": folder_name,
                    "zip_file_base_name": zip_file_base_name,
                    "config_name": config_name
                }
            else:
                # The "standard" mod config path:
                #  e.g.  vehicles--us_semi_us_semi.zip--t83_sleeper.jpg
                #        parts[1] = us_semi_us_semi.zip
                #        parts[2] = t83_sleeper.jpg
                raw_part = parts[1]  # e.g. "us_semi_us_semi.zip"
                main_str = raw_part.replace(".zip", "")  # "us_semi_us_semi"

                # --- Attempt Original Logic ---
                # Old approach: take the first underscore-chunk as folder_name,
                # everything else as zip_file_base_name
                folder_name_old = main_str.split("_", 1)[0]  # e.g. "us"
                zip_file_base_name_old = main_str.replace(f"{folder_name_old}_", "")  # e.g. "semi_us_semi"

                # If combined back, do we get the original main_str?
                reconstructed = folder_name_old + "_" + zip_file_base_name_old

                if reconstructed == main_str:
                    # Great, it matches: use the original approach
                    folder_name = folder_name_old
                    zip_file_base_name = zip_file_base_name_old
                else:
                    # Fallback: multi-underscore fiasco => treat the entire chunk as folder_name
                    # (and zip_file_base_name as blank or something minimal)
                    folder_name = main_str
                    zip_file_base_name = ""

                # --- MODIFIED: Extract config_name correctly ---
                config_name_with_ext = parts[2]  # Get the part with extension (e.g., "t83_sleeper.jpg")
                config_name = os.path.splitext(config_name_with_ext)[0] # Remove extension, get "t83_sleeper"
                # --- MODIFIED: Extract config_name correctly ---


                print(f"  DEBUG: Extracted - folder_name: {folder_name}, zip_file_base_name: {zip_file_base_name}, config_name: {config_name}")
                return {
                    "folder_name": folder_name,
                    "zip_file_base_name": zip_file_base_name,
                    "config_name": config_name
                }

        except Exception as e:
            print(f"ERROR: Exception during extraction: {e}")
            return None

    #@profile 
    def refresh_data_from_files(self):
        """Refreshes data from files, added search window update."""
        print("\n--- ConfigViewerApp.refresh_data_from_files() ENTRY ---")
        print("Refreshing data from files...")
        print("Calling self.load_data() ...")
        self.original_data, self.original_full_data = self.load_data()
        print("self.load_data() RETURNED.")
        self.data = list(self.original_data)
        self.full_data = dict(self.original_full_data)
        self.setup_sidebar_filter_dropdowns(self.sidebar_bottom_frame, 10)
        
        print("DEBUG: refresh_data_from_files - Manually calling write_watcher_output() BEFORE read_favorites()...")
        try:
            self.write_watcher_output(
                self.watcher_output_file,  # file_path
                self.check_mods,            # check_mods
                self.check_configs,         # check_configs
                self.current_user_vehicles_files, # user_vehicles_files
                self.current_config_pics_custom_files, # config_pics_custom_files
                self.current_mods_files,       # mods_files
                self.current_repo_files,       # repo_files
                self.current_vanilla_files,    # vanilla_files
                self.last_zip_count          # zip_count
            )
            print("DEBUG: refresh_data_from_files - write_watcher_output() BEFORE read_favorites() called successfully.")
        except Exception as e:
            print(f"Warning: Error writing WatcherOutput.txt in refresh_data_from_files BEFORE read_favorites(): {e}")
        
        self.read_favorites()
        print("Calling self.perform_search() ...")
        print("    refresh_data_from_files is calling self.perform_search()")
        self.perform_search()
        print("self.perform_search() RETURNED.")
        self.canvas.yview_moveto(0)
        print("Data refresh complete.")
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE
        print("--- ConfigViewerApp.refresh_data_from_files() EXIT ---\n")

        
        
    def find_image_path(self, folder_name, file_name):
        # Helps locate the correct file in config_pics_custom_folder
        if file_name.lower().startswith(f"vehicles--{folder_name.lower()}_user--"):
            file_name = file_name[len(f"vehicles--{folder_name}_user--"):]

        base_candidate = f"vehicles--{folder_name}_user--{file_name}"
        has_extension = any(file_name.lower().endswith(ext) for ext in ['.jpg', '.jpeg', '.png'])

        if has_extension:
            candidate = base_candidate
            for existing_file in os.listdir(self.config_pics_custom_folder):
                if existing_file.lower() == candidate.lower():
                    found_path = os.path.join(self.config_pics_custom_folder, existing_file)
                    return found_path
        else:
            for ext in ['jpg', 'jpeg', 'png']:
                candidate = f"{base_candidate}.{ext}"
                for existing_file in os.listdir(self.config_pics_custom_folder):
                    if existing_file.lower() == candidate.lower():
                        found_path = os.path.join(self.config_pics_custom_folder, existing_file)
                        return found_path
        return None



    def find_config_pic(self, candidate_image_name, config_pics_folder):
        """Helper function to find config pic path given a base name and folder."""
        for ext in ['jpg', 'jpeg', 'png']:
            check_name = f"{candidate_image_name}.{ext}"
            check_path = os.path.join(config_pics_folder, check_name)
            if os.path.exists(check_path):
                return check_path
        return None
        
        
    def generate_info_key(self, info_data):
        brand = info_data.get("Brand", "Unknown").strip()
        vehicle_type = info_data.get("Type", "Unknown").strip()
        return f"{brand}_{vehicle_type}"



    def log_folder_names_cache_on_startup(self):
        """
        Logs all folder names (keys) present in self.full_data_cache to 'folder_names_cache.txt' on startup.
        """
        log_file_path = os.path.join(self.script_dir, "data/folder_names_cache.txt")
        try:
            with open(log_file_path, "w", encoding="utf-8") as log_file:
                log_file.write("--- Folder Names Cache Log ---\n\n")
                if self.full_data_cache:
                    log_file.write("Folder names (keys) from self.full_data_cache:\n")
                    for folder_name in self.full_data_cache.keys(): # Iterate through keys (folder names)
                        log_file.write(f"{folder_name}\n")
                else:
                    log_file.write("self.full_data_cache is empty. No folder names to log from cache.\n")

                log_file.write("\n--- End of Folder Names Cache Log ---\n")
            print(f"Folder names from cache logged to: {log_file_path}")
        except Exception as e:
            print(f"Error writing folder names from cache to log file: {e}")

    def log_folder_names_on_startup(self):
        """
        Logs all folder names associated with each item in self.data to 'folder_names.txt' on startup.
        """
        log_file_path = os.path.join(self.script_dir, "data/folder_names.txt")
        try:
            with open(log_file_path, "w", encoding="utf-8") as log_file:
                log_file.write("--- Folder Names Log ---\n\n")
                if self.data:
                    log_file.write("Folder names from self.data:\n")
                    for item in self.data:
                        if len(item) == 5:  # Check if item tuple has expected length
                            folder_name = item[4] # Assuming folder_name is the 5th element
                            log_file.write(f"- {folder_name}\n")
                        else:
                            log_file.write(f"- Warning: Item tuple does not have expected length: {item}\n")
                else:
                    log_file.write("self.data is empty. No folder names to log.\n")

                log_file.write("\n--- End of Folder Names Log ---\n")
            print(f"Folder names logged to: {log_file_path}")
        except Exception as e:
            print(f"Error writing folder names to log file: {e}")


            
    # ------------------------------------------------------------
    # Setup Main GUI
    # ------------------------------------------------------------
    def setup_gui(self):
        self.setup_main_window()
        self.setup_top_frame()
        self.setup_bottom_frame()
        self.setup_main_frame()
        self.setup_canvas_and_scrollbar()
        self.setup_scrollable_frame()
        self.setup_sidebar_frame()

        
        self.setup_sidebar_top_frame_content()
        self.setup_sidebar_bottom_frame_content()
        self.setup_event_bindings()
        
        print("    setup_gui is calling initialize_data_and_grid()")
        self.initialize_data_and_grid()
        self.log_folder_names_on_startup() # <--- CALL THE NEW LOGGING FUNCTION HERE, AFTER GUI SETUP
        self.log_folder_names_cache_on_startup() # <--- CALL THE NEW CACHE LOGGING FUNCTION HERE

        self.periodically_update_search_results_window_position() # <--- ADD THIS LINE TO START PERIODIC CHECK
        self.periodically_update_details_window_position() # <--- ADD THIS LINE - PERIODIC UPDATE FOR DETAILS WINDOW
        
        
        # Bind hover event to top bar, sidebar, bottom bar, and scrollable canvas
        if hasattr(self, 'top_frame'):
            self.top_frame.bind("<Enter>", self.lift_search_results_window_without_destroying_dropdowns)
        if hasattr(self, 'sidebar_frame'):
            self.sidebar_frame.bind("<Enter>", self.lift_search_results_window_without_destroying_dropdowns)
        if hasattr(self, 'bottom_frame'):
            self.bottom_frame.bind("<Enter>", self.lift_search_results_window_without_destroying_dropdowns)
        #if hasattr(self, 'canvas'):
        #    self.canvas.bind("<Enter>", self.lift_search_results_window_without_destroying_dropdowns)
        if hasattr(self, 'scrollable_frame'):
            self.scrollable_frame.bind("<Enter>", self.lift_search_results_window_without_destroying_dropdowns)
 


    def setup_top_frame(self):
        # Creates AND assigns the top frame
        # Ensure this frame uses self.master as its parent
        frame = tk.Frame(self.master, bg="#333333", pady=10)
        frame.pack(side="top", fill="x")
        self.top_frame = frame # Assign to self.top_frame

        # Now call methods to populate it, passing the created frame
        self.create_search_bar(self.top_frame)
        self.create_top_buttons(self.top_frame)
        self.create_loading_label(self.top_frame)
        # self.create_progress_bar_main(self.top_frame) # If applicable


    def setup_bottom_frame(self, scale_changed=False):
        # Creates AND assigns the bottom frame
        # Ensure this frame uses self.master as its parent
        frame = tk.Frame(self.master, bg="#333333", pady=10)
        frame.pack(side="bottom", fill="x")
        self.bottom_frame = frame # Assign to self.bottom_frame

        # Now call methods to populate it, passing the created frame
        self.create_filter_button(self.bottom_frame)
        self.create_categorize_button(self.bottom_frame)
        self.create_category_list_button(self.bottom_frame)
        self.create_no_configs_message_label(self.bottom_frame)
        self.create_status_labels(self.bottom_frame)

        if scale_changed:
            self.create_settings_button(self.bottom_frame, scale_changed=True)
        else:
            self.create_settings_button(self.bottom_frame, scale_changed=False)


        self.create_restart_button(self.bottom_frame)
        self.create_hidden_vehicles_button(self.bottom_frame)
        self.create_isolated_mods_button(self.bottom_frame)
        self.create_progress_bar_main(self.bottom_frame)



    def setup_main_window(self):
        self.master.title(self.main_window_title)

        min_width = 967
        min_height = 647

        self.master.minsize(min_width, min_height)


        icon_path = self.script_dir / "data/icon.png"

        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            self.master.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")




		
		
    def create_search_bar(self, top_frame):
        """Creates the search bar with updated styling to match the dark theme and light grey background."""
        self.search_var = tk.StringVar()
        self.search_entry = search_entry = tk.Entry(top_frame, textvariable=self.search_var, font=("Segoe UI", 12+self.font_size_add), width=30, bg="#d9d9d9", fg="black", insertbackground="black") # <-- UPDATED bg to "#d9d9d9", fg to "black", insertbackground to "black"

        # --- COPY BUTTON STYLES FROM TOP/BOTTOM FRAME BUTTONS ---
        self.search_button_style_args = {
            "bg": "#333333",
            "fg": "#FFFFFF", # MODIFICATION: Change search icon emoji to white

        }
        # --- COPY BUTTON STYLES FROM TOP/BOTTOM FRAME BUTTONS ---

        search_button = tk.Label(
            top_frame,
            text="🔍",
            font=("Segoe UI", 14+self.font_size_add), # Font for the icon, keep it non-bold
            **self.search_button_style_args # <--- APPLY BUTTON STYLES
        )


        search_button.pack(side="left", padx=(4, 2)) 
        search_entry.pack(side="left", padx=(0, 10)) 

        search_entry.bind("<KeyRelease>", self._handle_main_search_key_release)

        # Define the handler method within your class:



        def delayed_lift(event):
            self.master.after(500, self.lift_search_results_window_without_destroying_dropdowns) # Schedule lift after 2 seconds

        #search_entry.bind("<KeyRelease>", delayed_lift) # NEW - Delayed lift

    def _handle_main_search_key_release(self, event):
        """
        Handles KeyRelease events for the search entry, ignoring specific keys
        and events immediately after external focus gain.
        """
        # --- Add this check at the very beginning ---
        if self._ignore_keyrelease_timer_id is not None:
            print(f"DEBUG: Ignoring KeyRelease '{event.keysym}' during post-focus grace period.")
            return # Stop processing this event during the ignore period
        # --- End of added check ---

        # Define the keysyms of keys to ignore (Escape, Alt, Tab)
        ignored_keys = {'Escape', 'Alt_L', 'Alt_R', 'Tab'}

        # print(f"Key released: {event.keysym}") # Optional: for debugging

        # Check if the released key's keysym is NOT in the set of ignored keys
        if event.keysym not in ignored_keys:
            self.start_debounce_highlighting()
        else:
            print(f"Ignoring key release for non-trigger key: {event.keysym}")


    def start_debounce_highlighting(self):
        """
        Starts the debounce timer for label highlighting.
        """
        if self.debounce_timer:
            self.master.after_cancel(self.debounce_timer) # Cancel existing timer

        #self.debounce_timer = self.master.after(2000, self.actual_label_highlighting) # Set new timer
        print("    start_debounce_highlighting( is calling self.perform_search() - user initiated search from typing in the search bar")
        self.debounce_timer = self.master.after(1000, self.perform_search)
        #self.lift_search_results_window()
        

    def destroy_search_mode_options_dropdown(self, event=None):
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            self.search_mode_options_dropdown_window.destroy()
            self.search_mode_options_dropdown_window = None

            

    def rebuild_gui(self, changing_scale=False):
        """Destroys and recreates the main GUI frames (top, bottom, main content area)."""


        
        print("\n--- Starting GUI Rebuild ---")

        scanning_win = None  # Initialize scanning_win

        if changing_scale:
            print("Called with changing_scale=True, destroying scanning, details, filters, hidden (withdrawing) and spawn queue window and changing font size")
            if self.font_size_add == 0:
                scanning_win = self.show_scanning_window(text=f"Rebuilding UI and setting scale to Small...")

            elif self.font_size_add == 2:
                scanning_win = self.show_scanning_window(text=f"Rebuilding UI and setting scale to Medium...")

            elif self.font_size_add == 4:
                scanning_win = self.show_scanning_window(text=f"Rebuilding UI and setting scale to Large...")


            # --- Close/hide other windows ---
            if hasattr(self, 'details_window') and self.details_window and not self.details_window_closed:
                print("Closing details window before GUI rebuild...")
                self.details_window_intentionally_closed = True
                self.on_details_window_close()


            if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists():
                print("Destroying filters window before GUI rebuild...")
                self.filters_window.destroy()
                self.filters_window = None
            if hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists():
                print("Withdrawing hidden vehicles window before GUI rebuild...")
                self.hidden_window.withdraw()
            if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
                print("Destroying spawn queue window before GUI rebuild...")
                self.destroy_spawn_queue_window()


        else:
            #scanning_win = self.show_scanning_window(text=f"Resizing window...")
            pass


        # --- Destroy existing frames AND reset attributes immediately ---
        print("Destroying existing frames and resetting attributes...")

        # Use try-except for safety during destruction
        try:
            if hasattr(self, 'top_frame') and self.top_frame and self.top_frame.winfo_exists():
                self.top_frame.destroy()
                print("  - Top frame destroyed.")
        except Exception as e:
            print(f"  - Error destroying top_frame: {e}")
        finally:
            self.top_frame = None # Set to None regardless of destruction success

        try:
            if hasattr(self, 'bottom_frame') and self.bottom_frame and self.bottom_frame.winfo_exists():
                self.bottom_frame.destroy()
                print("  - Bottom frame destroyed.")
        except Exception as e:
            print(f"  - Error destroying bottom_frame: {e}")
        finally:
            self.bottom_frame = None # Set to None regardless

        try:
            if hasattr(self, 'main_frame') and self.main_frame and self.main_frame.winfo_exists():
                # Destroying main_frame also destroys the canvas and sidebar within it
                self.main_frame.destroy()
                print("  - Main frame destroyed.")
        except Exception as e:
            print(f"  - Error destroying main_frame: {e}")
        finally:
            self.main_frame = None # Set to None regardless
            # Also reset references to widgets *inside* main_frame
            self.canvas = None
            self.scrollable_frame = None
            self.sidebar_frame = None
            self.sidebar_top_frame = None
            self.sidebar_bottom_frame = None
            self.sidebar_filter_buttons = {}
            # Add any other critical widgets that were inside main_frame

        # --- Let Tkinter process destroy events ---
        self.master.update_idletasks()
        print("  - Ran update_idletasks after destruction and reset.")

        # --- Recreate GUI components by calling setup methods ---
        print("Recreating GUI components...")
        # The setup methods MUST correctly assign to self attributes now
        self.setup_top_frame()           # Creates, assigns self.top_frame, packs, populates
        self.setup_main_frame()          # Creates, assigns self.main_frame, packs BEFORE bottom

        if changing_scale:
            self.setup_bottom_frame(scale_changed=True)        # Creates, assigns self.bottom_frame, packs LAST

        else:
            self.setup_bottom_frame(scale_changed=False)        # Creates, assigns self.bottom_frame, packs LAST

        # Create content *inside* the new self.main_frame
        # Ensure these methods use self.main_frame as parent
        self.setup_canvas_and_scrollbar()
        self.setup_scrollable_frame()
        self.setup_sidebar_frame()
        self.setup_sidebar_top_frame_content()
        self.setup_sidebar_bottom_frame_content()


        print("DEBUG: Checking self.sidebar_bottom_frame IMMEDIATELY AFTER setup calls in rebuild_gui:")
        if hasattr(self, 'sidebar_bottom_frame') and self.sidebar_bottom_frame and self.sidebar_bottom_frame.winfo_exists():
            print("  SUCCESS: self.sidebar_bottom_frame seems valid immediately after setup.")
        else:
            print("  ERROR: self.sidebar_bottom_frame is INVALID immediately after setup!")


        # --- Repopulate the main grid ---
        print("Repopulating main grid using update_grid_layout()...")
        # Ensure update_grid_layout uses self.scrollable_frame correctly

        self.destroy_search_results_window()

        #self.clear_all_filters_and_files()
        #self.search_var.set("")
        #self.perform_search()
        
        print("DEBUG: rebuild_gui is Calling set_filter_to_view_all_and_turn_subset_off after 200ms delay...")
        self.master.after(200, self.set_filter_to_view_all_and_turn_subset_off)

        print("DEBUG: rebuild_gui is Calling self.update_grid_layout() after 300ms delay...")
        self.master.after(300, self.update_grid_layout)
        # --- Re-establish event bindings ---
        print("Re-establishing event bindings...")
        # Ensure setup_event_bindings uses self.master, self.canvas etc. correctly
        self.setup_event_bindings()




        # --- Final UI update ---
        self.master.update_idletasks()


        #self.perform_search()


        self.rebuild_hidden_window_gui()


        if scanning_win:
            scanning_win.destroy()

        print("--- GUI Rebuild Complete ---\n")


    def rebuild_hidden_window_gui(self):
        """Destroys and recreates the widgets within the Hidden Vehicles window."""
        print("\n--- Starting Hidden Window GUI Rebuild ---")

        if not hasattr(self, 'hidden_window') or not self.hidden_window or not self.hidden_window.winfo_exists():
            print("Hidden window does not exist or is already destroyed. Cannot rebuild.")
            return

        # --- Destroy all direct children of the Toplevel window ---
        print("Destroying existing widgets inside hidden_window...")
        widget_count = 0
        for widget in self.hidden_window.winfo_children():
            try:
                widget.destroy()
                widget_count += 1
            except Exception as e:
                print(f"  - Error destroying widget {widget}: {e}")
        print(f"  - Destroyed {widget_count} widgets.")

        # --- Clear potentially dangling references specific to the hidden window ---
        self.hidden_window_search_entry = None
        self.hidden_window_canvas = None
        self.hidden_window_scrollable_frame = None
        self.hidden_window_custom_scrollbar_canvas_hidden = None
        self.hidden_window_restart_button = None
        self.vehicle_frames = [] # Reset the list of item frames
        # Add any other specific attributes if necessary

        # --- Let Tkinter process destroy events ---
        self.hidden_window.update_idletasks()
        print("  - Ran update_idletasks after destruction.")

        # --- Recreate widgets by calling the original creation function ---
        print("Recreating hidden window widgets...")
        # create_widgets_hidden_window expects the Toplevel window as parent
        self.create_widgets_hidden_window(self.hidden_window)
        # This call will also trigger update_vehicle_display to repopulate the list

        # --- Final UI update ---
        self.hidden_window.update_idletasks()
        print("--- Hidden Window GUI Rebuild Complete ---\n")
        
        
        
    def create_top_buttons(self, top_frame):
        """Creates and packs all top buttons in the given frame."""

        button_style_args = self._create_button_style()
        on_button_hover_enter, on_button_hover_leave, on_button_click = self._create_button_event_handlers()

        self._initialize_search_mode()
        self._create_search_mode_button(top_frame, button_style_args, on_button_click)
        self._create_filters_button(top_frame, button_style_args, on_button_click)
        self._create_subset_data_button(top_frame, button_style_args, on_button_click) # click is different for this button

        # --- NEW: Dropdown Buttons ---
        self.create_player_vehicle_dropdown_button(top_frame)
        self.create_remove_vehicles_dropdown_button(top_frame)
        self.create_add_vehicles_dropdown_button(top_frame)

        # --- NEW: Dropdown Buttons ---

        #self._create_resize_button(top_frame, button_style_args, on_button_hover_enter, on_button_hover_leave, on_button_click)
        self._create_show_switcher_button(top_frame, button_style_args, on_button_click)
        self._create_switch_to_beamng_button(top_frame, button_style_args, on_button_click)

        self.create_loading_label(top_frame) # Keep loading label creation here, assuming it's related to top frame



    def show_remove_vehicles_dropdown(self):
        self._show_dropdown_menu(self.remove_vehicles_button, [
            ("Remove Current Vehicle", self.on_delete_single_button_click),
            ("Remove All Other Vehicles", self.on_delete_all_other_vehicles_button_click),
            ("Remove Traffic Vehicles", self.on_delete_traffic_vehicles_button_click),
            ("Remove Parked Vehicles", self.on_delete_parked_vehicles_button_click),
            ("Remove Parked and Traffic Vehicles", self.on_delete_parked_and_traffic_vehicles_button_click),
        ], 'remove_vehicles_dropdown_window')

    def show_add_vehicles_dropdown(self):
        self._show_dropdown_menu(self.add_vehicles_button, [
            ("Spawn Traffic and Parked Vehicles", lambda: self.on_spawn_traffic_vehicles_button_click(type="Both")),
            ("Spawn Traffic Vehicles", lambda: self.on_spawn_traffic_vehicles_button_click(type="Traffic")),
            ("Spawn Parked Vehicles", lambda: self.on_spawn_traffic_vehicles_button_click(type="Parked")),
            ("Spawn Queue", self.show_spawn_queue_window),
            ("Spawn Random Vehicle", lambda: self.spawn_random_vehicle(vehicle_type=None, replace_current=False)),
            ("Spawn Random Car", lambda: self.spawn_random_vehicle(vehicle_type="car", replace_current=False)),
            ("Spawn Random Bus/Van/Truck", lambda: self.spawn_random_vehicle(vehicle_type="truck", replace_current=False)),
        ], 'add_vehicles_dropdown_window')

    def show_player_vehicle_dropdown(self):
        self._show_dropdown_menu(self.player_vehicle_button, [
            ("Spawn Default Vehicle", self.on_spawn_default_button_click),
            ("Replace Current with Default Vehicle", self.on_replace_with_default_button_click),
            ("Save Current Vehicle as Default", self.on_save_current_as_default_button_click),
            ("Replace with Random Vehicle", lambda: self.spawn_random_vehicle(vehicle_type=None, replace_current=True)),
            ("Replace with Random Car", lambda: self.spawn_random_vehicle(vehicle_type="car", replace_current=True)),
            ("Replace with Random Bus/Van/Truck", lambda: self.spawn_random_vehicle(vehicle_type="truck", replace_current=True)),
        ], 'player_vehicle_dropdown_window')
        

    def _show_dropdown_menu(self, parent_button, options, dropdown_name):
        if hasattr(self, dropdown_name) and getattr(self, dropdown_name) and getattr(self, dropdown_name).winfo_exists():
            getattr(self, dropdown_name).destroy()
            return

        button_x = parent_button.winfo_rootx()
        button_y = parent_button.winfo_rooty() + parent_button.winfo_height()

        setattr(self, dropdown_name, FadingToplevel(self.master, self))
        dropdown_window = getattr(self, dropdown_name)
        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        dropdown_window.geometry(f"+{button_x}+{button_y}")
        dropdown_window.config(bg="#333333")
        dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        def on_dropdown_option_click(command):
            command()
            dropdown_window.destroy()
            setattr(self, dropdown_name, None)

        for option_text, command in options:
            # --- Define Colors for these dropdown items ---
            original_bg = "#555555"
            original_fg = "#FFFFFF"

            # Specific hover colors for these action options
            item_hover_bg = "#d9d9d9"
            item_hover_fg = "black"

            # --- Button Creation (initial bg/fg will be set by _bind_animated_hover) ---
            dropdown_button = tk.Button(
                dropdown_window, # Ensure this window/frame exists
                text=option_text,
                font=("Segoe UI", 10 + self.font_size_add, "bold"),
                # The command lambda captures the specific command for this button
                command=lambda cmd=command: on_dropdown_option_click(cmd), # Ensure on_dropdown_option_click is defined
                borderwidth=1,      # Keep specific styling for dropdown items
                relief="solid",
                anchor="w",         # Align text to the West (left)
                padx=10,
                pady=5
                # bg and fg are now set by _bind_animated_hover
            )
            # Set active colors (for instant click flash) to match hover
            dropdown_button.config(
                activebackground=item_hover_bg,
                activeforeground=item_hover_fg
            )

            dropdown_button.pack(fill="x")

            # --- Apply Smooth Hover Animation ---
            self._bind_animated_hover(
                button=dropdown_button,
                original_bg=original_bg,
                original_fg=original_fg,
                hover_target_bg=item_hover_bg, # Custom hover BG
                hover_target_fg=item_hover_fg, # Custom hover FG
                check_state=False,             # Assuming these items are not disabled
                # No persistent selected state for these action buttons
                is_selected_initial=False,
                selected_bg=None,
                selected_fg=None,
                # No extra tooltip commands needed
                on_enter_extra_command=None,
                on_leave_extra_command=None
            )


        dropdown_window.bind("<FocusOut>", lambda event: self.destroy_dropdown_menu(dropdown_name))


    def destroy_dropdown_menu(self, dropdown_name):
        if hasattr(self, dropdown_name) and getattr(self, dropdown_name) and getattr(self, dropdown_name).winfo_exists():
            getattr(self, dropdown_name).destroy()
            setattr(self, dropdown_name, None)
        
 
    def close_all_vehicle_dropdowns(self):
        """Closes all vehicle-related dropdown menus."""
        dropdowns_to_close = [
            'remove_vehicles_dropdown_window',
            'add_vehicles_dropdown_window',
            'player_vehicle_dropdown_window'
        ]
        for dropdown_name in dropdowns_to_close:
            #print(f"Attempting to destroy dropdown: {dropdown_name}")
            self.destroy_dropdown_menu(dropdown_name)
            #print(f"Dropdown {dropdown_name} (if open) should now be destroyed.")
        
   
    def create_player_vehicle_dropdown_button(self, top_frame):
        button_style_args = self._create_button_style()
        # --- MODIFIED: Set default text color to orange ---
        button_style_args["fg"] = self.global_highlight_color
        # --- MODIFIED: Set default text color to orange ---
        on_button_hover_enter, on_button_hover_leave, on_button_click = self._create_button_event_handlers()

        self.player_vehicle_button = tk.Button(
            top_frame,
            text="Player Vehicle",
            command=self.show_player_vehicle_dropdown,
            **button_style_args
        )
        # --- MODIFIED: Store default text color as attribute ---
        self.player_vehicle_button.default_fg_color = self.global_highlight_color
        # --- MODIFIED: Store default text color as attribute ---
        self._bind_button_events_custom_fg(self.player_vehicle_button, on_button_hover_enter, on_button_hover_leave, on_button_click, default_fg=self.global_highlight_color) # Passing default_fg
        self.player_vehicle_button.pack(side="left", padx=(40, 10))

    def create_remove_vehicles_dropdown_button(self, top_frame):
        button_style_args = self._create_button_style()
        # --- MODIFIED: Set default text color to red ---
        button_style_args["fg"] = "#ffa1a1"
        # --- MODIFIED: Set default text color to red ---
        on_button_hover_enter, on_button_hover_leave, on_button_click = self._create_button_event_handlers()

        self.remove_vehicles_button = tk.Button(
            top_frame,
            text="Remove Vehicles",
            command=self.show_remove_vehicles_dropdown,
            **button_style_args
        )
        # --- MODIFIED: Store default text color as attribute ---
        self.remove_vehicles_button.default_fg_color = "#ffa1a1"
        # --- MODIFIED: Store default text color as attribute ---
        self._bind_button_events_custom_fg(self.remove_vehicles_button, on_button_hover_enter, on_button_hover_leave, on_button_click, default_fg="#ffa1a1") # Passing default_fg
        self.remove_vehicles_button.pack(side="left", padx=(0, 10))

    def create_add_vehicles_dropdown_button(self, top_frame):
        button_style_args = self._create_button_style()
        # --- MODIFIED: Set default text color to green ---
        button_style_args["fg"] = "#90ee90"
        # --- MODIFIED: Set default text color to green ---
        on_button_hover_enter, on_button_hover_leave, on_button_click = self._create_button_event_handlers()

        self.add_vehicles_button = tk.Button(
            top_frame,
            text="Spawn Vehicles",
            command=self.show_add_vehicles_dropdown,
            **button_style_args
        )
        # --- MODIFIED: Store default text color as attribute ---
        self.add_vehicles_button.default_fg_color = "#90ee90"
        # --- MODIFIED: Store default text color as attribute ---
        self._bind_button_events_custom_fg(self.add_vehicles_button, on_button_hover_enter, on_button_hover_leave, on_button_click, default_fg="#90ee90") # Passing default_fg
        self.add_vehicles_button.pack(side="left", padx=(0, 10))






    def _create_button_style(self):
        """Defines the common style arguments for buttons."""
        return {
            "bg": "#555555",
            "fg": "#FFFFFF",
            "relief": tk.FLAT,
            "bd": 0,
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "#FFFFFF",
            "font": ("Segoe UI", 12+self.font_size_add,)
        }

    def _create_button_event_handlers(self):
        """Creates and returns button event handler functions."""
        def on_button_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="#FFFFFF")

        def on_button_hover_leave(event, original_bg="#555555", original_fg="#FFFFFF"): # original_fg is now generic
            # --- MODIFIED: Use event.widget.default_fg_color to restore custom default fg ---
            original_fg_dynamic = getattr(event.widget, 'default_fg_color', "#FFFFFF") # Fallback to "#FFFFFF" if not set
            event.widget.config(bg=original_bg, fg=original_fg_dynamic) # Use dynamic original_fg
            # --- MODIFIED: Use event.widget.default_fg_color to restore custom default fg ---

        def on_button_click(event):
            event.widget.config(bg="#FFFFFF", fg="black")
            # Revert to hover style on enter, default on leave after click effect
            event.widget.bind("<Enter>", on_button_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="#FFFFFF": on_button_hover_leave(e, bg, fg))
        return on_button_hover_enter, on_button_hover_leave, on_button_click

 

    def _initialize_search_mode(self):
        """Initializes the search mode attribute if not already present."""
        if not hasattr(self, 'search_mode'):
            print("Warning: self.search_mode attribute not initialized. Defaulting to 'General'.")
            self.search_mode = "General"




    def _create_subset_data_button(self, top_frame, button_style_args, on_button_click):
        """Creates and packs the Subset Data button."""
        self.subset_data_button = tk.Button(
            top_frame,
            text="Off",  # Initial text
            #command=self.toggle_data_subset, # Call the toggle function - disabled
            **button_style_args
        )
        self.subset_data_button.bind("<Button-1>") # Keep click binding - but no click action defined here.
        #self.subset_data_button.bind("<Button-1>", on_button_click) # Original click binding - but not needed as per original code
        self.subset_data_button.pack(side="left", padx=(0, 10))
        if not hasattr(self, 'is_data_subset_active'):  # Initialize if not yet
            self.is_data_subset_active = False  # Initialize flag





    # unused, don't modify
    def _create_resize_button(self, top_frame, button_style_args, on_button_hover_enter, on_button_hover_leave, on_button_click):
        """Creates and packs the Resize Window button."""
        self.resize_button = tk.Button(
            top_frame,
            text="Change Window Size",
            command=self.do_nothing,
            **button_style_args
        )
        self._bind_button_events(self.resize_button, on_button_hover_enter, on_button_hover_leave, on_button_click)
        #self.resize_button.pack(side="right", padx=(0, 10))



        

    def _create_search_mode_button(self, top_frame, button_style_args, on_button_click): # No on_button_hover_enter/leave
        """Creates and packs the Search Mode button."""
        self.search_mode_button = tk.Button(
            top_frame,
            text=f"Search Mode: {getattr(self, 'search_mode', 'Default')}",
            command=self.show_search_mode_options_dropdown, # Use the passed on_button_click for the command
            **button_style_args
        )

        initial_bg = self._get_validated_current_color(self.search_mode_button, "bg")
        initial_fg = self._get_validated_current_color(self.search_mode_button, "fg")

        self._bind_animated_hover(
            button=self.search_mode_button,
            original_bg=initial_bg,
            original_fg=initial_fg,
            hover_target_fg="#FFFFFF",  # Explicitly set hover foreground to white
            check_state=True           # Or False if these buttons are always enabled
                                       # and you don't want the state check overhead.
            # No on_enter_extra_command
            # No on_leave_extra_command
        )
        self.search_mode_button.pack(side="left", padx=(0, 10))
        return self.search_mode_button # Good practice to return the created widget

    def _create_filters_button(self, top_frame, button_style_args, on_button_click): # No on_button_hover_enter/leave
        """Creates and packs the Filters button."""
        self.filters_button = tk.Button(
            top_frame,
            text="Vehicle Filters:",
            command=self.show_filters_window,
            **button_style_args
        )

        initial_bg = self._get_validated_current_color(self.filters_button, "bg")
        initial_fg = self._get_validated_current_color(self.filters_button, "fg")

        self._bind_animated_hover(
            button=self.filters_button,
            original_bg=initial_bg,
            original_fg=initial_fg,
            hover_target_fg="#FFFFFF",
            check_state=True
            # No on_enter_extra_command
            # No on_leave_extra_command
        )
        self.filters_button.pack(side="left", padx=(0, 0))
        return self.filters_button

    def _create_switch_to_beamng_button(self, top_frame, button_style_args, on_button_click): # No on_button_hover_enter/leave
        """Creates and packs the Switch to BeamNG button."""
        initial_text = getattr(self, 'new_button_label', None) or \
                       f"Switch to BeamNG ({getattr(self, 'DEFAULT_SWITCH_DISPLAY_TEXT', 'App')})"

        self.switch_to_beamng_button = tk.Button(
            top_frame,
            text=initial_text,
            command=self.focus_beamng_window,
            **button_style_args
        )

        initial_bg = self._get_validated_current_color(self.switch_to_beamng_button, "bg")
        initial_fg = self._get_validated_current_color(self.switch_to_beamng_button, "fg")

        self._bind_animated_hover(
            button=self.switch_to_beamng_button,
            original_bg=initial_bg,
            original_fg=initial_fg,
            hover_target_fg="#FFFFFF",
            check_state=True
            # No on_enter_extra_command
            # No on_leave_extra_command
        )
        self.switch_to_beamng_button.pack(side="right", padx=(0, 10))
        return self.switch_to_beamng_button

    def _create_show_switcher_button(self, top_frame, button_style_args, on_button_click): # No on_button_hover_enter/leave
        """Creates and packs the Show Switcher button."""
        self.show_switcher_button = tk.Button(
            top_frame,
            text="Show Switcher",
            command=self.toggle_floating_window_visibility,
            **button_style_args
        )

        initial_bg = self._get_validated_current_color(self.show_switcher_button, "bg")
        initial_fg = self._get_validated_current_color(self.show_switcher_button, "fg")

        self._bind_animated_hover(
            button=self.show_switcher_button,
            original_bg=initial_bg,
            original_fg=initial_fg,
            hover_target_fg="#FFFFFF",
            check_state=True
            # No on_enter_extra_command
            # No on_leave_extra_command
        )
        self.show_switcher_button.pack(side="right", padx=(0, 10))
        return self.show_switcher_button




    def is_settings_dropdown_open(self):
        return hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists()


    def create_categorize_button(self, bottom_frame):
        """Creates the 'Categorize by' button with smooth hover and disable support."""

        # --- Define Colors & Styles ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF"  # Hover text color
        active_bg = "#666666"
        active_fg = "#FFFFFF"
        disabled_fg = "grey"

        button_style_args = { # Normal state styles
            "bg": original_bg, "fg": original_fg, "relief": tk.FLAT, "bd": 0,
            "highlightbackground": original_bg, "activebackground": active_bg,
            "activeforeground": active_fg, "font": ("Segoe UI", 12 + self.font_size_add)
        }
        # Define disabled style separately
        disabled_button_style_args = button_style_args.copy()
        disabled_button_style_args["fg"] = disabled_fg
        disabled_button_style_args["activebackground"] = original_bg # No visual change on click when disabled
        disabled_button_style_args["activeforeground"] = disabled_fg

        # --- Create the Button ---
        button = tk.Button(
            bottom_frame,
            text=f"Categorize by: {self.categorization_mode}", # Ensure self.categorization_mode exists
            command=self.show_categorize_dropdown, # Ensure this method exists
            **button_style_args # Start with normal style
        )
        self.categorize_button = button # Store reference

        # --- Bind Hover/Destroy Events using the Helper ---
        # This replaces the local handlers and bindings for Enter, Leave, Destroy
        # and handles storing original colors.
        self._bind_animated_hover(
            button=button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=True # <<< IMPORTANT: This button can be disabled
        )

        # --- Pack the Button ---
        button.pack(side="left", padx=(10, 0))

        # --- State Update Function (Still needed for disable/enable logic) ---
        def update_button_state(is_disabled):
             """Updates button state, cancels animation, and applies correct style."""
             # Ensure button exists before proceeding
             if not button.winfo_exists():
                 print(f"Warning: Attempted to update state on destroyed button {button}")
                 return

             # Cancel any ongoing animation
             if button in self.animation_states:
                 state = self.animation_states[button]
                 anim_id = state.get('anim_id')
                 if anim_id:
                     try: button.after_cancel(anim_id)
                     except tk.TclError: pass
                 # Clear animation target state
                 state['anim_id'] = None
                 state['target_color'] = None
                 state['start_color'] = None

             # Update the class attribute tracking the state
             # self.is_search_results_window_active = is_disabled # Make sure this is the correct flag to update

             if is_disabled:
                 # Apply disabled style (including resetting bg/fg)
                 button.config(state=tk.DISABLED, **disabled_button_style_args)
             else:
                 # Apply normal style (resetting bg/fg to original)
                 button.config(state=tk.NORMAL, **button_style_args)

        # Attach the update method to the button instance for external access
        button.update_state = update_button_state

        # --- Set Initial State ---
        # Use the newly attached update_state function
        button.update_state(self.is_search_results_window_active)

  
  


    def show_categorize_dropdown(self):
        if hasattr(self, 'categorize_dropdown_window') and self.categorize_dropdown_window and self.categorize_dropdown_window.winfo_exists():
            self.categorize_dropdown_window.destroy()
            return

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot change Categorization mode while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return
        
        button = self.categorize_button
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty()
        button_height = button.winfo_height()

        self.categorize_dropdown_window = FadingToplevel(self.master, self)
        self.categorize_dropdown_window.overrideredirect(True)  # Remove window border
        self.categorize_dropdown_window.tk.call('tk', 'scaling', 1.25)  # Set to 100% scaling
        self.categorize_dropdown_window.config(bg="#555555") # Dark grey background for dropdown
        self.categorize_dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        categorize_options = ["Type", "Country", "None"] # Define categorize options

        def on_categorize_option_click(option):
            self.categorization_mode = option
            self.categorize_button.config(text=f"Categorize by: {self.categorization_mode}")
            self.grouped_data = self.format_grouped_data(self.data) # Re-group data
            print("    on_categorize_option_click is calling self.update_grid_layout() - inner function of show_categorize_dropdown")
            self.update_grid_layout() # Re-layout grid
            self.canvas.yview_moveto(0) # Reset scroll
            print("    on_categorize_option_click is calling self.perform_search() - inner function of show_categorize_dropdown")
            self.perform_search() # Re-apply search
            self.categorize_dropdown_window.destroy()
            self.categorize_dropdown_window = None


        for option in categorize_options:
            # --- Determine initial visual state ---
            is_selected = (option == self.categorization_mode)

            # --- Define Colors ---
            default_bg_color = "#555555"    # Normal, non-selected background
            default_fg_color = "#FFFFFF"    # Normal, non-selected foreground

            selected_option_bg = self.global_highlight_color # Background for selected item
            selected_option_fg = "#FFFFFF"                   # Foreground for selected item

            # Hover colors for these specific dropdown items
            dropdown_item_hover_bg = "#d9d9d9"
            dropdown_item_hover_fg = "black"

            # --- Button Creation ---
            # bg and fg are now set by _bind_animated_hover based on is_selected
            dropdown_button = tk.Button(
                self.categorize_dropdown_window, # Ensure this parent window exists
                text=f"Categorize by: {option}",
                font=("Segoe UI", 10 + self.font_size_add, "bold"),
                command=lambda opt=option: on_categorize_option_click(opt),
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5
                # Initial bg/fg will be set by _bind_animated_hover
            )
            dropdown_button.pack(fill="x")

            # --- Apply Smooth Hover Animation & Initial State ---
            # Assumes self._bind_animated_hover is defined in your class
            self._bind_animated_hover(
                button=dropdown_button,
                original_bg=default_bg_color,       # The "true" original, non-selected bg
                original_fg=default_fg_color,       # The "true" original, non-selected fg
                hover_target_bg=dropdown_item_hover_bg, # Custom hover BG for these items
                hover_target_fg=dropdown_item_hover_fg, # Custom hover FG for these items
                check_state=False,                    # Assuming these are not individually disabled
                is_selected_initial=is_selected,      # Is this button initially selected?
                selected_bg=selected_option_bg,       # Color if selected
                selected_fg=selected_option_fg        # Color if selected
            )


        # Force update to calculate window size based on content
        self.categorize_dropdown_window.update_idletasks()
        # Get the actual height of the dropdown window
        window_height = self.categorize_dropdown_window.winfo_height()
        # Calculate the target Y position (top edge of button minus window height)
        target_y = button_y - window_height
        # Set the final position
        self.categorize_dropdown_window.geometry(f"+{button_x}+{target_y}")

        self.categorize_dropdown_window.bind("<FocusOut>", lambda event: self.destroy_categorize_dropdown())

        self._update_filters_label_status()
  
        
        

    def destroy_categorize_dropdown(self):
        self.is_search_results_window_closing = True # <--- SET FLAG BEFORE DESTROY
        if hasattr(self, 'categorize_dropdown_window') and self.categorize_dropdown_window and self.categorize_dropdown_window.winfo_exists():
            self.categorize_dropdown_window.destroy()
            self.categorize_dropdown_window = None
        self.is_search_results_window_closing = False # <--- RESET FLAG AFTER DESTROY

            
            
            
            
            
            
    def create_loading_label(self, top_frame):
        # Create the Loading label, initially hidden
        self.loading_label = tk.Label(
            top_frame,
            text="Loading...",
            bg="#d9d9d9",
            font=("Segoe UI", 12+self.font_size_add, "bold"),
            fg="blue"
        )
        #self.loading_label.pack(side="left", padx=(0, 10))  # Place it next to the Search button
        self.loading_label.pack_forget()  # Initially hidden




    def create_category_list_button(self, bottom_frame):
        """Creates the 'Category List' button with smooth hover animation and disable support."""

        # --- Define Colors & Styles ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF" # Text color on hover
        active_bg = "#666666" # Standard click feedback color
        active_fg = "#FFFFFF" # Standard click feedback text color
        disabled_fg = "grey"

        button_style_args = { # Normal state styles
            "bg": original_bg,
            "fg": original_fg,
            "relief": tk.FLAT,
            "bd": 0,
            # "highlightthickness": 0, # REMOVED as per instruction
            "highlightbackground": original_bg,
            "activebackground": active_bg,
            "activeforeground": active_fg,
            "font": ("Segoe UI", 12 + self.font_size_add)
        }
        # Define disabled style separately
        disabled_button_style_args = button_style_args.copy()
        disabled_button_style_args["fg"] = disabled_fg
        disabled_button_style_args["activebackground"] = original_bg # No visual change on click when disabled
        disabled_button_style_args["activeforeground"] = disabled_fg

        # --- Create the Button ---
        button = tk.Button(
            bottom_frame,
            text="Category List",
            command=self.show_category_list_dropdown, # Ensure this method exists
            **button_style_args # Start with normal style initially
        )
        self.category_list_button = button # Store reference

        # --- Bind Hover/Destroy Events using the Helper ---
        # This replaces the local handlers, bindings, and color storage.
        self._bind_animated_hover(
            button=button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=True # <<< IMPORTANT: This button needs state checking for hover
        )

        # --- Pack the Button ---
        button.pack(side="left", padx=(10, 0))

        # --- State Update Function (Still needed for enable/disable logic) ---
        def update_state(is_disabled):
            """Updates button state, cancels animation, and applies correct style."""
            # Ensure button exists before proceeding
            if not button.winfo_exists():
                # Optional: Add a print warning if needed
                # print(f"Warning: Attempted to update state on destroyed category list button {button}")
                return

            # Cancel any ongoing animation
            if button in self.animation_states:
                state = self.animation_states[button]
                anim_id = state.get('anim_id')
                if anim_id:
                    try: button.after_cancel(anim_id)
                    except tk.TclError: pass
                # Clear animation target state
                state['anim_id'] = None
                state['target_color'] = None
                state['start_color'] = None

            # Update the button's state and appearance
            if is_disabled:
                button.config(state=tk.DISABLED, **disabled_button_style_args)
            else:
                button.config(state=tk.NORMAL, **button_style_args)

        # Attach the update method to the button instance for external access
        button.update_state = update_state

        # --- Set Initial State ---
        # Use the update_state function to set the correct initial appearance
        # Ensure self.is_search_results_window_active accurately reflects the desired initial state
        button.update_state(self.is_search_results_window_active)
 


    def destroy_category_list_dropdown(self):
        print("destroy_cat_list_func_entered")

        if self.category_list_button_clicked:
            self.category_list_button_clicked = False
            return
        
        if hasattr(self, 'category_list_dropdown_window') and self.category_list_dropdown_window and self.category_list_dropdown_window.winfo_exists():
            self.category_list_dropdown_window.destroy()
            self.category_list_dropdown_window = None




    def handle_jump_to_page_button_click(self):
        """Handles clicks on the 'Jump to page' button to show the dropdown menu."""
        if hasattr(self, 'jump_to_page_dropdown_window') and self.jump_to_page_dropdown_window and self.jump_to_page_dropdown_window.winfo_exists():
            self.jump_to_page_dropdown_window.destroy()
            return
        


        button = self.jump_to_page_button_bottom

        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty() # Get the top of the button

        self.jump_to_page_dropdown_window = dropdown_window = FadingToplevel(self.details_window, self)
        button_width = button.winfo_width() # Get the width of the button





        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        dropdown_window.config(bg="#333333")
        dropdown_window.attributes("-topmost", True)
        dropdown_window.config(highlightthickness=3, highlightbackground="#666666")


        canvas = tk.Canvas(dropdown_window, bg="#333333", highlightthickness=0, width=100, height=200) # Width same as zip dropdown, make scrollable
        scrollbar = tk.Scrollbar(dropdown_window, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#333333")

        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="top", fill="both", expand=True) # Pack canvas first to fill space above button
        canvas.configure(yscrollcommand=scrollbar.set)
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw", width=300) # Set width of scrollable frame inside canvas

        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_dropdown_mousewheel(ev, canvas)))
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))


        num_pages = math.ceil(len(self.details_filtered_data) / self.items_per_page) if self.items_per_page else 1
        current_page_index = self.details_page + 1 # Get current page number (1-indexed)

        def on_page_button_click(page_index):
            self.go_to_details_page(page_index)
            self.jump_to_page_dropdown_window.destroy()
            self.jump_to_page_dropdown_window = None

        for i in range(1, num_pages + 1):
            # --- Define Colors for page buttons ---
            page_default_bg = "#555555"
            page_default_fg = "#FFFFFF"
            page_selected_bg = self.global_highlight_color # Orange for current page
            page_selected_fg = "#FFFFFF"                   # White text for current page
            page_hover_bg = "#d9d9d9"
            page_hover_fg = "black"

            is_selected = (i == current_page_index) # Check if this is the current page

            page_button = tk.Button(
                scrollable_frame,
                text=f"Page {i}",
                font=("Segoe UI", 10 + self.font_size_add, "bold"),
                command=lambda idx=i: on_page_button_click(idx), # Ensure on_page_button_click exists
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5,

            )
            page_button.config(
                width=24, # Set fixed width
                activebackground=page_hover_bg, # For click flash
                activeforeground=page_hover_fg
            )
            page_button.pack(fill="x")
            # if hasattr(self, 'current_page_buttons_list'): self.current_page_buttons_list.append(page_button)


            self._bind_animated_hover(
                button=page_button,
                original_bg=page_default_bg,
                original_fg=page_default_fg,
                hover_target_bg=page_hover_bg,
                hover_target_fg=page_hover_fg,
                check_state=False,
                is_selected_initial=is_selected,
                selected_bg=page_selected_bg,
                selected_fg=page_selected_fg
            )
            # REMOVED old binds

        # --- Close Button (below scrollable frame, in dropdown_window) ---

        # --- Define Colors for the Close button ---
        close_button_original_bg = "#666666"
        close_button_original_fg = "#FFFFFF"
        # Hover to global highlight color (orange) or a custom one
        close_button_hover_bg = self.global_highlight_color # e.g., "#777777"
        close_button_hover_fg = "#FFFFFF" # Assuming white text on highlight

        close_button = tk.Button(
            dropdown_window, # Place in dropdown_window
            text="Close",
            font=("Segoe UI", 10 + self.font_size_add, "bold"),
            command=self.destroy_jump_to_page_dropdown_menu, # Ensure this method exists
            # bg and fg will be set by _bind_animated_hover initially
            borderwidth=1,
            relief="solid",
            padx=10,
            pady=5
        )
        # Set active colors for click flash (optional)
        close_button.config(
            activebackground=close_button_hover_bg, # Example: match hover for click
            activeforeground=close_button_hover_fg
        )
        close_button.pack(side="bottom", fill="x") # Pack to bottom of dropdown_window

        # --- Apply Smooth Hover Animation to the Close Button ---
        self._bind_animated_hover(
            button=close_button,
            original_bg=close_button_original_bg,
            original_fg=close_button_original_fg,
            hover_target_bg=close_button_hover_bg,
            hover_target_fg=close_button_hover_fg,
            check_state=False, # Assuming close button is always enabled
            is_selected_initial=False, # No selected state
            selected_bg=None,
            selected_fg=None
        )

        # Force update to calculate window size based on content
        dropdown_window.update_idletasks()
        # Get the actual dimensions of the dropdown window
        window_width = dropdown_window.winfo_width()
        window_height = dropdown_window.winfo_height()
        # Calculate target X (button's right edge - window width)
        target_x = (button_x + button_width) - window_width
        # Calculate target Y (button's top edge - window height)
        target_y = button_y - window_height
        # Set the final position
        dropdown_window.geometry(f"+{target_x}+{target_y}")


        dropdown_window.bind("<FocusOut>", lambda event: self.destroy_jump_to_page_dropdown_menu())

    def destroy_jump_to_page_dropdown_menu(self):
        if hasattr(self, 'jump_to_page_dropdown_window') and self.jump_to_page_dropdown_window and self.jump_to_page_dropdown_window.winfo_exists():
            self.jump_to_page_dropdown_window.destroy()
            self.jump_to_page_dropdown_window = None


    def go_to_details_page(self, page_index):
        """Navigates to the specified page in the details window."""

        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win

        if 1 <= page_index <= math.ceil(len(self.details_filtered_data) / self.items_per_page) if self.items_per_page else 1:
            self.details_page = page_index - 1
            ConfigViewerApp.details_widget_count = 0
            self.rebuild_simple_details()
            self._update_details_pagination_bar()
        else:
            print(f"Invalid page number: {page_index}")



    # ------------------------------------------------------------         
    #   Global Filters
    # ------------------------------------------------------------




    def apply_data_subset_filter(self, data_list):
        """
        Filters data list based on data_subset files, now with FAVORITES MODE handling.

        - In Favorites Mode with Global Filters OFF: Behaves like regular Favorites mode (data_subset files ignored for main grid).
        - In Favorites Mode with Global Filters ON: Filters using data_subset_favorites.txt.
        - In Non-Favorites Mode: Filters using data_subset.txt as before.
        """
        if not hasattr(self, 'is_data_subset_active') or self.is_data_subset_active is None:
            self.is_data_subset_active = False

        if not self.is_data_subset_active:
            return data_list

        subset_lines = set()
        data_subset_file_path = "" # Initialize to empty string

        # Determine which subset file to use based on mode and filters
        if self.filter_state == 5 and self.filter_options[self.filter_state] == "Favorites": # Favorites Mode
            if self.is_data_subset_active: # Global Filters ON in Favorites Mode
                data_subset_file_path = os.path.join(self.script_dir, "data/data_subset_favorites.txt")
                print("DEBUG: apply_data_subset_filter - Favorites Mode AND Global Filters ON - Using data_subset_favorites.txt")
            else:
                # Favorites Mode but Global Filters OFF - data_subset files are ignored for main grid filtering
                print("DEBUG: apply_data_subset_filter - Favorites Mode BUT Global Filters OFF - Ignoring data_subset files for main grid.")
                return data_list # Return original data list - data_subset files are ignored in this case

        else: # NOT Favorites Mode - use regular data_subset.txt
            data_subset_file_path = os.path.join(self.script_dir, self.data_subset_file)
            print("DEBUG: apply_data_subset_filter - NOT Favorites Mode - Using data_subset.txt")


        if data_subset_file_path and os.path.exists(data_subset_file_path): # Check if file path is set AND file exists
            with open(data_subset_file_path, 'r', encoding="utf-8") as f:
                for line in f:
                    subset_line = line.strip()
                    if subset_line:
                        subset_lines.add(subset_line)
        elif data_subset_file_path: # File path is set but doesn't exist (and it's supposed to be used in current mode)
            print(f"Warning: Data subset file not found at: {data_subset_file_path}. Returning empty subset.")
            return [] # Return empty list if data subset file is expected but not found
        else: # No data_subset file path set for the current mode (e.g., Favorites Mode, Global Filters OFF)
            return data_list # Return original list if no filtering needed


        if not subset_lines:
            return []

        filtered_data = []
        for item in data_list:
            pic_path = item[0]
            if pic_path:
                pic_filename = os.path.basename(pic_path)
                folder_name = item[4]

                required_prefix = f"vehicles--{folder_name}"
                is_substring_found = False

                for subset_line in subset_lines:
                    normalized_required_prefix = required_prefix.strip().lower()
                    normalized_subset_line = subset_line.strip().lower()

                    if normalized_required_prefix in normalized_subset_line:
                        filtered_data.append(item)
                        is_substring_found = True
                        break


        return filtered_data
  






    def destroy_search_mode_option_tooltip_global_filter(self):
        if self.current_tooltip_global_filter_window:
            self.current_tooltip_global_filter_window.destroy()
            self.current_tooltip_global_filter_window = None
            self.tooltip_global_filter_original_bg_color = None

    def show_search_mode_option_tooltip_global_filter(self, entry_widget, tip_text, tooltip_color="#555555", disappear_delay=0): # Added color and delay
        if self.current_tooltip_global_filter_window:
            self.destroy_search_mode_option_tooltip_global_filter()

        self.current_tooltip_global_filter_window = FadingToplevel(self.master, self)
        
        self.current_tooltip_global_filter_window.overrideredirect(True)
        self.current_tooltip_global_filter_window.tk.call('tk', 'scaling', 1.25)
        self.current_tooltip_global_filter_window.attributes("-topmost", True)

        tooltip_global_filter_label = tk.Label(self.current_tooltip_global_filter_window, text=tip_text, font=("Segoe UI", 10+self.font_size_add, "bold", "italic"), fg="#d9d9d9", bg=tooltip_color, padx=5, pady=2, relief=tk.SOLID, borderwidth=1) # Use tooltip_color
        tooltip_global_filter_label.pack(padx=1, pady=1)
        self.tooltip_global_filter_original_bg_color = tooltip_color # Set original color

        entry_width = entry_widget.winfo_width()
        entry_height = entry_widget.winfo_height()
        entry_abs_x = entry_widget.winfo_rootx()
        entry_abs_y = entry_widget.winfo_rooty()

        tooltip_global_filter_x = entry_abs_x + entry_width + 5
        tooltip_global_filter_y = entry_abs_y + (entry_height // 2) - (self.current_tooltip_global_filter_window.winfo_reqheight() // 2) + 88

        self.current_tooltip_global_filter_window.geometry(f"+{tooltip_global_filter_x}+{tooltip_global_filter_y}")
        self.current_tooltip_global_filter_window.after(9000, self.current_tooltip_global_filter_window.destroy)

        if disappear_delay > 0: # Implement disappear delay
            self.master.after(disappear_delay, self.destroy_search_mode_option_tooltip_global_filter)

    def show_error_tooltip_global_filter(self, entry_widget, tip_text): # Error tooltip function
        self.show_search_mode_option_tooltip_global_filter(entry_widget, tip_text, tooltip_color="#FF0000", disappear_delay=4000)

    def flash_tooltip_global_filter_orange(self):
        if self.current_tooltip_global_filter_window and self.tooltip_global_filter_original_bg_color:
            tooltip_global_filter_label = self.current_tooltip_global_filter_window.winfo_children()[0]
            original_color = self.tooltip_global_filter_original_bg_color
            tooltip_global_filter_label.config(bg="#FF0000")
            self.master.after(100, lambda: tooltip_global_filter_label.config(bg=original_color))

    def validate_numeric_input(self, new_text):
        return new_text.isdigit() or new_text == ""

    def toggle_on_off(self, button):
        if button.cget("text") == "Off":
            button.config(text="On")
        else:
            button.config(text="Off")

    def set_button_orange(self, button):
        button.config(bg=self.global_highlight_color, fg="#FFFFFF")

    def reset_button_color(self, button, on_off_button_style_args):
        button.config(bg=on_off_button_style_args["bg"], fg=on_off_button_style_args["fg"])

    def clear_filters_and_reset_buttons(self, entry_widgets, on_off_button_style_args):
        filter_settings = {} # Empty settings for clear action
        self.save_filter_settings(filter_settings) # Save empty settings

        for entry_key, entry in entry_widgets.items():
            if isinstance(entry, ttk.Entry):
                entry.delete(0, tk.END)
            if isinstance(entry_key, tuple):
                criterion, entry_index = entry_key
                if entry_index == 1:
                    button = entry_widgets.get((criterion, "button1"))
                else:
                    button = entry_widgets.get((criterion, "button2"))
            else:
                button = entry_widgets.get((entry_key, "button"))

            if button:
                button.config(text="Off")
                self.reset_button_color(button, on_off_button_style_args)

        print("GlobalFiltersCleared")



    def clear_all_filters_and_files(self, entry_widgets, on_off_button_style_args):
        self.clear_filters_and_reset_buttons(entry_widgets, on_off_button_style_args) # Clear filters and reset buttons first


        
        # Delete filter settings file if it exists
        if os.path.exists(self.filter_settings_file):
            os.remove(self.filter_settings_file)
            print(f"Deleted: {self.filter_settings_file}")
        else:
            print(f"File not found, cannot delete: {self.filter_settings_file}")

        # Delete filter output file if it exists
        if os.path.exists(self.filter_output_file):
            os.remove(self.filter_output_file)
            print(f"Deleted: {self.filter_output_file}")
        else:
            print(f"File not found, cannot delete: {self.filter_output_file}")

        if os.path.exists(self.data_subset_file):
           os.remove(self.data_subset_file)
           print(f"Deleted: {self.data_subset_file}")
        else:
            print(f"File not found, cannot delete: {self.data_subset_file}")

        self.is_data_subset_active = False # <--- ALWAYS TURN SUBSET DATA OFF when "Clear Filters" is clicked
        self.subset_data_button.config(text="Off") # Update button text
        self.reset_button_color(self.subset_data_button, self.button_style_args)

        self.is_search_results_window_active_bypass_flag = True

        print("    clear_all_filters_and_files is calling self.perform_search()")
        self.perform_search()

        #print("    clear_all_filters_and_files is calling self.update_grid_layout() - after 100ms") this isn't necessary anymore. everything that leads to this function being called updates the layout already
        #self.master.after(100, self.update_grid_layout)



        print("Data Subset Mode: OFF (Set by Clear Filters)") # Debug print
        
   



    def update_button_on_entry_change(self, button, entry, on_off_button_style_args):
        if entry.get():
            button.config(text="On")
            self.set_button_orange(button)
        else:
            button.config(text="Off")
            self.reset_button_color(button, on_off_button_style_args)

    def apply_filters(self, entry_widgets):
        filter_settings = {}
        filters_output_string = ""
        filter_segments = []
        has_error = False

        # Check for contradictory Contains/DoesNotContain and invalid numeric ranges BEFORE applying filters
        for criterion in ["Brand", "Configuration", "Fuel Type", "Drivetrain", "Transmission"]:
            entry1 = entry_widgets.get((criterion, 1))
            entry2 = entry_widgets.get((criterion, 2))
            if entry1 and entry2 and entry1.get() and entry2.get() and entry1.get().lower() == entry2.get().lower():
                self.show_error_tooltip_global_filter(entry_widgets.get((criterion, 2)), "Cannot have the same value for Both")
                has_error = True
                break

        if not has_error:
            for criterion in self.numeric_criteria:
                entry1 = entry_widgets.get((criterion, 1))
                entry2 = entry_widgets.get((criterion, 2))
                if entry1 and entry2 and entry1.get() and entry2.get():
                    try:
                        below_value = float(entry1.get())
                        above_value = float(entry2.get())
                        if above_value >= below_value:
                            self.show_error_tooltip_global_filter(entry_widgets.get((criterion, 2)), "Above number Cannot be higher than or equal to Below")
                            has_error = True
                            break
                    except ValueError:
                        pass

        if has_error:
            return None

        for entry_key, entry in entry_widgets.items():
            if isinstance(entry, ttk.Entry):
                filter_text = entry.get()
                if isinstance(entry_key, tuple):
                    criterion, entry_index = entry_key
                    button_key = (criterion, f"button{entry_index}")
                    button_state = entry_widgets[button_key].cget("text")
                    filter_settings.setdefault(criterion, []).append({"entry": filter_text, "button": button_state, "index": entry_index})
                    if filter_text: # Only add to filter string if there is text in the entry, regardless of button state
                        if criterion == "Top Speed (km/h)":
                            try:
                                top_speed_kmh = float(filter_text)
                                top_speed_ms = top_speed_kmh / 3.6
                                filter_text_ms = f"{top_speed_ms:.2f}"
                            except ValueError:
                                filter_text_ms = filter_text
                            filter_text_display = filter_text_ms
                            filter_type = "Below (m/s)" if entry_index == 1 else "Above (m/s)"
                        elif criterion in self.numeric_criteria:
                            filter_type = "Below" if entry_index == 1 else "Above"
                            filter_text_display = filter_text
                        else:
                            filter_type = "Contains" if entry_index == 1 else "DoesNotContain"
                            filter_text_display = filter_text
                        if button_state == "On": # <--- ADDED CHECK FOR BUTTON STATE BEFORE ADDING TO FILTER STRING
                            filter_segments.append(f"{criterion}{filter_type} \"{filter_text_display}\"") # <--- ONLY ADD IF BUTTON IS ON AND ENTRY HAS TEXT
                else:
                    button_key = (entry_key, "button")
                    button_state = entry_widgets[button_key].cget("text")
                    filter_settings[entry_key] = {"entry": filter_text, "button": button_state}
                    if filter_text: # Only add to filter string if there is text in the entry, regardless of button state
                        filter_type = "Contains"
                        if button_state == "On": # <--- ADDED CHECK FOR BUTTON STATE BEFORE ADDING TO FILTER STRING
                            filter_segments.append(f"{entry_key}{filter_type} \"{filter_text}\"") # <--- ONLY ADD IF BUTTON IS ON AND ENTRY HAS TEXT

        filters_output_string = " | ".join(filter_segments)

        self.save_filter_settings(filter_settings)

        if not filters_output_string.strip():
            print("GlobalFiltersCleared")
            return
            filters_variable = ""
        else:
            print("GlobalFiltersApplied")
            print(filters_output_string.strip())
            filters_variable = filters_output_string.strip()
            print("-" * 20)

        #if self.filters_window and self.filters_window.winfo_exists():
        #    self.filters_window.destroy()
        #    self.filters_window = None
        
        self.set_button_orange(self.subset_data_button) # <--- SET BUTTON ORANGE when "On"
        return filters_variable
        


    def center_window(self, toplevel):
        toplevel.update_idletasks()
        master_width = self.master.winfo_width()
        master_height = self.master.winfo_height()
        master_x = self.master.winfo_rootx()
        master_y = self.master.winfo_rooty()

        toplevel_width = toplevel.winfo_reqwidth()
        toplevel_height = toplevel.winfo_reqheight()

        if toplevel_width == 1:
            geometry_str = toplevel.geometry()
            toplevel_width = int(geometry_str.split('x')[0])
            toplevel_height = int(geometry_str.split('x')[1].split('+')[0])

        x = master_x + (master_width - toplevel_width) // 2
        y = master_y + (master_height - toplevel_height) // 2

        toplevel.geometry(f"+{x}+{y}")

    def save_filter_settings(self, filter_settings):
        with open(self.filter_settings_file, 'w', encoding="utf-8") as f:
            for criterion, value in filter_settings.items():
                if isinstance(value, list): # For dual entries
                    line_parts = [criterion]
                    for item in value:
                        line_parts.extend([item['entry'], item['button']])
                    f.write(','.join(line_parts) + '\n')
                else: # For single entry
                    f.write(f"{criterion},{value['entry']},{value['button']}\n")

    def load_filter_settings(self):
        filter_settings = {}
        if os.path.exists(self.filter_settings_file):
            with open(self.filter_settings_file, 'r', encoding="utf-8") as f:
                for line in f:
                    parts = line.strip().split(',')
                    if not parts:
                        continue # Skip empty lines
                    criterion = parts[0]
                    if len(parts) == 3: # Single entry
                        filter_settings[criterion] = {"entry": parts[1], "button": parts[2]}
                    elif len(parts) > 3 and len(parts) % 2 == 1: # Dual entries
                        filter_settings[criterion] = []
                        for i in range(1, len(parts), 2):
                            filter_settings[criterion].append({"entry": parts[i], "button": parts[i+1], "index": (i // 2) + 1})
        return filter_settings

    def show_filters_window(self):
        """
        Shows the filters window.
        - Closes existing filters window if already open.
        - Prevents opening if details window is open.
        """
        print("DEBUG: show_filters_window - Function entry") # <-- DEBUG: Function entry


        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot use filters while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return
        


        if self.search_mode == "Configs": # <--- CHECK SEARCH MODE HERE
            #messagebox.showinfo(
            #    "Filters Unavailable",
            #    "Please switch out of 'Search Mode: Configs' before trying to apply filters.",
            #    parent=app.master
            #)
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot use filters in Config Search mode.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return


        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
            self.spawn_queue_window.destroy()

        if hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists():
            self.hidden_window.withdraw()
        

        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists():
            self.filters_window.focus_set()
            self.filters_window.deiconify()
            return


        if self.details_window and not self.details_window_closed:
            # Details window is open, prevent opening filters window and show messagebox
            print("DEBUG: show_filters_window - Details window is open - Condition is TRUE") # <-- DEBUG: Condition check - TRUE
            print(f"  DEBUG: self.details_window: {self.details_window}") # <-- DEBUG: Check window object
            print(f"  DEBUG: self.details_window_closed: {self.details_window_closed}") # <-- DEBUG: Check closed flag

            print("DEBUG: show_filters_window - Attempting to show messagebox...") # <-- DEBUG: Before messagebox


            scanning_win = None
            try:
                scanning_win = self.show_scanning_window(text="Cannot adjust filters while search or filtering is active.")
                self.master.after(3125, lambda: scanning_win.destroy() if scanning_win and scanning_win.winfo_exists() else None)
            except Exception as e:
                print(f"Error managing scanning window: {e}")
                if scanning_win and scanning_win.winfo_exists():
                    scanning_win.destroy()




            if self.filters_window and self.filters_window.winfo_exists():
                self.filters_window.focus_set()
                self.filters_window.deiconify() # If filters window is open but hidden behind, focus it
            print("DEBUG: show_filters_window - Existing filters window focused (if it exists).") # <-- DEBUG: Focus call
            return

        else:
            print("DEBUG: show_filters_window - Details window is NOT open or is closed - Condition is FALSE") # <-- DEBUG: Condition check - FALSE

        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists():
            print("DEBUG: show_filters_window - Filters window already open, destroying it.")
            #self.filters_window.destroy()
            self.filters_window.focus_set()
            self.filters_window.deiconify()
            #self.filters_window = None

        self.filters_window = filters_window = tk.Toplevel(self.master)
        filters_window.title("Filters")


        if self.font_size_add == 0:
            filters_window.geometry("655x528")

        elif self.font_size_add == 2:
            filters_window.geometry("700x578")

        elif self.font_size_add == 4:
            filters_window.geometry("755x670")







        #filters_window.attributes("-topmost", True)
        #filters_window.transient(self.master) #dont uncomment this line or remove it
        filters_window.resizable(False, False)
        filters_window.config(bg="#333333")
        #filters_window.overrideredirect(True) # Remove window border
        filters_window.tk.call('tk', 'scaling', 1.25) # Set to 100% scaling


        icon_path = self.script_dir / "data/icon.png"

        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            self.filters_window.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")


        filter_frame = tk.Frame(filters_window, padx=10, pady=10, bg="#333333")
        filter_frame.pack(fill=tk.BOTH, expand=True)


        self.center_window(filters_window)

        style = ttk.Style()
        style.theme_use('clam')
        label_font = ("Segoe UI", 12+self.font_size_add, "bold")
        entry_font = ("Segoe UI", 11+self.font_size_add)

        style.configure("DarkTheme.TLabel", background="#333333", foreground="#FFFFFF", font=label_font)
        style.configure("DarkTheme.TEntry", fieldbackground="#d9d9d9", foreground="black", lightcolor="#d9d9d9", borderwidth=1, relief="solid", font=entry_font)
        style.configure("Title.DarkTheme.TLabel", background="#333333", foreground="#FFFFFF", font=("Segoe UI", 14+self.font_size_add, "bold"))

        bottom_button_style_args = {
            "bg": "#555555",
            "fg": "#FFFFFF",
            "relief": tk.FLAT, # Make flat
            "bd": 0,          # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "#FFFFFF",
            "font":("Segoe UI", 12+self.font_size_add),
        }

        on_off_button_style_args = {
            "bg": "#555555",
            "fg": "#FFFFFF",
            "relief": tk.FLAT, # Make flat
            "bd": 0,          # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "#FFFFFF",
            "font":("Segoe UI", 10+self.font_size_add),
        }

        equal_width = 5
        button_entry_padx = 10
        top_speed_entry_button_space_padx = 12
        row_pady = 10

        text_filter_criteria = [
            "Brand",
            "Country", # <--- ADDED "Country" HERE, UNDER BRAND
            #"Configuration", #the issue with this is that it will not file specific configurations if they aren't named within the json file (or there's no json file at all
            "Fuel Type",
            "Drivetrain",
            "Transmission",
        ]
        numeric_filter_criteria = [
            "Top Speed (km/h)",
            "Power",
            "0-100 km/h",
            "Off-Road Score",
            "Braking G",
        ]
        filter_criteria = text_filter_criteria + numeric_filter_criteria # Combine lists in desired order


        row_num = 1
        title_label = ttk.Label(filter_frame, text="Filters", style="Title.DarkTheme.TLabel", anchor=tk.CENTER)
        title_label.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, row_pady))

        entry_widgets = {}
        contains_criteria = ["Brand", "Configuration", "Fuel Type", "Drivetrain", "Transmission", "Country"] # <--- ADDED "Country" HERE
        validation_command = (filters_window.register(self.validate_numeric_input), '%P')
        loaded_settings = self.load_filter_settings() # Load settings here

        for criterion in filter_criteria:
            label = ttk.Label(filter_frame, text=criterion, anchor="e", style="DarkTheme.TLabel")
            label.grid(row=row_num, column=0, sticky="ne", pady=(row_pady, 5), padx=(0, 5))

            if criterion in ["Top Speed (km/h)", "Power", "0-100 km/h", "Off-Road Score", "Braking G", "Brand", "Configuration", "Fuel Type", "Drivetrain", "Transmission", "Country"]: # <--- ADDED "Country" HERE
                entry_frame = tk.Frame(filter_frame, bg="#333333")
                entry_frame.grid(row=row_num, column=1, sticky="ew", pady=(row_pady, 5))

                # First Button and Entry
                on_off_button1 = tk.Button(entry_frame, text="Off", width=equal_width,
                                         **on_off_button_style_args)
                on_off_button1.pack(side=tk.LEFT, padx=(0, button_entry_padx))
                self.on_off_buttons_list.append(on_off_button1)
                entry_widgets[(criterion, "button1")] = on_off_button1

                entry1 = ttk.Entry(entry_frame, style="DarkTheme.TEntry", width=equal_width, font=entry_font,
                                     validate="key", validatecommand=validation_command if criterion in self.numeric_criteria else None)
                entry1.pack(side=tk.LEFT, fill="x", expand=True)

                entry1.bind("<KeyRelease>", lambda event, btn=on_off_button1, entry=entry1, style_args=on_off_button_style_args: self.update_button_on_entry_change(btn, entry, style_args))
                entry1.bind("<Button-2>", lambda event, entry=entry1, criterion=criterion, btn=on_off_button1, style_args=on_off_button_style_args: [entry.delete(0, tk.END), btn.config(text="Off"), self.reset_button_color(btn, style_args)])

                if criterion in self.numeric_criteria:
                    entry1.bind("<KeyPress>", lambda event, entry=entry1: self.flash_tooltip_global_filter_orange() if not (event.char.isdigit() or event.char == "") and event.keysym != "BackSpace" else None)

                if criterion == "Top Speed (km/h)":
                    tooltip_global_filter_text1 = "Below this number (km/h)"
                    tooltip_global_filter_text2 = "Above this number (km/h)"
                elif criterion in self.numeric_criteria:
                    tooltip_global_filter_text1 = "Below this number"
                    tooltip_global_filter_text2 = "Above this number"
                elif criterion in contains_criteria:
                    tooltip_global_filter_text1 = "Contains"
                    tooltip_global_filter_text2 = "Does not contain"
                else: # Default case - if needed for other criteria in the future
                    tooltip_global_filter_text1 = "Enter filter value" # Or some default text
                    tooltip_global_filter_text2 = "Enter filter value" # Or some default text, or leave empty if no second entry for these


                entry1.bind("<FocusIn>", lambda event, entry=entry1, text=tooltip_global_filter_text1: self.show_search_mode_option_tooltip_global_filter(entry, text))
                entry1.bind("<FocusOut>", lambda event: self.destroy_search_mode_option_tooltip_global_filter())
                entry_widgets[(criterion, 1)] = entry1

                # Second Button and Entry
                button2_padx = button_entry_padx
                if criterion == "Top Speed (km/h)":
                    button2_padx = top_speed_entry_button_space_padx
                else:
                    button2_padx = button_entry_padx
                on_off_button2 = tk.Button(entry_frame, text="Off", width=equal_width,
                                         **on_off_button_style_args)
                on_off_button2.pack(side=tk.LEFT, padx=(button2_padx, button_entry_padx))
                self.on_off_buttons_list.append(on_off_button2)
                entry_widgets[(criterion, "button2")] = on_off_button2

                entry2 = ttk.Entry(entry_frame, style="DarkTheme.TEntry", width=equal_width, font=entry_font,
                                     validate="key", validatecommand=validation_command if criterion in self.numeric_criteria else None)
                entry2.pack(side=tk.LEFT, fill="x", expand=True)
                entry2.bind("<KeyRelease>", lambda event, btn=on_off_button2, entry=entry2, style_args=on_off_button_style_args: self.update_button_on_entry_change(btn, entry, style_args))
                entry2.bind("<Button-2>", lambda event, entry=entry2, criterion=criterion, btn=on_off_button2, style_args=on_off_button_style_args: [entry.delete(0, tk.END), btn.config(text="Off"), self.reset_button_color(btn, style_args)])


                if criterion in self.numeric_criteria:
                    entry2.bind("<KeyPress>", lambda event, entry=entry2: self.flash_tooltip_global_filter_orange() if not (event.char.isdigit() or event.char == "") and event.keysym != "BackSpace" else None)


                entry2.bind("<FocusIn>", lambda event, entry=entry2, text=tooltip_global_filter_text2: self.show_search_mode_option_tooltip_global_filter(entry, text))
                entry2.bind("<FocusOut>", lambda event: self.destroy_search_mode_option_tooltip_global_filter())
                entry_widgets[(criterion, 2)] = entry2

                # Load saved settings if available
                if criterion in loaded_settings and isinstance(loaded_settings[criterion], list):
                    for setting in loaded_settings[criterion]:
                        if setting['index'] == 1:
                            entry1.insert(0, setting['entry'])
                            entry_widgets[(criterion, "button1")].config(text=setting['button'])
                            if setting['button'] == "On":
                                self.set_button_orange(entry_widgets[(criterion, "button1")])
                        elif setting['index'] == 2:
                            entry2.insert(0, setting['entry'])
                            entry_widgets[(criterion, "button2")].config(text=setting['button'])
                            if setting['button'] == "On":
                                self.set_button_orange(entry_widgets[(criterion, "button2")])
                elif criterion in loaded_settings and not isinstance(loaded_settings[criterion], list): # Single entry criteria
                    entry1 = entry_widgets.get((criterion, 1)) # Use entry1 here as single entry uses entry1 only in this setup
                    if entry1:
                        entry1.insert(0, loaded_settings[criterion]['entry'])
                        entry_widgets[(criterion, "button1")].config(text=loaded_settings[criterion]['button'])
                        if loaded_settings[criterion]['button'] == "On":
                            self.set_button_orange(entry_widgets[(criterion, "button1")])


                row_num += 1
            elif criterion not in ["Top Speed (km/h)", "Power", "0-100 km/h", "Off-Road Score", "Braking G", "Brand", "Configuration", "Fuel Type", "Drivetrain", "Transmission", "Country"]: # Single Entry Criteria # <--- ADDED "Country" HERE
                entry = ttk.Entry(filter_frame, style="DarkTheme.TEntry", font=entry_font) # Single Entry if not in dual entry criteria
                entry.grid(row=row_num, column=1, sticky="ew", pady=(row_pady, 5))
                on_off_button = tk.Button(filter_frame, text="Off", width=equal_width, **on_off_button_style_args)
                on_off_button.grid(row=row_num, column=2, sticky="w", padx=(button_entry_padx, 0), pady=(row_pady, 5))

                entry.bind("<KeyRelease>", lambda event, btn=on_off_button, entry=entry, style_args=on_off_button_style_args: self.update_button_on_entry_change(btn, entry, style_args))
                entry.bind("<Button-2>", lambda event, entry=entry, btn=on_off_button, style_args=on_off_button_style_args: [entry.delete(0, tk.END), btn.config(text="Off"), self.reset_button_color(btn, style_args)])

                entry_widgets[(criterion, 1)] = entry # Still using index 1 for consistency, but it's a single entry now.
                entry_widgets[(criterion, "button")] = on_off_button

                # Load saved settings for single entry criteria
                if criterion in loaded_settings and not isinstance(loaded_settings[criterion], list): # Ensure not list in case of previous dual setup
                    if 'entry' in loaded_settings[criterion] and 'button' in loaded_settings[criterion]:
                        entry.insert(0, loaded_settings[criterion]['entry'])
                        on_off_button.config(text=loaded_settings[criterion]['button'])
                        if loaded_settings[criterion]['button'] == "On":
                            self.set_button_orange(on_off_button)
                row_num += 1


        def clear_focus_on_click(event):
            if event.widget not in entry_widgets.values():
                filters_window.focus_set()
        filters_window.bind("<Button-1>", clear_focus_on_click)

        filter_frame.columnconfigure(1, weight=1)

        buttons_frame = tk.Frame(filters_window, bg="#333333", pady=10)
        buttons_frame.pack(side=tk.BOTTOM, fill=tk.X)

        try:
            original_bg = bottom_button_style_args.get('bg', "#555555")
            original_fg = bottom_button_style_args.get('fg', "#FFFFFF")
            # Ensure active colors are in the style for consistent click feedback
            active_bg = bottom_button_style_args.get('activebackground', "#666666")
            active_fg = bottom_button_style_args.get('activeforeground', "#FFFFFF")
            # Update the style dict if active colors were missing
            bottom_button_style_args['activebackground'] = active_bg
            bottom_button_style_args['activeforeground'] = active_fg
        except AttributeError: # Handle if bottom_button_style_args is not a dict
             print("Warning: bottom_button_style_args is invalid. Using default colors.")
             original_bg = "#555555"
             original_fg = "#FFFFFF"
             active_bg = "#666666"
             active_fg = "#FFFFFF"
             # Create a default style dict if needed
             bottom_button_style_args = {
                "bg": original_bg, "fg": original_fg, "relief": tk.FLAT, "bd": 0,
                "highlightbackground": original_bg, # Example default values
                "activebackground": active_bg, "activeforeground": active_fg
             }


        hover_fg = "#FFFFFF" # Standard hover foreground

        # --- Create Apply Button ---
        apply_button = tk.Button(
            buttons_frame,
            text="Apply Filters",
            command=lambda: self.apply_filters_and_run_filter(entry_widgets),
            **bottom_button_style_args
        )
        apply_button.pack(side=tk.LEFT, padx=10, expand=True, fill=tk.X)

        # --- Create Clear Button ---
        clear_button = tk.Button(
            buttons_frame,
            text="Clear",
            command=lambda: self.clear_all_filters_and_files(entry_widgets, on_off_button_style_args),
            **bottom_button_style_args
        )
        clear_button.pack(side=tk.RIGHT, padx=10, expand=True, fill=tk.X)



        # --- Bind Apply Button using the helper function ---
        self._bind_animated_hover(
            button=apply_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False # Assuming always enabled
        )

        # --- Bind Clear Button using the helper function ---
        self._bind_animated_hover(
            button=clear_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False # Assuming always enabled
        )


        #self.center_window()
        
        
  
        

        
        
    def apply_filters_and_run_filter(self, entry_widgets):
        """Applies filters and runs file filtering, added search window update."""

        # --- MODIFICATION START: Check if filters are empty ---
        filters_are_empty = True
        for entry_key, entry in entry_widgets.items():
            if isinstance(entry, ttk.Entry) and entry.get().strip():
                filters_are_empty = False
                break
            if isinstance(entry_key, tuple): # Check dual entry criteria too
                criterion, entry_index = entry_key
                if isinstance(entry, ttk.Entry) and entry.get().strip():
                    filters_are_empty = False
                    break
        if filters_are_empty:
            print("DEBUG: apply_filters_and_run_filter - No filters entered (all entries empty). Triggering Clear Filters behavior.")
            self.clear_all_filters_and_files(entry_widgets, self.button_style_args) # Use self.button_style_args
            return  # Exit early, mimicking Clear button behavior
        # --- MODIFICATION END: Check if filters are empty ---


        filters_variable = self.apply_filters(entry_widgets)
        if filters_variable is not None:
            self.filter_config_files(filters_variable)
            self.is_data_subset_active = True
            self.subset_data_button.config(text="On")
            print("    apply_filters_and_run_filter is calling self.perform_search()")
            self.perform_search()
            print("Data Subset Mode: ON (Set by Apply Filters)")
            self.update_search_results_window_ui()

            # --- MODIFICATION START: Open Search Results Window after applying filters ---
            if not hasattr(self, 'search_results_window') or not self.search_results_window or not self.search_results_window.winfo_exists():
                self.search_results_window = self.show_search_results_window(self.data) # Pass current data
                print("DEBUG: apply_filters_and_run_filter - Search Results window CREATED after applying filters.")
            self.search_results_window.lift() # Bring to front if already open
            print("DEBUG: apply_filters_and_run_filter - Search Results window LIFTED after applying filters.")
            # --- MODIFICATION END: Open Search Results Window after applying filters ---

        self.lift_search_results_window()





    def get_json_value_safe(self, data, key, regex_pattern=None):
        # No JSON decoding anymore - data is always a string
        if regex_pattern and isinstance(regex_pattern, str):
            try:
                match = re.search(regex_pattern, data, re.IGNORECASE | re.MULTILINE) # Added re.MULTILINE for multiline JSON
                if match:
                    return match.group(1).strip() if match.groups() else match.group(0).strip() # Return captured group or full match
            except: # Regex error, return None
                return None
        return None # Key not found and regex failed or not provided

    def _parse_filters(self, filters_string):
        """Parses the filter string into individual filter conditions."""
        filter_conditions = []
        brand_filter = None
        country_filter = None

        if not filters_string:
            print("No filters applied for file filtering.")
            return filter_conditions, brand_filter, country_filter

        for segment in filters_string.split(" | "):
            parts = re.split(r'(Contains|DoesNotContain|Below \(m/s\)|Above \(m/s\)|Below|Above)', segment)
            if len(parts) == 3:
                criterion = parts[0].strip() # Added strip here to remove potential leading/trailing spaces
                filter_type = parts[1]
                filter_value = parts[2].strip().strip('"')
                condition = {'criterion': criterion, 'type': filter_type, 'value': filter_value}
                filter_conditions.append(condition)
                if criterion == "Brand":
                    brand_filter = condition
                elif criterion == "Country":
                    country_filter = condition
        return filter_conditions, brand_filter, country_filter

    def _check_condition(self, file_content, condition, filename=""):
        """Checks if a single filter condition is met for a given file content, reading content directly."""
        criterion = condition['criterion']
        filter_type = condition['type']
        filter_value = condition['value']
        file_value = None

        if file_content is None:
            return False, f"Error: File content for {filename} is missing."

        if criterion == "Brand":
            file_value = self.get_json_value_safe(file_content, "Brand", r'"Brand"\s*:\s*"([^"]*)"')
        elif criterion == "Country":
            file_value = self.get_json_value_safe(file_content, "Country", r'"Country"\s*:\s*"([^"]*)"')
        elif criterion == "Configuration":
            file_value_json = self.get_json_value_safe(file_content, "Configuration", r'"Configuration"\s*:\s*"([^"]*)"')
            name_parts = filename.split('--info_info_')
            file_value_name = name_parts[1].replace(".json", "_", "-") if len(name_parts) > 1 else None
            file_value = file_value_json or file_value_name
        elif criterion == "Top Speed (km/h)":
            top_speed_ms_str = self.get_json_value_safe(file_content, "Top Speed", r'"Top Speed"\s*:\s*([\d.]*)')
            if top_speed_ms_str:
                try:
                    top_speed_ms = float(top_speed_ms_str)
                    file_value = top_speed_ms * 3.6
                except ValueError:
                    file_value = None
        elif criterion == "Power":
            file_value = self.get_json_value_safe(file_content, "Power", r'"Power"\s*:\s*([\d.]*)')
        elif criterion == "0-100 km/h":
            file_value = self.get_json_value_safe(file_content, "0-100 km/h", r'"0-100 km/h"\s*:\s*([\d.]*)')
        elif criterion == "Off-Road Score":
            file_value = self.get_json_value_safe(file_content, "Off-Road Score", r'"Off-Road Score"\s*:\s*([\d.]*)')
        elif criterion == "Braking G":
            file_value = self.get_json_value_safe(file_content, "Braking G", r'"Braking G"\s*:\s*([\d.]*)')
        elif criterion == "Fuel Type":
            file_value = self.get_json_value_safe(file_content, "Fuel Type", r'"Fuel Type"\s*:\s*"([^"]*)"')
        elif criterion == "Drivetrain":
            file_value = self.get_json_value_safe(file_content, "Drivetrain", r'"Drivetrain"\s*:\s*"([^"]*)"')
        elif criterion == "Transmission":
            file_value = self.get_json_value_safe(file_content, "Transmission", r'"Transmission"\s*:\s*"([^"]*)"')

        if file_value is None and filter_type not in ["Contains", "DoesNotContain"]:
            return False, f"{criterion}: Value not found in file."

        condition_met = False
        if filter_type == "Contains":
            condition_met = filter_value.lower() in str(file_value).lower() if file_value is not None else False
        elif filter_type == "DoesNotContain":
            condition_met = filter_value.lower() not in str(file_value).lower() if file_value is not None else True # Handle None as not containing
        elif filter_type in ["Below", "Above", "Below (m/s)", "Above (m/s)"]:
            try:
                file_value_float = float(str(file_value)) if file_value is not None else None
                filter_value_float = float(filter_value)
                if file_value_float is not None: # Only compare if file_value is valid number
                    if filter_type in ["Below", "Below (m/s)"]:
                        condition_met = file_value_float < filter_value_float
                    elif filter_type in ["Above", "Above (m/s)"]:
                        condition_met = file_value_float > filter_value_float
            except (ValueError, TypeError):
                condition_met = False # Handle non-numeric comparisons as not met

        if not condition_met and file_value is not None: # Only provide reason if we could get a file_value
             return False, f"{criterion} {filter_type} {filter_value}, but file has value: '{file_value}'"
        elif not condition_met:
            return False, f"{criterion} {filter_type} {filter_value}, but value could not be determined in file." # More generic reason for no file_value
        return True, None





    def _process_main_info_files(self, matches_data, brand_filter, country_filter, outfile): # Modified to take matches_data
        """Processes main info files from matches_data, applying brand and country filters."""
        main_info_brand_check_results = {}
        main_info_country_check_results = {}
        not_matched_files_details = []

        outfile.write("---\nProcessing Main Info Files (Brand/Country Check):\n")
        for entry in matches_data: # Iterate through matches_data
            filename = entry['filename']
            file_content = entry['content']
            if "INDIVIDUAL" in filename: # Skip individual files here
                continue

            brand_check_failed_reason = None
            country_check_failed_reason = None
            is_match = True

            if brand_filter:
                condition_met, reason = self._check_condition(file_content, brand_filter, filename)
                if not condition_met:
                    is_match = False
                    brand_check_failed_reason = reason

            if country_filter:
                condition_met, reason = self._check_condition(file_content, country_filter, filename)
                if not condition_met:
                    is_match = False
                    country_check_failed_reason = reason
                    if brand_check_failed_reason:
                        brand_check_failed_reason += f"; and {country_check_failed_reason}"
                    else:
                        brand_check_failed_reason = country_check_failed_reason # Reusing variable name for combined reason


            main_zip_name_match = re.search(r'vehicles--(.+?\.zip)--info\.json', filename, re.IGNORECASE)
            main_zip_name = main_zip_name_match.group(1) if main_zip_name_match else None
            outfile.write(f"DEBUG: Main File - Filename: {filename}, main_zip_name: '{main_zip_name}', Brand/Country Check Result: {not brand_check_failed_reason}\n")
            main_info_brand_check_results[main_zip_name] = not brand_check_failed_reason
            main_info_country_check_results[main_zip_name] = not country_check_failed_reason

            if brand_check_failed_reason:
                not_matched_files_details.append({'filename': filename, 'content_summary': file_content[:200] + "...", 'reasons': [brand_check_failed_reason]})
                outfile.write(f"  Filename: {filename} - Brand/Country Check Failed\n")
                outfile.write(f"  Reasons: {brand_check_failed_reason}\n")
                outfile.write("-" * 20 + "\n")
            else:
                outfile.write(f"  Filename: {filename} - Brand/Country Check Passed (or no brand/country filter)\n")
                outfile.write("-" * 20 + "\n")


        return main_info_brand_check_results, main_info_country_check_results, not_matched_files_details


    def _process_individual_files(self, matches_data, filter_conditions, main_info_brand_check_results, main_info_country_check_results, outfile): # Modified to take matches_data
        """Processes individual files from matches_data, applying filters and considering main info file results."""
        matched_files_details = []
        not_matched_files_details = []
        data_subset_pairs = []
        main_info_matched_for_subset = set()

        outfile.write("\n---\nProcessing Individual Files:\n")
        for entry in matches_data: # Iterate through matches_data
            filename = entry['filename']
            file_content = entry['content']
            if "INDIVIDUAL" not in filename: # Skip main files here
                continue

            is_match = True
            reasons_not_matched = []
            brand_check_failed = False
            country_check_failed = False

            individual_zip_name_match = re.search(r'vehicles--INDIVIDUAL--(.+?\.zip)--info_info_.*\.json', filename, re.IGNORECASE)
            individual_zip_name = individual_zip_name_match.group(1) if individual_zip_name_match else None

            related_main_info_brand_check_passed = True # Default if no brand filter
            related_main_info_country_check_passed = True # Default if no country filter

            if any(cond['criterion'] == "Brand" for cond in filter_conditions): # Check if brand filter is applied at all
                related_main_info_brand_check_passed = main_info_brand_check_results.get(individual_zip_name, False)
            if any(cond['criterion'] == "Country" for cond in filter_conditions): # Check if country filter is applied at all
                related_main_info_country_check_passed = main_info_country_check_results.get(individual_zip_name, True)


            outfile.write(f"DEBUG: Individual File - Filename: {filename}, individual_zip_name: '{individual_zip_name}', related_main_info_brand_check_passed: {related_main_info_brand_check_passed}, related_main_info_country_check_passed: {related_main_info_country_check_passed}\n")


            if not related_main_info_brand_check_passed:
                is_match = False
                brand_check_failed = True
                reasons_not_matched.append("Related Main File Failed Brand Check (or missing Main Info File with Brand Filter active)")

            if not related_main_info_country_check_passed:
                is_match = False
                country_check_failed = True
                if not brand_check_failed:
                    reasons_not_matched.append("Related Main File Failed Country Check (or missing Main Info File with Country Filter active)")


            if is_match: # Only proceed with other filters if main file brand/country check passed or no brand/country filter
                for condition in filter_conditions:
                    if condition['criterion'] in ["Brand", "Country"]: # Skip Brand and Country here, already handled
                        continue

                    condition_met, reason = self._check_condition(file_content, condition, filename)
                    if not condition_met:
                        is_match = False
                        reasons_not_matched.append(reason)


            if is_match:
                matched_files_details.append({'filename': filename, 'content_summary': file_content[:200] + "...", 'reasons': "Matched all criteria"})
                outfile.write(f"  Filename: {filename} - Matched\n")
                outfile.write(f"  Reasons: Matched all criteria\n")
                outfile.write("-" * 20 + "\n")
                individual_zip_name_match_subset = re.search(r'vehicles--INDIVIDUAL--(.+?\.zip)--info_info_.*\.json', filename, re.IGNORECASE) # Re-extract for subset pairing to ensure correct zip name
                individual_zip_name_subset = individual_zip_name_match_subset.group(1) if individual_zip_name_match_subset else None
                data_subset_pairs.append({'main_file': individual_zip_name_subset, 'individual_file': filename})
                main_info_matched_for_subset.add(individual_zip_name_subset)

            else:
                not_matched_files_details.append({'filename': filename, 'content_summary': file_content[:200] + "...", 'reasons': reasons_not_matched})
                outfile.write(f"  Filename: {filename} - Not Matched\n")
                outfile.write(f"  Reasons: {reasons_not_matched}\n")
                outfile.write("-" * 20 + "\n")


        return matched_files_details, not_matched_files_details, data_subset_pairs, main_info_matched_for_subset



    def _write_output_summary(self, outfile, matched_files_details, not_matched_files_details, data_subset_pairs, main_info_files_from_matches): # Modified to take main_info_files from matches data
        """Writes the summary of matched and not matched files to the output file."""
        outfile.write("\n---\n--- Matched Files Summary ---\n")
        for file_detail in matched_files_details:
            outfile.write(f"Filename: {file_detail['filename']}\n")
            outfile.write(f"Reasons: {file_detail['reasons']}\n")
            outfile.write("-" * 20 + "\n")

        outfile.write("\n---\n--- Not Matched Files Summary ---\n")
        for file_detail in not_matched_files_details:
            outfile.write(f"Filename: {file_detail['filename']}\n")
            outfile.write(f"Reasons: {file_detail['reasons']}\n")
            outfile.write("-" * 20 + "\n")

        main_info_files_written = set()

        outfile.write("\n---\n--- DEBUG LOGS ---\n") # <--- ADDED DEBUG LOG SECTION HEADER

        outfile.write("\n---\n--- Data Subset Files ---\n")
        for pair in data_subset_pairs:
            main_file_zip_name = pair['main_file']
            individual_file_name = pair['individual_file']

            main_info_filename = None
            for main_filename in main_info_files_from_matches: # Use main_info_files from matches data
                if main_file_zip_name and main_file_zip_name in main_filename:
                    main_info_filename = main_filename
                    break

            if main_info_filename and main_info_filename not in main_info_files_written:
                outfile.write(f"Subset Main File: {main_info_filename}\n")
                main_info_files_written.add(main_info_filename)

            if main_info_filename:
                outfile.write(f"Subset Individual File: {individual_file_name}\n")



    def filter_config_files(self, filters_string):
        """Filters configuration files based on the provided filter string, reading from matches.txt."""

        if not os.path.exists(self.configinfo_folder):
            print(f"Error: Configinfo folder '{self.configinfo_folder}' not found.")
            return

        filter_conditions, brand_filter, country_filter = self._parse_filters(filters_string)

        matches_file_path = os.path.join(self.script_dir, self.matches_txt) # Path to matches.txt
        matches_data = []
        main_info_files_from_matches = [] # To track main info files from matches.txt

        try:
            with open(matches_file_path, 'r', encoding="utf-8") as f:
                current_filename = None
                current_content_lines = []
                reading_content = False
                for line in f:
                    line = line.strip()
                    if not line:
                        continue # Skip empty lines

                    if not reading_content:
                        if line == '}': # Check if a '}' appears unexpectedly as a filename
                            #print(f"Warning: Unexpected 'curly brace' as filename in {self.matches_txt}. Skipping line.")
                            continue # Skip this line and move to the next
                        current_filename = line
                        reading_content = True
                        if "INDIVIDUAL" not in current_filename and "info.json" in current_filename: # Track main files from matches.txt
                            main_info_files_from_matches.append(current_filename)
                    elif line == '}': # Assuming JSON ends with '}' at the end of content
                        current_content_lines.append(line)
                        content = "\n".join(current_content_lines)
                        matches_data.append({'filename': current_filename, 'content': content})
                        current_filename = None  # Reset filename IMMEDIATELY after processing content
                        current_content_lines = []
                        reading_content = False
                    elif reading_content:
                        current_content_lines.append(line)

        except FileNotFoundError:
            print(f"Error: {self.matches_txt} file not found in script directory: {self.script_dir}")
            return
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON in {self.matches_txt}: {e}")
            return


        matched_files_details = [] # Initialize here to be used if no outfile context
        not_matched_files_details = []
        data_subset_pairs = []
        main_info_brand_check_results = {}
        main_info_country_check_results = {}
        main_info_matched_for_subset = set()


        with open(self.filter_output_file, 'w', encoding="utf-8") as outfile, open("data/data_subset.txt", 'w', encoding="utf-8") as subset_outfile:
            outfile.write("Filter Results:\n\n")

            main_info_brand_check_results, main_info_country_check_results, not_matched_files_details_main = self._process_main_info_files(
                matches_data, brand_filter, country_filter, outfile # Pass matches_data
            )
            not_matched_files_details.extend(not_matched_files_details_main) # Combine not matched from main files

            matched_files_details_ind, not_matched_files_details_ind, data_subset_pairs, main_info_matched_for_subset = self._process_individual_files(
                matches_data, filter_conditions, main_info_brand_check_results, main_info_country_check_results, outfile # Pass matches_data
            )
            matched_files_details.extend(matched_files_details_ind) # Combine matched from individual files
            not_matched_files_details.extend(not_matched_files_details_ind) # Combine not matched from individual files


            self._write_output_summary(outfile, matched_files_details, not_matched_files_details, data_subset_pairs, main_info_files_from_matches) # Pass main_info_files from matches

            main_info_files_written = set()
            for pair in data_subset_pairs:
                main_file_zip_name = pair['main_file']
                individual_file_name = pair['individual_file']

                main_info_filename = None
                for main_filename in main_info_files_from_matches: # Iterate from main_info_files_from_matches
                    if main_file_zip_name and main_file_zip_name in main_filename:
                        main_info_filename = main_filename
                        break

                if main_info_filename and main_info_filename not in main_info_files_written:
                    subset_outfile.write(f"{main_info_filename}\n")
                    main_info_files_written.add(main_info_filename)

                if main_info_filename:
                    subset_outfile.write(f"{individual_file_name}\n")


        print(f"Filter results written to {self.filter_output_file}")
        print(f"Data subset file list written to data_subset.txt")

        transformed_lines = self.process_individual_lines() # Assuming this method exists in your class

        if transformed_lines is not None:
            with open("data/data_subset.txt", 'w', encoding="utf-8") as subset_outfile: # Reopen to overwrite or consider different logic
                for line in transformed_lines:
                    subset_outfile.write(f"{line}\n")
            print(f"Transformed image file list written to data_subset.txt (overwritten)")
        else:
            print("No transformed lines generated or error in processing.")

        # Assuming generate_data_subset_favorites is a function you want to call
        # and it's defined elsewhere or needs to be defined within the class
        if hasattr(self, 'generate_data_subset_favorites'): # Check if it's a method of the class
            self.generate_data_subset_favorites(self.script_dir)
        elif 'generate_data_subset_favorites' in globals(): # Check if it's a global function (less likely in class context)
            generate_data_subset_favorites(self.script_dir) # Call as global function
        else:
            print("Warning: generate_data_subset_favorites function not found or not callable as class method.") # Handle if function is missing
 



    def process_individual_lines(self):
        """
        Reads the data_subset_file, processes lines containing '--INDIVIDUAL--',
        and returns a list of transformed lines, checking for file existence in ConfigPics.
        Includes the original line before the transformed lines in the output.

        For lines with '--INDIVIDUAL--', it:
        - Removes '--INDIVIDUAL--'
        - Removes 'info_info_'
        - Changes the extension to jpg, png, and jpeg, creating three lines for each original line.
        - Checks if the file exists in the ConfigPics folder before adding to output.
        - Includes the original input line before the generated lines.

        Returns:
            list: A list of strings, where each string is a processed line,
                  with original lines preceding their transformed counterparts if applicable.
        """
        transformed_lines = []
        try:
            #script_dir = os.path.dirname(os.path.abspath(__file__))
            config_pics_dir = os.path.join(self.script_dir, "data/ConfigPics")

            with open(self.data_subset_file, 'r', encoding="utf-8") as f:
                for line in f:
                    original_input_line = line.strip() # Store the original stripped line for later use
                    line = original_input_line # Use stripped line for processing
                    if "--INDIVIDUAL--" in line:
                        # Process individual line
                        transformed_lines.append(original_input_line) # Add the original line first

                        parts = line.split('--')
                        if len(parts) >= 4: # Ensure enough parts to process
                            base_path = parts[0]
                            zip_name = parts[2] # parts[1] is INDIVIDUAL which we remove
                            info_part = parts[3]

                            # Remove "info_info_" and get the identifier
                            identifier_with_ext = info_part.replace("info_info_", "")

                            if "." in identifier_with_ext:
                                identifier, old_ext = identifier_with_ext.rsplit('.', 1) # Split once at the first dot

                                base_output_line = f"{base_path}--{zip_name}--{identifier}"
                                extensions = ["jpg", "png", "jpeg"]
                                for ext in extensions:
                                    transformed_line = f"{base_output_line}.{ext}"
                                    file_path_to_check = os.path.join(config_pics_dir, transformed_line)
                                    if os.path.exists(file_path_to_check):
                                        transformed_lines.append(transformed_line)
                    # If you want to keep lines without --INDIVIDUAL-- as they are in the output file, uncomment this:
                    # else:
                    #     transformed_lines.append(original_input_line) # Append original line if not processed

        except FileNotFoundError:
            print(f"Error: File not found: {self.data_subset_file}")
            return [] # Or handle the error as needed

        return transformed_lines
        



    def edit_file_with_transformed_lines(self):
        """
        Processes the data_subset_file and overwrites it with the transformed lines.
        If you uncommented the `else` part in `process_individual_lines`, it will
        also keep the original lines that were not transformed in the output file.
        """
        transformed_lines = self.process_individual_lines()
        try:
            with open(self.data_subset_file, 'w', encoding="utf-8") as f: # Open file in write mode ('w' to overwrite)
                for line in transformed_lines:
                    f.write(line + '\n') # Write each transformed line to the file
            print(f"File '{self.data_subset_file}' updated with transformed lines.")
        except Exception as e:
            print(f"Error writing to file '{self.data_subset_file}': {e}")

    def toggle_data_subset(self):
        """Toggles data subset mode, added search window update."""
        pass #remove comment if you want to re-enable the toggle data subset button. # clicking on the button itself is disabled to prevent empty filters from being applied, don't remove comment
        if self.details_window and not self.details_window_closed:
            messagebox.showinfo(
                "Filter State Switching Unavailable",
                "Cannot adjust filters while configuration details window is open.",
                parent=self.master
            )
            return
        else:
            print("DEBUG: show_filters_window - Details window is NOT open or is closed - Condition is FALSE")

        if self.search_mode == "Configs":
            messagebox.showinfo(
                "Subset Data Unavailable",
                "Please switch out of 'Search Mode: Configs' before toggling Filters.",
                parent=self.master
            )
            return

        if not hasattr(self, 'is_data_subset_active'):
            self.is_data_subset_active = False

        self.is_data_subset_active = not self.is_data_subset_active
        if self.is_data_subset_active:
            self.subset_data_button.config(text="On")
            self.set_button_orange(self.subset_data_button)
        else:
            self.subset_data_button.config(text="Off")
            self.reset_button_color(self.subset_data_button, self.button_style_args)
        print("    toggle_data_subset is calling self.perform_search()")
        self.perform_search()
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE

       
        
        

    #   Global Filters End
    # ------------------------------------------------------------


    def create_filter_button(self, bottom_frame):
        """Creates the filter button with smooth hover animation."""

        # --- Define Colors & Styles ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF" # Text color on hover
        active_bg = "#666666" # Standard click feedback color
        active_fg = "#FFFFFF" # Standard click feedback text color

        button_style_args = {
            "bg": original_bg,
            "fg": original_fg,
            "relief": tk.FLAT,
            "bd": 0,
            # "highlightthickness": 0, # REMOVED as per instruction
            "highlightbackground": original_bg,
            "activebackground": active_bg, # For standard click feedback
            "activeforeground": active_fg, # For standard click feedback
            "font": ("Segoe UI", 12 + self.font_size_add)
        }

        # --- Create the Button ---
        # Ensure required attributes exist (e.g., in __init__)
        # if not hasattr(self, 'filter_options'): self.filter_options = {0: "Default"}
        # if not hasattr(self, 'filter_state'): self.filter_state = 0

        button = tk.Button(
            bottom_frame,
            text=f"{self.filter_options[self.filter_state]} [0]", # Update text as needed
            command=self.show_filter_dropdown,
            **button_style_args
        )
        self.filter_button = button # Store reference if needed elsewhere in the class

        # --- Bind Hover/Destroy Events using the Helper ---
        # This replaces the local handlers, bindings, and color storage
        self._bind_animated_hover(
            button=button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False # This button did not check state in original code
        )

        # --- Pack the Button ---
        button.pack(side="left", padx=(10, 0))



    def show_filter_dropdown(self):
        if hasattr(self, 'filter_dropdown_window') and self.filter_dropdown_window and self.filter_dropdown_window.winfo_exists():
            self.filter_dropdown_window.destroy()
            return

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot change main filter mode while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return
        
        button = self.filter_button
        # Force update to ensure button dimensions and position are current
        button.update_idletasks()
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty()
        # button_height = button.winfo_height() # We don't strictly need button_height for this calculation

        self.filter_dropdown_window = FadingToplevel(self.master, self) # Use master.root or appropriate parent
        self.filter_dropdown_window.overrideredirect(True) # Remove window border
        # Don't set geometry yet
        self.filter_dropdown_window.wm_attributes("-topmost", True) # Keep on top of other windows

        # Configure window appearance before adding content
        self.filter_dropdown_window.tk.call('tk', 'scaling', 1.25) # Apply scaling early if possible
        self.filter_dropdown_window.config(bg="#333333") # Dark grey background for dropdown
        self.filter_dropdown_window.config(highlightthickness=3, highlightbackground="#666666")



        def on_dropdown_button_click(index):
            self.filter_state = index # <--- FIX: Correctly update filter_state
            current_filter = self.filter_options[self.filter_state]
            self.filter_button.config(text=f"{current_filter} [0]")
            #self.filter_dropdown_window.destroy()
            #self.filter_dropdown_window = None

            # --- NEW: Reset Brand, Name, Bodystyle, and Country filters to "All..." when main filter changes ---
            brand_button = self.sidebar_filter_buttons.get("Brand")
            if brand_button:
                brand_button.config(text="All Brands")

            name_button = self.sidebar_filter_buttons.get("Name") # <--- Get Name button
            if name_button:
                name_button.config(text="All Names") # <--- Reset Name button to "All Names"

            bodystyle_button = self.sidebar_filter_buttons.get("Bodystyle") # <--- Get Bodystyle button
            if bodystyle_button:
                bodystyle_button.config(text="All BodyStyles") # <--- Reset Bodystyle button to "All BodyStyles"

            country_button = self.sidebar_filter_buttons.get("Country") # <--- Get Country button
            if country_button:
                country_button.config(text="All Countries") # <--- Reset Country button to "All Countries"
            # --- NEW: Reset Brand, Name, Bodystyle, and Country filters to "All..." when main filter changes ---

            print("    on_dropdown_button_click is calling self.perform_search() - inner function of show_filter_dropdown")
            self.perform_search() # <--- FIX: Call perform_search here to apply filter

            # --- MODIFICATION START: Open Search Results Window for non-"View All" filters ---
            if self.filter_state != 0: # Check if the selected filter is NOT "View All" (index 0)
                if not hasattr(self, 'search_results_window') or not self.search_results_window or not self.search_results_window.winfo_exists():
                    self.search_results_window = self.show_search_results_window(self.data) # Pass current data
                    print("DEBUG: show_filter_dropdown - Search Results window CREATED due to filter change (non-'View All').")
                self.search_results_window.lift() # Bring to front if already open
                print("DEBUG: show_filter_dropdown - Search Results window LIFTED.")


            elif hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
                # --- MODIFIED CONDITION: Check if search bar is EMPTY AND GLOBAL FILTERS ARE OFF before destroying ---
                if not self.search_var.get().strip() and not self.is_data_subset_active: # Check for empty search AND global filters OFF
                    self.destroy_search_results_window() # Close Search Results window if switching back to "View All" AND search bar is empty AND global filters are OFF
                    self.search_results_window = None
                    self.is_search_results_window_active = False
                    print(f"!!!!!!!!!! self.is_search_results_window_active SET TO FALSE by on_dropdown_button_click, under show_filter_dropdown. Timestamp: {time.time()} !!!!!!!!!!")

                    print("DEBUG: show_filter_dropdown - Search Results window DESTROYED (switching back to 'View All' AND search bar EMPTY AND Global Filters OFF).")
                else:
                    print("DEBUG: show_filter_dropdown - Keeping Search Results window OPEN (switching back to 'View All' BUT search bar NOT empty OR Global Filters ON).") # DEBUG - Window Kept Open
            # --- MODIFICATION END: Open Search Results Window for non-"View All" filters ---

            if hasattr(self, 'categorize_dropdown_window') and self.categorize_dropdown_window and self.categorize_dropdown_window.winfo_exists():

                self.categorize_dropdown_window.destroy()
                self.categorize_dropdown_window = None

        # --- MODIFICATION: Filter out the items to be hidden ---
        filtered_options_list = [option for index, option in enumerate(self.filter_options) if index not in [1, 2, 3]] # Indices of "Items with Config Preview Images [debug]", "Items Without Config Preview Images [debug]", "Only Mods"
        # --- MODIFICATION: Filter out the items to be hidden ---


        for index, option in enumerate(filtered_options_list): # Corrected enumerate here
            # --- Determine initial colors and selected state ---
            is_selected = (option == self.filter_options[self.filter_state]) # Check if this option is the currently selected filter

            default_bg_color = "#555555"    # Normal, non-selected background
            default_fg_color = "#FFFFFF"    # Normal, non-selected foreground

            selected_option_bg = self.global_highlight_color # Orange background for current filter
            selected_option_fg = "#FFFFFF"                   # White text for visibility on orange

            # --- Define hover colors for these dropdown items ---
            dropdown_item_hover_bg = "#d9d9d9"
            dropdown_item_hover_fg = "black"

            # Determine the actual initial bg/fg for the button based on selection
            # This is now handled by _bind_animated_hover's `is_selected_initial` logic

            # --- Button creation (styles are now set by _bind_animated_hover initially) ---
            dropdown_button = tk.Button(
                self.filter_dropdown_window, # Ensure this window exists
                text=option,
                font=("Segoe UI", 10 + self.font_size_add, "bold"),
                # The command now needs to also handle visually updating the selected item
                # This lambda is just for the original command part. Visual update is separate.
                command=lambda idx=self.filter_options.index(option): on_dropdown_button_click(idx), # <--- MODIFIED: Use original index from self.filter_options
                borderwidth=1, # Keep these styles if they are specific to dropdown items
                relief="solid",
                anchor="w",
                padx=10,
                pady=5
                # bg and fg are set by _bind_animated_hover
            )
            dropdown_button.pack(fill="x")

            # --- Apply Smooth Hover Animation using the modified binder ---
            self._bind_animated_hover(
                button=dropdown_button,
                original_bg=default_bg_color,       # The "true" original, non-selected bg
                original_fg=default_fg_color,       # The "true" original, non-selected fg
                hover_target_bg=dropdown_item_hover_bg, # Custom hover BG
                hover_target_fg=dropdown_item_hover_fg, # Custom hover FG
                check_state=False,                    # Assuming these are not disabled
                is_selected_initial=is_selected,      # Is this button initially selected?
                selected_bg=selected_option_bg,       # Color if selected
                selected_fg=selected_option_fg        # Color if selected
            )

        # --- DYNAMIC POSITIONING ---
        # Force Tkinter to calculate the window's required size based on its contents
        self.filter_dropdown_window.update_idletasks()

        # Get the actual calculated height of the dropdown window
        window_height = self.filter_dropdown_window.winfo_height()

        # Calculate the target Y coordinate: button's top edge minus window's height
        target_y = button_y - window_height

        # Set the final geometry
        self.filter_dropdown_window.geometry(f"+{button_x}+{target_y}")

        
        # Bind focus out to close the dropdown if clicked outside
        self.filter_dropdown_window.bind("<FocusOut>", lambda event: self.destroy_filter_dropdown())

        self._update_filters_label_status()
 

    def set_filter_to_view_all_and_turn_subset_off(self):
        """
        Sets the filter state to 'View All' and updates the UI accordingly.
        """
        view_all_index = 0 
        if 0 <= view_all_index < len(self.filter_options):
            self.filter_state = view_all_index
            current_filter = self.filter_options[self.filter_state]
            self.filter_button.config(text=f"{current_filter} [0]") # Update button text

            if self.filters_window and self.filters_window.winfo_exists():
                self.filters_window.destroy()
                self.filters_window = None

            # Clear Global Filters and Reset Buttons
            entry_widgets = {}
            on_off_button_style_args = self._create_button_style() # Or however you get button style args
            self.clear_all_filters_and_files(entry_widgets, on_off_button_style_args)


            # Disable Subset Mode
            self.is_data_subset_active = False
            self.subset_data_button.config(text="Off")
            self.reset_button_color(self.subset_data_button, self.button_style_args)

            print("    set_filter_to_view_all_and_turn_subset_off is calling self.perform_search() - and also clearing the search bar")
            self.search_var.set("")
            self.perform_search() 
            print("Filter set to 'View All'.")
        else:
            print("Error: 'View All' filter option not found.")



    def destroy_filter_dropdown(self):
        self.is_search_results_window_closing = True # <--- SET FLAG BEFORE DESTROY
        if hasattr(self, 'filter_dropdown_window') and self.filter_dropdown_window and self.filter_dropdown_window.winfo_exists():
            self.filter_dropdown_window.destroy()
            self.filter_dropdown_window = None
        self.is_search_results_window_closing = False # <--- RESET FLAG AFTER DESTROY
 
  
    def create_status_labels(self, bottom_frame):
        self.deleting_label = tk.Label(bottom_frame, text="", bg="#333333", fg="#d9d9d9", font=("Segoe UI", 12+self.font_size_add, "bold")) # Dark bg, lightgrey fg
        self.deleting_label.pack(side="left", expand=True, padx=(10, 0))




    def create_no_configs_message_label(self, bottom_frame):
        """Creates the 'No configurations available' label, initially hidden."""
        self.no_configs_label = tk.Label(
            bottom_frame,
            text="No configurations available for vehicle under filter restrictions",
            bg="#333333",
            fg=self.global_highlight_color,
            font=("Segoe UI", 12+self.font_size_add, "bold")
        )
        self.no_configs_label.pack(side="left", padx=(10, 0))  # Pack BEFORE settings button
        self.no_configs_label.pack_forget()  # Initially hidden


    def hide_no_configs_label(self):
        """Hides the 'No configurations available' label."""
        self.no_configs_label.pack_forget()

        if self.scanning_window:
            self.scanning_window.destroy()

        self.scanning_window = None


    def create_isolated_mods_button(self, bottom_frame):
        """Creates the 'Isolated Mods' button with smooth hover animation."""
        # --- Define Colors & Styles ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF" # Explicitly defining, though binder defaults to original_fg if None
        active_bg = "#666666"
        active_fg = "#FFFFFF"

        button_style_args = {
            "bg": original_bg, "fg": original_fg, "relief": tk.FLAT, "bd": 0,
            "highlightbackground": original_bg,
            "activebackground": active_bg, "activeforeground": active_fg,
            "font": ("Segoe UI", 12 + self.font_size_add)
        }

        # --- Create the Button ---
        button = tk.Button(
            bottom_frame,
            text="Isolated Mods",
            command=self.open_isolated_folder_in_explorer, # Ensure this method exists
            **button_style_args
        )
        self.isolated_mods_button = button # Store reference if needed

        # --- Bind using the helper ---
        self._bind_animated_hover(
            button=button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg, # Can omit if same as original_fg
            check_state=False # Assuming this button is always enabled
        )

        # --- Pack the Button ---
        button.pack(side="right", padx=(0, 10))
        return button

    def create_hidden_vehicles_button(self, bottom_frame):
        """Creates the 'Hidden Vehicles' button with smooth hover animation."""
        # --- Define Colors & Styles ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF"
        active_bg = "#666666"
        active_fg = "#FFFFFF"

        button_style_args = {
            "bg": original_bg, "fg": original_fg, "relief": tk.FLAT, "bd": 0,
            "highlightbackground": original_bg,
            "activebackground": active_bg, "activeforeground": active_fg,
            "font": ("Segoe UI", 12 + self.font_size_add)
        }

        # --- Create the Button ---
        button = tk.Button(
            bottom_frame,
            text="Hidden Vehicles",
            command=self.show_hidden_vehicles_window, # Ensure this method exists
            **button_style_args
        )
        self.hidden_vehicles_button = button # Store reference if needed

        # --- Bind using the helper ---
        self._bind_animated_hover(
            button=button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False # Assuming this button is always enabled
        )

        # --- Pack the Button ---
        button.pack(side="right", padx=(0, 10))
        return button


    def create_settings_button(self, bottom_frame, scale_changed=False):
        """Creates the 'Settings' button with smooth hover animation."""
        # --- Define Colors & Styles ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF"
        active_bg = "#666666"
        active_fg = "#FFFFFF"

        button_style_args = {
            "bg": original_bg, "fg": original_fg, "relief": tk.FLAT, "bd": 0,
            "highlightbackground": original_bg,
            "activebackground": active_bg, "activeforeground": active_fg,
            "font": ("Segoe UI", 12 + self.font_size_add)
        }

        # --- Create the Button ---
        button = tk.Button(
            bottom_frame,
            text="Settings",
            command=self.show_settings_dropdown, # Ensure this method exists
            **button_style_args
        )
        self.settings_button = button # Store reference

        # --- Bind using the helper FOR HOVER ---
        self._bind_animated_hover(
            button=button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False # Assuming this button is always enabled
        )

        # --- Keep OTHER specific bindings ---
        button.bind("<Button-3>", self.on_settings_button_right_click) # Ensure this method exists

        # --- Pack the Button ---
        button.pack(side="right", padx=(0, 10))

        # --- Keep special logic ---
        if scale_changed:
            print("DEBUG: Font size changed this session. Scheduling settings dropdown reopen in half a second second.")
            # Ensure self.master or appropriate root window reference exists
            self.master.after(500, self.show_settings_dropdown)

        return button


    def create_restart_button(self, bottom_frame):
        """Creates the 'Restart' button with smooth hover animation."""
        # --- Define Colors & Styles ---
        original_bg = "#555555"
        # Use the specific original foreground color for this button
        original_fg = self.restart_button_active_fg_color # Ensure this attribute exists
        hover_fg = "#FFFFFF" # Hover text color is still white
        active_bg = "#666666"
        active_fg = "#FFFFFF"

        button_style_args = {
            "bg": original_bg, "fg": original_fg, # Use specific initial fg
            "relief": tk.FLAT, "bd": 0,
            "highlightbackground": original_bg,
            "activebackground": active_bg, "activeforeground": active_fg,
            "font": ("Segoe UI", 12 + self.font_size_add)
        }

        # --- Create the Button ---
        button = tk.Button(
            bottom_frame,
            text="Restart",
            command=self.restart_script_and_save_settings, # Ensure this method exists
            **button_style_args
        )
        self.restart_button = button # Store reference if needed

        # --- Bind using the helper ---
        self._bind_animated_hover(
            button=button,
            original_bg=original_bg,
            original_fg=original_fg, # Pass the specific original fg
            hover_target_fg=hover_fg,       # Specify the hover fg
            check_state=False      # Assuming this button is always enabled
        )

        # --- Pack the Button ---
        button.pack(side="right", padx=(0, 10))
        return button





    def show_settings_dropdown(self):
        # --- Check if the button still exists ---
        if not hasattr(self, 'settings_button') or not self.settings_button.winfo_exists():
             print("Error: Settings button does not exist.")
             return

        trigger_button = self.settings_button # Use a local variable for clarity

        # --- Toggle check: Destroy existing dropdown if present ---
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            print("Dropdown exists, destroying it.")
            self.destroy_settings_dropdown() # Use the dedicated destroy method
            return # Exit after destroying

        print("Creating new dropdown.")

        # --- Create the Toplevel window ---
        self.settings_dropdown_window = FadingToplevel(self.master, self)
        self.settings_dropdown_window.overrideredirect(True)
        # Basic styling - do this early
        self.settings_dropdown_window.config(bg="#333333")
        self.settings_dropdown_window.config(highlightthickness=3, highlightbackground="#666666")


        try:
            # Apply scaling *before* adding content if you need it per-window
            self.settings_dropdown_window.tk.call('tk', 'scaling', 1.25)
            print("Applied tk scaling (1.25x) to dropdown.")
        except tk.TclError:
            print("Warning: Failed to set tk scaling for dropdown (might not be supported).")


        # --- Define the click handler nested function ---
        def on_settings_option_click(command, is_toggle_action):
            # Execute the primary action

            is_font_toggle = (command == self.toggle_font_size)

            command()

            if is_font_toggle:
                print("Font size toggled, marking for restart note.")
                self.font_size_changed_this_session = True
                self.destroy_settings_dropdown()
                

            should_reopen = is_toggle_action
            current_window = getattr(self, 'settings_dropdown_window', None) # Get current ref

            # Safely destroy the current dropdown window *before* potentially reopening
            if current_window and current_window.winfo_exists():
                 # Don't destroy here if reopening, destroy happens in the main toggle check
                 if not should_reopen:
                      print("Non-toggle action, destroying dropdown from click handler.")
                      self.destroy_settings_dropdown() # Use dedicated method
                 # If reopening, the destroy/recreate is handled by the 'after' call below
            # else:
                 # self.settings_dropdown_window = None # Ensure ref is clear if window didn't exist

            # Update any UI elements that depend on the setting
            self.update_settings_dropdown_button_text() # Call your update method



            if should_reopen:
                print("Toggle action detected, scheduling dropdown reopen...")
                # Check if the trigger button still exists before scheduling reopen
                if trigger_button.winfo_exists():
                    # Use master.after to allow the event loop to process destruction/updates
                    # before attempting recreation. This prevents issues.
                    # We need to destroy the *current* one *before* calling show_settings_dropdown again
                    if current_window and current_window.winfo_exists():
                         current_window.destroy()
                         self.settings_dropdown_window = None # Clear ref *immediately* after destroy

                    # Schedule the reopening
                    self.master.after(250, self.show_settings_dropdown)
                else:
                    print("Warning: Original settings button gone, cannot reopen dropdown.")
                    self.settings_dropdown_window = None # Ensure ref is cleared
            # No else needed for non-toggle, destruction was handled above or dropdown remains closed






        # --- Define settings options ---
        settings_options = [
            # Format: (Text, Command, Is_Toggle_Flag)

            ("SEPARATOR", "Information Display"),

            ("❓ Show Configs Without Vehicle Preview Images: " + ("On" if self.placeholder_settings else "Off"), self.toggle_placeholder_settings, True), # 🖼️ = Images (related to preview images) - changed from ⬜ to be more direct about images being the subject
            ("📁 Display Vehicle Folder Names Under Previews: " + ("On" if self.show_folder_settings else "Off"), self.toggle_show_folder_settings, False), # 📁 = Folder

            ("✨ Attempt to Show the Latest Installed Mods In The List First: " + ("On" if self.sort_by_install_date else "Off"), self.toggle_sort_by_install_date, True), # 📅 = Date/Time (for latest)
            ("📌 Display Pinned 'Favorites' Category: " + ("On" if self.show_pinned_favorites_category else "Off"), self.toggle_show_pinned_favorites_category, True), 

            ("SEPARATOR", "Configuration List"),

            ("👆 Double Clicking On a Vehicle Preview should: " + ("Replace the Current Vehicle" if self.middle_click_settings else "Add it to the Spawn Queue"), self.toggle_middle_click_settings, True), # 🖱️ = Mouse Click Action 
            ("↕️ 'Jump to page' Button Placement in Configuration List: " + ("Bottom" if self.jump_to_page_button_should_be_bottom else "Top"), self.toggle_jump_to_page_button_should_be_bottom, True), # ↕️ = Vertical Placement
            ("📜 Auto-close Configurations list when switching to BeamNG and back: " + ("Off" if self.leave_config_window_open else "On"), self.toggle_leave_config_window_open, True),            


            ("SEPARATOR", "General Behavior and UI Settings"),

            ("🚀 Show Transparent Switcher Window On Application Launch: " + ("On" if self.show_switcher_on_startup else "Off"), self.toggle_show_switcher_on_startup, True), # 🚀 = Launch/Startup
            ("➖ Collapse All Type and Country Categories On Application Launch: " + ("On" if self.collapse_categories_by_default else "Off"), self.toggle_collapse_categories_by_default, True), # ➖ = Collapse/Hide            
            (f"📚 Default Categorization mode: {self.default_categorization_mode}", self.toggle_default_categorization_mode, True),
            (f"⚙️ UI Font Size and Scale: {self._get_font_size_name()}", self.toggle_font_size, True),


            ("SEPARATOR", "Other Utilities"),

            ("🔄 Rescan All Mods, Configurations and Refresh UI", self.on_rescan_all_button_click_handler, False), # 🔄 = Refresh/Rescan
            ("🚮 Clear BeamNG's Vehicle Cache (May help with missing/incorrect textures)", self.delete_beam_vehicle_cache, False),
            ("❌ Close Settings Menu", self.do_nothing, False), # ❌ = Close/Exit


            #("🔧 Rebuild GUI (Experimental)", self.rebuild_gui, False), # leave this commented out
        ]

        print(f"📚 Default Categorization mode: {self.default_categorization_mode} SETTINGS DROPDOWN SEES")
        # --- Create and Pack the Content (Setting Buttons) ---
        # This determines the required size of the dropdown window
        for option_item in settings_options: # Iterate through the modified list
            if len(option_item) == 3:
                # This is a BUTTON item
                option_text, command, is_toggle = option_item # Unpack the button data

                # --- Define Colors for these dropdown items ---
                original_bg = "#555555"
                original_fg = "#FFFFFF"

                # Specific hover colors for these settings options
                settings_item_hover_bg = "#d9d9d9"
                settings_item_hover_fg = "black"

                # --- Button Creation (initial bg/fg will be set by _bind_animated_hover) ---
                dropdown_button = tk.Button(
                    self.settings_dropdown_window, # Ensure this window/frame exists
                    text=option_text,
                    font=("Segoe UI", 10 + self.font_size_add, "bold"),
                    # The command lambda captures the specific command and toggle state for this button
                    command=lambda cmd=command, toggle=is_toggle: on_settings_option_click(cmd, toggle),
                    borderwidth=1,      # Keep specific styling for dropdown items
                    relief="solid",
                    anchor="w",         # Align text to the West (left)
                    padx=10,
                    pady=5

                )

                dropdown_button.config(
                    activebackground=settings_item_hover_bg,
                    activeforeground=settings_item_hover_fg
                )

                dropdown_button.pack(fill="x", padx=2, pady=(1,0)) # Add a little padding

                # --- Apply Smooth Hover Animation using the modified binder ---
                self._bind_animated_hover(
                    button=dropdown_button,
                    original_bg=original_bg,
                    original_fg=original_fg,
                    hover_target_bg=settings_item_hover_bg, # Custom hover BG
                    hover_target_fg=settings_item_hover_fg, # Custom hover FG
                    check_state=False,                      # Assuming these items are not disabled
                    # No selected state needed for these settings options
                    is_selected_initial=False,
                    selected_bg=None,
                    selected_fg=None
                )


            elif len(option_item) == 2:
                marker, separator_name_text = option_item # Unpack the separator data
                if marker == "SEPARATOR":
                    # Create and pack the separator name label
                    separator_label = tk.Label(
                        self.settings_dropdown_window,
                        text=separator_name_text,
                        font=("Segoe UI", 10 + self.font_size_add, "italic"), # Slightly different font
                        fg="#BBBBBB",  # Lighter text color for the separator name
                        bg="#333333",  # Match dropdown background
                        anchor="w",
                        padx=10,
                    )
                    separator_label.pack(fill="x", padx=2, pady=(5, 0)) # pady=(extra_top_space, space_before_line)
                    
                    if self.dev_mode:
                        separator_label.bind("<Button-3>", self.enter_command)

                    # # Create and pack the separator line (a thin Frame)
                    # separator_line = tk.Frame(
                    #     self.settings_dropdown_window,
                    #     height=1,        # Height of the line
                    #     bg="#4A4A4A"     # Color of the line, slightly darker than text, lighter than deepest bg
                    # )
                    # separator_line.pack(fill="x", padx=5, pady=(0, 5)) # pady=(space_after_label, space_after_line)
                
                else:
                    print(f"Warning: Encountered an unknown 2-element item in settings_options: {option_item}")
            else:
                print(f"Warning: Encountered an item with unexpected format in settings_options: {option_item}")



        # --- DYNAMIC POSITIONING - AFTER content is packed ---

        # 1. Force Tkinter to calculate the window size needed for the content
        self.settings_dropdown_window.update_idletasks()

        # 2. Get the actual required width and height of the dropdown
        dropdown_width = self.settings_dropdown_window.winfo_width()
        dropdown_height = self.settings_dropdown_window.winfo_height()

        # 3. Get the trigger button's screen position and width
        button_x = trigger_button.winfo_rootx()
        button_y = trigger_button.winfo_rooty()
        button_width = trigger_button.winfo_width()
        # button_height = trigger_button.winfo_height() # Still not needed for this alignment

        # 4. Calculate the top-left (x, y) for the dropdown window
        # Align right edge: dropdown_x + dropdown_width = button_x + button_width
        dropdown_x = button_x + button_width - dropdown_width
        # Align dropdown bottom to button top: dropdown_y + dropdown_height = button_y
        dropdown_y = button_y - dropdown_height

        # 5. Apply the calculated geometry
        print(f"Calculated Geometry: {dropdown_width}x{dropdown_height}+{dropdown_x}+{dropdown_y}")
        self.settings_dropdown_window.geometry(f"{dropdown_width}x{dropdown_height}+{dropdown_x}+{dropdown_y}")





    def do_nothing(self):
        """
        dummy function that does nothing
        """
        return
        


    def on_settings_button_right_click(self, event):
        """
        This function is called when the settings button is right-clicked.
        It triggers the self.toggle_console() function.
        """
        self.toggle_console()



        self.enable_debug_shortcuts = True

        if self.enable_debug_shortcuts:


            #self.master.bind_all("<Control-y>", lambda event: self.focus_beamng_window()) # <--- ADD THIS LINE

            ### SHORTCUTS START HERE ###
            self.master.bind_all("<Control-j>", lambda event: self.show_hidden_vehicles_window(), add='+') #debug
            self.master.bind_all("<Control-k>", lambda event: self.set_filter_to_view_all_and_turn_subset_off(), add='+') #debug
            self.master.bind_all("<Control-l>", lambda event: self.open_isolated_folder_in_explorer(), add='+') #debug
            self.master.bind_all("<Control-f>", lambda event: self.on_color_picker_replace_or_spawn(), add='+') #debug
            self.master.bind_all("<Control-g>", lambda event: self.color_picker1(), add='+') #debug
            self.master.bind_all("<Control-d>", lambda event: self.manual_gc_collect(), add='+') # Bind Ctrl+G to manual GC
            self.master.bind_all("<Control-s>", lambda event: self.update_grid_layout(), add='+') #debug
            self.master.bind_all("<Control-q>", lambda event: self.perform_search(), add='+') #debug      
            self.master.bind_all("<Control-P>", lambda event: self.destroy_search_results_window(), add='+') #debug
            self.master.bind_all("<Control-h>", lambda event: self.force_clear_all_hover_effects(), add='+')     
            self.master.bind_all("<Control-d>", lambda event: self.hide_sidebar_info(), add='+')
            self.master.bind_all("<Control-x>", lambda event: self.toggle_show_pinned_favorites_category(called_via_shortcut=True), add='+')
            self.master.bind_all("<Control-z>", lambda event: self.show_search_results_window(self.data), add='+')
            #self.master.bind_all("<Control-w>", lambda event: self._move_cursor_away(), add='+')
            #self.master.bind_all("<Control-k>", lambda event: self._restore_cursor(), add='+')
            #self.master.bind_all("<Control-e>", lambda event: self.print_cursor_location(), add='+')
            #self.master.bind_all("<Shift-a>", lambda event: self.show_search_results_window(final_list))




            scanning_win = self.show_scanning_window(text="Debug Shortcuts Activated.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)


        
    def handle_escape_globally(self):
        """
        Handles the Escape key press globally.
        Prioritizes closing/clearing windows in a specific order:
        1. Spawn Queue
        2. Filters
        3. Hidden Window (clear search or withdraw)
        4. Details Window (destroy sub-window, clear search, or close)
        5. Main Search Bar (clear)
        Uses winfo_ismapped() to check for actual visibility.
        """
        print("DEBUG: handle_escape_globally called")

        # 1. Check Spawn Queue Window
        # Use winfo_ismapped() to check if it's actually visible
        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists() and self.spawn_queue_window.winfo_ismapped():
            print("DEBUG: Closing Spawn Queue Window")
            self.spawn_queue_window.destroy()
            return

        # 2. Check Filters Window
        # Use winfo_ismapped()
        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists() and self.filters_window.winfo_ismapped():
            print("DEBUG: Closing Filters Window")
            self.filters_window.destroy()
            return

        # 3. Check Hidden Window
        # Use winfo_ismapped()
        if hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists() and self.hidden_window.winfo_ismapped():
            hidden_search_content = self.hidden_window_search_var.get()
            # Check if search bar has actual text (not empty and not placeholder)
            if hidden_search_content and hidden_search_content != self.placeholder_text:
                print("DEBUG: Clearing Hidden Window search")
                self.hidden_window_search_var.set("")
                self.filter_vehicles()
                # self.on_search_focus_in(event=None) # Call if needed after clearing
            else:
                # Withdraw if search is empty or just placeholder
                print("DEBUG: Withdrawing Hidden Window")
                self.hidden_window.withdraw()
            return # Return after handling hidden window

        # 4. Check Details Window
        # Use winfo_ismapped() instead of relying on self.details_window_closed
        if hasattr(self, 'details_window') and self.details_window and self.details_window.winfo_exists() and self.details_window.winfo_ismapped():
            print("DEBUG: Handling Details Window")

            # 4a. Prioritize closing a specific sub-window if it exists and is mapped
            if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists() and self.current_detail_window.winfo_ismapped():
                print("DEBUG: Destroying current_detail_window")
                self.current_detail_window.destroy()
                self.current_detail_window = None
                # Decide: should pressing Esc again close the main details window?
                # If yes, DON'T return here. If no (one Esc = one action), DO return.
                # Let's assume one action per press for now.
                return

            # 4b. If no active sub-window, check the details search bar
            if self.details_search_var.get():
                print("DEBUG: Clearing details search.")
                self.details_search_var.set("")
                self.perform_details_search()
            else:
                # 4c. If search is empty, close/hide the main details window
                print("DEBUG: Closing/Hiding details window via close_details_window_from_x_button()")
                # Ensure on_details_window_close correctly hides or destroys the window
                self.close_details_window_from_x_button()
            return # Return after handling details window

        # 5. If none of the above windows were active, clear the main search bar (if not empty)
        print("DEBUG: No specific window active.")
        if self.search_var.get():
             print("    handle_escape_globally is calling self.perform_search() - and clearing the search bar")
             print("DEBUG: Clearing main search bar.")
             self.search_var.set("")
             self.perform_search()
        else:
             print("DEBUG: Main search bar already empty.")
        # No return needed here, it's the last step.




    def toggle_middle_click_settings(self):
        """Toggles the 'Double Click to Spawn setting and updates dropdown text."""

        self.middle_click_settings = not self.middle_click_settings
        self.update_settings_dropdown_button_text()
        self.save_settings()


    def toggle_show_folder_settings(self):
        """Toggles the 'Include Without Preview Images' setting and updates dropdown text."""

        #if self.search_results_window:
        #    scanning_win = self.show_scanning_window(text="Cannot adjust this setting while search or filtering is active.")
        #    time.sleep(3.125)
        #    if scanning_win:
        #        scanning_win.destroy()
        #        self.lift_search_results_window()
        #    return 
        

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust this setting while there are pending hidden vehicles.")

            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return




        self.show_folder_settings = not self.show_folder_settings

        if self.search_results_window_on_screen:
            print("  DEBUG: toggle_show_folder_settings ran while Search results window should be on the screen, destroying and recreating it...")
            self.destroy_search_results_window()
                
            print("  DEBUG: creating new search results window.")
            self.search_results_window = self.show_search_results_window(self.data)

            
            print("  DEBUG: setting self.search_results_window_on_screen to True ")
            print(" DEBUG: setting this to true so we can update the grid layout when the search results window closes properly after changing the show folder settings")
            self.window_size_changed_during_search_results_window = True 

        else:
            print("search results window on screen evaluated to false, running update grid layout")


            #self.grouped_data = self.format_grouped_data(self.data) # Re-group and re-sort // why? 


            #self.canvas.yview_moveto(0)
            #print("    toggle_show_folder_settings is calling self.perform_search()")
            #self.perform_search()

            print("    toggle_show_folder_settings is calling self.update_grid_layout()")
            self.update_grid_layout()


        self.canvas.yview_moveto(0)

        #self._update_filters_label_status()



        #self.update_settings_dropdown_button_text() # Call function to update button text
        self.master.after(600, self.show_settings_dropdown)

        self.save_settings() # Save setting to file - ADDED


    def toggle_leave_config_window_open(self):
        """Toggles the 'Jump to page button location' setting and updates dropdown text."""

        self.leave_config_window_open = not self.leave_config_window_open
        
        '''
        if self.dev_mode:

            scanning_win = self.show_scanning_window(text=f"self.leave_config_window_open = {self.leave_config_window_open}", dev_notif=True)
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
                '''

        self.update_settings_dropdown_button_text()
        self.save_settings()




    def toggle_jump_to_page_button_should_be_bottom(self):
        """Toggles the 'Jump to page button location' setting and updates dropdown text."""

        self.jump_to_page_button_should_be_bottom = not self.jump_to_page_button_should_be_bottom
        self.update_settings_dropdown_button_text()
        self.save_settings()




    def toggle_placeholder_settings(self):
        """Toggles the 'Include Without Preview Images' setting and updates dropdown text."""

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot perform this action while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return
        

            


        if os.path.exists(self.cache_file_path):
            try:
                print("deleting config_processing_cache.json")
                os.remove(self.cache_file_path) #
            except OSError as e:
                print(f"Warning: Failed to delete cache file {self.cache_file_path}: {e}")


        self.placeholder_settings = not self.placeholder_settings
        self.update_settings_dropdown_button_text()
        self.save_settings()

        time.sleep(0.1)
        self.on_rescan_all_button_click()



    def _get_font_size_name(self):
            """Returns the string name for the current font size setting."""
            if self.font_size_add == 4:
                return "Large"
            elif self.font_size_add == 2:
                return "Medium"
            else: # Default to "Default" if 0 or any unexpected value
                return "Small"

    def toggle_font_size(self):
        """Cycles through font size settings: Default -> Medium -> Large -> Default."""

        '''
        if self.search_results_window:
            scanning_win = self.show_scanning_window(text="Cannot adjust this setting while search or filtering is active.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.lift_search_results_window()
            return 
            '''

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust this setting while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return
        

        print(f"Toggling font size. Current add value: {self.font_size_add}")
        if self.font_size_add == 0: # Was Default
            self.font_size_add = 2   # Set to Medium
            print("  Set to Medium (2)")
        elif self.font_size_add == 2: # Was Medium
            self.font_size_add = 4   # Set to Large
            print("  Set to Large (4)")
        else: # Was Large (or unexpected), loop back
            self.font_size_add = 0   # Set to Default
            print("  Set to Default (0)")

        self.save_settings() # Save the new setting immediately
        # No need to directly update UI here, the dropdown refresh handles it
        # Returning True signals the click handler to refresh the dropdown
        self.rebuild_gui(changing_scale=True)


        return True # Indicate it was a toggle action that needs refresh


    def toggle_default_categorization_mode(self):
        if self.default_categorization_mode == 'Type':
            self.default_categorization_mode = 'Country'
            print(f"self.default_categorization_mode set to {self.default_categorization_mode}")

        elif self.default_categorization_mode == 'Country':
            self.default_categorization_mode = 'None'
            print(f"self.default_categorization_mode set to {self.default_categorization_mode}")

        elif self.default_categorization_mode == 'None':
            self.default_categorization_mode = 'Type'
            print(f"self.default_categorization_mode set to {self.default_categorization_mode}")

        self.save_settings() # Save the new setting immediately




    def delete_beam_vehicle_cache(self):
        userfolder_root = (os.path.dirname(os.path.dirname(self.script_dir))) # Go up 2 levels (likely 0.35 or something like that)
        folder_path = os.path.join(userfolder_root, "temp") # head to the temp folder
        vehicle_cache_folder_to_delete = os.path.join(folder_path, "vehicles") # vehicles folder to target

        operation_state = None
        if os.path.exists(vehicle_cache_folder_to_delete):
            if os.path.isdir(vehicle_cache_folder_to_delete):
                print(f"Vehicle cache folder found. Proceeding with deletion...")
                try:
                    # Delete the entire directory tree
                    shutil.rmtree(vehicle_cache_folder_to_delete)
                    print(f"Successfully deleted: {vehicle_cache_folder_to_delete}")
                    operation_state = "folder_deleted"
                except OSError as e:
                    # OSError can occur for various reasons (permissions, file in use, etc.)
                    print(f"Error deleting folder '{vehicle_cache_folder_to_delete}': {e}")
                    print(f"OSError deleting vehicle cache: {e}") # Also print to console for dev
                    operation_state = "folder_cannot_be_deleted"
            else:
                print(f"Path '{vehicle_cache_folder_to_delete}' exists but is not a directory. No action taken.")
                print(f"Warning: '{vehicle_cache_folder_to_delete}' is not a directory.")
                operation_state = "folder_is_not_directory"
        else:
            print(f"Vehicle cache folder '{vehicle_cache_folder_to_delete}' does not exist. No action needed.")
            operation_state = "folder_does_not_exist"

            
        if operation_state == "folder_deleted":    
            scanning_win = self.show_scanning_window(text="BeamNG Vehicle Cache Cleared Successfully")

        elif operation_state == "folder_cannot_be_deleted":
            scanning_win = self.show_scanning_window(text="Could not clear BeamNG Vehicle Cache.\n" 
                                                    "Try closing BeamNG first then try again.", medium=True)

        elif operation_state == "folder_is_not_directory":
            scanning_win = self.show_scanning_window(text="Could not clear BeamNG Vehicle Cache")

        elif operation_state == "folder_does_not_exist":
            scanning_win = self.show_scanning_window(text="BeamNG Vehicle Cache already cleared")

        else:
            scanning_win = self.show_scanning_window(text="Could not clear BeamNG Vehicle Cache")

        
        if scanning_win:

            def close_scanning_window():

                scanning_win.destroy()

            scanning_win.after(5125, close_scanning_window)




    def load_settings(self): # add the fav category
        """Loads settings from settings file, including collapse categories by default."""

        print("\n--- load_settings() DEBUG ENTRY ---") # Debug entry

        try:
            if os.path.exists(self.settings_file_path):
                print(f"DEBUG: Settings file exists: {self.settings_file_path}") # Debug - file exists
                with open(self.settings_file_path, "r", encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith("SwitcherPosition:"):
                            try:
                                pos_str = line[len("SwitcherPosition:"):].strip()
                                x_str, y_str = pos_str.strip("()").split(",")
                                x = int(x_str.strip())
                                y = int(y_str.strip())
                                self.floating_window_last_position = (x, y)
                                print(f"Loaded floating window position from file: {self.floating_window_last_position}") # Debug
                            except ValueError:
                                print("Warning: Invalid SwitcherPosition format in settings file.")
                        elif line.startswith("ShowSwitcherOnStartup:"):
                            value_str = line[len("ShowSwitcherOnStartup:"):].strip().lower()
                            print(f"DEBUG: ShowSwitcherOnStartup line found, value_str: '{value_str}'") # Debug - value_str
                            if value_str == "on":
                                self.show_switcher_on_startup = True
                            elif value_str == "off":
                                self.show_switcher_on_startup = False
                            else:
                                print(f"Warning: Invalid ShowSwitcherOnStartup value: '{value_str}'. Using default.")
                        elif line.startswith("SortByInstallDate:"):
                            value_str = line[len("SortByInstallDate:"):].strip().lower()
                            print(f"DEBUG: SortByInstallDate line found, value_str: '{value_str}'") # Debug - value_str for sort date
                            if value_str == "on":
                                self.sort_by_install_date = True
                            elif value_str == "off":
                                self.sort_by_install_date = False
                            else:
                                print(f"Warning: Invalid SortByInstallDate value: '{value_str}'. Using default.")
                        elif line.startswith("CollapseCategoriesByDefault:"):
                            value_str = line[len("CollapseCategoriesByDefault:"):].strip().lower()
                            print(f"DEBUG: CollapseCategoriesByDefault line found, value_str: '{value_str}'") # Debug - value_str for collapse categories
                            if value_str == "on":
                                self.collapse_categories_by_default = True
                            elif value_str == "off":
                                self.collapse_categories_by_default = False
                            else:
                                print(f"Warning: Invalid CollapseCategoriesByDefault value: '{value_str}'. Using default.")

                        # --- NEW: Load Include No Preview Images Setting ---
                        elif line.startswith("PlaceholderSetting:"):
                            value_str = line[len("PlaceholderSetting:"):].strip().lower()
                            print(f"DEBUG: IncludeNoPreviewImages line found, value_str: '{value_str}'") # Debug - value_str for placeholder_settings
                            if value_str == "on":
                                self.placeholder_settings = True
                            elif value_str == "off":
                                self.placeholder_settings = False
                            else:
                                print(f"Warning: Invalid IncludeNoPreviewImages value: '{value_str}'. Using default.")
                        # --- NEW: Load Include No Preview Images Setting ---


                        elif line.startswith("middle_click_settings:"):
                            value_str = line[len("middle_click_settings:"):].strip().lower()
                            print(f"DEBUG: middle_click_settings line found, value_str: '{value_str}'")
                            if value_str == "on":
                                self.middle_click_settings = True
                            elif value_str == "off":
                                self.middle_click_settings = False
                            else:
                                print(f"Warning: Invalid middle_click_settings value: '{value_str}'. Using default.")

                        elif line.startswith("show_folder_settings:"):
                            value_str = line[len("show_folder_settings:"):].strip().lower()
                            print(f"DEBUG: show_folder_settings line found, value_str: '{value_str}'")
                            if value_str == "on":
                                self.show_folder_settings = True
                            elif value_str == "off":
                                self.show_folder_settings = False
                            else:
                                print(f"Warning: Invalid show_folder_settings value: '{value_str}'. Using default.")

                        elif line.startswith("jump_to_page_button_should_be_bottom:"):
                            value_str = line[len("jump_to_page_button_should_be_bottom:"):].strip().lower()
                            print(f"DEBUG: jump_to_page_button_should_be_bottom, value_str: '{value_str}'") 
                            if value_str == "on":
                                self.jump_to_page_button_should_be_bottom = True
                            elif value_str == "off":
                                self.jump_to_page_button_should_be_bottom = False
                            else:
                                print(f"Warning: Invalid jump_to_page_button_should_be_bottom value: '{value_str}'. Using default.")

                        elif line.startswith("leave_config_window_open:"):
                            value_str = line[len("leave_config_window_open:"):].strip().lower()
                            print(f"DEBUG: leave_config_window_open, value_str: '{value_str}'") 
                            if value_str == "on":
                                self.leave_config_window_open = True
                            elif value_str == "off":
                                self.leave_config_window_open = False
                            else:
                                print(f"Warning: Invalid leave_config_window_open value: '{value_str}'. Using default.")

                        elif line.startswith("show_pinned_favorites_category:"):
                            value_str = line[len("show_pinned_favorites_category:"):].strip().lower()
                            print(f"DEBUG: show_pinned_favorites_category, value_str: '{value_str}'")
                            if value_str == "on":
                                self.show_pinned_favorites_category = True
                            elif value_str == "off":
                                self.show_pinned_favorites_category = False
                            else:
                                print(f"Warning: Invalid self.show_pinned_favorites_category: '{value_str}'. Using default.")


                        elif line.startswith("FontSizeAdd:"): 
                            value_str = line[len("FontSizeAdd:"):].strip() # Added: Extract the value part
                            print(f"DEBUG: FontSizeAdd line found, value_str: '{value_str}'") # Optional: Add debug print here too
                            try:
                                loaded_size = int(value_str)

                                if loaded_size in [0, 2, 4]: # Your original check
                                    self.font_size_add = loaded_size
                                    print(f"  Loaded font size add value: {self.font_size_add}")
                                #else:
                                    #print(f"  Warning: Invalid FontSizeAdd value: '{value_str}'. Using default ({default_font_size_add}).")
                                    #self.font_size_add = default_font_size_add # Use the defined default
                            except ValueError:
                                print(f"  Warning: Invalid FontSizeAdd format: '{value_str}'. Using default ({self.font_size_add}).")
                                #self.font_size_add = default_font_size_add # Use the defined default


                        elif line.startswith("default_categorization_mode:"): 
                            self.default_categorization_mode = line[len("default_categorization_mode:"):].strip() 
                            print(f"DEBUG: default_categorization_mode line found, '{self.default_categorization_mode}'") # Optional: Add debug print here too
                            try:

                                    self.categorization_mode = self.default_categorization_mode
                                    print(f"  Loaded default_categorization_mode value: {self.categorization_mode}")

                            except Exception as e:
                                print(f"  Warning: Could not load default categorization mode from file: '{self.default_categorization_mode}'. Using default cat mode ({self.categorization_mode}).")




                        else:
                            pass # Keep this for lines that don't match any setting
            else:
                print(f"DEBUG: Settings file DOES NOT exist: {self.settings_file_path}") # Debug - file does not exist

        except Exception as e:
            print(f"Error loading floating window position and settings: {e}")


      
        

    def save_settings(self):
        """Saves settings to settings file, including collapse categories by default."""

        try:
            with open(self.settings_file_path, "w", encoding="utf-8") as f:
                f.write(f"SwitcherPosition: {self.floating_window_last_position}\n")
                f.write(f"ShowSwitcherOnStartup: {'on' if self.show_switcher_on_startup else 'off'}\n")
                f.write(f"SortByInstallDate: {'on' if self.sort_by_install_date else 'off'}\n")
                f.write(f"CollapseCategoriesByDefault: {'on' if self.collapse_categories_by_default else 'off'}\n")
                f.write(f"PlaceholderSetting: {'on' if self.placeholder_settings else 'off'}\n")
                f.write(f"middle_click_settings: {'on' if self.middle_click_settings else 'off'}\n")
                f.write(f"show_folder_settings: {'on' if self.show_folder_settings else 'off'}\n")
                f.write(f"jump_to_page_button_should_be_bottom: {'on' if self.jump_to_page_button_should_be_bottom else 'off'}\n")
                f.write(f"leave_config_window_open: {'on' if self.leave_config_window_open else 'off'}\n")
                f.write(f"show_pinned_favorites_category: {'on' if self.show_pinned_favorites_category else 'off'}\n")
                f.write(f"default_categorization_mode: {self.default_categorization_mode}\n")
                f.write(f"FontSizeAdd: {self.font_size_add}\n")

                if self.items_to_be_hidden or self.unhide_was_toggled_in_hidden_window:
                    print("--- self.items_to_be_hidden or self.unhide_was_toggled_in_hidden_window are True, deleting config_processing_cache.json---\n")



                    if os.path.exists(self.cache_file_path):
                        try:
                            os.remove(self.cache_file_path) #
                        except OSError as e:
                            print(f"Warning: Failed to delete cache file {self.cache_file_path}: {e}")


        except Exception as e:
            print(f"Error saving floating window position and settings: {e}")






    def toggle_show_switcher_on_startup(self):
        """Toggles the 'Show Switcher On Startup' setting and updates dropdown text."""
        print(f"toggle_show_switcher_on_startup - BEFORE toggle: self.show_switcher_on_startup = {self.show_switcher_on_startup}") # Debugging print
        self.show_switcher_on_startup = not self.show_switcher_on_startup
        print(f"toggle_show_switcher_on_startup - AFTER toggle: self.show_switcher_on_startup = {self.show_switcher_on_startup}") # Debugging print
        self.update_settings_dropdown_button_text() # Update dropdown text
        self.save_settings() # Save setting to file - MODIFIED to call save_settings
        
        

    def destroy_settings_dropdown(self):
        self.is_search_results_window_closing = True # <--- SET FLAG BEFORE DESTROY
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            self.settings_dropdown_window.destroy()
            self.settings_dropdown_window = None
        self.is_search_results_window_closing = False # <--- RESET FLAG AFTER DESTROY


    def create_item_count_label(self, bottom_frame):
        self.item_count_label = tk.Label(bottom_frame, text="", bg="#333333", fg="#d9d9d9", font=("Segoe UI", 12+self.font_size_add)) # Dark bg, lightgrey fg
        self.item_count_label.pack(side="right", padx=(10, 10))

    def setup_main_frame(self):
        # Creates AND assigns the main frame
        # Ensure this frame uses self.master as its parent
        frame = tk.Frame(self.master, bg="#333333")
        frame.pack(fill="both", expand=True)
        self.main_frame = frame # Assign to self.main_frame
        # NOTE: The content (canvas, sidebar) is created by subsequent setup calls
        # which should use self.main_frame as their parent

    def setup_canvas_and_scrollbar(self):
        # Main grid Canvas
        self.canvas = tk.Canvas(self.main_frame, bg="#444444", highlightthickness=0, yscrollincrement=10)
        self.canvas.configure(yscrollcommand=self.custom_scrollbar_set)

        # Custom Scrollbar Canvas - NO PACKING HERE INITIALLY
        self.custom_scrollbar_canvas = tk.Canvas(self.main_frame, bg="#555555", highlightthickness=0, width=15)
        self.scrollbar_thumb = self.custom_scrollbar_canvas.create_rectangle(0, 0, 15, 20, fill=self.global_highlight_color, outline="")
        self.scrollbar_thumb_dragging = False
        self.scrollbar_thumb_start_y = 0
        self.scrollbar_mouse_start_y = 0

        self.custom_scrollbar_canvas.bind("<ButtonPress-1>", self.custom_scrollbar_click)
        self.custom_scrollbar_canvas.bind("<B1-Motion>", self.custom_scrollbar_drag)
        self.custom_scrollbar_canvas.bind("<ButtonRelease-1>", self.custom_scrollbar_release)


        self.canvas.pack(side="left", fill="both", expand=True) # Canvas takes up most space

        # Place the scrollbar using 'place' for absolute positioning BEHIND sidebar
        self.custom_scrollbar_canvas.place(relx=1.0, rely=0.0, anchor='ne', relheight=1.0, x=-310, bordermode="inside") # Position 330px from right edge


        # Initialize scrollbar to canvas link - needed for initial setup
        self.canvas.configure(yscrollcommand=self.custom_scrollbar_set)
  

  
    def setup_scrollable_frame(self):
        """Sets up the scrollable frame with a darker gray background."""
        self.scrollable_frame = tk.Frame(self.canvas, bg="#444444") # <--- DARKER GRAY BACKGROUND for scrollable_frame
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")



        
    def setup_sidebar_frame(self):
        print("--- DEBUG: ENTERING setup_sidebar_frame ---")

        
        self.sidebar_frame = tk.Frame(self.main_frame, width=300, highlightthickness=1, highlightbackground="#333333", bg="#333333") # Changed sidebar_frame bg to "#333333" - MATCH TOP HALF - CHANGED BACK TO "#333333"
        print(f"DEBUG: Created self.sidebar_frame. Parent is: {self.sidebar_frame.master}") # ADD THIS

        self.sidebar_frame.pack(side="right", fill="y", padx=(10, 0), pady=10,  expand=False,  )
        self.sidebar_frame.pack_propagate(False) # Prevent sidebar from resizing to content

        # Split sidebar into top and bottom halves - WITH background colors
        self.sidebar_top_frame = tk.Frame(self.sidebar_frame, bg="#333333", highlightthickness=0) # Top half for car info -  Keep at "#333333"
        self.sidebar_bottom_frame = tk.Frame(self.sidebar_frame, bg="#333333", highlightthickness=0) # Bottom half for filters label - CHANGED to MATCH TOP HALF - "#333333" - NOW MATCHES TOP HALF

        # --- MODIFIED PACKING ORDER - REVERSED TOP AND BOTTOM FRAMES ---
        self.sidebar_bottom_frame.pack(side="top", fill="x", expand=False, padx=0, pady=0) #  sidebar_bottom_frame (Constraints) packed FIRST at the TOP
        self.sidebar_top_frame.pack(side="bottom", fill="both", expand=True, padx=0, pady=0) # sidebar_top_frame (Car Info) packed SECOND below it, side=BOTTOM
        # --- MODIFIED PACKING ORDER ---
        print("--- DEBUG: EXITING setup_sidebar_frame ---") 




    def setup_sidebar_top_frame_content(self):


        #if self.hide_main_grid_and_sidebar_start_passed == 1: # Set the flag for subsequent calls - if startup has not passed  (false) 
        #    return  # Exit function early on first call


        sidebar_padding = 10
        self.sidebar_car_name_label = tk.Label(self.sidebar_top_frame, text="", font=("Segoe UI", 14+self.font_size_add, "bold"), bg="#333333", fg="lightgrey", wraplength=280, justify="center") # Dark bg, lightgrey fg
        self.sidebar_car_name_label.pack(in_=self.sidebar_top_frame, pady=(sidebar_padding*2, sidebar_padding), padx=sidebar_padding)

        # Placeholder image for sidebar - CHANGED placeholder to MATCH sidebar_top_frame BG COLOR - "#333333"
        placeholder_image = Image.new("RGB", (280, 150), "#333333") # CHANGED to "#333333" - MATCH sidebar_top_frame BG COLOR
        placeholder_photo = ImageTk.PhotoImage(placeholder_image)
        self.sidebar_image_label = tk.Label(self.sidebar_top_frame, image=placeholder_photo, bg="#333333") # Dark bg
        self.sidebar_image_label.image = placeholder_photo
        self.sidebar_image_label.pack(in_=self.sidebar_top_frame, pady=(0, sidebar_padding), padx=sidebar_padding)

        # Sidebar Loading Label
        self.sidebar_loading_label = tk.Label(self.sidebar_top_frame, text="Loading...", font=("Segoe UI", 10+self.font_size_add, "italic"), fg=self.global_highlight_color, bg="#333333") # Dark bg, orange fg
        self.sidebar_loading_label.pack(in_=self.sidebar_top_frame, pady=(0, sidebar_padding), padx=sidebar_padding)
        self.sidebar_loading_label.pack_forget()

        self.create_sidebar_info_labels(self.sidebar_top_frame, sidebar_padding)
        self.create_sidebar_zip_name_label(self.sidebar_top_frame, sidebar_padding)

    def setup_sidebar_bottom_frame_content(self):



        sidebar_padding = 10
        # Calculate the maximum width for the text itself, considering padding
        # Assuming the sidebar_bottom_frame is roughly 300px wide from its definition
        # or slightly less due to the main sidebar frame's padding/border.
        # Let's target slightly less than 300 to be safe, e.g., 280px for the text width.
        max_text_width = 280 # Adjust this value as needed

        self.sidebar_filters_label = tk.Label(
            self.sidebar_bottom_frame,
            text="Constraints",
            font=("Segoe UI", 14+self.font_size_add, "bold"),
            bg="#333333",
            fg="#FFFFFF",
            justify="center", 
            wraplength=max_text_width # Set maximum line length in pixels
        )
        self.sidebar_filters_label.pack(
            in_=self.sidebar_bottom_frame,
            side="top",
            fill="x", # Still fill horizontally to use available space
            pady=(sidebar_padding*2, sidebar_padding),
            padx=sidebar_padding
        )

        self.create_sidebar_filter_dropdowns(self.sidebar_bottom_frame, sidebar_padding)
        



    def create_sidebar_info_labels(self, sidebar_top_frame, sidebar_padding): # Modified to include Author labels
        info_font = ("Segoe UI", 11+self.font_size_add, "italic") # Smaller font for info labels
        category_font = ("Segoe UI", 11+self.font_size_add, "bold") # Smaller font for category labels

        self.sidebar_brand_label = tk.Label(sidebar_top_frame, text="", font=category_font, bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.sidebar_brand_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_brand_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_brand_info_label.config(text="")
        self.sidebar_brand_info_label.pack_forget()

        self.sidebar_description_label = tk.Label(sidebar_top_frame, text="", font=category_font, bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.sidebar_description_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_description_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_description_info_label.config(text="")
        self.sidebar_description_info_label.pack_forget()

        self.sidebar_slogan_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_slogan_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_slogan_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_slogan_info_label.config(text="")
        self.sidebar_slogan_info_label.pack_forget()

        self.sidebar_country_label = tk.Label(sidebar_top_frame, text="", font=category_font, bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.sidebar_country_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_country_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_country_info_label.config(text="")
        self.sidebar_country_info_label.pack_forget()

        self.sidebar_derbyclass_label = tk.Label(sidebar_top_frame, text="", font=category_font, bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.sidebar_derbyclass_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_derbyclass_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_derbyclass_info_label.config(text="")
        self.sidebar_derbyclass_info_label.pack_forget()

        # --- NEW: Author Labels ---
        self.sidebar_author_label = tk.Label(sidebar_top_frame, text="", font=category_font, bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.sidebar_author_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_author_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_author_info_label.config(text="")
        self.sidebar_author_info_label.pack_forget()
        # --- NEW: Author Labels ---

    def create_sidebar_zip_name_label(self, sidebar_top_frame, sidebar_padding):
        # Sidebar Zip Name Label (at the bottom of top frame)
        self.sidebar_zip_name_label = tk.Label(sidebar_top_frame, text="", font=("Segoe UI", 10+self.font_size_add), bg="#333333", fg="lightgrey", wraplength=280, justify="center") # Dark bg, lightgrey fg
        self.sidebar_zip_name_label.config(text="") # Set to "" initially - ENSURE IT IS ""
        self.sidebar_zip_name_label.pack(in_=sidebar_top_frame, side="bottom", pady=sidebar_padding, padx=sidebar_padding)

    def setup_sidebar_bottom_frame(self): # MOVED TO THE TOP, THIS IS THE TOP SECTION OF THE SIDEBAR, DO NOT REMOVE THIS COMMENT
        # Sidebar Frame (Main Grid) - CONTAINER FRAME - NO BG COLOR
        self.sidebar_frame = tk.Frame(self.main_frame, width=300, highlightthickness=1, highlightbackground=self.global_highlight_color, bg="#333333")
        self.sidebar_frame.pack(side="right", fill="y", padx=(10, 0), pady=10,  expand=False,  )
        self.sidebar_frame.pack_propagate(False) # Prevent sidebar from resizing to content

        # Split sidebar into top and bottom halves - WITH background colors
        self.sidebar_top_frame = tk.Frame(self.sidebar_frame, bg="#333333", highlightthickness=0) # Top half for car info
        self.sidebar_bottom_frame = tk.Frame(self.sidebar_frame, bg="#222222", highlightthickness=0) # Bottom half for filters label - DARKER bg - CORRECT BG COLOR HERE

        # --- MODIFIED PACKING ORDER - REVERSED TOP AND BOTTOM FRAMES ---
        self.sidebar_bottom_frame.pack(side="top", fill="x", expand=False, padx=0, pady=0) #  sidebar_bottom_frame (Constraints) packed FIRST at the TOP
        self.sidebar_top_frame.pack(side="bottom", fill="both", expand=True, padx=0, pady=0) # sidebar_top_frame (Car Info) packed SECOND below it, side=BOTTOM
        # --- MODIFIED PACKING ORDER ---



    def _update_filters_label_status(self):
        """
        Checks the status of filter buttons and updates the "Filters" label accordingly.
        If any filter is active (not "All..."), the label turns orange and shows "(Active)".
        Otherwise, it reverts to the default style.
        MODIFIED to disable sidebar filter buttons under certain conditions. <----- ADDED
        """
        self.all_filters_all = True  # Assume all filters are "All..." initially
        filter_buttons = self.sidebar_filter_buttons

        # --- MODIFIED: Check conditions to disable sidebar filter buttons ---
        disable_sidebar_filters = False
        if self.is_data_subset_active: # Condition 1: Data Subset Active
            disable_sidebar_filters = True
        elif self.filter_state != 0: # Condition 2: Not View All or Favorites
            disable_sidebar_filters = True

        if disable_sidebar_filters:
            print("DEBUG: _update_filters_label_status - Disabling sidebar filter buttons (Subset Active OR Not View All/Favorites).") # Debug
            for filter_name in filter_buttons:
                button = filter_buttons[filter_name]
                button.config(state=tk.DISABLED, fg="grey") # Disable and grey out
        else:
            print("DEBUG: _update_filters_label_status - Enabling sidebar filter buttons.") # Debug
            for filter_name in filter_buttons:
                button = filter_buttons[filter_name]
                button.config(state=tk.NORMAL, fg="#FFFFFF") # Enable and set text color back to white
        # --- MODIFIED: Check conditions to disable sidebar filter buttons ---


        if filter_buttons["Brand"].cget("text") != "All Brands":
            self.all_filters_all = False
        if filter_buttons["Name"].cget("text") != "All Names":
            self.all_filters_all = False
        if filter_buttons["Country"].cget("text") != "All Countries":
            self.all_filters_all = False
        if filter_buttons["Bodystyle"].cget("text") != "All BodyStyles":
            self.all_filters_all = False

        if self.all_filters_all:
            self.sidebar_filters_label.config(fg="#FFFFFF", text="Constraints") # Default color and text

            # --- MODIFICATION START: Conditionally close Search Results window when Constraints become inactive ---
            if self.filter_state == 0 and not self.search_var.get().strip() and not self.is_data_subset_active: # Check for View All, empty search, and no global filters
                if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
                    self.destroy_search_results_window()
                    self.search_results_window = None
                    self.is_search_results_window_active = False

                    #if self.window_was_resized_2:
                    #    self.master.after(5000, self.update_grid_layout)
                    #    self.window_was_resized_2 = False
                    print("DEBUG: _update_filters_label_status - Search Results window DESTROYED because Constraints are inactive AND View All + Empty Search + No Global Filters.")
                else:
                    print("DEBUG: _update_filters_label_status - Search Results window NOT open, no need to destroy (Constraints inactive AND View All + Empty Search + No Global Filters).") # Debug - Window Not Open
            # --- MODIFICATION END: Conditionally close Search Results window when Constraints become inactive ---


        else:
            # --- MODIFICATION START: Open Search Results Window before setting label to "(Active)" ---
            if not hasattr(self, 'search_results_window') or not self.search_results_window or not self.search_results_window.winfo_exists():
                self.search_results_window = self.show_search_results_window(self.data) # Pass current data
                print("DEBUG: _update_filters_label_status - Search Results window CREATED because Constraints are becoming active.")
            self.search_results_window.lift() # Ensure it's visible
            self.is_search_results_window_active = True
            print("DEBUG: _update_filters_label_status - Search Results window LIFTED because Constraints are becoming active.")
            # --- MODIFICATION END: Open Search Results Window before setting label to "(Active)" ---

            self.sidebar_filters_label.config(fg=self.global_highlight_color, text="Constraints (Active)") # Keep orange for active state
 

        
 

    def _create_filter_dropdown_frame(self, sidebar_bottom_frame, sidebar_padding):
        """
        Creates the frame to hold filter dropdown elements.
        """
        sidebar_filter_dropdowns_frame = tk.Frame(sidebar_bottom_frame, bg="#333333")  # Frame for dropdowns - CHANGED to "#333333" - MATCH TOP HALF
        sidebar_filter_dropdowns_frame.pack(side="top", fill="x", padx=sidebar_padding, pady=(0, sidebar_padding))
        return sidebar_filter_dropdowns_frame


    def _add_filter_dropdown_elements(self, dropdown_frame, filter_options_data):
        """
        Adds labels and buttons (acting as dropdowns) for each filter option to the frame,
        WITH smooth hover animation and INSTANT visual reset on click.
        """
        dropdown_row = 0
        dropdown_col = 0
        self.sidebar_filter_buttons = {}

        # --- Define Colors & Styles ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF"
        active_bg = "#666666"
        active_fg = "#FFFFFF"

        button_style_args_constraints = {
            "bg": original_bg, "fg": original_fg, "relief": tk.FLAT, "bd": 0,
            "highlightthickness": 0, "highlightbackground": original_bg,
            "activebackground": active_bg, "activeforeground": active_fg
            # Font applied directly below
        }

        for filter_name, options in filter_options_data.items():
            # --- Label Creation (Unchanged) ---
            label = tk.Label(dropdown_frame, text=f"{filter_name}:", font=("Segoe UI", 11+self.font_size_add, "bold"), bg="#333333", fg="#d9d9d9", anchor="w")
            label.grid(row=dropdown_row, column=dropdown_col, sticky="w", padx=(0, 5), pady=(2, 5))

            # --- Get the actual command method dynamically ---
            # It's crucial to get the method itself, not call it yet
            try:
                original_command_func = getattr(self, f"show_sidebar_{filter_name.lower()}_dropdown")
            except AttributeError:
                print(f"Error: Method show_sidebar_{filter_name.lower()}_dropdown not found!")
                # Assign a dummy command to prevent errors
                original_command_func = lambda: print(f"Missing command for {filter_name}")

            # --- Create the Button (WITHOUT command initially) ---
            button = tk.Button(
                dropdown_frame,
                text=options[0],
                font=("Segoe UI", 10+self.font_size_add),
                # command= set below using the wrapper
                width=12,
                **button_style_args_constraints
            )
            button.grid(row=dropdown_row, column=dropdown_col+1, sticky="ew", padx=(0, 5), pady=(2, 5))

            # --- Define the Command Wrapper ---
            # This function will run when the button is clicked
            def command_wrapper(btn=button, cmd=original_command_func, bg=original_bg, fg=original_fg):
                try:
                    # 1. Reset Appearance IMMEDIATELY
                    if btn.winfo_exists() and btn['state'] == tk.NORMAL:
                        # Instantly set foreground back
                        btn.config(fg=fg)
                        # Start animation back to original background
                        # This cancels any highlight animation and starts the revert
                        self._start_animation(btn, properties_to_animate={'bg':'original_bg', 'fg':'original_fg'})
                except tk.TclError:
                    pass # Widget might be gone

                # 2. Execute the Original Command Function
                cmd() # Call the saved original command (e.g., self.show_sidebar_category_dropdown)

            # --- Assign the Wrapper to the Button's Command ---
            button.config(command=command_wrapper)

            # --- Apply Smooth Hover Animation (Still needed for Enter/Leave) ---
            self._bind_animated_hover(
                button=button,
                original_bg=original_bg,
                original_fg=original_fg,
                hover_target_fg=hover_fg,
                check_state=True # Still check state for hover effects
            )

            # --- Storing Reference (Unchanged) ---
            self.sidebar_filter_buttons[filter_name] = button

            dropdown_row += 1


            

    def _configure_filter_dropdown_frame_layout(self, dropdown_frame):
        """
        Configures the column layout of the filter dropdown frame to allow expansion.
        Now configures TWO columns, one for label, one for button.
        """
        dropdown_frame.columnconfigure(1, weight=1)  # Ensure button column (column 1) expands


    def create_sidebar_filter_dropdowns(self, sidebar_bottom_frame, sidebar_padding):
        """
        Creates and configures filter dropdowns in the sidebar.
        """
        self.sidebar_filter_dropdowns_frame = self._create_filter_dropdown_frame(sidebar_bottom_frame, sidebar_padding)

        # --- MODIFIED: Filter options data WITHOUT Type and Author, and IN DESIRED ORDER for single column ---
        filter_options_data = {
            "Brand": ["All Brands"] + self.get_unique_brands(),
            "Name": ["All Names"] + self.get_unique_names(),  # Use dynamic name list here
            "Country": ["All Countries"] + self.get_unique_countries(), # NEW: Country options
            "Bodystyle": ["All BodyStyles"] + self.get_unique_body_styles(),  # NEW: Body Style options
            # "Author": ["All Authors", "Author 1", "Author 2"], # REMOVED Author
            # "Type": ["All Types", "Type 1", "Type 2"] # REMOVED Type
        }
        # --- MODIFIED: Filter options data WITHOUT Type and Author, and IN DESIRED ORDER for single column ---

        self._add_filter_dropdown_elements(self.sidebar_filter_dropdowns_frame, filter_options_data)

        self._configure_filter_dropdown_frame_layout(self.sidebar_filter_dropdowns_frame)



    def show_sidebar_brand_dropdown(self):
        self._show_sidebar_filter_dropdown("Brand", self.sidebar_filter_buttons["Brand"])



    def _filter_dropdown_options(self, search_text, original_options):
        """Filters dropdown options based on search text."""
        filtered_options = []
        for option in original_options:
            if search_text in option.lower():
                filtered_options.append(option)
        return filtered_options

    def _clear_dropdown_options(self, scrollable_frame):
        """Clears all widgets within the scrollable frame except the search entry."""
        widgets_to_destroy = []
        for widget in scrollable_frame.winfo_children():
            if not isinstance(widget, tk.Entry):
                widgets_to_destroy.append(widget)
        for widget in widgets_to_destroy:
            widget.destroy()
        scrollable_frame.update_idletasks() # Force update after destroy


    def _create_dropdown_option_buttons(self, scrollable_frame, current_options, button, dropdown_window):
        """Creates and packs option buttons in the scrollable frame with smooth hover."""
        # This function is very similar to _create_bodystyle_option_buttons and _create_country_option_buttons
        # The main difference is the command called (_on_name_dropdown_button_click)

        # --- Define Colors ---
        default_bg_color = "#555555"    # Normal, non-selected background
        default_fg_color = "#FFFFFF"    # Normal, non-selected foreground

        selected_option_bg = self.global_highlight_color # Background for the currently "selected" option
        selected_option_fg = "#FFFFFF"                   # Foreground for the "selected" option

        # Specific hover colors for these dropdown items
        dropdown_item_hover_bg = "#d9d9d9"
        dropdown_item_hover_fg = "black"

        # Get the text of the main button that opened this dropdown, to determine current selection
        current_main_button_text = button.cget("text")

        # Store references to the created buttons if the click handler needs to update them all
        created_buttons_list = [] # Example

        for option in current_options:
            # --- Determine if this option is currently selected ---
            is_selected = (option == current_main_button_text)

            # --- Button Creation ---
            # Initial bg/fg will be set by _bind_animated_hover based on is_selected
            dropdown_option_button = tk.Button( # Renamed for clarity
                scrollable_frame,
                text=option,
                font=("Segoe UI", 10 + self.font_size_add, "bold"),
                # The command lambda captures necessary arguments for the click handler
                command=lambda opt=option, main_btn=button, dd_win=dropdown_window: \
                    self._on_name_dropdown_button_click(opt, fname="name", fbutton=main_btn, fdropdown_window=dd_win),
                borderwidth=1,      # Keep specific styling
                relief="solid",
                anchor="w",
                padx=10,
                pady=2,
                width=240 # If you need fixed width, keep it.
                # bg and fg are now set by _bind_animated_hover
            )
            # Set active colors (for instant click flash) - optional
            dropdown_option_button.config(
                activebackground=dropdown_item_hover_bg,
                activeforeground=dropdown_item_hover_fg
            )
            # Apply fixed width if desired (as in original)
            dropdown_option_button.config(width=240)


            dropdown_option_button.pack(fill="x")
            created_buttons_list.append(dropdown_option_button)

            # --- Apply Smooth Hover Animation using the modified binder ---
            self._bind_animated_hover(
                button=dropdown_option_button,
                original_bg=default_bg_color,       # The "true" original, non-selected bg
                original_fg=default_fg_color,       # The "true" original, non-selected fg
                hover_target_bg=dropdown_item_hover_bg, # Custom hover BG for these items
                hover_target_fg=dropdown_item_hover_fg, # Custom hover FG for these items
                check_state=False,                    # Assuming these are not individually disabled
                is_selected_initial=is_selected,      # Is this button initially "selected"?
                selected_bg=selected_option_bg,       # Color if selected
                selected_fg=selected_option_fg        # Color if selected
            )


    def _on_name_dropdown_button_click(self, option_text, fname, fbutton, fdropdown_window):
        """Handles the button click event in the Name dropdown., added search window update."""
        print("    DEBUG: _on_name_dropdown_button_click() START")
        fbutton.config(text=option_text)
        self._filter_data_by_name(option_text)
        bodystyle_button = self.sidebar_filter_buttons.get("Bodystyle")
        if bodystyle_button:
            bodystyle_button.config(text="All BodyStyles")
        country_button = self.sidebar_filter_buttons.get("Country")
        if country_button:
            country_button.config(text="All Countries")

        self._update_ui_elements(fdropdown_window)
        self._update_filters_label_status()
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE
        print("    DEBUG: _on_name_dropdown_button_click() END")



    def _update_name_dropdown_options(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Updates the options displayed in the Name dropdown based on search input."""
        print("    DEBUG: _update_name_dropdown_options() START") # Debug

        search_text = search_var.get().strip().lower()
        filtered_options = self._filter_dropdown_options(search_text, original_options) # 1. Filter options

        # --- DEBUGGING: Inspect children BEFORE destruction ---
        print("    DEBUG: update_dropdown_options - --- BEFORE DESTROY ---")
        print("    DEBUG: update_dropdown_options - scrollable_frame children COUNT:", len(scrollable_frame.winfo_children()))
        for i, child in enumerate(scrollable_frame.winfo_children()):
            print(f"      DEBUG: Child {i}: Widget Class: {type(child)}, Widget Name: {child.winfo_name()}")

        self._clear_dropdown_options(scrollable_frame) # 2. Clear existing options

        # --- DEBUGGING: Inspect children AFTER destruction ---
        print("    DEBUG: update_dropdown_options - --- AFTER DESTROY ---")
        print("    DEBUG: update_dropdown_options - scrollable_frame children COUNT:", len(scrollable_frame.winfo_children()))
        for i, child in enumerate(scrollable_frame.winfo_children()):
            print(f"      DEBUG: Child {i}: Widget Class: {type(child)}, Widget Name: {child.winfo_name()}")


        # --- DEBUG PRINT: Check if search_entry still exists ---
        search_entry_exists = False
        for child in scrollable_frame.winfo_children():
            if isinstance(child, tk.Entry):
                search_entry_exists = True
                break
        print(f"    DEBUG: update_dropdown_options - search_entry EXISTS after destroy:", search_entry_exists) # Debug - Search Entry Check

        self._create_dropdown_option_buttons(scrollable_frame, filtered_options, button, dropdown_window) # 3. Create new option buttons


        canvas.config(scrollregion=canvas.bbox("all"))
        # --- DEBUG PRINT: End of update_dropdown_options ---
        print("    DEBUG: update_dropdown_options - current_options after update:", filtered_options) # Debug
        print("    DEBUG: _update_name_dropdown_options() END") # Debug


    def _get_dynamic_name_options(self):
        """Helper function to get dynamic name options based on selected brand."""
        brand_button = self.sidebar_filter_buttons.get("Brand")
        selected_brand = brand_button.cget("text") if brand_button else "All Brands"
        dynamic_name_options = ["All Names"] + self.get_unique_names(selected_brand)
        print("  DEBUG: dynamic_name_options after get_unique_names():", dynamic_name_options)  # Debug
        return dynamic_name_options



    def _filter_data_by_name(self, option_text):
        """Filters the displayed data by name, respecting the main search query and other filters. - MODIFIED to maintain query context and use data_cache"""
        filtered_data = []
        # --- MODIFIED: Start filtering from data_cache ALWAYS ---
        data_to_filter = list(self.data_cache) # Start with cached data

        # --- Apply main search query filter ---
        query = self.search_var.get().strip().lower()
        if query:
            query_filtered_data = []
            for item in data_to_filter:
                if self._perform_item_search(query, item):
                    query_filtered_data.append(item)
            data_to_filter = query_filtered_data # Use query-filtered data for further filtering
        # --- Apply main search query filter ---

        # --- NEW: Apply Brand filter BEFORE Name filter (respect additive filtering) ---
        brand_filter = self.sidebar_filter_buttons["Brand"].cget("text")
        if brand_filter != "All Brands":
            brand_filtered_list = []
            for item in data_to_filter: # Filter from query-filtered data
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand == brand_filter:
                    brand_filtered_list.append(item)
            data_to_filter = brand_filtered_list # Use brand-filtered data for further filtering
        # --- NEW: Apply Brand filter BEFORE Name filter (respect additive filtering) ---


        if option_text == "All Names":
            # When "All Names" is selected, use the data ALREADY filtered by query and Brand (if any)
            filtered_data = data_to_filter # <--- MODIFIED: Use data filtered by query and Brand, DO NOT reset to original
        else:
            # Apply Name filter on the data already filtered by query and Brand (if any)
            for item in data_to_filter: # <--- MODIFIED: Iterate over query and Brand-filtered data
                _, _, _, info_data, _ = item
                name = info_data.get("Name", "").strip()
                if name == option_text:
                    filtered_data.append(item)

        self.data = filtered_data
        self.grouped_data = self.format_grouped_data(self.data)
        #self.update_grid_layout()
        self.canvas.yview_moveto(0)
        




    def _filter_data_by_bodystyle(self, option_text):
        """Filters the displayed data based on the selected bodystyle option, added search window update."""
        filtered_data = []
        data_to_filter = list(self.data_cache)

        query = self.search_var.get().strip().lower()
        if query:
            query_filtered_data = []
            for item in data_to_filter:
                if self._perform_item_search(query, item):
                    query_filtered_data.append(item)
            data_to_filter = query_filtered_data

        brand_filter = self.sidebar_filter_buttons["Brand"].cget("text")
        name_filter = self.sidebar_filter_buttons["Name"].cget("text")
        country_filter = self.sidebar_filter_buttons["Country"].cget("text")

        if brand_filter != "All Brands":
            brand_filtered_list = []
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand == brand_filter:
                    brand_filtered_list.append(item)
            data_to_filter = brand_filtered_list

        if name_filter != "All Names":
            name_filtered_list = []
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                name = info_data.get("Name", "").strip()
                if name == name_filter:
                    name_filtered_list.append(item)
            data_to_filter = name_filtered_list

        if country_filter != "All Countries":
            country_filtered_list = []
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                country = info_data.get("Country", "").strip()
                if country == country_filter:
                    country_filtered_list.append(item)
            data_to_filter = country_filtered_list

        if option_text == "All BodyStyles":
            filtered_data = data_to_filter
        else:
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                body_style = info_data.get("Body Style", "").strip()
                if body_style == option_text:
                    filtered_data.append(item)
        self.data = filtered_data

        self.grouped_data = self.format_grouped_data(self.data)
        #self.update_grid_layout()
        self.canvas.yview_moveto(0)
        self._update_filters_label_status()
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE

      
        


    def _filter_data_by_country(self, option_text):
        """Filters data by country, respecting Brand and Name filters, and now main search query, added search window update."""
        filtered_data = []
        data_to_filter = list(self.data_cache)

        query = self.search_var.get().strip().lower()
        if query:
            query_filtered_data = []
            for item in data_to_filter:
                if self._perform_item_search(query, item):
                    query_filtered_data.append(item)
            data_to_filter = query_filtered_data

        brand_filter = self.sidebar_filter_buttons["Brand"].cget("text")
        name_filter = self.sidebar_filter_buttons["Name"].cget("text")

        if brand_filter != "All Brands":
            brand_filtered_list = []
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand == brand_filter:
                    brand_filtered_list.append(item)
            data_to_filter = brand_filtered_list

        if name_filter != "All Names":
            name_filtered_list = []
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                name = info_data.get("Name", "").strip()
                if name == name_filter:
                    name_filtered_list.append(item)
            data_to_filter = name_filtered_list

        if option_text == "All Countries":
            filtered_data = data_to_filter
        else:
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                country = info_data.get("Country", "").strip()
                if country == option_text:
                    filtered_data.append(item)

        self.data = filtered_data
        self.grouped_data = self.format_grouped_data(self.data)
        #self.update_grid_layout()
        self.canvas.yview_moveto(0)
        self._update_filters_label_status()
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE


        

        
    def _reset_data_or_apply_brand_filter(self):
        """Resets data to original or applies brand filter when 'All Names' is selected."""
        brand_filter = self.sidebar_filter_buttons["Brand"].cget("text")
        if brand_filter == "All Brands":
            self.data = list(self.original_data) # Reset to original data
        else:
            # Apply ONLY the Brand filter
            filtered_data = []
            for item in self.original_data:
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand == brand_filter:
                    filtered_data.append(item)
            self.data = filtered_data

            self._update_filters_label_status()
            self.update_search_results_window_ui() # <----- ADD THIS LINE HERE
            
            
            

    def _apply_name_and_brand_filters(self, option_text):
        """Applies both name and brand filters to the data."""
        filtered_data = []
        selected_name = option_text # Get the selected name

        # Find and set associated brand if Brand filter is "All Brands"
        if self.sidebar_filter_buttons["Brand"].cget("text") == "All Brands":
            associated_brand = self._find_associated_brand(selected_name)
            if associated_brand:
                self.sidebar_filter_buttons["Brand"].config(text=associated_brand) # Update Brand button text
                print(f"DEBUG: Brand filter set to: {associated_brand} based on Name selection.")

        # Apply Name and Brand filters
        for item in self.original_data:
            _, _, _, info_data, _ = item
            name = info_data.get("Name", "").strip()
            brand_filter = self.sidebar_filter_buttons["Brand"].cget("text")
            brand = info_data.get("Brand", "").strip()

            brand_condition = (brand_filter == "All Brands") or (brand == brand_filter)
            name_condition = (name == option_text)
            if name_condition and brand_condition:
                filtered_data.append(item)
        self.data = filtered_data
        self._update_filters_label_status()
        self.update_search_results_window_ui() 
        

    def _find_associated_brand(self, selected_name):
        """Finds the associated brand for a given name from original data."""
        for item in self.original_data:
            _, _, _, info_data, _ = item
            name_from_data = info_data.get("Name", "").strip()
            if name_from_data == selected_name:
                associated_brand = info_data.get("Brand", "").strip()
                if associated_brand:
                    return associated_brand
        return None # Return None if no associated brand is found (or if brand is empty)


    def _update_ui_elements(self, fdropdown_window):
        """Updates the UI elements after data filtering, added search window update."""
        #self.update_grid_layout()
        self.canvas.yview_moveto(0)
        fdropdown_window.destroy()
        setattr(self, f"sidebar_name_dropdown_window", None)
        self._update_filters_label_status()
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE



    def _get_dynamic_name_options(self):
        """Helper function to get dynamic name options based on selected brand."""
        brand_button = self.sidebar_filter_buttons.get("Brand")
        selected_brand = brand_button.cget("text") if brand_button else "All Brands"
        dynamic_name_options = ["All Names"] + self.get_unique_names(selected_brand)
        print("  DEBUG: dynamic_name_options after get_unique_names():", dynamic_name_options)  # Debug
        return dynamic_name_options

    def _destroy_existing_dropdown(self, dropdown_attr_name):
        """Destroys an existing dropdown window if it exists."""
        if hasattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name).winfo_exists():
            getattr(self, dropdown_attr_name).destroy()

    def _create_dropdown_base(self, button, dropdown_attr_name):
        """Creates the base dropdown window, canvas, scrollbar, and frame (MODIFIED for scrolling and animation)."""
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty()
        button_height = button.winfo_height() # Get button height for positioning

        dropdown_window = FadingToplevel(self.master, self, fade_in_duration_ms=0)
        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        dropdown_window.config(bg="#333333")
        highlight_thickness_val = 3
        dropdown_window.config(highlightthickness=highlight_thickness_val, highlightbackground="#666666")

        canvas_height_val = 410
        if self.font_size_add == 0:
            canvas_width_val = 180
        elif self.font_size_add == 2:
            canvas_width_val = 170
        elif self.font_size_add == 4:
            canvas_width_val = 160
        
        canvas = tk.Canvas(dropdown_window, bg="#444444", highlightthickness=0, width=canvas_width_val, height=canvas_height_val)

        scrollbar = tk.Scrollbar(dropdown_window, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#333333")

        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        canvas.configure(yscrollcommand=scrollbar.set)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        # --- Animation Setup ---
        scrollbar_width_estimate = 17 # A common estimate for Tkinter scrollbars
        target_win_width = canvas_width_val + scrollbar_width_estimate + (2 * highlight_thickness_val)
        target_win_height = canvas_height_val + (2 * highlight_thickness_val)

        anim_fixed_x = button_x
        initial_anim_height = 1 # Define initial height for animation start

        # CORRECTED: Calculate anim_anchor_y for the dropdown's top edge.
        # To have the dropdown's bottom meet the button's top edge initially:
        # bottom_of_dropdown_at_start = anim_anchor_y + initial_anim_height
        # We want bottom_of_dropdown_at_start == button_y
        # So, anim_anchor_y + initial_anim_height = button_y
        # Therefore:
        anim_anchor_y = button_y - initial_anim_height

        # Set initial geometry for animation (very small height, at final position and width)
        dropdown_window.geometry(f"{target_win_width}x{initial_anim_height}+{anim_fixed_x}+{anim_anchor_y}")
        dropdown_window.update_idletasks() # Ensure geometry is processed

        animation_step = 40  # Pixels per step
        animation_delay = 10 # Milliseconds between steps

        self._animate_window_height(
            window=dropdown_window,
            target_height=target_win_height,
            current_height=initial_anim_height, # Start animation from this height
            step=animation_step,
            delay=animation_delay,
            fixed_x=anim_fixed_x,
            final_width=target_win_width,
            anchor_y=anim_anchor_y,       # Use the corrected Y for the top edge
            anchor_point='top'            # Animate downwards
        )
        # --- End Animation Setup ---

        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_dropdown_mousewheel(ev, canvas)))
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))

        dropdown_window.bind("<FocusOut>", lambda event, name_to_close=dropdown_attr_name: self.destroy_sidebar_filter_dropdown(name_to_close))
        setattr(self, dropdown_attr_name, dropdown_window)
        return scrollable_frame, dropdown_window, canvas



    def _create_name_dropdown_content(self, scrollable_frame, dynamic_name_options, button, dropdown_window, canvas):
        """Creates the content of the name dropdown: search entry and options."""
        search_var = tk.StringVar()
        search_entry = tk.Entry(scrollable_frame, textvariable=search_var, font=("Segoe UI", 10+self.font_size_add), bg="#FFFFFF", fg="black", width=18)
        search_entry.pack(pady=(5, 2), padx=5, fill="x")
        search_entry.focus_set()
        
        
        filter_options_data = { # NOTE: This is likely redundant and can be removed/reworked
            "Brand": ["All Brands"] + self.get_unique_brands(),
            "Name": dynamic_name_options,
            "Country": ["All Countries", "Country 1", "Country 2"],
            "Author": ["All Authors", "Author 1", "Author 2"],
            "Bodystyle": ["All Bodystyles", "Bodystyle 1", "Bodystyle 2"],
            "Type": ["All Types", "Type 1", "Type 2"]
        }
        original_options = filter_options_data["Name"] # NOTE: Redundant - dynamic_name_options is already calculated

        #search_entry.bind("<KeyRelease>", lambda event: self._update_name_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window)) #debounce this please
        search_entry.bind("<KeyRelease>", lambda event: self._debounced_update_name_dropdown(search_var, original_options, scrollable_frame, canvas, button, dropdown_window))
        
        self._update_name_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window) # Initial population

        


    def _debounced_update_name_dropdown(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Debounced version of _update_name_dropdown_options."""
        if self.debounce_timer:
            self.master.after_cancel(self.debounce_timer)
        self.debounce_timer = self.master.after(
            600,  # Adjust delay as needed (milliseconds)
            lambda: self._update_name_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window)
        )

    def show_sidebar_name_dropdown(self):  # --- MODIFIED: Refactored using smaller functions ---
        """Shows the dropdown for Name filter, now dynamically populated based on Brand."""
        print("\n--- show_sidebar_name_dropdown() DEBUG START ---") # Debug Entry

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust constraints while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return
        

        dropdown_attr_name = f"sidebar_name_dropdown_window"
        self._destroy_existing_dropdown(dropdown_attr_name) # 1. Destroy existing dropdown

        button = self.sidebar_filter_buttons["Name"]
        scrollable_frame, dropdown_window, canvas = self._create_dropdown_base(button, dropdown_attr_name) # 2. Create dropdown base

        dynamic_name_options = self._get_dynamic_name_options() # 3. Get dynamic name options

        self._create_name_dropdown_content(scrollable_frame, dynamic_name_options, button, dropdown_window, canvas) # 4. Create dropdown content

        button_x = button.winfo_rootx() # Position after content is created for better placement
        button_y = button.winfo_rooty()
        dropdown_window.geometry(f"+{button_x}+{button_y}") # Final position

        print("--- show_sidebar_name_dropdown() DEBUG END ---\n") # Debug Exit




    def show_sidebar_country_dropdown(self):
        """Shows the dropdown for Country filter, now dynamically populated based on Brand and Name selections."""
        print("\n--- show_sidebar_country_dropdown() DEBUG START ---") # Debug Entry

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust constraints while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return
        


        dropdown_attr_name = f"sidebar_country_dropdown_window"
        self._destroy_existing_dropdown(dropdown_attr_name) # 1. Destroy existing dropdown

        button = self.sidebar_filter_buttons["Country"]
        scrollable_frame, dropdown_window, canvas = self._create_dropdown_base(button, dropdown_attr_name) # 2. Create dropdown base

        # --- NEW: Get currently selected Brand and Name from buttons ---
        brand_button = self.sidebar_filter_buttons.get("Brand")
        selected_brand = brand_button.cget("text") if brand_button else "All Brands"
        name_button = self.sidebar_filter_buttons.get("Name")
        selected_name = name_button.cget("text") if name_button else "All Names"
        print(f"  DEBUG: show_sidebar_country_dropdown - Selected Brand: '{selected_brand}', Selected Name: '{selected_name}'") # Debug

        dynamic_country_options = ["All Countries"] + self.get_unique_countries(selected_brand, selected_name) # 3. Get dynamic country options - PASSING BRAND and NAME FILTERS
        print(f"  DEBUG: show_sidebar_country_dropdown - Dynamic Country Options: {dynamic_country_options}") # Debug

        self._create_country_dropdown_content(scrollable_frame, dynamic_country_options, button, dropdown_window, canvas) # 4. Create dropdown content - NEW CONTENT CREATION FUNCTION

        button_x = button.winfo_rootx() # Position after content is created for better placement
        button_y = button.winfo_rooty()
        dropdown_window.geometry(f"+{button_x}+{button_y}") # Final position

        print("--- show_sidebar_country_dropdown() DEBUG END ---\n") # Debug Exit
        

    def _create_country_option_buttons(self, scrollable_frame, current_options, button, dropdown_window):
        """Creates and packs option buttons in the scrollable frame for country with smooth hover."""

        # --- Define Colors ---
        default_bg_color = "#555555"    # Normal, non-selected background
        default_fg_color = "#FFFFFF"    # Normal, non-selected foreground

        selected_option_bg = self.global_highlight_color # Background for the currently "selected" option
        selected_option_fg = "#FFFFFF"                   # Foreground for the "selected" option

        # Specific hover colors for these dropdown items
        dropdown_item_hover_bg = "#d9d9d9"
        dropdown_item_hover_fg = "black"

        # Get the text of the main button that opened this dropdown, to determine current selection
        current_main_button_text = button.cget("text")

        for option in current_options:
            # --- Determine if this option is currently selected ---
            is_selected = (option == current_main_button_text)

            # --- Button Creation ---
            # Initial bg/fg will be set by _bind_animated_hover based on is_selected
            dropdown_option_button = tk.Button( # Renamed to avoid confusion
                scrollable_frame,
                text=option,
                font=("Segoe UI", 10 + self.font_size_add, "bold"),
                # The command lambda captures necessary arguments for the click handler
                command=lambda opt=option, main_btn=button, dd_win=dropdown_window: \
                    self._on_country_dropdown_button_click(opt, fname="country", fbutton=main_btn, fdropdown_window=dd_win),
                borderwidth=1,      # Keep specific styling
                relief="solid",
                anchor="w",
                padx=10,
                pady=2,
                width=240 # If you need fixed width, keep it. Otherwise, remove for dynamic width.
                # bg and fg are now set by _bind_animated_hover
            )
            # Set active colors (for instant click flash) - optional
            dropdown_option_button.config(
                activebackground=dropdown_item_hover_bg,
                activeforeground=dropdown_item_hover_fg
            )

            dropdown_option_button.pack(fill="x")

            # --- Apply Smooth Hover Animation using the modified binder ---
            self._bind_animated_hover(
                button=dropdown_option_button,
                original_bg=default_bg_color,       # The "true" original, non-selected bg
                original_fg=default_fg_color,       # The "true" original, non-selected fg
                hover_target_bg=dropdown_item_hover_bg, # Custom hover BG for these items
                hover_target_fg=dropdown_item_hover_fg, # Custom hover FG for these items
                check_state=False,                    # Assuming these are not individually disabled
                is_selected_initial=is_selected,      # Is this button initially "selected"?
                selected_bg=selected_option_bg,       # Color if selected
                selected_fg=selected_option_fg        # Color if selected
            )

        

    def _update_country_dropdown_options(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Updates the options displayed in the Country dropdown based on search input."""
        print("    DEBUG: _update_country_dropdown_options() START") # Debug

        search_text = search_var.get().strip().lower()
        filtered_options = self._filter_dropdown_options(search_text, original_options) # 1. Filter options

        self._clear_dropdown_options(scrollable_frame) # 2. Clear existing options
        self._create_country_option_buttons(scrollable_frame, filtered_options, button, dropdown_window) # 3. Create new option buttons

        canvas.config(scrollregion=canvas.bbox("all"))
        # --- DEBUG PRINT: End of update_dropdown_options ---
        print("    DEBUG: _update_country_dropdown_options() END") # Debug
        

    def _create_country_dropdown_content(self, scrollable_frame, dynamic_country_options, button, dropdown_window, canvas):
        """Creates the content of the country dropdown: search entry and options."""
        search_var = tk.StringVar()
        search_entry = tk.Entry(scrollable_frame, textvariable=search_var, font=("Segoe UI", 10+self.font_size_add), bg="#FFFFFF", fg="black", width=18)
        search_entry.pack(pady=(5, 2), padx=5, fill="x")
        search_entry.focus_set()
        
        filter_options_data = { # NOTE: This is likely redundant and can be removed/reworked - but keep for now
            "Brand": ["All Brands"] + self.get_unique_brands(),
            "Name": ["All Names", "Name 1", "Name 2"],
            "Country": dynamic_country_options, # Pass dynamic options here
            "Author": ["All Authors", "Author 1", "Author 2"],
            "Bodystyle": ["All Bodystyles", "Bodystyle 1", "Bodystyle 2"],
            "Type": ["All Types", "Type 1", "Type 2"]
        }
        original_options = filter_options_data["Country"] # Get Country options

        #search_entry.bind("<KeyRelease>", lambda event: self._update_country_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window))
        #self._update_country_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window) # Initial population

        search_entry.bind("<KeyRelease>", lambda event: self._debounced_update_country_dropdown(search_var, original_options, scrollable_frame, canvas, button, dropdown_window))
        
        self._update_country_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window) # Initial population

        


    def _debounced_update_country_dropdown(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Debounced version of _update_country_dropdown_options."""
        if self.debounce_timer:
            self.master.after_cancel(self.debounce_timer)
        self.debounce_timer = self.master.after(
            600,  # Adjust delay as needed (milliseconds)
            lambda: self._update_country_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window)
        )
        

    def show_sidebar_bodystyle_dropdown(self):
        """Shows the dropdown for Body Style filter, now dynamically populated based on Brand, Name, and Country."""
        print("\n--- show_sidebar_bodystyle_dropdown() DEBUG START ---") # Debug Entry


        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust constraints while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return
        


        dropdown_attr_name = f"sidebar_bodystyle_dropdown_window"
        self._destroy_existing_dropdown(dropdown_attr_name) # 1. Destroy existing dropdown

        button = self.sidebar_filter_buttons["Bodystyle"]
        scrollable_frame, dropdown_window, canvas = self._create_dropdown_base(button, dropdown_attr_name) # 2. Create dropdown base

        # --- NEW: Get currently selected Brand, Name, and Country from buttons ---
        brand_button = self.sidebar_filter_buttons.get("Brand")
        selected_brand = brand_button.cget("text") if brand_button else "All Brands"
        name_button = self.sidebar_filter_buttons.get("Name")
        selected_name = name_button.cget("text") if name_button else "All Names"
        country_button = self.sidebar_filter_buttons.get("Country") # NEW: Get Country button
        selected_country = country_button.cget("text") if country_button else "All Countries" # NEW: Get selected Country
        print(f"  DEBUG: show_sidebar_bodystyle_dropdown - Selected Brand: '{selected_brand}', Selected Name: '{selected_name}', Selected Country: '{selected_country}'") # Debug

        dynamic_bodystyle_options = self.get_unique_body_styles(selected_brand, selected_name, selected_country) # 3. Get dynamic bodystyle options - PASSING BRAND, NAME, and COUNTRY FILTERS
        print(f"  DEBUG: show_sidebar_bodystyle_dropdown - Dynamic BodyStyle Options (BEFORE 'All' insertion): {dynamic_bodystyle_options}") # Debug

        # --- NEW: Ensure "All BodyStyles" is ALWAYS the first option (no change needed here) ---
        if "All BodyStyles" not in dynamic_bodystyle_options:
            dynamic_bodystyle_options.insert(0, "All BodyStyles") # Insert at the beginning if not present
        elif dynamic_bodystyle_options[0] != "All BodyStyles": # If present but not first, move to first
            dynamic_bodystyle_options.remove("All BodyStyles")
            dynamic_bodystyle_options.insert(0, "All BodyStyles")
        # --- NEW: Ensure "All BodyStyles" is ALWAYS the first option (no change needed here) ---
        print(f"  DEBUG: show_sidebar_bodystyle_dropdown - Dynamic BodyStyle Options (AFTER 'All' insertion/move): {dynamic_bodystyle_options}") # Debug

        self._create_bodystyle_dropdown_content(scrollable_frame, dynamic_bodystyle_options, button, dropdown_window, canvas) # 4. Create dropdown content

        button_x = button.winfo_rootx() # Position after content is created for better placement
        button_y = button.winfo_rooty()
        dropdown_window.geometry(f"+{button_x}+{button_y}") # Final position

        print("--- show_sidebar_bodystyle_dropdown() DEBUG END ---\n") # Debug Exit
        


    def _destroy_existing_dropdown(self, filter_name):
        """Destroys the existing dropdown window if it exists."""
        dropdown_attr_name = f"sidebar_{filter_name.lower()}_dropdown_window"
        if hasattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name).winfo_exists():
            getattr(self, dropdown_attr_name).destroy()
            return True  # Indicate dropdown was destroyed
        return False # Indicate no dropdown to destroy

    def _calculate_dropdown_position(self, button_widget):
        """Calculates the position for the dropdown window relative to the button."""
        button_x = button_widget.winfo_rootx()
        button_y = button_widget.winfo_rooty()
        return button_x, button_y

    def _create_dropdown_window(self, master, button_x, button_y):
        """
        Creates and animates the toplevel dropdown window.
        Its target size is determined based on self.font_size_add.
        The window's top edge will be at button_y - 250, and it will animate downwards.

        Args:
            master: The Tkinter master widget for the FadingToplevel.
            button_x (int): The target X coordinate for the dropdown's top-left corner.
            button_y (int): The Y coordinate used to calculate the dropdown's top edge.
                            The dropdown's top will be at button_y - 250.
        """
        dropdown_window = FadingToplevel(master, self, fade_in_duration_ms=0) # Use 'master' arg
        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        dropdown_window.config(bg="#444444")
        highlight_thickness_val = 3
        dropdown_window.config(highlightthickness=highlight_thickness_val, highlightbackground="#666666")

        # --- Determine target dimensions based on self.font_size_add (for internal content) ---
        # Assuming these are canvas dimensions, and window needs to fit them + scrollbar + border
        canvas_height_val = 410 # Fixed height from your snippet

        if self.font_size_add == 0:
            canvas_width_val = 180
        elif self.font_size_add == 2:
            canvas_width_val = 170
        elif self.font_size_add == 4:
            canvas_width_val = 160

        # Estimate scrollbar width (assuming one might be present, similar to _create_dropdown_base)
        scrollbar_width_estimate = 17 # A common estimate
        
        # Calculate target window dimensions
        # Target width = canvas width + scrollbar width + 2 * border thickness
        target_width = canvas_width_val + scrollbar_width_estimate + (2 * highlight_thickness_val)
        # Target height = canvas height + 2 * border thickness
        target_height = canvas_height_val + (2 * highlight_thickness_val)
        # --- End Dimension Determination ---

        # --- Animation Setup ---
        anim_fixed_x = button_x
        initial_anim_height = 1  # Start animation with a 1-pixel height

        # CORRECTED: Calculate anim_anchor_y for the dropdown's top edge.
        # To have the dropdown's bottom meet the button's top edge initially (when dropdown height is initial_anim_height):
        # anim_anchor_y (top of dropdown) = button_y (top of button) - initial_anim_height
        anim_anchor_y = button_y - initial_anim_height

        # Set the initial geometry for the animation:
        # Positioned at anim_fixed_x, anim_anchor_y (which is just above button's top),
        # with target_width and initial_anim_height.
        dropdown_window.geometry(f"{target_width}x{initial_anim_height}+{anim_fixed_x}+{anim_anchor_y}")
        dropdown_window.update_idletasks()  # Ensure geometry is processed before animation starts

        animation_step = 40   # Pixels per step
        animation_delay = 10  # Milliseconds between steps

        self._animate_window_height(
            window=dropdown_window,
            target_height=target_height,
            current_height=initial_anim_height,
            step=animation_step,
            delay=animation_delay,
            fixed_x=anim_fixed_x,
            final_width=target_width,
            anchor_y=anim_anchor_y,       # Use the corrected Y for the top edge
            anchor_point='top'            # Animate by growing height downwards
        )
        # --- End Animation Setup --

        return dropdown_window

    def _create_scrollable_canvas(self, dropdown_window, dropdown_width, dropdown_height):
        """Creates the scrollable canvas and frame within the dropdown window."""
        canvas = tk.Canvas(dropdown_window, bg="#444444", highlightthickness=0, width=dropdown_width, height=dropdown_height)
        scrollbar = tk.Scrollbar(dropdown_window, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#444444", width=dropdown_width, height=dropdown_height)

        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        canvas.configure(yscrollcommand=scrollbar.set)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        # --- NEW: Bind Mousewheel only on Canvas Enter/Leave ---
        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_dropdown_mousewheel(ev, canvas)))
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))
        # --- NEW: Bind Mousewheel only on Canvas Enter/Leave ---
        return canvas, scrollable_frame

    def _create_search_bar(self, scrollable_frame, search_var):
        """Creates the search bar entry in the scrollable frame."""
        search_bar_width = 18
        search_entry = tk.Entry(scrollable_frame, textvariable=search_var, font=("Segoe UI", 10+self.font_size_add), bg="#FFFFFF", fg="black", width=search_bar_width)
        search_entry.pack(pady=(5, 2), padx=5, fill="x")
        search_entry.focus_set()

        return search_entry

    def _update_dropdown_options(self, scrollable_frame, search_var, original_options, button_widget, dropdown_width, on_dropdown_button_click, canvas):
        """Updates the dropdown options based on the search input."""
        def update_options(event=None):
            search_text = search_var.get().strip().lower()
            filtered_options = [option for option in original_options if search_text in option.lower()]

            for widget in scrollable_frame.winfo_children()[1:]:  # Skip search entry (index 0)
                widget.destroy()

            self._create_dropdown_buttons(scrollable_frame, filtered_options, button_widget, dropdown_width, on_dropdown_button_click)
            canvas.config(scrollregion=canvas.bbox("all"))

        return update_options # Return the function to be bound

    def _create_dropdown_buttons(self, scrollable_frame, options, button_widget, dropdown_width, on_dropdown_button_click):
        """Creates the dropdown buttons in the scrollable frame with smooth hover."""

        # --- Define Colors ---
        default_bg_color = "#555555"    # Normal, non-selected background
        default_fg_color = "#FFFFFF"    # Normal, non-selected foreground

        selected_option_bg = self.global_highlight_color # Background for the currently "selected" option
        selected_option_fg = "#FFFFFF"                   # Foreground for the "selected" option

        # Specific hover colors for these dropdown items
        dropdown_item_hover_bg = "#d9d9d9"
        dropdown_item_hover_fg = "black"

        # Get the text of the main button that opened this dropdown, to determine current selection
        current_main_button_text = button_widget.cget("text")

        # Store references to the created buttons if the on_dropdown_button_click needs to update them all
        # You might want to pass a list to this function to populate, or handle it in the caller
        created_buttons_list = [] # Example

        for option in options:
            # --- Determine if this option is currently selected ---
            is_selected = (option == current_main_button_text)

            # --- Button Creation ---
            # Initial bg/fg will be set by _bind_animated_hover based on is_selected
            dropdown_option_button = tk.Button( # Renamed for clarity
                scrollable_frame,
                text=option,
                font=("Segoe UI", 10 + self.font_size_add, "bold"),
                # The command lambda captures the option for the click handler
                command=lambda opt=option: on_dropdown_button_click(opt), # Uses the passed click handler
                borderwidth=1,      # Keep specific styling
                relief="solid",
                anchor="w",
                padx=10,
                pady=2,
                #width=dropdown_width, # Use the passed dropdown_width argument
                width=240 # Or keep fixed if dropdown_width isn't always what you want here
                # bg and fg are now set by _bind_animated_hover
            )

            # Apply width if provided and valid
            if dropdown_width is not None and isinstance(dropdown_width, int) and dropdown_width > 0:
                 dropdown_option_button.config(width=dropdown_width)
            else:
                 # If fixed width is desired when dropdown_width is not applicable:
                 # dropdown_option_button.config(width=240) # Example fixed width
                 pass # Or let it auto-size based on text

            # Set active colors (for instant click flash) - optional
            dropdown_option_button.config(
                activebackground=dropdown_item_hover_bg,
                activeforeground=dropdown_item_hover_fg
            )

            dropdown_option_button.pack(fill="x")
            created_buttons_list.append(dropdown_option_button) # Add to list

            # --- Apply Smooth Hover Animation using the modified binder ---
            self._bind_animated_hover(
                button=dropdown_option_button,
                original_bg=default_bg_color,       # The "true" original, non-selected bg
                original_fg=default_fg_color,       # The "true" original, non-selected fg
                hover_target_bg=dropdown_item_hover_bg, # Custom hover BG for these items
                hover_target_fg=dropdown_item_hover_fg, # Custom hover FG for these items
                check_state=False,                    # Assuming these are not individually disabled
                is_selected_initial=is_selected,      # Is this button initially "selected"?
                selected_bg=selected_option_bg,       # Color if selected
                selected_fg=selected_option_fg        # Color if selected
            )


    def _on_dropdown_button_click_for_brands(self, option_text, filter_name, button_widget, dropdown_window):
        """Handles the click event for the BRANDS dropdown button and nothing else).
           MODIFIED to reset Bodystyle AND Country filters when Brand filter changes.
           MODIFIED to call _update_filters_label_status AFTER button config.
        """
        print(f"\n--- _on_dropdown_button_click_for_brands() DEBUG START ---")
        print(f"  DEBUG: filter_name: {filter_name}, option_text: {option_text}")

        button_widget.config(text=option_text)

        if filter_name.lower() == "brand": # Filtering logic for Brand - CASE INSENSITIVE COMPARISON
            print("  DEBUG: Inside filter_name.lower() == 'brand' block - CORRECT BLOCK NOW ENTERED") # Debug - Correct block entered
            if option_text == "All Brands":
                print("  DEBUG: option_text is 'All Brands'") # Debug - All Brands
                # --- MODIFIED: ALWAYS respect main filter when "All Brands" is selected ---
                print("    DEBUG: Main filter is ALWAYS respected for 'All Brands', using filtered_original_data_for_brands")
                self.data = list(self.filtered_original_data_for_brands) # Use filtered data
                # --- MODIFIED: ALWAYS respect main filter when "All Brands" is selected ---
            else:
                print(f"  DEBUG: option_text is a specific brand: '{option_text}' - filtering data") # Debug - Specific Brand
                filtered_data = []
                # --- MODIFIED: Filter based on filtered_original_data_for_brands instead of original_data ---
                for item in self.filtered_original_data_for_brands: # <--- MODIFIED: Use filtered data as source
                    _, _, _, info_data, _ = item
                    brand = info_data.get("Brand", "").strip()
                    if brand == option_text:
                        filtered_data.append(item)
                self.data = filtered_data
                # --- MODIFIED: Filter based on filtered_original_data_for_brands instead of original_data ---

            self.grouped_data = self.format_grouped_data(self.data)
            #self.update_grid_layout()
            self.canvas.yview_moveto(0)

            name_button = self.sidebar_filter_buttons.get("Name") # Get the Name button widget
            if name_button:
                name_button.config(text="All Names") # Set text to "All Names"

            # --- NEW: Reset Bodystyle and Country filters to "All..." when Brand changes ---
            bodystyle_button = self.sidebar_filter_buttons.get("Bodystyle") # Get Bodystyle button
            if bodystyle_button:
                bodystyle_button.config(text="All BodyStyles") # Reset Bodystyle button text

            country_button = self.sidebar_filter_buttons.get("Country") # NEW: Get Country button
            if country_button:
                country_button.config(text="All Countries") # NEW: Reset Country button text
            # --- NEW: Reset Bodystyle and Country filters to "All..." when Brand changes ---


        elif filter_name.lower() == "name": # Filtering logic for Name
             # No changes needed here for Name filter itself (logic already in _on_name_dropdown_button_click)
             pass # Placeholder, keep existing Name filter logic in _on_name_dropdown_button_click

        elif filter_name.lower() == "bodystyle": # Filtering logic for Bodystyle
            self._on_bodystyle_dropdown_button_click(option_text, filter_name, button_widget, dropdown_window) # Call existing bodystyle handler
        elif filter_name.lower() == "country": # Filtering logic for Country
            self._on_country_dropdown_button_click(option_text, filter_name, button_widget, dropdown_window) # Call existing country handler
        elif filter_name.lower() == "author": # REMOVE THIS BRANCH
            pass # Add any specific logic for Author if needed, currently generic # REMOVE THIS LINE
        elif filter_name.lower() == "type": # REMOVE THIS BRANCH
            pass # Add any specific logic for Type if needed, currently generic # REMOVE THIS LINE


        dropdown_window.destroy()
        dropdown_attr_name = f"sidebar_{filter_name.lower()}_dropdown_window"
        setattr(self, dropdown_attr_name, None)
        self._update_filters_label_status() # <--- UPDATE FILTERS LABEL STATUS HERE
        
        print("--- _on_dropdown_button_click_for_brands() DEBUG END ---\n")
        self.update_search_results_window_ui() 


    def _on_country_dropdown_button_click(self, option_text, fname, fbutton, fdropdown_window):
        """Handles the button click event in the Country dropdown.
           MODIFIED to reset Bodystyle filter when Country changes.
           MODIFIED to call _update_filters_label_status AFTER button config.
        """
        print("    DEBUG: _on_country_dropdown_button_click() START") # Debug
        fbutton.config(text=option_text)
        self._filter_data_by_country(option_text) # Call country-specific filter function

        # --- NEW: Reset Bodystyle filter to "All BodyStyles" when Country changes ---
        bodystyle_button = self.sidebar_filter_buttons.get("Bodystyle") # Get Bodystyle button
        if bodystyle_button:
            bodystyle_button.config(text="All BodyStyles") # Reset Bodystyle button text
        # --- NEW: Reset Bodystyle filter to "All BodyStyles" when Country changes ---

        self._update_ui_elements(fdropdown_window)
        self._update_filters_label_status() # <--- UPDATE FILTERS LABEL STATUS HERE
        print("    DEBUG: _on_country_dropdown_button_click() END") # Debug
        
        
        
    def _show_sidebar_filter_dropdown(self, filter_name, button_widget): #FOR BRANDS
        """Displays the sidebar filter dropdown."""


        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust constraints while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return
        

        
        if self._destroy_existing_dropdown(filter_name):
            return

        button_x, button_y = self._calculate_dropdown_position(button_widget)
        dropdown_window = self._create_dropdown_window(self.master, button_x, button_y)



        if self.font_size_add == 0:
            canvas, scrollable_frame = self._create_scrollable_canvas(dropdown_window, 180, 410) # dropdown width FOR BRANDS 

        elif self.font_size_add == 2:
            canvas, scrollable_frame = self._create_scrollable_canvas(dropdown_window, 170, 410)

        elif self.font_size_add == 4:
            canvas, scrollable_frame = self._create_scrollable_canvas(dropdown_window, 160, 410)



        search_var = tk.StringVar()
        search_entry = self._create_search_bar(scrollable_frame, search_var)

        filter_options_data = {
            "Brand": ["All Brands"] + self.get_unique_brands(),
            "Name": ["All Names", "Name 1", "Name 2"],
            "Country": ["All Countries"] + self.get_unique_countries(),
            # "Author": ["All Authors", "Author 1", "Author 2"], # REMOVED Author
            "Bodystyle": ["All Bodystyles"] + self.get_unique_body_styles(),
            # "Type": ["All Types", "Type 1", "Type 2"] # REMOVED Type
        }
        original_options = filter_options_data[filter_name]
        current_options = list(original_options)

        on_dropdown_button_click_lambda = lambda opt: self._on_dropdown_button_click_for_brands(opt, filter_name, button_widget, dropdown_window)
        update_dropdown_options_func = self._update_dropdown_options(
            scrollable_frame, search_var, original_options, button_widget, 240, on_dropdown_button_click_lambda, canvas
        )

        def debounced_update_dropdown_options(event):
            if self.debounce_timer:
                self.master.after_cancel(self.debounce_timer)
            self.debounce_timer = self.master.after(600, lambda: update_dropdown_options_func(event)) # 200ms delay

        search_entry.bind("<KeyRelease>", debounced_update_dropdown_options)

        self._create_dropdown_buttons(scrollable_frame, current_options, button_widget, 240, on_dropdown_button_click_lambda)


        dropdown_window.bind("<FocusOut>", lambda event, fname=filter_name: self.destroy_sidebar_filter_dropdown(fname))
        dropdown_attr_name = f"sidebar_{filter_name.lower()}_dropdown_window"
        setattr(self, dropdown_attr_name, dropdown_window)
        dropdown_window.geometry(f"+{button_x}+{button_y}")


        dropdown_window.bind("<FocusOut>", lambda event, fname=filter_name: self.destroy_sidebar_filter_dropdown(fname))
        dropdown_attr_name = f"sidebar_{filter_name.lower()}_dropdown_window"
        setattr(self, dropdown_attr_name, dropdown_window)
        dropdown_window.geometry(f"+{button_x}+{button_y}")

        
        
    def on_dropdown_mousewheel(self, event, canvas):
        """Handles mousewheel scrolling for dropdown canvas with ease-out (size-independent)."""
        if not canvas.winfo_exists():
            return

        if event.delta:
            scroll_units = int(-1 * (event.delta / 120))

            current_y = canvas.yview()[0]
            max_y_scroll = 1.0
            scrollable_height = canvas.bbox("all")[3] - canvas.bbox("all")[1] if canvas.bbox("all") else 0
            canvas_height = canvas.winfo_height()

            if scrollable_height <= canvas_height:
                return

            # Calculate scroll step based on a fraction of the *visible* canvas height
            scroll_fraction = 0.7  # Adjust this fraction (e.g., 0.1, 0.15, 0.25) for sensitivity
            scroll_step_normalized = (canvas_height / scrollable_height) * scroll_fraction * scroll_units
            # Explanation:
            # - (canvas_height / scrollable_height):  This is the proportion of the *total* content that is visible.
            # - scroll_fraction:  We want to scroll by a fraction of this visible portion.
            # - scroll_units:  Multiply by the scroll units.

            target_y_normalized = current_y + scroll_step_normalized
            target_y_normalized = max(0.0, min(max_y_scroll, target_y_normalized))

            self.scroll_target_y = target_y_normalized
            self.scroll_start_y = current_y
            self.scroll_start_time = self.master.tk.call('clock', 'milliseconds')

            if self.scroll_animation_id:
                canvas.after_cancel(self.scroll_animation_id)
            self.animate_dropdown_scroll(canvas)


    def animate_dropdown_scroll(self, canvas):
        """Animates the canvas scroll with ease-out."""
        current_time = self.master.tk.call('clock', 'milliseconds')
        time_elapsed = current_time - self.scroll_start_time
        progress = min(1.0, time_elapsed / self.scroll_duration) # Normalized progress (0 to 1)

        # Ease-out function (simple quadratic)
        ease_out_progress = progress * (2 - progress) #  f(t) = t * (2 - t)

        # Calculate current scroll position based on eased progress
        current_y_normalized = self.scroll_start_y + (self.scroll_target_y - self.scroll_start_y) * ease_out_progress

        canvas.yview_moveto(current_y_normalized)

        if progress < 1.0:
            self.scroll_animation_id = canvas.after(10, self.animate_dropdown_scroll, canvas) # 10ms delay for animation step
        else:
            self.scroll_animation_id = None # Animation finished
            


    def destroy_sidebar_filter_dropdown(self, filter_name):
        dropdown_attr_name = f"sidebar_{filter_name.lower()}_dropdown_window"
        if hasattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name).winfo_exists():
            getattr(self, dropdown_attr_name).destroy()
            setattr(self, dropdown_attr_name, None) # Clear dropdown window attribute

    def setup_event_bindings(self):
        """Sets up main window and canvas event bindings."""
        self.master.bind("<Configure>", self.combined_configure_handler)
        self.canvas.bind("<Enter>", lambda e: self.canvas.bind_all("<MouseWheel>", self.on_mousewheel_main))
        self.canvas.bind("<Leave>", lambda e: self.canvas.unbind_all("<MouseWheel>"))

        self.master.bind_all("<Escape>", lambda event: self.handle_escape_globally())

        # --- Focus Related Bindings ---
        # Use add='+' to avoid replacing other potential bindings on these events
        self.master.bind("<FocusIn>", self.on_master_focus_in, add='+')
        self.master.bind("<FocusOut>", self.on_master_focus_out, add='+')
        # --- End Focus Bindings ---

        # Binding for other clicks (kept from your example)
        self.master.bind("<Button-1>", self.on_main_window_click)

        self.master.bind_all('<KeyPress-Alt_L>', self.prevent_alt_freeze)
        self.master.bind_all('<KeyPress-Alt_R>', self.prevent_alt_freeze)


        if self.dev_mode:
            self.master.bind_all("<+>", lambda event: self.focus_beamng_window())
            self.master.bind_all("<Control-P>", lambda event: self.update_grid_layout())


        self.master.bind_all("<Control-y>", lambda event: self.focus_beamng_window()) # <--- ADD THIS LINE
        self.master.bind_all("<Control-Y>", lambda event: self.focus_beamng_window()) 



        # Storing previous geometry (kept from your example)
        self.prev_master_x = self.master.winfo_x()
        self.prev_master_y = self.master.winfo_y()
        self.prev_master_width = self.master.winfo_width()
        self.prev_master_height = self.master.winfo_height()


    def prevent_alt_freeze(self, event):
        """Prevents the default Alt key behavior that can freeze Tkinter."""
        print(f"Alt key pressed ({event.keysym}), preventing default action.")
        # Returning "break" stops Tkinter from processing the event further,
        # effectively preventing the default menu activation behavior.
        return "break"


    def on_master_focus_in(self, event=None):
        """Handles the main window gaining OS focus."""
        # Ensure the event is actually for the master window itself
        if event is not None and event.widget == self.master:
            print("--- Window <FocusIn> detected ---")
            self.window_has_os_focus = True
            # Call the central update function to recalculate the main flag
            self.update_main_focus_flag()
            # Keep your original action
            self.lift_search_results_window() # Or whatever this method does
        # Handle case where focus_force might trigger this without an event object
        elif event is None:
            print("--- Window <FocusIn> likely triggered programmatically ---")
            self.window_has_os_focus = True
            self.update_main_focus_flag()
            self.lift_search_results_window()


    def on_master_focus_out(self, event=None):
        """Handles the main window losing OS focus."""
        # Ensure the event is actually for the master window itself
        if event is not None and event.widget == self.master:
            print("--- Window <FocusOut> detected ---")
            self.window_has_os_focus = False
            # *** As requested: Directly set the main flag to False when window loses focus ***
            self.main_search_entry_widget_focused_but_window_not_focus = False
            print(f"Window lost focus. Flag forced to FALSE.")
            # Optionally, you could call update_main_focus_flag() here too,
            # but the direct set fulfills the request. If you called the update
            # function, it would also result in False because window_has_os_focus is False.
            self.on_main_window_click(event, called_to_destroy=True)
            print("cursor restored from focus out")


        elif event is None:
            print("--- Window <FocusOut> likely triggered programmatically ---")
            self.window_has_os_focus = False
            self.main_search_entry_widget_focused_but_window_not_focus = False
            print("cursor restored from focus out")

            print(f"Window lost focus (programmatic). Flag forced to FALSE.")


    def update_main_focus_flag(self):
        """
        Central function to update the state of
        'main_search_entry_widget_focused_but_window_not_focus'
        based on current internal focus and window focus state.
        """
        internal_focus_on_search = False
        try:
            # Check if search_entry exists and has internal focus
            if hasattr(self, 'search_entry') and self.search_entry.winfo_exists():
                current_focus = self.master.focus_get()
                internal_focus_on_search = (self.search_entry == current_focus)
                # print(f"Debug update_main_focus_flag: Current internal focus: {current_focus}, Is it search_entry? {internal_focus_on_search}")
            else:
                # print("Debug update_main_focus_flag: search_entry doesn't exist.")
                pass # internal_focus_on_search remains False

        except Exception as e:
            print(f"Error checking internal focus in update_main_focus_flag: {e}")
            internal_focus_on_search = False # Assume no focus on error

        # --- The Core Logic ---
        # The flag should be True only if:
        # 1. Internal focus IS on the search entry AND
        # 2. The window does NOT have OS focus
        previous_flag_state = self.main_search_entry_widget_focused_but_window_not_focus
        self.main_search_entry_widget_focused_but_window_not_focus = \
            internal_focus_on_search and (not self.window_has_os_focus)
        # --- End Core Logic ---

        if previous_flag_state != self.main_search_entry_widget_focused_but_window_not_focus:
            print(f"update_main_focus_flag: InternalFocus={internal_focus_on_search}, "
                f"WindowHasFocus={self.window_has_os_focus} -> Flag changed to: "
                f"{self.main_search_entry_widget_focused_but_window_not_focus}")
        # else:
            # print(f"update_main_focus_flag: InternalFocus={internal_focus_on_search}, WindowHasFocus={self.window_has_os_focus} -> Flag remains: {self.main_search_entry_widget_focused_but_window_not_focus}")

    def _start_switcher_monitoring(self):
        """Starts the watchdog observer for the switcher confirmation file."""
        if self.switcher_observer is not None:
            print("Switcher confirmation file observer already running.")
            return

        watch_directory = self.switcher_confirmation_path.parent
        try:
            print(f"Ensuring watch directory exists: {watch_directory}")
            watch_directory.mkdir(parents=True, exist_ok=True)
        except OSError as e:
             print(f"ERROR: Could not create directory for monitoring: {watch_directory} - {e}")
             return

        print(f"Starting switcher confirmation file monitoring for: {self.switcher_confirmation_path}")

        # Create handler, passing the QUEUE, not master or callback directly
        event_handler = SwitcherConfirmationHandler(
            self.switcher_confirmation_path,
            self.switcher_callback_queue # <<< PASS THE QUEUE
        )
        self.switcher_observer = Observer()
        try:
            self.switcher_observer.schedule(event_handler, str(watch_directory), recursive=False)
            self.switcher_observer.start()
            print(f"Switcher observer started monitoring directory: {watch_directory}")
            # Start the periodic queue check in Tkinter thread
            self._check_switcher_queue() # <<< START QUEUE CHECKING
        except Exception as e:
            print(f"Error starting switcher observer: {e}")
            self.switcher_observer = None

    def _check_switcher_queue(self):
        """Checks the queue for callbacks requested by the switcher handler."""
        try:
            # Get message from queue (non-blocking)
            callback_request = self.switcher_callback_queue.get_nowait()
            if callback_request == "run_focus": # Check for specific message
                print("DEBUG Switcher Queue Check: Received 'run_focus' request.")
                self.focus_config_viewer_from_floating_button() # Call the actual function
                self.skip_perform_search = True
        except queue.Empty:
            pass # No request in the queue
        except Exception as e:
            print(f"ERROR checking switcher queue: {e}")
        finally:
            # Reschedule the check
            self._after_id_switcher_check = self.master.after(100, self._check_switcher_queue) # Check every 100ms


    # --- Modify _stop_switcher_monitoring to cancel the after loop ---
    def _stop_switcher_monitoring(self):
        """Stops the switcher confirmation file observer."""
        # <<< Cancel the after loop FIRST >>>
        if self._after_id_switcher_check:
            self.master.after_cancel(self._after_id_switcher_check)
            self._after_id_switcher_check = None

        if self.switcher_observer:
            # ... (rest of observer stopping logic remains the same) ...
            observer_was_running = self.switcher_observer.is_alive()
            print("Stopping switcher confirmation file monitoring...")
            try:
                self.switcher_observer.stop()
                self.switcher_observer.join(timeout=0.5)
                if self.switcher_observer.is_alive():
                    print("Warning: Switcher observer thread did not stop gracefully.")
            except Exception as e:
                print(f"Error stopping switcher observer: {e}")
            finally:
                 self.switcher_observer = None
                 if observer_was_running:
                     print("Switcher monitoring stopped.")




    def _parse_keyboard_diff(self, filepath):
        """
        Parses the keyboard.diff file to find ALL EMM command bindings.
        Returns a list of valid Tkinter binding strings.
        """
        print(f"--- DEBUG PARSING START: {filepath} ---")
        bindings_found = [] # Initialize list to store results
        try:
            if not os.path.exists(filepath):
                print("DEBUG PARSE: File does not exist.")
                return [] # Return empty list if file doesn't exist

            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                # print(f"DEBUG PARSE: File content read:\n>>>\n{content}\n<<<") # Keep for debugging if needed

            # Find all potential blocks containing the action
            # This regex is broad - finds { ... "action":"runEmmCommandBinding" ... }
            # It assumes somewhat well-formed blocks but allows other keys
            block_pattern = re.compile(r'\{\s*[^\{\}]*?"action"\s*:\s*"runEmmCommandBinding"[^\{\}]*?\}', re.DOTALL)
            # Regex to find the control within a block
            control_pattern = re.compile(r'"control"\s*:\s*"ctrl\s+([a-z0-9]|numpad[0-9])"')

            for block_match in block_pattern.finditer(content):
                block_content = block_match.group(0)
                # print(f"DEBUG PARSE: Examining block:\n{block_content}") # Debug found blocks
                control_match = control_pattern.search(block_content)

                if control_match:
                    key = control_match.group(1).lower()
                    # print(f"DEBUG PARSE: Found potential key in block: '{key}'")

                    # Format for Tkinter
                    binding_string = None
                    if key.startswith("numpad"):
                        digit = key[6:]
                        if digit.isdigit():
                            binding_string = f"<Control-KP_{digit}>"
                        else:
                            print(f"WARN PARSE: Invalid numpad format in block: {key}")
                    elif len(key) == 1 and (key.isalnum()):
                        binding_string = f"<Control-{key}>"
                    else:
                        print(f"WARN PARSE: Invalid key format in block: {key}")

                    if binding_string:
                        # Avoid adding duplicates from the file itself
                        if binding_string not in bindings_found:
                            bindings_found.append(binding_string)
                            # print(f"DEBUG PARSE: Added binding: {binding_string}")
                        # else:
                            # print(f"DEBUG PARSE: Duplicate binding found in file, skipping: {binding_string}")


                # else:
                    # print("DEBUG PARSE: 'control: ctrl ...' pattern not found in this block.")

            print(f"DEBUG PARSE: Final list of bindings found: {bindings_found}")
            return bindings_found # Return the list (could be empty)

        except IOError as e:
            print(f"Error reading keyboard.diff: {e}")
            return [] # Return empty list on error
        except Exception as e:
            print(f"Error parsing keyboard.diff: {e}")
            return [] # Return empty list on error
        finally:
            print(f"--- DEBUG PARSING END ---")

    def _start_keyboard_diff_monitoring(self):
        """Starts the watchdog observer to monitor the keyboard.diff file."""
        print("Starting keyboard.diff monitoring...")
        if self.watchdog_observer is not None:
            print("Watchdog observer already running.")
            return

        # ... (directory checking logic) ...
        directory_to_watch = os.path.dirname(self.keyboard_diff_path)
        if not os.path.exists(directory_to_watch):
            print(f"Warning: Directory to watch does not exist: {directory_to_watch}")


        # --- Initial check ---
        initial_binding = self._parse_keyboard_diff(self.keyboard_diff_path)
        print(f"Initial parse result: {initial_binding}")
        self.binding_update_queue.put(initial_binding)
        self._check_binding_queue(initial_call=True)
        # --- End Initial check ---

        # Setup watchdog
        # Pass 'self' if parse_func needs it, or make parse_func standalone
        event_handler = KeyboardDiffHandler(self.keyboard_diff_path, self.binding_update_queue, self._parse_keyboard_diff)
        # Store a reference to the handler if needed for cleanup
        self._watchdog_handler_ref = event_handler

        self.watchdog_observer = Observer()
        try:
            self.watchdog_observer.schedule(event_handler, directory_to_watch, recursive=False)
            self.watchdog_observer.start()
            print(f"Watchdog started monitoring directory: {directory_to_watch}")
        except Exception as e:
            print(f"Error starting watchdog observer: {e}")
            self.watchdog_observer = None
            return

        self._check_binding_queue()

    def _stop_keyboard_diff_monitoring(self):
        """Stops the watchdog observer and cleans up."""
        print("Stopping keyboard.diff monitoring...")
        # ... (timer cancellation, observer stop/join) ...

        # Unbind all currently active bindings
        if self.current_emm_bindings: # Check if list is not empty
            print(f"Unbinding final keys: {self.current_emm_bindings}")
            bindings_to_clear = list(self.current_emm_bindings) # Copy list
            for binding in bindings_to_clear:
                upper_binding_to_unbind = None
                match_ctrl_lower = re.match(r"<Control-([a-z])>$", binding)
                if match_ctrl_lower:
                    lower_key = match_ctrl_lower.group(1)
                    upper_key = lower_key.upper()
                    upper_binding_to_unbind = f"<Control-{upper_key}>"

                # Unbind base
                print(f"  Unbinding final: {binding}")
                try:
                    self.master.unbind_all(binding)
                except Exception as e:
                    print(f"  Error during final unbind of {binding}: {e}")

                # Unbind upper if needed
                if upper_binding_to_unbind:
                    print(f"  Unbinding final uppercase: {upper_binding_to_unbind}")
                    try:
                        self.master.unbind_all(upper_binding_to_unbind)
                    except Exception as e:
                        print(f"  Error during final unbind of {upper_binding_to_unbind}: {e}")

            self.current_emm_bindings = [] # Clear the state list
        print("Keyboard.diff monitoring stopped.")


    # --- Tkinter Integration ---

    def _check_binding_queue(self, initial_call=False):
        """Checks the queue for binding updates from the watchdog thread."""
        try:
            # Use get_nowait to avoid blocking the Tkinter thread
            new_binding = self.binding_update_queue.get_nowait()
            print(f"DEBUG QUEUE: Got item from queue: {new_binding} (Type: {type(new_binding)})") # ADD THIS

            self._update_emm_binding(new_binding)
        except queue.Empty:
            pass # No update needed
        except Exception as e:
            print(f"Error processing binding queue: {e}")

        # Reschedule unless it was just the initial call to process immediately
        if not initial_call:
             # Schedule the next check (e.g., every 250ms)
             self._after_id_binding_check = self.master.after(250, self._check_binding_queue)


    def _format_binding_for_display(self, binding_str):
        """Converts Tkinter binding string to a more user-friendly format."""
        if not binding_str or not isinstance(binding_str, str):
            return ""

        # 1. Clean up brackets and KeyPress
        binding_str = binding_str.strip('<>')
        binding_str = binding_str.replace("KeyPress-", "") # Remove KeyPress if present

        # 2. Split based on the hyphen separator used by Tkinter
        #    Handles cases like Control-Shift-c correctly
        parts = binding_str.split('-')

        formatted_parts = []
        known_keys_lower = { # Use lowercase for easier comparison
            "control": "Ctrl",
            "alt": "Alt",
            "shift": "Shift",
            "tab": "Tab",
            "return": "Return", # Tk uses Return for Enter
            "space": "Space",   # Tk uses space
            "escape": "Escape", # Tk uses Escape
            "prior": "PageUp",  # Tk uses Prior/Next
            "next": "PageDown",
            "backspace": "Backspace",
            "delete": "Delete",
            "up": "Up",
            "down": "Down",
            "left": "Left",
            "right": "Right",
            # Add more function keys, numpad keys, etc. as needed
            "f1": "F1", "f2": "F2", "f3": "F3", "f4": "F4",
            "f5": "F5", "f6": "F6", "f7": "F7", "f8": "F8",
            "f9": "F9", "f10": "F10", "f11": "F11", "f12": "F12",
        }

        for part in parts:
            part_lower = part.lower()
            if part_lower in known_keys_lower:
                formatted_parts.append(known_keys_lower[part_lower])
            elif len(part) == 1 and part.isalpha():
                formatted_parts.append(part.upper())
            elif len(part) > 1 :
                # Capitalize only the first letter for unknown multi-char keys
                formatted_parts.append(part.capitalize())
            else:
                # Keep numbers/symbols as is (e.g., 1, plus, minus)
                # Tk uses 'plus', 'minus' for '+' '-' keys
                if part_lower == 'plus':
                    formatted_parts.append('+')
                elif part_lower == 'minus':
                    formatted_parts.append('-')
                else:
                    formatted_parts.append(part)


        # 3. Join the parts with "+"
        return "+".join(formatted_parts)



    def _update_emm_binding(self, new_bindings_list):
        """
        Updates bindings based on the new list provided.
        Filters out incompatible bindings (<Control-letter> required).
        If the list is empty after validation, uses the default binding.
        Compares with current bindings, unbinds removed ones, binds added ones.
        Handles binding both lowercase and uppercase for Control + letter combos.
        **Also updates the 'Switch to BeamNG' button label.**
        """
        # --- Input Type Validation ---
        if not isinstance(new_bindings_list, list):
            print(f"ERROR: _update_emm_binding received non-list: {new_bindings_list}. Using empty list.")
            new_bindings_list = [] # Corrected this line from original code comment

        # --- Binding Format Validation ---
        valid_bindings_list = []
        # Regex to match '<Control-' followed by a single letter (case-insensitive) and '>'
        valid_pattern = re.compile(r"^<Control-([a-zA-Z])>$")
        for binding in new_bindings_list:
            if isinstance(binding, str) and valid_pattern.match(binding):
                # Ensure we store the canonical lowercase version if needed,
                # or just keep the original valid one. Let's keep the original
                # format as the binding/unbinding logic handles case.
                 match = valid_pattern.match(binding)
                 lower_case_binding = f"<Control-{match.group(1).lower()}>"
                 if lower_case_binding not in valid_bindings_list: # Avoid duplicates after lowercasing
                     valid_bindings_list.append(lower_case_binding)

            else:
                print(f"Incompatible binding detected: '{binding}'. Only <Control-letter> bindings are supported. Skipping.")
        # --- Use the validated list from now on ---
        print(f"Validated bindings list: {valid_bindings_list}")


        # --- Calculate Differences ---
        current_bindings_set = set(self.current_emm_bindings)
        # Use the *validated* list to determine the new set
        new_bindings_set = set(valid_bindings_list)

        bindings_to_remove = current_bindings_set - new_bindings_set
        bindings_to_add = new_bindings_set - current_bindings_set

        # --- Unbind Removed ---
        if bindings_to_remove:
            print(f"Bindings to remove: {bindings_to_remove}")
            for binding in bindings_to_remove:
                # Unbinding logic already handles finding the uppercase variant
                # based on the lowercase stored version.
                upper_binding_to_unbind = None
                match_ctrl_lower = re.match(r"<Control-([a-z])>$", binding) # Match should work as we store lowercase
                if match_ctrl_lower:
                    lower_key = match_ctrl_lower.group(1)
                    upper_key = lower_key.upper()
                    upper_binding_to_unbind = f"<Control-{upper_key}>"
                else:
                     print(f"Warning: Could not parse binding to unbind for uppercase: {binding}")


                print(f"Unbinding: {binding}")
                try:
                    self.master.unbind_all(binding)
                except Exception as e:
                    print(f"Error unbinding {binding}: {e}")

                if upper_binding_to_unbind:
                    print(f"Unbinding uppercase: {upper_binding_to_unbind}")
                    try:
                        self.master.unbind_all(upper_binding_to_unbind)
                    except Exception as e:
                        print(f"Error unbinding {upper_binding_to_unbind}: {e}")

        # --- Bind Added ---
        if bindings_to_add:
            print(f"Bindings to add: {bindings_to_add}")
            for binding in bindings_to_add:
                # Binding logic already handles binding uppercase variant too
                upper_binding_to_bind = None
                match_ctrl_lower = re.match(r"<Control-([a-z])>$", binding) # Match should work as we store lowercase
                if match_ctrl_lower:
                    lower_key = match_ctrl_lower.group(1)
                    upper_key = lower_key.upper()
                    upper_binding_to_bind = f"<Control-{upper_key}>"
                else:
                     print(f"Warning: Could not parse binding to bind for uppercase: {binding}")

                print(f"Binding: {binding}")
                try:
                    self.master.bind_all(binding, self._emm_binding_callback)
                except Exception as e:
                    print(f"Error binding {binding}: {e}")

                if upper_binding_to_bind:
                    print(f"Binding uppercase: {upper_binding_to_bind}")
                    try:
                        self.master.bind_all(upper_binding_to_bind, self._emm_binding_callback)
                    except Exception as e:
                        print(f"Error binding {upper_binding_to_bind}: {e}")

        # --- Update State ---
        if bindings_to_remove or bindings_to_add:
             # Store the *validated* and processed list (which is now canonical lowercase)
            self.current_emm_bindings = list(valid_bindings_list)
            print(f"Current active EMM bindings updated to: {self.current_emm_bindings}")

        # --- Update Switch Button Label ---
        # This logic updates the button label based on the *contents* of self.current_emm_bindings
        display_binding_text = self.DEFAULT_SWITCH_DISPLAY_TEXT # Start with default

        if not self.current_emm_bindings:
            # List is empty (after validation), use default text
            display_binding_text = self.DEFAULT_SWITCH_DISPLAY_TEXT
        else:
            # List is not empty, check for default binding and others
            # Note: self.current_emm_bindings now contains only lowercase valid bindings
            other_bindings = [b for b in self.current_emm_bindings if b != self.DEFAULT_SWITCH_BINDING] # Find bindings *not* Ctrl+y

            if self.DEFAULT_SWITCH_BINDING in self.current_emm_bindings:
                # Default binding (<Control-y>) IS in the list
                if other_bindings:
                    # Use the first *other* binding found
                    display_binding_text = self._format_binding_for_display(other_bindings[0])
                else:
                    # Only the default binding is in the list, use its display text
                    display_binding_text = self.DEFAULT_SWITCH_DISPLAY_TEXT
            elif other_bindings:
                # Default binding is NOT in the list, but others are. Use the first one.
                 display_binding_text = self._format_binding_for_display(other_bindings[0])
            # else: Default binding not present and no other bindings (list was empty, handled above)

        # Ensure the button exists before trying to configure it
        if self.switch_to_beamng_button:
            self.new_button_label = f"Switch to BeamNG ({display_binding_text})"
            print(f"Updating button label to: {self.new_button_label}")
            self.switch_to_beamng_button.config(text=self.new_button_label)
        else:
            print("Warning: switch_to_beamng_button not created yet, cannot update label.")



        # These ensure Ctrl+Y always works, regardless of the list passed to _update_emm_binding

        self.master.bind_all("<Control-y>", lambda event: self.focus_beamng_window())
        self.master.bind_all("<Control-Y>", lambda event: self.focus_beamng_window())

    def _emm_binding_callback(self, event=None):
        """Wrapper callback function called by the dynamic binding."""
        # This ensures 'self' is correctly referenced
        print(f"focus_beamng_window SHOULD BE GETTING RAN RIGHT NOW")
        self.focus_beamng_window()




    def combined_configure_handler(self, event):
        """
        Combines the functionality of throttled_resize and update_window_geometries
        into a single handler for the <Configure> event.
        """
        self.throttled_resize(event)
        self.update_window_geometries(event)
        self.on_master_window_moved(event)

        
    def on_master_window_moved(self, event):
        """
        This method is called whenever the master window is moved or resized.
        It compares the current window position and size to the previous ones and
        triggers self.on_main_window_click() only if they are different.
        """
        current_x = self.master.winfo_x()
        current_y = self.master.winfo_y()
        current_width = self.master.winfo_width()
        current_height = self.master.winfo_height()

        if (current_x != self.prev_master_x or
            current_y != self.prev_master_y or
            current_width != self.prev_master_width or
            current_height != self.prev_master_height):

            #print("Master window was moved or resized (position or size changed)!")
            #print(f"Old position: x={self.prev_master_x}, y={self.prev_master_y}")
            #print(f"Old size: width={self.prev_master_width}, height={self.prev_master_height}")
            #print(f"New position: x={current_x}, y={current_y}")
            #print(f"New size: width={current_width}, height={current_height}")

            self.on_main_window_click(event, called_to_destroy=False)

            # Update previous position and size to the current ones
            self.prev_master_x = current_x
            self.prev_master_y = current_y
            self.prev_master_width = current_width
            self.prev_master_height = current_height
        else:
            #print("Master window was moved or resized, but position and size are unchanged.")
            pass
            
            
    def lift_search_results_window(self, event=None):
        """
        Lifts the search results window, details window, and filters window to the top when the main window gains focus,
        with existence checks and conditional lifting for details window.
        """
        if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
            #print("DEBUG: lift_search_results_window - Search Results window exists and is active - lifting.")
            self.search_results_window.lift()

        # --- MODIFIED: Check for details window existence AND if it's open before lifting ---
        if hasattr(self, 'details_window') and self.details_window and self.details_window.winfo_exists() and not self.details_window_closed:
            #print("DEBUG: lift_search_results_window - Details window exists and is OPEN - lifting and grabbing focus.")
            self.details_window.lift()
            #self.details_window.grab_set() # Grab focus only if details window is open
            if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
                self.current_detail_window.lift()

        #else:
            #print("DEBUG: lift_search_results_window - Details window NOT lifted (not existing or closed).")

        # --- MODIFIED: Check for filters window existence before lifting ---
        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            #print("DEBUG: lift_search_results_window - Filters window exists and Details window is CLOSED - lifting Filters window.")
            self.filters_window.lift()
        #elif hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists() and self.is_details_window_open():
             #print("DEBUG: lift_search_results_window - Filters window exists BUT Details window is OPEN - NOT lifting Filters window (Details window has priority).")
        elif hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.spawn_queue_window.lift()
        elif hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.hidden_window.lift()


        #else:
            #print("DEBUG: lift_search_results_window - Filters window NOT lifted (not existing or Details window is open).")
        # --- MODIFIED: Check for filters window existence before lifting ---
        
        # --- START: Dropdown menu destruction logic from on_main_window_click ---
        if self.is_filter_dropdown_open():
            self.destroy_filter_dropdown()
        if self.is_categorize_dropdown_open():
            self.destroy_categorize_dropdown()
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            self.destroy_search_mode_options_dropdown_menu()
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            self.destroy_settings_dropdown()
        if self.is_category_list_dropdown_open():
            self.destroy_category_list_dropdown()

        self.close_all_vehicle_dropdowns()
        
        filter_names = ["brand", "name", "country", "author", "bodystyle", "type"]
        for fname in filter_names:
            if self.is_sidebar_filter_dropdown_open(fname):
                self.destroy_sidebar_filter_dropdown(fname)
        # --- END: Dropdown menu destruction logic from on_main_window_click ---
        
        

    def lift_search_results_window_without_destroying_dropdowns(self, event=None):
        """
        Lifts the search results window, details window, and filters window to the top when the main window gains focus,
        with existence checks and conditional lifting for details window.
        """
        if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
            #print("DEBUG: lift_search_results_window - Search Results window exists and is active - lifting.")
            self.search_results_window.lift()
            self.lift_all_dropdowns()

        # --- MODIFIED: Check for details window existence AND if it's open before lifting ---
        if hasattr(self, 'details_window') and self.details_window and self.details_window.winfo_exists() and not self.details_window_closed:
            #print("DEBUG: lift_search_results_window - Details window exists and is OPEN - lifting and grabbing focus.")
            self.details_window.lift()
            #self.details_window.grab_set() # Grab focus only if details window is open
            if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
                self.current_detail_window.lift()

        #else:
            #print("DEBUG: lift_search_results_window - Details window NOT lifted (not existing or closed).")

        # --- MODIFIED: Check for filters window existence before lifting ---
        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            #print("DEBUG: lift_search_results_window - Filters window exists and Details window is CLOSED - lifting Filters window.")
            self.filters_window.lift()
            self.lift_all_dropdowns()

        #elif hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists() and self.is_details_window_open():
             #print("DEBUG: lift_search_results_window - Filters window exists BUT Details window is OPEN - NOT lifting Filters window (Details window has priority).")
        elif hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.spawn_queue_window.lift()
        elif hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.hidden_window.lift()

            self.lift_all_dropdowns()


        #else:
            #print("DEBUG: lift_search_results_window - Filters window NOT lifted (not existing or Details window is open).")
        # --- MODIFIED: Check for filters window existence before lifting ---


    def lift_all_dropdowns(self):
        """
        Lifts all currently open dropdown windows to the front.
        """
        dropdown_window_attributes = [
            'filter_dropdown_window',
            'categorize_dropdown_window',
            'search_mode_options_dropdown_window',
            'settings_dropdown_window',
            'category_list_dropdown_window',
            'zip_search_dropdown_window',
            'player_vehicle_dropdown_window',
            'remove_vehicles_dropdown_window',
            'add_vehicles_dropdown_window'
        ]

        print("\n--- lift_all_dropdowns() DEBUG ENTRY ---") # Debug Entry

        for attr_name in dropdown_window_attributes:
            dropdown_window = getattr(self, attr_name, None)  # Get attribute value, default to None if not exists
            if dropdown_window and dropdown_window.winfo_exists():
                print(f"  DEBUG: lift_all_dropdowns - Lifting dropdown window: {attr_name}") # Debug - Lifting Window
                dropdown_window.lift()
            else:
                print(f"  DEBUG: lift_all_dropdowns - Dropdown window NOT lifted: {attr_name} (not existing or not mapped)") # Debug - Window Not Lifted

        print("--- lift_all_dropdowns() DEBUG EXIT ---\n") # Debug Exit

        
        
    def on_main_window_click(self, event, called_to_destroy=False):
        """Handles clicks on the main window to close dropdown menus and unfocus search bar."""
        if self.is_filter_dropdown_open():
            if not self.is_descendant_of(event.widget, self.filter_dropdown_window):
                self.destroy_filter_dropdown()
        if self.is_categorize_dropdown_open():
            if not self.is_descendant_of(event.widget, self.categorize_dropdown_window):
                self.destroy_categorize_dropdown()
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            if not self.is_descendant_of(event.widget, self.search_mode_options_dropdown_window) and event.widget != self.search_mode_button and event.widget != self.search_entry:
                self.destroy_search_mode_options_dropdown_menu()
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            if not self.is_descendant_of(event.widget, self.settings_dropdown_window) and event.widget != self.settings_button:
                self.destroy_settings_dropdown()


        if self.is_category_list_dropdown_open(): # <-- ADDED THIS LINE
            if not self.is_descendant_of(event.widget, self.category_list_dropdown_window) and event.widget != self.category_list_button: # <-- AND THIS CONDITION
                self.master.after(100, self.destroy_category_list_dropdown) # <-- AND THIS CALL
                

        self.close_all_vehicle_dropdowns()   

        if not called_to_destroy:
            if event.widget != self.search_entry:
                self.master.focus_set()

            filter_names = ["brand", "name", "country", "author", "bodystyle", "type"]
            for fname in filter_names:
                if self.is_sidebar_filter_dropdown_open(fname):
                    dropdown_window = getattr(self, f"sidebar_{fname}_dropdown_window")
                    if not self.is_descendant_of(event.widget, dropdown_window):
                        self.destroy_sidebar_filter_dropdown(fname)


    def is_zip_search_dropdown_open(self):
        """Check if the zip search dropdown menu is currently open."""
        return hasattr(self, 'zip_search_dropdown_window') and self.zip_search_dropdown_window and self.zip_search_dropdown_window.winfo_exists()



        
        
    def show_search_mode_options_dropdown(self, event=None):
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            self.search_mode_options_dropdown_window.destroy()
            return

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot switch Search Mode while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return
        

        button = self.search_mode_button
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty() + button.winfo_height()

        self.search_mode_options_dropdown_window = FadingToplevel(self.master, self)
        self.search_mode_options_dropdown_window.overrideredirect(True)
        self.search_mode_options_dropdown_window.tk.call('tk', 'scaling', 1.25)
        self.search_mode_options_dropdown_window.geometry(f"+{button_x}+{button_y}")
        self.search_mode_options_dropdown_window.config(bg="#333333")
        self.search_mode_options_dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        search_modes = ["General", "Configs"] # Define search mode options
        self.current_tooltip_window = None # Initialize to None to track current tooltip

        def show_search_mode_option_tooltip(mode, button_widget): # Modified to take button_widget
            if self.current_tooltip_window:
                self.destroy_search_mode_option_tooltip_global_filter() # Destroy any existing tooltip

            self.current_tooltip_window = FadingToplevel(self.master, self)
            self.current_tooltip_window.overrideredirect(True) # No border for tooltip
            self.current_tooltip_window.tk.call('tk', 'scaling', 1.25)

            tip_text = ""
            if mode == "General":
                tip_text = "Search for Name, Brand, Type, Zip, etc..."
            elif mode == "Configs":
                tip_text = "Search for Config Name, Config File Name"

            tooltip_label = tk.Label(self.current_tooltip_window, text=tip_text, font=("Segoe UI", 10+self.font_size_add, "bold", "italic"), fg="#d9d9d9", bg="#555555", padx=5, pady=2, relief=tk.SOLID, borderwidth=1) # Darker bg for tooltip
            tooltip_label.pack(padx=1, pady=1) # Padding inside tooltip

            # Position tooltip to the right of the button
            button_width = button_widget.winfo_width()
            button_height = button_widget.winfo_height()
            button_abs_x = button_widget.winfo_rootx()
            button_abs_y = button_widget.winfo_rooty()

            tooltip_x = button_abs_x + button_width + 5 # 5px gap
            tooltip_y = button_abs_y + (button_height + 67) - (self.current_tooltip_window.winfo_reqheight() // 2)

            self.current_tooltip_window.geometry(f"+{tooltip_x}+{tooltip_y}")
            self.current_tooltip_window.after(4000, self.current_tooltip_window.destroy)

        def destroy_search_mode_option_tooltip():
            if self.current_tooltip_window:
                self.current_tooltip_window.destroy()
                self.current_tooltip_window = None


        def on_search_mode_option_click(mode):
            if mode == "Configs":
                # Destroy Filters Window
                if self.filters_window and self.filters_window.winfo_exists():
                    self.filters_window.destroy()
                    self.filters_window = None

                # Clear Global Filters and Reset Buttons
                entry_widgets = {}  # Assuming you have access to entry_widgets in this scope or can retrieve them
                on_off_button_style_args = self._create_button_style() # Or however you get button style args
                self.clear_all_filters_and_files(entry_widgets, on_off_button_style_args)


                # Disable Subset Mode
                self.is_data_subset_active = False
                self.subset_data_button.config(text="Off")
                self.reset_button_color(self.subset_data_button, self.button_style_args)

            self.search_var.set("") # Clear the search bar text
            self.search_mode = mode
            self.search_mode_button.config(text=f"Search Mode: {self.search_mode}")
            print("    on_search_mode_option_click is calling self.perform_search() and clearing the search bar - inner function of show_search_mode_options_dropdown")
            self.perform_search() # Perform search after mode change # <--- ADDED perform_search() HERE
            self.destroy_search_mode_options_dropdown_menu()
            destroy_search_mode_option_tooltip() # Destroy tooltip when option is clicked

            # Update Filters Button state based on search mode
            button_style_args = self._create_button_style()
            disabled_button_style_args = button_style_args.copy()
            disabled_button_style_args["fg"] = "grey"
            disabled_button_style_args["activebackground"] = "#555555"
            disabled_button_style_args["activeforeground"] = "grey"

            if self.search_mode == "Configs":
                self.filters_button.config(

                    state=tk.DISABLED
                )
                self.filters_button.unbind("<Enter>") # Unbind hover
                self.filters_button.unbind("<Leave>") # Unbind leave
                self.filters_button.unbind("<Button-1>") # Unbind click

            else: # General mode
                self.filters_button.config(

                    state=tk.NORMAL
                )

                initial_bg = self._get_validated_current_color(self.filters_button, "bg")
                initial_fg = self._get_validated_current_color(self.filters_button, "fg")

                self._bind_animated_hover(
                    button=self.filters_button,
                    original_bg=initial_bg,
                    original_fg=initial_fg,
                    hover_target_fg="#FFFFFF",
                    check_state=True
                )

        search_modes = ["General", "Configs"]
        dropdown_row = 0 # Assuming this is used for layout if not pack

        for mode in search_modes:
            # --- Define Colors ---
            default_bg_color = "#555555"
            default_fg_color = "#FFFFFF"

            selected_mode_bg = self.global_highlight_color
            selected_mode_fg = "#FFFFFF" # Assuming white text on highlight

            # Specific hover colors for these items
            item_hover_bg = "#d9d9d9"
            item_hover_fg = "black"

            # --- Determine if this mode is currently selected ---
            is_selected = (mode == self.search_mode) # Ensure self.search_mode exists and is current

            # --- Button Creation ---
            dropdown_button = tk.Button(
                self.search_mode_options_dropdown_window, # Ensure this window exists
                text=f"{mode}",
                font=("Segoe UI", 10 + self.font_size_add, "bold"),
                command=lambda m=mode: on_search_mode_option_click(m), # Ensure this handler exists
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5
                # bg and fg are set by _bind_animated_hover
            )
            # Set active colors (for instant click flash)
            dropdown_button.config(
                activebackground=item_hover_bg,
                activeforeground=item_hover_fg
            )
            dropdown_button.pack(fill="x")

            # --- Define Extra Commands for Tooltips ---
            # Lambdas capture the current 'mode' and 'dropdown_button' for each iteration
            enter_tooltip_command = lambda m=mode, btn=dropdown_button: show_search_mode_option_tooltip(m, btn)
            leave_tooltip_command = lambda: destroy_search_mode_option_tooltip()

            # --- Apply Smooth Hover Animation with Extra Commands ---
            self._bind_animated_hover(
                button=dropdown_button,
                original_bg=default_bg_color,
                original_fg=default_fg_color,
                hover_target_bg=item_hover_bg,
                hover_target_fg=item_hover_fg,
                check_state=False, # Assuming not disabled
                is_selected_initial=is_selected,
                selected_bg=selected_mode_bg,
                selected_fg=selected_mode_fg,
                on_enter_extra_command=enter_tooltip_command, # Pass tooltip show command
                on_leave_extra_command=leave_tooltip_command   # Pass tooltip destroy command
            )
            dropdown_row += 1

        self.search_mode_options_dropdown_window.bind("<FocusOut>", self.destroy_search_mode_options_dropdown) # Bind focus out to window


        


    def destroy_search_mode_options_dropdown_menu(self):
        self.is_search_results_window_closing = True # <--- SET FLAG BEFORE DESTROY
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            self.search_mode_options_dropdown_window.destroy()
            self.search_mode_options_dropdown_window = None
        self.is_search_results_window_closing = False # <--- RESET FLAG AFTER DESTROY

            
            
    def is_sidebar_filter_dropdown_open(self, filter_name):
        dropdown_attr_name = f"sidebar_{filter_name}_dropdown_window"
        return hasattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name).winfo_exists()
        
    # --- Helper functions to check if dropdowns are open ---
    def is_filter_dropdown_open(self):
        return hasattr(self, 'filter_dropdown_window') and self.filter_dropdown_window and self.filter_dropdown_window.winfo_exists()


    def is_categorize_dropdown_open(self):
        return hasattr(self, 'categorize_dropdown_window') and self.categorize_dropdown_window and self.categorize_dropdown_window.winfo_exists()

    def is_category_list_dropdown_open(self): # <-- ADDED THIS FUNCTION
        return hasattr(self, 'category_list_dropdown_window') and self.category_list_dropdown_window and self.category_list_dropdown_window.winfo_exists()







    def initialize_data_and_grid(self):
        self.grouped_data = self.format_grouped_data(self.data)
        print("    initialize_data_and_grid is calling self.populate_initial_grid()")
        self.populate_initial_grid()
        self.details_sidebar_debounce_timer = None # Initialize debounce timer for details sidebar
        self.current_main_sidebar_item = None # To store the currently selected item in main grid sidebar

        print(f"config_pics_custom_folder: {self.config_pics_custom_folder}")  # Debugging print







    def show_scanning_window(self, text="Changes detected, scanning...", tall=False, medium=False, click_dismiss=False, dev_notif=None):
        self.show_scanning_window_count += 1 # Increment the counter each time the function is called


        if self.show_scanning_window_count <= 2 or \
            "scan" in text.lower() or \
            "disappears" in text.lower() or \
            "loading" in text.lower() or \
            "saving" in text.lower() or \
            "rebuilding" in text.lower() or \
            "updating" in text.lower() or \
            "running" in text.lower() or \
            "minimized" in text.lower() or \
            "attempts" in text.lower() or \
            "restarting" in text.lower() or \
            "initial" in text.lower() or \
            "dev notif" in text.lower() or \
            "launching" in text.lower() or \
            "empty" in text.lower():


            #if self.dev_mode and "loading" in text.lower():
            #    return
            
        
            if self.show_scanning_window_count <= 2 or dev_notif:
                scanning_window = tk.Toplevel(self.master)
            else:
                scanning_window = FadingToplevel(self.master, self, fade_in_duration_ms=0)
        else:

            scanning_window = FadingToplevel(self.master, self)



        scanning_window.bind("<Button-1>", self.destroy_scanning_window)



        
        scanning_window.title("Ellexium's Advamced Vehicle Selector")

        icon_path = self.script_dir / "data/icon.png"

        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            scanning_window.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")

        scanning_window.attributes('-topmost', True)
        #scanning_window.overrideredirect(True)  # Remove window border
        scanning_window.tk.call('tk', 'scaling', 1.25)
        scanning_window.resizable(False, False)

        # Define scanning window size - default values
        window_width = 600
        window_height = 70

        # Check if text contains "restart the game" and adjust window size if it does
        if "restart the game" in text.lower(): # Convert text to lowercase for case-insensitive check
            window_width = 700  # little wider than default
            window_height = 140 # x2 regular scan win

        # Check if text contains "disappears" and adjust window size if it does
        if "disappears" in text.lower() or "other categories" in text.lower(): # Convert text to lowercase for case-insensitive check
            window_width = 600 
            window_height = 140 


        if medium:
            window_width = 600 
            window_height = 140 

        if tall:
            window_width = 700  
            window_height = 160 


        if dev_notif:
            scanning_window.configure(bg="green")
        else:
            scanning_window.configure(bg="#333333")  # Set background color

        # Ensure the main window's geometry is updated
        self.master.update_idletasks()

        # --- Centering Logic ---
        if self.show_scanning_window_count <= 2:
            # Center on screen for the first two calls
            screen_width = scanning_window.winfo_screenwidth()
            screen_height = scanning_window.winfo_screenheight()
            pos_x = (screen_width // 2) - (window_width // 2)
            pos_y = (screen_height // 2) - (window_height // 2)
            scanning_window.overrideredirect(True)  # Remove window border
            scanning_window.config(highlightthickness=5, highlightbackground="#555555") # Add border here

            
        else:
            # Center relative to master window for subsequent calls
            # Get main window's position and size
            master_x = self.master.winfo_rootx()
            master_y = self.master.winfo_rooty()
            master_width = self.master.winfo_width()
            master_height = self.master.winfo_height()
            

            # Calculate position for the scanning window to be centered relative to master
            pos_x = master_x + (master_width // 2) - (window_width // 2)
            pos_y = master_y + (master_height // 2) - (window_height // 2)
            scanning_window.overrideredirect(True)  # Remove window border
            scanning_window.config(highlightthickness=5, highlightbackground="#555555") # Add border here
            # Schedule destroy_lingering_scanning_windows after 7 seconds

            if "scanning and refreshing data" in text.lower(): # Convert text to lowercase for case-insensitive check
                scanning_window.after(13000, lambda window=scanning_window: window.destroy())
                # pass # do not destroy the window, something else will handle it

            else:
                if not click_dismiss:
                    scanning_window.after(7000, lambda window=scanning_window: window.destroy())

                #if click_dismiss:
                #    scanning_window.bind("<Button-1>", self.destroy_warning_scanning_window)
   

        # --- START: Added code to save position ---
        try:
            data_folder = self.script_dir / "data"
            position_file_path = data_folder / "scanning_window_position.txt"

            with open(position_file_path, 'w') as f:
                f.write(f"{pos_x},{pos_y}") # Save as comma-separated x,y
            print(f"Saved scanning window position ({pos_x},{pos_y}) to {position_file_path}") # Optional confirmation

        except Exception as e:
            print(f"Error saving scanning window position: {e}")



        # Set the geometry of the scanning window
        scanning_window.geometry(f"{window_width}x{window_height}+{pos_x}+{pos_y}")


        lbl = tk.Label(
            scanning_window,
            text=text,
            font=("Segoe UI", 12, "bold"),
            fg="#ffffff",  # Start with white text (or very light grey)
            bg="#333333"
        )
        lbl.pack(expand=True, padx=20, pady=20)

        if click_dismiss:
            self._start_fade_loop(lbl, self.warning_color_sidebar, self.default_sidebar_color)


        scanning_window.update()

        return scanning_window

    def destroy_scanning_window(self, event=None):
        """Destroys the scanning window if it exists."""
        
        self.scanning_window.destroy()

        if self.scanning_window:
            self.scanning_window.destroy()
            self.scanning_window = None

        if self.warning_scanning_win:
            self.warning_scanning_win.destroy()
            self.warning_scanning_win = None


        return

    

    ######################################################################
    #               start of interaction with beamng                  #
    ######################################################################

    def focus_beamng_window(self):
        beamng_window_handle = None
        window_title_regex = r"BeamNG\.drive.*"  # CHANGED REGEX HERE!
        process_name_check = 'BeamNG.drive.x64.exe'

        def window_enum_handler(hwnd, wildcard):
            nonlocal beamng_window_handle

            if not win32gui.IsWindowVisible(hwnd): # First check if window is visible, skip if not
                return True

            # --- Use ctypes to call GetWindowThreadProcessId ---
            try:
                process_id = ctypes.c_ulong()
                thread_id = ctypes.c_ulong()

                # GetWindowThreadProcessId function from user32.dll
                get_process_thread_id_func = ctypes.windll.user32.GetWindowThreadProcessId
                get_process_thread_id_func(hwnd, ctypes.byref(process_id)) # Call the function

                process_id = process_id.value # Extract process ID value
                thread_id_val = thread_id.value # Not really needed in this ctypes version, but kept for potential debugging

                last_error = ctypes.GetLastError() # Get last error using ctypes


            except Exception as e_ctypes_call: # Catch exceptions during ctypes call
                return True # Skip to next window
            # --- End ctypes call ---


            process_name = None # Initialize process_name
            try:
                current_process = psutil.Process(process_id) # Try to get process object IMMEDIATELY
                process_name = current_process.name() # Get process name
            except psutil.NoSuchProcess as e: # Catch NoSuchProcess right after PID retrieval
                return True # Skip to next window
            except Exception as e_process_get: # Catch any other exception when getting process info
                return True


            if process_name != process_name_check: # Check process name *before* title
                return True # Not BeamNG.drive, skip to next window

            # ONLY if it's the correct process, check the title:
            window_text = win32gui.GetWindowText(hwnd)
            match_result = re.search(window_title_regex, window_text)

            if match_result:
                beamng_window_handle = hwnd
                return False # Stop enumeration

            return True # Continue enumeration

        # --- MODIFIED: Try-except block with retry for EnumWindows ---
        attempts = 2  # Number of attempts
        for attempt in range(attempts):
            try:
                win32gui.EnumWindows(window_enum_handler, None)
                break  # If EnumWindows succeeds, break out of the loop
            except pywintypes.error as e:
                if e.args[0] == 2 and attempt < attempts - 1: # Check for error code 2 and if retries are remaining
                    print(f"Warning: EnumWindows failed on attempt {attempt + 1} with error: {e}. Retrying in 0.1s...")
                    time.sleep(0.1) # Small delay before retry
                    continue # Retry EnumWindows
                else:
                    print(f"Error: EnumWindows failed after {attempts} attempts with error: {e}")
                    break # Break loop if it's not error code 2 or no retries left
        # --- MODIFIED: Try-except block with retry for EnumWindows ---

        if beamng_window_handle:
            

            #if win32gui.IsIconic(beamng_window_handle): # Check if minimized
            #    print("BeamNG.drive window is minimized.") # Optional print for console
            #    return False # Stop focusing and return False
            #else:
            #    win32gui.ShowWindow(beamng_window_handle, 5) # SW_RESTORE
            #    win32gui.SetForegroundWindow(beamng_window_handle)
            #    self.on_details_window_close()
            #    return True

            is_minimized = win32gui.IsIconic(beamng_window_handle) # Check if minimized

            if is_minimized:
                print("BeamNG.drive window is minimized. Restoring...") # Optional print for console
                # Restore the window from minimized state.
                # SW_RESTORE activates and displays the window. If the window is minimized
                # or maximized, the system restores it to its original size and position.
                win32gui.ShowWindow(beamng_window_handle, win32con.SW_RESTORE)

            # Now, whether it was minimized or just inactive,
            # bring the window to the foreground.
            # Note: SW_RESTORE might already bring it somewhat forward, but
            # SetForegroundWindow is more forceful/explicit about giving it focus.
            try:
                # Sometimes SetForegroundWindow needs the window to be shown first,
                # which SW_RESTORE does.
                win32gui.SetForegroundWindow(beamng_window_handle)
            except Exception as e:
                # SetForegroundWindow can sometimes fail due to OS restrictions
                # (e.g., another app forcefully holding focus).
                # If it fails, the window should still be restored (if it was minimized)
                # or remain visible (if it was just in the background).
                print(f"Warning: Could not set foreground window: {e}")
                # As a fallback, ensure it's at least shown/activated if it wasn't minimized
                if not is_minimized:
                    win32gui.ShowWindow(beamng_window_handle, win32con.SW_SHOW) # SW_SHOW (5) activates

            if not self.leave_config_window_open:
                self.details_window_intentionally_closed = True
                
                self.on_details_window_close() # Call your function regardless
            return True


            
        else:
            print("BeamNG.drive window not found.") # Keep this print
            return False

    def is_beamng_running(self):
        process_name = 'BeamNG.drive.x64.exe'
        print(f"Checking if process '{process_name}' is running...")
        for proc in psutil.process_iter(['name', 'exe']): # Request 'exe' in process info
            if proc.info['name'] == process_name:
                exe_path = proc.info['exe'] # Get the executable path
                print(f"Process '{process_name}' is running. Executable path: '{exe_path}'") # Print path
                return True
        print(f"Process '{process_name}' is not running.")
        return False
    



    def focus_config_viewer_from_floating_button_layer_2(self):
        """
        Attempts to restore/show the main selflication window (self.master),
        bring it to the foreground, and give it keyboard input focus.

        Args:
            self: The selflication instance ('self').

        Returns:
            True if focus attempt was likely successful, False otherwise.
        """


        try:
            # Ensure the master window actually exists
            if not self.master.winfo_exists():
                print("Error: Main window (self.master) does not exist.")
                return False

            hwnd = self.master.winfo_id()
            print(f"Debug: Targeting HWND: {hwnd} for window '{self.master.title()}'")

            # --- Update Tkinter's state *before* Win32 checks ---
            # This might help sync the states if Tkinter hid the window itself
            self.master.update_idletasks()

        except Exception as e:
            print(f"Error getting main window HWND or checking existence: {e}")
            return False

        try:
            # --- Step 1: Determine State and Restore/Show if Necessary ---
            needs_showing = False
            is_minimized = False
            show_command = win32con.SW_SHOWNORMAL # Default command if not minimized but hidden

            try:
                placement = win32gui.GetWindowPlacement(hwnd)
                current_state = placement[1] # showCmd value
                print(f"Debug: Current window placement state (showCmd): {current_state}")

                if current_state in [win32con.SW_SHOWMINIMIZED, win32con.SW_MINIMIZE, win32con.SW_SHOWMINNOACTIVE]:
                    print(f"Main window (HWND: {hwnd}) detected as minimized.")
                    is_minimized = True
                    needs_showing = True
                    show_command = win32con.SW_RESTORE # Use RESTORE for minimized windows
                elif not win32gui.IsWindowVisible(hwnd):
                    # It's not minimized, but it's not visible either (e.g., withdrawn)
                    print(f"Main window (HWND: {hwnd}) detected as not visible (but not minimized).")
                    needs_showing = True
                    # Keep default show_command = SW_SHOWNORMAL (or try SW_SHOW)
                    show_command = win32con.SW_SHOW # SW_SHOW might be slightly better here
                else:
                    print(f"Main window (HWND: {hwnd}) is already visible and not minimized.")
                    needs_showing = False

            except pywintypes.error as e_place:
                print(f"Warning: Could not get window placement for HWND {hwnd}: {e_place}. Falling back to IsIconic/IsWindowVisible.")
                try:
                    if win32gui.IsIconic(hwnd):
                        print(f"Main window (HWND: {hwnd}) detected as minimized (IsIconic fallback).")
                        is_minimized = True
                        needs_showing = True
                        show_command = win32con.SW_RESTORE
                    elif not win32gui.IsWindowVisible(hwnd):
                        print(f"Main window (HWND: {hwnd}) detected as not visible (IsWindowVisible fallback).")
                        needs_showing = True
                        show_command = win32con.SW_SHOW # Use SHOW if just invisible
                    else:
                        print(f"Main window (HWND: {hwnd}) selfears visible (fallback check).")
                        needs_showing = False
                except pywintypes.error as e_fallback:
                    print(f"Error: Could not determine visibility state via fallbacks for HWND {hwnd}: {e_fallback}")
                    # Proceed with caution, assume needs showing? Or return False? Let's try showing.
                    needs_showing = True
                    show_command = win32con.SW_SHOW

            # If determined it needs showing/restoring:
            if needs_showing:
                print(f"Attempting ShowWindow(hwnd, {show_command}) for HWND: {hwnd}...")
                try:
                    # BringWindowToTop *before* ShowWindow might sometimes help prepare it
                    # win32gui.BringWindowToTop(hwnd)
                    # time.sleep(0.05)

                    win32gui.ShowWindow(hwnd, show_command)
                    print(f"Debug: Called ShowWindow with command {show_command}.")
                    # Give window manager time & update Tkinter
                    time.sleep(0.15) # Keep slightly longer delay
                    self.master.update_idletasks()
                    print(f"Debug: Called update_idletasks after ShowWindow.")

                    # --- Verification ---
                    visible_after = win32gui.IsWindowVisible(hwnd)
                    placement_after = win32gui.GetWindowPlacement(hwnd)
                    state_after = placement_after[1]
                    print(f"Debug: State after ShowWindow: Visible={visible_after}, Placement={state_after}")

                    if not visible_after or state_after in [win32con.SW_SHOWMINIMIZED, win32con.SW_MINIMIZE, win32con.SW_SHOWMINNOACTIVE]:
                        print(f"Warning: Window HWND {hwnd} still not visible or is minimized after ShowWindow command {show_command}. Trying BringWindowToTop/SetForeground anyway.")
                        # Try BringWindowToTop as a last resort visibility attempt before focus
                        try:
                            win32gui.BringWindowToTop(hwnd)
                            time.sleep(0.05)
                            print("Debug: Called BringWindowToTop as extra measure.")
                        except Exception as e_bring:
                            print(f"Debug: BringWindowToTop failed: {e_bring}")
                    else:
                        print("Debug: Window selfears successfully restored/shown.")

                except pywintypes.error as e_show:
                    print(f"Error during ShowWindow command {show_command} for HWND {hwnd}: {e_show}")
                    # If showing fails, focus likely won't work, but we can still try
                except Exception as e_show_general:
                    print(f"Unexpected error during window showing: {e_show_general}")

            # --- Step 2 & 3: Attempt Focus (Keep previous logic) ---
            focus_success = False
            try:
                # --- Attempt Direct Focus ---
                print(f"Attempting SetForegroundWindow for HWND: {hwnd}")
                win32gui.SetForegroundWindow(hwnd)
                time.sleep(0.05)
                if win32gui.GetForegroundWindow() == hwnd:
                    print("SetForegroundWindow succeeded and confirmed foreground.")
                    self.master.focus_force()
                    self.master.update_idletasks()
                    focus_success = True
                    # Optional: self.on_details_window_close()
                else:
                    print("SetForegroundWindow called, but window did not become foreground. Proceeding to hack.")
                    # Fall through

            except pywintypes.error as e_fg:
                print(f"SetForegroundWindow failed initially (Error: {e_fg.winerror} - {e_fg}). Attempting workaround...")
                # Fall through
            except Exception as e_fg_general:
                print(f"Unexpected error during initial SetForegroundWindow: {e_fg_general}. Attempting workaround...")
                # Fall through

            # --- Focus Hack Attempt (only if direct focus failed) ---
            if not focus_success:
                current_thread_id = win32api.GetCurrentThreadId()
                # Need to re-get target_thread_id in case window was recreated? Unlikely but safe.
                target_thread_id, _ = win32process.GetWindowThreadProcessId(hwnd)
                attached = False

                try:
                    if current_thread_id != target_thread_id:
                        # Check if already attached from a previous attempt (shouldn't hselfen with finally block, but safe)
                        # Note: Checking attachment state directly is complex. Assume not attached.
                        print(f"Attaching input thread {current_thread_id} to {target_thread_id}")
                        win32process.AttachThreadInput(current_thread_id, target_thread_id, True)
                        attached = True

                    print("Simulating ALT key press/release...")
                    win32api.keybd_event(win32con.VK_MENU, 0, 0, 0)
                    time.sleep(0.02)
                    win32api.keybd_event(win32con.VK_MENU, 0, win32con.KEYEVENTF_KEYUP, 0)
                    time.sleep(0.05)

                    print(f"Retrying SetForegroundWindow for HWND: {hwnd} after workaround...")
                    win32gui.SetForegroundWindow(hwnd)
                    time.sleep(0.05)

                    if win32gui.GetForegroundWindow() == hwnd:
                        print("SetForegroundWindow succeeded after workaround and confirmed foreground.")
                        focus_success = True
                    else:
                        print("SetForegroundWindow hack did not result in foreground. Trying BringWindowToTop.")
                        win32gui.BringWindowToTop(hwnd)
                        time.sleep(0.05)
                        if win32gui.GetForegroundWindow() == hwnd:
                            print("BringWindowToTop selfears to have brought it to foreground.")
                            focus_success = True # Consider this success
                        else:
                            print("Focus could not be guaranteed even after workarounds.")
                            focus_success = False

                    if focus_success:
                        self.master.focus_force()
                        self.master.update_idletasks()

                except pywintypes.error as e_hack:
                    print(f"Error during focus hack (Error: {e_hack.winerror} - {e_hack}).")
                    focus_success = False # Ensure it's false on error
                except Exception as e_hack_general:
                    print(f"Unexpected error during focus hack: {e_hack_general}")
                    focus_success = False # Ensure it's false on error
                finally:
                    if attached:
                        try:
                            print(f"Detaching input thread {current_thread_id} from {target_thread_id}")
                            win32process.AttachThreadInput(current_thread_id, target_thread_id, False)
                        except Exception as e_detach:
                            print(f"Warning: Error detaching thread input: {e_detach}")


            # --- Optional: Close details window ---
            # if focus_success:
                # self.on_details_window_close()

            self.lift_search_results_window()

            self.search_entry.focus_set()

            self.skip_perform_search = False
            print("skip_perform_search reset to FALSE")

            return focus_success

        except Exception as e_main:
            print(f"General error during main window focus attempt: {e_main}")
            return False


    def _clear_ignore_state(self):
        """Called by the timer to end the ignore period and re-enable input."""
        print("DEBUG: KeyRelease ignore period ended.")

        # --- Re-enable the search entry ---
        try:
            # Check if it's currently disabled *before* enabling,
            # although enabling a normal entry is harmless.
            if self.search_entry.cget('state') == tk.DISABLED:
                print("DEBUG: Re-enabling search entry.")
                self.search_entry.config(state=tk.NORMAL)
            else:
                 print("DEBUG: Search entry was already enabled when ignore period ended.")
        except AttributeError:
             print("ERROR: self.search_entry does not exist when trying to re-enable.")
             # Handle error
        except tk.TclError as e:
             print(f"WARN: Error re-enabling search entry (maybe destroyed?): {e}")

        # --- Clear the timer ID ---
        self._ignore_keyrelease_timer_id = None

    def send_escape(self, event=None):

        if not self.is_beamng_running():
            #messagebox.showerror("Error", "BeamNG.drive is not running.")
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="BeamNG.drive does not appear to be running.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()
            return False # Indicate failure
        self.details_window_intentionally_closed = True
        self.on_details_window_close()
        print("BeamNG.drive is running.") # Added print
        #time.sleep(0.125) # Reduced time.sleep to quarter

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        time.sleep(0.125) # Reduced time.sleep to quarter
        if not self.focus_beamng_window():

            scanning_win = self.show_scanning_window(text="Please ensure BeamNG.drive is open and not minimized.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()

            #messagebox.showerror("Error", "BeamNG.drive window not found.")
            return False # Indicate failure

        print("BeamNG.drive window focused.") # Added print
        #time.sleep(0.125) # Reduced time.sleep to quarter


        pydirectinput.keyDown('esc')
        time.sleep(0.125)
        pydirectinput.keyUp('esc')
        

    def send_j(self, event=None):

        if not self.is_beamng_running():
            #messagebox.showerror("Error", "BeamNG.drive is not running.")
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="BeamNG.drive does not appear to be running.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()
            return False # Indicate failure
        self.details_window_intentionally_closed = True
        self.on_details_window_close()
        print("BeamNG.drive is running.") # Added print
        #time.sleep(0.125) # Reduced time.sleep to quarter

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        time.sleep(0.125) # Reduced time.sleep to quarter
        if not self.focus_beamng_window():

            scanning_win = self.show_scanning_window(text="Please ensure BeamNG.drive is open and not minimized.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()

            #messagebox.showerror("Error", "BeamNG.drive window not found.")
            return False # Indicate failure

        print("BeamNG.drive window focused.") # Added print


        pydirectinput.keyDown('j')
        time.sleep(0.125)
        pydirectinput.keyUp('j')

        

    def run_spawn_queue(self, retry=False, attempt_number=1):


        if retry:
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text=f"Spawn queue spawning attempts: {attempt_number}")
            time.sleep(0.725)
            if scanning_win:
                scanning_win.destroy()


        scanning_window = None # Initialize scanning_window outside try block

        scanning_window = self.show_scanning_window(text="Attempting to spawn multiple vehicles from Spawn Queue, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
        # Make the window visible
        scanning_window.deiconify()
        self.master.update_idletasks() # Force window to appear immediately

        try:
            with open(self.SPAWN_QUEUE_FILE, 'r', encoding="utf-8") as f:
                commands = f.readlines()
                pass

        except FileNotFoundError:

            print(f"spawn queue file doesn't exist")

        
            scanning_win = self.show_scanning_window(text="Spawn queue empty.")

            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
                self.show_spawn_queue_window()
            return



        if not self.is_beamng_running():
            #messagebox.showerror("Error", "BeamNG.drive is not running.")
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="BeamNG.drive does not appear to be running.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()
            return False # Indicate failure


        print("BeamNG.drive is running.") # Added print
        time.sleep(1.125) # Reduced time.sleep to quarter

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        time.sleep(1.125) # Reduced time.sleep to quarter
        if not self.focus_beamng_window():

            scanning_win = self.show_scanning_window(text="Please ensure BeamNG.drive is open and not minimized.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()

            #messagebox.showerror("Error", "BeamNG.drive window not found.")
            return False # Indicate failure

        print("BeamNG.drive window focused.") # Added print
        time.sleep(1.125) # Reduced time.sleep to quarter

        self.focus_beamng_window()

        pydirectinput.keyDown('shift')
        pydirectinput.keyDown('ctrl')
        pydirectinput.keyDown('alt')
        pydirectinput.keyDown('f11')

        # Wait for the specified hold time
        time.sleep(0.125)

        pydirectinput.keyUp('f11')
        pydirectinput.keyUp('alt')
        pydirectinput.keyUp('ctrl')
        pydirectinput.keyUp('shift')

        self.details_window_intentionally_closed = True
        self.on_details_window_close()

        if scanning_window:
            scanning_window.destroy() # Destroy the scanning window after spawn attempt
        
        print(f"Spawn Queue actions completed. ATTEMPT {attempt_number}") # Updated message


        data_folder = self.script_dir / "data"
        COMMANDconfirmation = data_folder / "commandconfirmation.txt"

        max_attempts = 7

        # --- NOW CHECK FOR THE FILE AFTER RUNNING ACTIONS ---
        print(f"Checking for file '{COMMANDconfirmation}' - Attempt {attempt_number}/{max_attempts}...")
        if os.path.exists(COMMANDconfirmation):
            print(f"File '{COMMANDconfirmation}' exists after actions on attempt {attempt_number}. Deleting it.")
            try:
                os.remove(COMMANDconfirmation)
                print(f"File '{COMMANDconfirmation}' deleted successfully.")
                return True # Indicate success (file existed and was deleted)
            except OSError as e:
                print(f"Error deleting file '{COMMANDconfirmation}': {e}")
                return False # Indicate failure (file deletion error)

        else: # File does not exist AFTER running actions
            if attempt_number >= max_attempts: # Check attempt number for max retries
                print(f"File '{COMMANDconfirmation}' still does not exist after {max_attempts} attempts. Stopping.")

                scanning_win = None  # Initialize scanning_win

                scanning_win = self.show_scanning_window(text=f"Maximum number of attempts ({attempt_number}) to spawn multiple vehicles from Spawn Queue reached. \nPlease ensure EllexiumModManagerInput.zip is in the mods folder and restart the game.")
                time.sleep(5.725)
                if scanning_win:
                    scanning_win.destroy()

                return False # Indicate failure (file never appeared after max attempts)
            else:
                print(f"File '{COMMANDconfirmation}' does not exist on attempt {attempt_number}. Retrying function...")
                time.sleep(1.125) # Reduced time.sleep to quarter
                return self.run_spawn_queue(retry=True, attempt_number=attempt_number + 1) # Recursive call, incrementing attempt_number


    def run_spawn_queue_transient(self, retry=False, attempt_number=1): # NEW FUNCTION FOR TRANSIENT QUEUE, added retry parameter


        if retry:
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text=f"Spawn/Replace/Delete/Save attempts: {attempt_number}")
            time.sleep(0.725)
            if scanning_win:
                scanning_win.destroy()



        # --- RUN THE FUNCTION ACTIONS FIRST ---
        if not self.is_beamng_running():
            #messagebox.showerror("Error", "BeamNG.drive is not running.")
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="BeamNG.drive does not appear to be running.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()
            return False # Indicate failure


        print("BeamNG.drive is running.") # Added print
        time.sleep(1.125) # Reduced time.sleep to quarter

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        time.sleep(1.125) # Reduced time.sleep to quarter
        if not self.focus_beamng_window():

            scanning_win = self.show_scanning_window(text="Please ensure BeamNG.drive is open and not minimized.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()

            #messagebox.showerror("Error", "BeamNG.drive window not found.")
            return False # Indicate failure

        print("BeamNG.drive window focused.") # Added print

        self.focus_beamng_window()

        # Press and hold Shift, Ctrl, and Alt keys
        pydirectinput.keyDown('shift')
        pydirectinput.keyDown('ctrl')
        pydirectinput.keyDown('alt')
        pydirectinput.keyDown('f12')

        # Wait for the specified hold time
        time.sleep(0.125)


        pydirectinput.keyUp('f12')
        pydirectinput.keyUp('alt')
        pydirectinput.keyUp('ctrl')
        pydirectinput.keyUp('shift')

            
        if not self.leave_config_window_open:
            self.details_window_intentionally_closed = True        


            self.master.after(2000, self.on_details_window_close)
        

        print(f"Transient Spawn Queue actions completed. ATTEMPT {attempt_number}") # Updated message


        data_folder = self.script_dir / "data"
        COMMANDconfirmation = data_folder / "commandconfirmation.txt"

        max_attempts = 7 #change back to 7

        # --- NOW CHECK FOR THE FILE AFTER RUNNING ACTIONS ---
        print(f"Checking for file '{COMMANDconfirmation}' - Attempt {attempt_number}/{max_attempts}...")
        if os.path.exists(COMMANDconfirmation):
            print(f"File '{COMMANDconfirmation}' exists after actions on attempt {attempt_number}. Deleting it.")
            try:
                os.remove(COMMANDconfirmation)
                print(f"File '{COMMANDconfirmation}' deleted successfully.")
                return True # Indicate success (file existed and was deleted)
            except OSError as e:
                print(f"Error deleting file '{COMMANDconfirmation}': {e}")
                return False # Indicate failure (file deletion error)

        else: # File does not exist AFTER running actions
            if attempt_number >= max_attempts: # Check attempt number for max retries
                print(f"File '{COMMANDconfirmation}' still does not exist after {max_attempts} attempts. Stopping.")

                scanning_win = None  # Initialize scanning_win

                scanning_win = self.show_scanning_window(text=f"Maximum number of attempts ({attempt_number}) to spawn, replace, save or delete vehicle(s) reached. \nPlease ensure EllexiumModManagerInput.zip is in the mods folder and restart the game.")
                time.sleep(5.725)
                if scanning_win:
                    scanning_win.destroy()

                return False # Indicate failure (file never appeared after max attempts)
            else:
                print(f"File '{COMMANDconfirmation}' does not exist on attempt {attempt_number}. Retrying function...")
                time.sleep(1.125) # Reduced time.sleep to quarter
                return self.run_spawn_queue_transient(retry=True, attempt_number=attempt_number + 1) # Recursive call, incrementing attempt_number


    def spawn_random_vehicle(self, event=None, vehicle_type=None, replace_current=False):
        """
        Selects a random vehicle configuration from specified types,
        displays informative feedback, prevents too many consecutive same-brand spawns,
        optionally replaces the current vehicle, and uses the transient spawn queue.

        Args:
            event: Optional event data (e.g., from Tkinter binding).
            vehicle_type (str, optional): If specified, only vehicles of this type
                                         (case-insensitive) are considered.
                                         Defaults to None (uses the default whitelist).
            replace_current (bool): If True, use 'replaceVehicle' instead of
                                    'spawnNewVehicle'. Defaults to False.
        """
        print(f"\n--- spawn_random_vehicle() ENTRY (Type: {vehicle_type or 'Whitelisted'}, Replace: {replace_current}) ---")

        # Determine allowed types
        if vehicle_type:
            # Use the specified type, making it lowercase and putting it in a set
            try:
                allowed_types = {vehicle_type.strip().lower()}
                print(f"  Filtering for specific type: {allowed_types}")
            except AttributeError:
                 print(f"Error: Invalid vehicle_type provided: {vehicle_type}. Must be a string.")
                 messagebox.showerror("Error", f"Invalid vehicle type specified: {vehicle_type}")
                 return
        else:
            # Default whitelist
            allowed_types = {'car', 'truck', 'bus', 'van', 'aircraft'}
            print(f"  Using whitelisted types: {allowed_types}")

        # 1. Gather potential candidates (tuples) for allowed types
        #    Store: (spawn_cmd, info_data, folder_name, zip_file)
        filtered_candidates = []
        if not hasattr(self, 'original_full_data') or not self.original_full_data:
            print("Error: Vehicle data (original_full_data) not loaded.")
            messagebox.showerror("Error", "Vehicle data not loaded. Cannot spawn random vehicle.")
            return
        # Ensure brand history list exists (important if __init__ wasn't run or was modified)
        if not hasattr(self, '_last_spawned_brands'):
            print("Warning: _last_spawned_brands not initialized. Initializing now.")
            self._last_spawned_brands = []


        print("  Gathering and filtering potential candidates by type...")
        total_configs_checked = 0
        allowed_configs_found = 0

        for folder_name, config_list_or_dict in self.original_full_data.items():
            actual_configs = []
            if isinstance(config_list_or_dict, list):
                actual_configs = config_list_or_dict
            elif isinstance(config_list_or_dict, dict) and 'configs' in config_list_or_dict and isinstance(config_list_or_dict['configs'], list):
                actual_configs = config_list_or_dict['configs']

            for config_tuple in actual_configs:
                total_configs_checked += 1
                if isinstance(config_tuple, (list, tuple)) and len(config_tuple) >= 5:
                    pic_path, spawn_cmd, zip_file, info_data, f_name = config_tuple

                    current_vehicle_type = ""
                    if info_data and isinstance(info_data, dict):
                        # Ensure type matching is case-insensitive and ignores whitespace
                        current_vehicle_type = info_data.get("Type", "").strip().lower()
                    else:
                        continue # Skip if no valid info_data

                    if current_vehicle_type in allowed_types:
                        if spawn_cmd:
                            # Store the necessary tuple for later info retrieval
                            filtered_candidates.append((spawn_cmd, info_data, folder_name, zip_file))
                            allowed_configs_found += 1
                # else: # Optional debug for structure issues
                    # print(f"    Skipping config due to unexpected structure: {config_tuple}")


        print(f"  Checked {total_configs_checked} total configurations.")
        print(f"  Found {len(filtered_candidates)} candidates matching allowed types.")

        if not filtered_candidates:
            type_str = f"type '{vehicle_type}'" if vehicle_type else "the allowed types"
            print(f"Error: No valid candidates found for {type_str}.")
            messagebox.showerror("Error", f"No vehicles of {type_str} found.")
            return

        # 1.5. Apply consecutive brand filtering (before random choice)
        eligible_candidates = filtered_candidates
        forbidden_brand = None
        # Check if the last two spawns were the same brand (case-insensitive)
        if len(self._last_spawned_brands) == 2 and self._last_spawned_brands[0] and self._last_spawned_brands[0] == self._last_spawned_brands[1]:
             forbidden_brand = self._last_spawned_brands[0] # Already stored lowercase
             print(f"  Applying brand filter: Avoiding '{forbidden_brand}' due to consecutive spawns.")
             # Filter the candidates, ensuring brand comparison is also lowercase
             eligible_candidates = [
                 cand for cand in filtered_candidates
                 if cand[1].get("Brand", "").strip().lower() != forbidden_brand
             ]
             print(f"  Found {len(eligible_candidates)} candidates after brand filtering.")

             # If filtering removed *all* candidates, fall back to the original list
             # to avoid getting stuck if only one brand is available for the chosen type.
             if not eligible_candidates:
                 print(f"  Warning: Brand filtering removed all candidates. Falling back to allow '{forbidden_brand}'.")
                 eligible_candidates = filtered_candidates # Use original list

        # 2. Choose a random candidate tuple from the (potentially brand-filtered) list
        try:
            # Use eligible_candidates which might be the same as filtered_candidates
            chosen_candidate = random.choice(eligible_candidates)
            # Unpack the chosen candidate
            chosen_spawn_cmd, chosen_info_data, chosen_folder_name, chosen_zip_file = chosen_candidate
        except IndexError:
            print("Error: Could not select a random candidate (list empty unexpectedly after filtering).")
            messagebox.showerror("Error", "Could not select a random vehicle from the allowed types.")
            return
        except Exception as e:
            print(f"Error during random choice: {e}")
            messagebox.showerror("Error", f"An error occurred selecting a random vehicle: {e}")
            return

        # 3. Determine the BEST display name and update brand history
        brand_display = chosen_info_data.get("Brand", "").strip()
        pc_filename_base = self.extract_name_from_spawn_command(chosen_spawn_cmd) or "UnknownPC"
        config_display_name = pc_filename_base # Default to PC name

        # Try to get friendly configuration name from individual info file
        try:
            zip_file_base_name = os.path.splitext(chosen_zip_file)[0] if chosen_zip_file else ""
            individual_info_path = self.find_individual_info_file(
                chosen_folder_name, zip_file_base_name, pc_filename_base
            )
            if individual_info_path:
                individual_data, _ = self._load_individual_info(individual_info_path) # Ignore file content here
                friendly_name = individual_data.get("Configuration", "").strip()
                if friendly_name:
                    config_display_name = friendly_name # Use friendly name if available
                    print(f"  Using friendly config name: '{config_display_name}'")
                else:
                    print(f"  Friendly config name not found in individual JSON, using PC name: '{pc_filename_base}'")
            else:
                print(f"  Individual info file not found, using PC name: '{pc_filename_base}'")
        except Exception as e:
            print(f"  Warning: Error finding/loading individual info for display name: {e}. Using PC name: '{pc_filename_base}'")

        # Construct the final message string
        if brand_display:
            vehicle_display_name_for_msg = f"{brand_display} - {config_display_name}"
        else:
            vehicle_display_name_for_msg = config_display_name # Show only config name if no brand

        print(f"  Selected vehicle for spawning: {vehicle_display_name_for_msg}")

        # ---> Update Brand History <---
        chosen_brand_lower = brand_display.lower() # Store lowercase for consistent comparison
        self._last_spawned_brands.append(chosen_brand_lower)
        if len(self._last_spawned_brands) > 2:
            self._last_spawned_brands.pop(0) # Keep only the last two
        print(f"  Updated brand history: {self._last_spawned_brands}")
        # -----------------------------


        # 4. Prepare the spawn command (remove comments)
        prepared_spawn_cmd = ""
        try:
            modified_lines = []
            for line in chosen_spawn_cmd.splitlines():
                # Remove comments like -- (USE...) or (USE...) if they exist
                use_index = line.find('-- (USE')
                if use_index != -1:
                    modified_lines.append(line[:use_index].strip())
                elif line.strip().endswith(')'): # Check for just (USE...) variant
                    use_index_alt = line.find('(USE')
                    if use_index_alt != -1 and line.index(')', use_index_alt) == len(line.strip()) -1 : # Ensure it's at the end
                         modified_lines.append(line[:use_index_alt].strip())
                    else:
                         modified_lines.append(line.strip()) # Keep line if (USE..) isn't the end comment
                else:
                    modified_lines.append(line.strip())
            prepared_spawn_cmd = '\n'.join(filter(None, modified_lines)) # Join non-empty lines

            if not prepared_spawn_cmd:
                print("Error: Prepared spawn command is empty after modification.")
                messagebox.showerror("Error", "Failed to prepare the spawn command.")
                return

            # ---> Conditionally Replace Spawn Command <---
            if replace_current:
                if "spawnNewVehicle" in prepared_spawn_cmd:
                    prepared_spawn_cmd = prepared_spawn_cmd.replace("spawnNewVehicle", "replaceVehicle")
                    print("  Modified command to use 'replaceVehicle'.")
                else:
                    print("  Warning: 'spawnNewVehicle' not found in command, cannot replace.")
            # -------------------------------------------

            print(f"  Prepared spawn command for queue:\n---\n{prepared_spawn_cmd}\n---") # Print command for verification

        except Exception as e:
            print(f"Error preparing spawn command: {e}")
            messagebox.showerror("Error", f"Error preparing spawn command: {e}")
            return

        # 5. Show "Attempting to spawn..." message with the better name
        scanning_window = None
        try:
            action = "Replacing current vehicle with" if replace_current else "Attempting to spawn random vehicle:"
            scanning_window = self.show_scanning_window(
                text=f"{action}\n{vehicle_display_name_for_msg}\n"
                     "Please try not to click anything until this notification disappears."
            )
            scanning_window.deiconify()
            self.master.update_idletasks() # Assuming self.master is your Tk root or relevant widget
        except Exception as e:
            print(f"Warning: Could not show scanning window: {e}")

        # 6. Write the command to the transient spawn queue file
        try:
            # Ensure the directory exists (optional, but good practice)
            queue_dir = os.path.dirname(self.SPAWN_QUEUE_TRANSIENT_FILE)
            if queue_dir: # Only create if not in the current directory
                 os.makedirs(queue_dir, exist_ok=True)

            # Write the standard header and the prepared command
            with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f:
                # This Lua code writes to a confirmation file *within the game's environment*
                # Make sure the path mods/EllexiumModManager/data/ is accessible *by the game*
                confirmation_path_lua = "mods/EllexiumModManager/data/commandconfirmation.txt"
                # Escape backslashes for Lua string literal if needed (usually forward slashes work)
                confirmation_path_lua = confirmation_path_lua.replace('\\', '\\\\')

                f.write(f'local f = io.open("{confirmation_path_lua}", "w")\n')
                f.write('if f then f:write("ok"); f:close(); end\n') # Write "ok" and close file
                f.write(prepared_spawn_cmd + '\n')
            print(f"  Spawn command written to transient queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'")

            # **Crucially, delete any *old* confirmation file before triggering the spawn**
            # Use the *actual* path relative to your Python script/working directory
            # This path might be different from the Lua path depending on your setup
            confirmation_file_python = confirmation_path_lua # Adjust if needed!
            if os.path.exists(confirmation_file_python):
                print(f"  Deleting existing confirmation file: {confirmation_file_python}")
                try:
                    os.remove(confirmation_file_python)
                except OSError as e:
                    print(f"  Warning: Could not delete existing confirmation file: {e}")


        except Exception as e:
            messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}")
            print(f"ERROR: Failed to write spawn command: {e}")
            if scanning_window and scanning_window.winfo_exists(): scanning_window.destroy()
            return

        # 7. Trigger the spawn action
        print("  Triggering transient spawn queue execution...")
        # Pass the *Python-accessible* path to the confirmation file if needed by run_spawn_queue_transient
        success = self.run_spawn_queue_transient(retry=False, attempt_number=1) # Modify call if needed

        # 8. Handle result and close scanning window
        if success:
            action_desc = "replacement" if replace_current else "spawn"
            print(f"  Random vehicle {action_desc} initiated successfully (BeamNG confirmation received).")
        else:
            action_desc = "replacement" if replace_current else "spawn"
            print(f"  Random vehicle {action_desc} failed or timed out (BeamNG confirmation not received).")
            # Optionally show an error message to the user here
            # messagebox.showwarning("Spawn Failed", "Could not confirm vehicle spawn/replacement in BeamNG.")


        if scanning_window and scanning_window.winfo_exists():
            # Add a slight delay before closing the window so the user can read it
            delay_ms = 2000 if success else 3000 # Longer delay on failure?
            self.master.after(delay_ms, lambda: scanning_window.destroy() if scanning_window and scanning_window.winfo_exists() else None)

        print(f"--- spawn_random_vehicle() EXIT ---")

            

##################################################### SPAWNING VEHICLES 


    
    def on_color_picker_replace_or_spawn(self):
        print("on_color_picker_replace_or_spawn function called in ConfigViewerApp!")

        scanning_window = self.show_scanning_window(text="Attempting to spawn/replace vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
        # Make the window visible
        scanning_window.deiconify()
        self.master.update_idletasks() # Force window to appear immediately

        self.is_details_sidebar_sticky = True
        self.is_details_sidebar_showing_default = False
        # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
        try:
            print(f"Running Spawn Queue Transient Directly (likely through the color picker)")
            self.run_spawn_queue_transient(retry=False, attempt_number=1)
        except Exception as e:
            #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
            print(f"ERROR: Failed to spawn: {e}") # Error print
        # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---


    def on_spawn_new_button_click(self, spawn_cmd, event=None):
        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        #spawn_cmd = None
        info_data = None
        picture_path = None
        zip_file = None


        if self.is_details_sidebar_showing_default: # NEW: Check if sidebar is showing DEFAULT config
            print("DEBUG: Spawn New Click - Sidebar showing DEFAULT config, attempting to extract data from labels...") # Debug
            # --- NEW: Get FULL spawn_cmd from the LABEL's stored attribute, not label text ---
            spawn_cmd = getattr(self.details_sidebar_config_name_label, 'spawn_command', None) # Get FULL spawn_cmd from label attribute
            if spawn_cmd:
                print(f"  DEBUG: Extracted spawn_cmd from label attribute: '{spawn_cmd}'") # Debug - Extracted from label attribute
            else:
                print("  Warning: Could not extract spawn_cmd from sidebar label attribute (default config).") # Debug - Label Extract Fail
                spawn_cmd = None # Ensure spawn_cmd is None if extraction fails

            # --- For info_data and picture_path, we might have to use the default config item again (less ideal) ---
            default_config_item = self.find_default_config_item_details(self.details_data, self.current_details_zip_file)
            if default_config_item:
                picture_path, _, _, info_data, _ = default_config_item # Get from default config item again
            else:
                info_data = {} # Fallback to empty info_data
                picture_path = None # Fallback to None picture path
                print("  Warning: Could not retrieve default_config_item for info_data/picture_path.") # Debug - Default Item Retrieval Fail
            zip_file = self.current_details_zip_file # Zip file is still known

        elif hasattr(self, 'current_details_sidebar_spawn_cmd'): # Fallback to existing logic if NOT default config
            print("DEBUG: Spawn New Click - Sidebar showing CLICKED image config, using stored attributes...") # Debug
            spawn_cmd = self.current_details_sidebar_spawn_cmd # Use stored attributes (as before)
            info_data = self.current_details_sidebar_info_data
            picture_path = self.current_details_sidebar_picture_path
            zip_file = self.current_details_sidebar_zip_file
        else:
            print("Warning: Spawn command not available for Spawn New action.")
            return # Exit if no spawn command available


        scanning_window = None # Initialize scanning_window outside try block
        if spawn_cmd: # Only proceed if spawn_cmd is successfully obtained (either from label or stored attribute)
            try:
                scanning_window = self.show_scanning_window(text="Attempting to spawn vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
                # Make the window visible
                scanning_window.deiconify()
                self.master.update_idletasks() # Force window to appear immediately

                self.is_details_sidebar_sticky = True
                self.is_details_sidebar_showing_default = False
                # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
                try:
                    with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                        modified_lines = []
                        for line in spawn_cmd.splitlines():
                            use_index = line.find('(USE')
                            if use_index != -1:
                                modified_lines.append(line[:use_index])  # Keep only the part before (USE
                            else:
                                modified_lines.append(line) # Keep the line as is if (USE is not found

                        modified_spawn_cmd = '\n'.join(modified_lines)
                        f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                        f.write(modified_spawn_cmd + '\n') # Write command to file
                    #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                    print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                    self.run_spawn_queue_transient(retry=False, attempt_number=1)
                except Exception as e:
                    #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                    print(f"ERROR: Failed to spawn: {e}") # Error print
                # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

            except Exception as e:
                print(f"Error during spawn process: {e}")
            finally: # Ensure scanning window is always destroyed
                if scanning_window:
                    scanning_window.destroy() # Destroy the scanning window after spawn attempt

        else:
            print("Warning: Spawn command STILL not available for writing to Spawn Queue.") # Debug - Still no spawn command
            
        

    def on_replace_current_button_click(self, spawn_cmd=None, event=None):
        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        #spawn_cmd = None
        info_data = None
        picture_path = None
        zip_file = None

        #if self.is_details_sidebar_showing_default: # NEW: Check if sidebar is showing DEFAULT config
        print("DEBUG: Replace Current Click - attempting to extract data from labels...") # Debug
        # --- NEW: Get FULL spawn_cmd from the LABEL's stored attribute, not label text ---

        if not spawn_cmd:
            spawn_cmd = getattr(self.details_sidebar_config_name_label, 'spawn_command', None) # Get FULL spawn_cmd from label attribute


        if spawn_cmd:
            spawn_cmd = spawn_cmd.replace("spawnNewVehicle", "replaceVehicle")

            print(f"  DEBUG: Extracted spawn_cmd from label attribute: '{spawn_cmd}'") # Debug - Extracted from label attribute
        else:
            print("  Warning: Could not extract spawn_cmd from sidebar label attribute (default config).") # Debug - Label Extract Fail
            spawn_cmd = None # Ensure spawn_cmd is None if extraction fails

        # --- For info_data and picture_path, we might have to use the default config item again (less ideal) ---
        default_config_item = self.find_default_config_item_details(self.details_data, self.current_details_zip_file)
        if default_config_item:
            picture_path, _, _, info_data, _ = default_config_item # Get from default config item again
        else:
            info_data = {} # Fallback to empty info_data
            picture_path = None # Fallback to None picture path
            print("  Warning: Could not retrieve default_config_item for info_data/picture_path.") # Debug - Default Item Retrieval Fail
        zip_file = self.current_details_zip_file # Zip file is still known



        scanning_window = None # Initialize scanning_window outside try block
        if spawn_cmd: # Only proceed if spawn_cmd is successfully obtained (either from label or stored attribute)
            try:
                scanning_window = self.show_scanning_window(text="Attempting to replace vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
                # Make the window visible
                scanning_window.deiconify()
                self.master.update_idletasks() # Force window to appear immediately

                self.is_details_sidebar_sticky = True
                self.is_details_sidebar_showing_default = False
                # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
                try:
                    with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                        modified_lines = []
                        for line in spawn_cmd.splitlines():
                            use_index = line.find('(USE')
                            if use_index != -1:
                                modified_lines.append(line[:use_index])  # Keep only the part before (USE
                            else:
                                modified_lines.append(line) # Keep the line as is if (USE is not found

                        modified_spawn_cmd = '\n'.join(modified_lines)
                        f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                        f.write(modified_spawn_cmd + '\n') # Write command to file
                    #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                    print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                    self.run_spawn_queue_transient(retry=False, attempt_number=1)
                except Exception as e:
                    #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                    print(f"ERROR: Failed to spawn: {e}") # Error print
                # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

            except Exception as e:
                print(f"Error during spawn process: {e}")
            finally: # Ensure scanning window is always destroyed
                if scanning_window:
                    scanning_window.destroy() # Destroy the scanning window after spawn attempt

        else:
            print("Warning: Spawn command STILL not available for writing to Spawn Queue.") # Debug - Still no spawn command
            
            
            
    def on_add_to_queue_button_click(self):
        return # this is unused and unreliable
        """Handles click on the 'Add to Spawn New' button in the details sidebar.
        Modified to write the spawn command to the spawn queue file
        and refresh the Spawn Queue window if it is open.
        """
        spawn_cmd = None
        info_data = None
        picture_path = None
        zip_file = None

        if self.is_details_sidebar_showing_default:
            print("DEBUG: Spawn New Click - Sidebar showing DEFAULT config, attempting to extract data from labels...")
            spawn_cmd = getattr(self.details_sidebar_config_name_label, 'spawn_command', None)
            if spawn_cmd:
                print(f"  DEBUG: Extracted spawn_cmd from label attribute: '{spawn_cmd}'")
            else:
                print("  Warning: Could not extract spawn_cmd from sidebar label attribute (default config).")
                spawn_cmd = None

            default_config_item = self.find_default_config_item_details(self.details_data, self.current_details_zip_file)
            if default_config_item:
                picture_path, _, _, info_data, _ = default_config_item
            else:
                info_data = {}
                picture_path = None
                print("  Warning: Could not retrieve default_config_item for info_data/picture_path.")
            zip_file = self.current_details_zip_file

        elif hasattr(self, 'current_details_sidebar_spawn_cmd'):
            print("DEBUG: Spawn New Click - Sidebar showing CLICKED image config, using stored attributes...")
            spawn_cmd = self.current_details_sidebar_spawn_cmd
            info_data = self.current_details_sidebar_info_data
            picture_path = self.current_details_sidebar_picture_path
            zip_file = self.current_details_sidebar_zip_file
        else:
            print("Warning: Spawn command not available for Spawn New action.")
            return

        scanning_window = None
        if spawn_cmd:
            try:

                self.is_details_sidebar_sticky = True
                self.is_details_sidebar_showing_default = False
                # --- MODIFIED: Write to spawn queue file and refresh window if open ---
                try:
                    
                    spawn_cmd = re.sub(r'\((USE', '--(USE', spawn_cmd, count=1)
                    print(f"Modified spawn_cmd: {spawn_cmd}")
                    
                    with open(self.SPAWN_QUEUE_FILE, 'a', encoding="utf-8") as f:
                        f.write(f"{spawn_cmd} -- (USE 1|||{picture_path}||| 2[{zip_file}]\n")


                        
                    #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to persistent spawn queue file: \n\n'{self.SPAWN_QUEUE_FILE}'")
                    print(f"DEBUG: Command written to spawn queue file: '{self.SPAWN_QUEUE_FILE}'")

                    # --- NEW: Refresh Spawn Queue Window if open ---
                    if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
                        print("DEBUG: Spawn Queue window is open, refreshing content...")
                        self.populate_spawn_queue_window(self.spawn_queue_scrollable_frame) # Refresh content
                        print("DEBUG: Spawn Queue window content refreshed.")
                    # --- NEW: Refresh Spawn Queue Window if open ---

                except Exception as e:
                    print(f"ERROR: Failed to add spawn queue: {e}")
                # --- MODIFIED: Write to spawn queue file and refresh window if open ---

            except Exception as e:
                print(f"Error during spawn process: {e}")

        else:
            print("Warning: Spawn command STILL not available for writing to Spawn Queue.")

            
            
    def on_delete_single_button_click(self):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = "be:getPlayerVehicle(0):delete()"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to delete current vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt

    def on_delete_all_other_vehicles_button_click(self):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = "core_multiSpawn.deleteVehicles()"
        spawn_cmd2 = "dofile('mods/EllexiumModManager/data/delete_non_traffic.lua')"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to delete all vehicles except current, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                    f.write(spawn_cmd2 + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
     

    def on_delete_traffic_vehicles_button_click(self):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = "gameplay_traffic.deleteVehicles()"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to delete all moving traffic vehicles, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
                

    def on_delete_parked_vehicles_button_click(self):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = "gameplay_parking.deleteVehicles()"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to delete parked vehicles, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
                
     
     
    def on_spawn_traffic_vehicles_button_click(self, event=None, type=None):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        
        if type == "Both":
            spawn_cmd = "gameplay_traffic.setupTraffic()"
            spawn_cmd2 = "gameplay_parking.setupVehicles()"

        elif type == "Traffic":
            spawn_cmd = "gameplay_traffic.setupTraffic()"
            spawn_cmd2 = ""

        elif type == "Parked":
            spawn_cmd = ""
            spawn_cmd2 = "gameplay_parking.setupVehicles()"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to spawn traffic vehicles, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                    f.write(spawn_cmd2 + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
     
     
    def on_delete_parked_and_traffic_vehicles_button_click(self):
        self.on_delete_parked_and_traffic_vehicles_button_click_handle(retry=False, attempt_number=1)


    def on_delete_parked_and_traffic_vehicles_button_click_handle(self, retry=False, attempt_number=1):


        if retry:
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text=f"Delete attempts: {attempt_number}")
            time.sleep(0.725)
            if scanning_win:
                scanning_win.destroy()


        if not self.is_beamng_running():
            #messagebox.showerror("Error", "BeamNG.drive is not running.")
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="BeamNG.drive does not appear to be running.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()
            return False # Indicate failure



        print("BeamNG.drive is running.") # Added print
        time.sleep(1.125) # Reduced time.sleep to quarter

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        time.sleep(1.125) # Reduced time.sleep to quarter
        if not self.focus_beamng_window():

            scanning_win = self.show_scanning_window(text="Please ensure BeamNG.drive is open and not minimized.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()

            #messagebox.showerror("Error", "BeamNG.drive window not found.")
            return False # Indicate failure

        print("BeamNG.drive window focused.") # Added print

        self.focus_beamng_window()

        pydirectinput.keyDown('shift')
        pydirectinput.keyDown('ctrl')
        pydirectinput.keyDown('alt')
        pydirectinput.keyDown('f10')

        # Wait for the specified hold time
        time.sleep(0.125)

        pydirectinput.keyUp('f10')
        pydirectinput.keyUp('alt')
        pydirectinput.keyUp('ctrl')
        pydirectinput.keyUp('shift')

        self.details_window_intentionally_closed = True
        self.on_details_window_close()

        print(f"Deletion completed. ATTEMPT {attempt_number}") # Updated message


        data_folder = self.script_dir / "data"
        COMMANDconfirmation = data_folder / "commandconfirmation.txt"

        max_attempts = 7

        # --- NOW CHECK FOR THE FILE AFTER RUNNING ACTIONS ---
        print(f"Checking for file '{COMMANDconfirmation}' - Attempt {attempt_number}/{max_attempts}...")
        if os.path.exists(COMMANDconfirmation):
            print(f"File '{COMMANDconfirmation}' exists after actions on attempt {attempt_number}. Deleting it.")
            try:
                os.remove(COMMANDconfirmation)
                print(f"File '{COMMANDconfirmation}' deleted successfully.")
                return True # Indicate success (file existed and was deleted)
            except OSError as e:
                print(f"Error deleting file '{COMMANDconfirmation}': {e}")
                return False # Indicate failure (file deletion error)

        else: # File does not exist AFTER running actions
            if attempt_number >= max_attempts: # Check attempt number for max retries
                print(f"File '{COMMANDconfirmation}' still does not exist after {max_attempts} attempts. Stopping.")

                scanning_win = None  # Initialize scanning_win

                scanning_win = self.show_scanning_window(text=f"Maximum number of attempts ({attempt_number}) to delete vehicle(s) reached. \nPlease ensure EllexiumModManagerInput.zip is in the mods folder and restart the game.")
                time.sleep(5.725)
                if scanning_win:
                    scanning_win.destroy()

                return False # Indicate failure (file never appeared after max attempts)
            else:
                print(f"File '{COMMANDconfirmation}' does not exist on attempt {attempt_number}. Retrying function...")
                time.sleep(1.125) # Reduced time.sleep to quarter
                return self.on_delete_parked_and_traffic_vehicles_button_click_handle(retry=True, attempt_number=attempt_number + 1) # Recursive call, incrementing attempt_number
  
     
     
    def on_save_current_as_default_button_click(self):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = "core_vehicle_partmgmt.save('settings/default.pc')"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to save current vehicle as default, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt

     
    def on_spawn_default_button_click(self):
        """Handles click on the 'Spawn Default' button.
        MODIFIED: Extracts {model} from default.pc dynamically.
        """

        #self.spawn_random_vehicle()
        #return # testing


        model_name = None  # Initialize model_name to None

        # 1. Construct the path to default.pc
        #script_dir = os.path.dirname(os.path.abspath(__file__))
        settings_dir = os.path.dirname(os.path.dirname(self.script_dir)) # Go up two levels
        default_pc_path = os.path.join(settings_dir, "settings", "default.pc")

        print(f"DEBUG: spawn_default_button_click - Constructed default.pc path: {default_pc_path}") # DEBUG

        # 2. Read and Parse default.pc to extract "model"
        try:
            if os.path.exists(default_pc_path):
                with open(default_pc_path, 'r', encoding="utf-8") as f:
                    default_pc_content = f.read()

                # Use regex to find the "model" value
                model_match = re.search(r'"model"\s*:\s*"([^"]*)"', default_pc_content)
                if model_match:
                    model_name = model_match.group(1)
                    print(f"DEBUG: spawn_default_button_click - Extracted model name from default.pc: {model_name}") # DEBUG
                else:
                    print("Warning: spawn_default_button_click - Could not find 'model' key in default.pc using regex.") # Warning
            else:
                print(f"Warning: spawn_default_button_click - default.pc file not found at: {default_pc_path}") # Warning
                #messagebox.showwarning("File Not Found", f"default.pc file not found at: {default_pc_path}", parent=self.master) # User feedback
                #return  # Exit if default.pc is not found

        except Exception as e:
            print(f"ERROR: spawn_default_button_click - Error reading or parsing default.pc: {e}") # Error handling
            #messagebox.showerror("Error", f"Error reading default.pc: {e}", parent=self.master) # User feedback
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Unable to spawn default vehicle configuration")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return

        if model_name:      
            spawn_cmd = f'core_vehicles.spawnNewVehicle("{model_name}", {{config = \'settings/default.pc\'}})'
            
        else:    
            spawn_cmd = f'core_vehicles.spawnNewVehicle("pickup", {{config = \'vehicles/pickup/d15_4wd_A.pc\'}})'



        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to spawn default vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: {self.SPAWN_QUEUE_TRANSIENT_FILE}") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
     
    def on_replace_with_default_button_click(self):
        """Handles click on the 'Spawn Default' button.
        MODIFIED: Extracts {model} from default.pc dynamically.
        """
        model_name = None  # Initialize model_name to None

        # 1. Construct the path to default.pc
        #script_dir = os.path.dirname(os.path.abspath(__file__))
        settings_dir = os.path.dirname(os.path.dirname(self.script_dir)) # Go up two levels
        default_pc_path = os.path.join(settings_dir, "settings", "default.pc")

        print(f"DEBUG: spawn_default_button_click - Constructed default.pc path: {default_pc_path}") # DEBUG

        # 2. Read and Parse default.pc to extract "model"
        try:
            if os.path.exists(default_pc_path):
                with open(default_pc_path, 'r', encoding="utf-8") as f:
                    default_pc_content = f.read()

                # Use regex to find the "model" value
                model_match = re.search(r'"model"\s*:\s*"([^"]*)"', default_pc_content)
                if model_match:
                    model_name = model_match.group(1)
                    print(f"DEBUG: spawn_default_button_click - Extracted model name from default.pc: {model_name}") # DEBUG
                else:
                    print("Warning: spawn_default_button_click - Could not find 'model' key in default.pc using regex.") # Warning
            else:
                print(f"Warning: spawn_default_button_click - default.pc file not found at: {default_pc_path}") # Warning
                #messagebox.showwarning("File Not Found", f"default.pc file not found at: {default_pc_path}", parent=self.master) # User feedback
                #return  # Exit if default.pc is not found

        except Exception as e:
            print(f"ERROR: spawn_default_button_click - Error reading or parsing default.pc: {e}") # Error handling
            #messagebox.showerror("Error", f"Error reading default.pc: {e}", parent=self.master) # User feedback

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Unable to spawn default vehicle configuration")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
            return  # Exit on error

        if model_name:      
            spawn_cmd = f'core_vehicles.replaceVehicle("{model_name}", {{config = \'settings/default.pc\'}})'
            
        else:    
            spawn_cmd = f'core_vehicles.replaceVehicle("pickup", {{config = \'vehicles/pickup/d15_4wd_A.pc\'}})'



        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to replace current with default vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: {self.SPAWN_QUEUE_TRANSIENT_FILE}") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
      


####################################################################



    def show_spawn_queue_window(self):
        """Displays the Spawn Queue window."""
        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
            self.spawn_queue_window.focus_set()
            self.spawn_queue_window.deiconify()
            return

        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists():
            self.filters_window.destroy()

        if hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists():
            self.hidden_window.withdraw()
            
        
        self.spawn_queue_window = dropdown_window = tk.Toplevel(self.master)
        dropdown_window.title("Spawn Queue")
        dropdown_window.overrideredirect(False)  # Keep window decorations
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        #dropdown_window.transient(self.master)
        #dropdown_window.attributes("-topmost", True) # Always on top
        dropdown_window.config(bg="#333333") # Dark background
        dropdown_window.geometry("442x500")
        dropdown_window.resizable(False, True)

        icon_path = self.script_dir / "data/icon.png"

        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            dropdown_window.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")


        # **Spawn Queue Title**
        title_label = tk.Label(dropdown_window, text="Spawn Queue", font=("Segoe UI", 13+self.font_size_add, "bold"), fg="#FFFFFF", bg="#333333") # Bold title
        title_label.pack(pady=(10, 0)) # Add padding above the title

        main_frame = tk.Frame(dropdown_window, bg="#333333", padx=10, pady=10) # Main frame with padding
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Scrollable Canvas for Queue Items
        self.spawn_queue_canvas = canvas = tk.Canvas(main_frame, bg="#444444", highlightthickness=0, yscrollincrement=10) # <-- ADDED CANVAS - assign to self.spawn_queue_canvas
        canvas.configure(yscrollcommand=self.custom_spawn_queue_scrollbar_set) # <-- Configure with custom scrollbar set command

        # Custom Scrollbar Canvas for Spawn Queue Window
        self.custom_scrollbar_canvas_spawn_queue = tk.Canvas(main_frame, bg="#555555", highlightthickness=0, width=15)
        self.scrollbar_thumb_spawn_queue = self.custom_scrollbar_canvas_spawn_queue.create_rectangle(0, 0, 15, 20, fill=self.global_highlight_color, outline="")
        self.scrollbar_thumb_dragging_spawn_queue = False
        self.scrollbar_thumb_start_y_spawn_queue = 0
        self.scrollbar_mouse_start_y_spawn_queue = 0

        self.custom_scrollbar_canvas_spawn_queue.bind("<ButtonPress-1>", self.custom_spawn_queue_scrollbar_click)
        self.custom_scrollbar_canvas_spawn_queue.bind("<B1-Motion>", self.custom_spawn_queue_scrollbar_drag)
        self.custom_scrollbar_canvas_spawn_queue.bind("<ButtonRelease-1>", self.custom_spawn_queue_scrollbar_release)


        self.spawn_queue_scrollable_frame = scrollable_frame = tk.Frame(canvas, bg="#444444") # Scrollable frame

        canvas.pack(side="left", fill=tk.BOTH, expand=True) # <-- PACK CANVAS
        #canvas.configure(yscrollcommand=scrollbar.set) # <-- CONFIGURE CANVAS YSCROLLCOMMAND
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        # --- NEW: Bind Mousewheel to the canvas for smooth scrolling ---
        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_mousewheel_spawn_queue(ev, canvas)))
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))
        # --- NEW: Bind Mousewheel to the canvas for smooth scrolling ---

        # Position custom scrollbar - place after canvas packing
        self.custom_scrollbar_canvas_spawn_queue.place(relx=1.0, rely=0.0, anchor='ne', relheight=1.0, bordermode="inside")


        # Button Frame at the Bottom (anchored)
        button_frame = tk.Frame(dropdown_window, bg="#333333", pady=10) # Frame for buttons at bottom
        button_frame.pack(side="bottom", fill="x", anchor="s") # Anchor to bottom

        button_original_style = {
            'bg': '#555555',             # Default background
            'fg': 'white',              # Default foreground
            'activebackground': '#666666', # Standard active background
            'activeforeground': 'white',  # Standard active foreground
            'relief': tk.FLAT,          # Ensure flat relief for consistency
            'bd': 0                     # Ensure no border for consistency
            # Font applied below
        }
        # Try to merge/override with self.button_style_args if it exists
        if hasattr(self, 'button_style_args') and isinstance(self.button_style_args, dict):
            # Merge, giving preference to self.button_style_args but ensuring essentials
            base_styles_to_keep = {'relief': tk.FLAT, 'bd': 0} # Ensure these are flat
            merged_style = self.button_style_args.copy()
             # Ensure active colors are present
            if 'activebackground' not in merged_style: merged_style['activebackground'] = '#666666'
            if 'activeforeground' not in merged_style: merged_style['activeforeground'] = 'white'
            merged_style.update(base_styles_to_keep) # Ensure flatness overrides
            button_original_style = merged_style
        else:
            print("Warning: self.button_style_args not found or invalid. Using default styles.")

        # Extract final original colors
        original_bg = button_original_style['bg']
        original_fg = button_original_style['fg']
        hover_fg = "#FFFFFF" # Standard hover foreground


        # --- Create Spawn Button ---
        spawn_button = tk.Button(
            button_frame,
            text="Spawn",
            font=("Segoe UI", 12 + self.font_size_add),
            command=self.on_spawn_queue_spawn_button_click, # Ensure method exists
            **button_original_style # Apply the determined style
        )

        # --- Create Clear Button ---
        clear_button = tk.Button(
            button_frame,
            text="Clear",
            font=("Segoe UI", 12 + self.font_size_add),
            command=self.on_spawn_queue_clear_button_click, # Ensure method exists
            **button_original_style # Apply the determined style
        )

        # --- Bind Spawn Button using the helper function ---
        self._bind_animated_hover(
            button=spawn_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False # Assuming always enabled
        )

        # --- Bind Clear Button using the helper function ---
        self._bind_animated_hover(
            button=clear_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False # Assuming always enabled
        )

        spawn_button.pack(side="left", fill="x", expand=True, padx=(10,5)) # Fill X and expand
        clear_button.pack(side="right", fill="x", expand=True, padx=(5,10)) # Fill X and expand


        # Populate the queue window with items
        self.populate_spawn_queue_window(scrollable_frame)

        dropdown_window.protocol("WM_DELETE_WINDOW", self.destroy_spawn_queue_window)
        self.center_window(dropdown_window) # Center the new window
        self.center_window_spawn_queue(dropdown_window)


    def center_window_spawn_queue(self, window):
        """Centers the given window on the master window."""
        window.update_idletasks() # Update window geometry to get correct sizes

        master_width = self.master.winfo_width()
        master_height = self.master.winfo_height()
        master_x = self.master.winfo_x()
        master_y = self.master.winfo_y()

        window_width = window.winfo_width()
        window_height = window.winfo_height()

        x = master_x + (master_width - window_width) // 2
        y = master_y + (master_height - window_height) // 2

        window.geometry(f"+{x}+{y}")

    def custom_spawn_queue_scrollbar_click(self, event):
        """Start thumb dragging on mouse click for Spawn Queue window."""
        self.scrollbar_thumb_dragging_spawn_queue = True
        self.scrollbar_thumb_start_y_spawn_queue = self.custom_scrollbar_canvas_spawn_queue.coords(self.scrollbar_thumb_spawn_queue)[1]
        self.scrollbar_mouse_start_y_spawn_queue = event.y

    def custom_spawn_queue_scrollbar_drag(self, event):
        """Drag thumb and update canvas view for Spawn Queue window."""
        if not self.scrollbar_thumb_dragging_spawn_queue:
            return

        mouse_y = event.y
        delta_y = mouse_y - self.scrollbar_mouse_start_y_spawn_queue
        new_thumb_y = self.scrollbar_thumb_start_y_spawn_queue + delta_y

        canvas_height = self.spawn_queue_canvas.winfo_height() # Use spawn_queue_canvas here
        scroll_range = self.spawn_queue_canvas.bbox("all") # Use spawn_queue_canvas here
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height:
            return # No scrolling needed if content fits

        thumb_height = self.custom_scrollbar_canvas_spawn_queue.coords(self.scrollbar_thumb_spawn_queue)[3] - self.custom_scrollbar_canvas_spawn_queue.coords(self.scrollbar_thumb_spawn_queue)[1]
        max_thumb_y = canvas_height - thumb_height
        new_thumb_y = max(0, min(max_thumb_y, new_thumb_y)) # Clamp thumb position

        self.custom_scrollbar_canvas_spawn_queue.coords(self.scrollbar_thumb_spawn_queue, 0, new_thumb_y, 15, new_thumb_y + thumb_height)

        scroll_fraction = new_thumb_y / max_thumb_y if max_thumb_y > 0 else 0
        self.spawn_queue_canvas.yview_moveto(scroll_fraction) # Use spawn_queue_canvas here


    def custom_spawn_queue_scrollbar_release(self, event):
        """Stop thumb dragging on mouse release for Spawn Queue window."""
        self.scrollbar_thumb_dragging_spawn_queue = False

    def custom_spawn_queue_scrollbar_set(self, *args):
        """Custom scrollbar set command to update thumb position for Spawn Queue window."""
        if self.scrollbar_thumb_dragging_spawn_queue:
            return # Prevent updates if dragging manually

        start, end = args[0:2]
        canvas_height = self.spawn_queue_canvas.winfo_height() # Use spawn_queue_canvas here
        scroll_range = self.spawn_queue_canvas.bbox("all") # Use spawn_queue_canvas here
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height: # NO SCROLLING NEEDED - SET TO GREY
            self.custom_scrollbar_canvas_spawn_queue.itemconfig(self.scrollbar_thumb_spawn_queue, fill="#555555")
        else: # SCROLLING IS POSSIBLE - KEEP ORANGE (or set back to orange if it was grey)
            self.custom_scrollbar_canvas_spawn_queue.itemconfig(self.scrollbar_thumb_spawn_queue, fill=self.global_highlight_color)

        thumb_height = max(20, canvas_height * (canvas_height / scrollable_height)) if scrollable_height > canvas_height else canvas_height # Minimum thumb height
        thumb_y_start = canvas_height * float(start)
        thumb_y_end = thumb_y_start + thumb_height
        self.custom_scrollbar_canvas_spawn_queue.coords(self.scrollbar_thumb_spawn_queue, 0, thumb_y_start, 15, thumb_y_end)




    def on_mousewheel_spawn_queue(self, event, canvas):
        """Handle mouse wheel events for smooth scrolling in the spawn queue window."""
        if canvas.winfo_exists():
            if os.name == 'nt':
                delta = int(event.delta / 120) # Removed negation here
            else:
                delta = int(event.delta) # Removed negation here
            # --- MODIFIED: Initiate smooth scroll animation for spawn queue ---
            self.start_smooth_scroll_spawn_queue(delta, canvas) # Call smooth scroll for search results
            #canvas.yview_scroll(delta, "units") # Original non-smooth scroll

    def start_smooth_scroll_spawn_queue(self, delta_units, canvas_sub):
        """Starts smooth scrolling animation for the spawn queue canvas - NORMALIZED SPEED."""
        if self.scroll_animation_timer:
            self.spawn_queue_window.after_cancel(self.scroll_animation_timer)  # Cancel any existing animation

        scroll_delta_units = delta_units  # Store delta in UNITS

        current_yview = canvas_sub.yview()  # Get current yview
        current_pos = current_yview[0]  # Get the current top position (0.0 to 1.0)

        canvas_height = canvas_sub.winfo_height()
        scrollable_height = canvas_sub.bbox("all")[3] if canvas_sub.bbox("all") else canvas_height # Use canvas height as fallback
        if scrollable_height <= 0:
            scrollable_height = canvas_height # Prevent division by zero

        # Calculate scroll step based on a fraction of the *visible* canvas height
        scroll_fraction = 0.7  # Adjust this fraction (e.g., 0.1, 0.15, 0.25) for sensitivity
        scroll_step_normalized = (canvas_height / scrollable_height) * scroll_fraction * scroll_delta_units
        # Explanation:
        # - (canvas_height / scrollable_height):  This is the proportion of the *total* content that is visible.
        # - scroll_fraction:  We want to scroll by a fraction of this visible portion.
        # - scroll_units:  Multiply by the scroll units.

        target_y_normalized = current_pos - scroll_step_normalized # Changed + to - here to correct direction
        target_y_normalized = max(0.0, min(1.0, target_y_normalized))

        self.scroll_target_yview = target_y_normalized
        self.scroll_start_y = current_pos
        self.scroll_start_time = self.master.tk.call('clock', 'milliseconds')

        if self.scroll_animation_id:
            canvas_sub.after_cancel(self.scroll_animation_id)
        self.animate_scroll_spawn_queue(0, canvas_sub)

    def animate_scroll_spawn_queue(self, step, canvas_sub):
        """Animates the canvas scroll with ease-out for the spawn queue window."""
        current_time = self.master.tk.call('clock', 'milliseconds')
        time_elapsed = current_time - self.scroll_start_time
        progress = min(1.0, time_elapsed / self.scroll_duration) # Normalized progress (0 to 1)

        # Ease-out function (simple quadratic)
        ease_out_progress = progress * (2 - progress) #  f(t) = t * (2 - t)

        # Calculate current scroll position based on eased progress
        current_y_normalized = self.scroll_start_y + (self.scroll_target_yview - self.scroll_start_y) * ease_out_progress

        canvas_sub.yview_moveto(current_y_normalized)

        if progress < 1.0:
            self.scroll_animation_id = canvas_sub.after(10, lambda: self.animate_scroll_spawn_queue(step + 1, canvas_sub)) # 10ms delay for animation step
        else:
            self.scroll_animation_id = None # Animation finished


    def destroy_spawn_queue_window(self):
        """Destroys the Spawn Queue window and clears the reference."""
        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
            self.spawn_queue_window.destroy()
            self.spawn_queue_window = None





    def populate_spawn_queue_window(self, parent_frame):
        """Populates the Spawn Queue window with items from Spawn_Queue_Transient.txt."""
        # --- Clear existing items ---
        for widget in parent_frame.winfo_children():
            widget.destroy()
        self.spawn_queue_items = [] # Reset the list tracking items
        print("DEBUG: populate_spawn_queue_window - Cleared existing items from scrollable frame.")

        # --- Define Button Colors (Retrieve Safely ONCE before the loop) ---
        try:
            if not hasattr(self, 'button_style_args'):
                 print("Warning: self.button_style_args missing. Using default button styles.")
                 # Define a default style if necessary
                 self.button_style_args = {'bg': '#555555', 'fg': 'white', 'activebackground': '#666666', 'activeforeground': 'white', 'relief': tk.FLAT, 'bd': 0}

            remove_original_bg = self.button_style_args.get('bg', "#555555")
            remove_original_fg = self.button_style_args.get('fg', "#FFFFFF")
            # Ensure active colors exist for click feedback
            if 'activebackground' not in self.button_style_args:
                 self.button_style_args['activebackground'] = '#666666'
            if 'activeforeground' not in self.button_style_args:
                 self.button_style_args['activeforeground'] = 'white'

        except Exception as e:
             print(f"Error accessing self.button_style_args: {e}. Using default colors.")
             remove_original_bg = "#555555"
             remove_original_fg = "#FFFFFF"
             # Reset style args to a safe default
             self.button_style_args = {'bg': remove_original_bg, 'fg': remove_original_fg, 'activebackground': '#666666', 'activeforeground': 'white', 'relief': tk.FLAT, 'bd': 0}

        remove_hover_fg = "#FFFFFF" # Standard hover foreground

        # --- Read Commands ---
        try:
            with open(self.SPAWN_QUEUE_FILE, 'r', encoding="utf-8") as f:
                commands = f.readlines()
        except FileNotFoundError:
            print(f"Warning: Spawn queue file not found: {self.SPAWN_QUEUE_FILE}")
            commands = []


        # --- Loop through commands ---
        for command_line in commands:
            command_line = command_line.strip()
            if not command_line or command_line.lower().startswith("local"):
                if command_line.lower().startswith("local"):
                     print(f"DEBUG: Skipping line starting with 'local': {command_line}")
                continue

            # --- Create Frame for the item ---
            item_frame = tk.Frame(parent_frame, bg="#444444", pady=5)
            # Pack the item_frame immediately so it appears
            item_frame.pack(fill="x", padx=10, pady=2)

            # --- Extract Info (Regex logic unchanged) ---
            model_match = re.search(r'core_vehicles\.spawnNewVehicle\("([^"]+)"', command_line)
            config_match = re.search(r'config\s*=\s*\'([^\']+)\'', command_line)
            picture_path_match = re.search(r'USE 1\|\|\|(.*?)\|\|\|', command_line)

            model_name = model_match.group(1) if model_match else "Unknown Model"
            config_path = config_match.group(1) if config_match else "settings/default.pc"
            config_name_base = os.path.splitext(os.path.basename(config_path))[0]
            picture_path_str = picture_path_match.group(1) if picture_path_match else None
            config_display_name = config_name_base

            # --- Load Config Info (Unchanged) ---
            info_data = {}
            if picture_path_str:
                try: # Add try-except around potentially failing file operations
                    config_info_path = self.get_config_info_path_from_picture_path(picture_path_str)
                    if config_info_path:
                        info_data, _ = self._load_individual_info(config_info_path)
                        config_display_name = info_data.get("Configuration", config_name_base)
                except Exception as e:
                    print(f"Error processing info for {picture_path_str}: {e}")


            # --- Image Loading (Placeholder and Actual - Unchanged) ---
            try:
                placeholder_image = Image.new("RGB", (110, 60), "#d9d9d9")
                placeholder_photo = ImageTk.PhotoImage(placeholder_image)
            except Exception as e:
                 print(f"Error creating placeholder image: {e}")
                 placeholder_photo = None # Handle error gracefully

            image_photo = placeholder_photo
            if picture_path_str:
                try:
                    image = Image.open(picture_path_str)
                    image = image.resize((110, 60))
                    image_photo = ImageTk.PhotoImage(image)
                except FileNotFoundError:
                    print(f"Warning: Image file not found: {picture_path_str}")
                    image_photo = placeholder_photo # Fallback to placeholder
                except Exception as e:
                    print(f"Error loading image from {picture_path_str}: {e}")
                    image_photo = placeholder_photo # Fallback

            # --- Image Label (Create and Pack) ---
            if image_photo: # Only create label if image exists
                image_label = tk.Label(item_frame, image=image_photo, bg="#444444")
                image_label.image = image_photo # Keep reference
                image_label.pack(side="left", padx=5, pady=5)

            # --- Config Label (Create and Pack) ---
            config_label = tk.Label(item_frame, text=config_display_name, font=("Segoe UI", 10+self.font_size_add, "bold"), fg="#FFFFFF", bg="#444444", anchor="w", wraplength=250, justify=tk.LEFT)
            config_label.pack(side="top", fill="x", padx=5)

            # --- Remove Button ---
            # REMOVED: Old local handler functions

            # Create the button
            remove_button = tk.Button(
                item_frame,
                text="Remove",
                font=("Segoe UI", 9 + self.font_size_add),
                command=lambda cmd=command_line, frame=item_frame: self.on_remove_queue_item(cmd, frame),
                **self.button_style_args # Apply common style (includes active colors)
            )

            # Bind smooth hover effects using the helper
            self._bind_animated_hover(
                button=remove_button,
                original_bg=remove_original_bg, # Use color retrieved before loop
                original_fg=remove_original_fg, # Use color retrieved before loop
                hover_target_fg=remove_hover_fg,
                check_state=False # Assuming button is always enabled
            )

            # Pack the button AFTER creating and binding
            remove_button.pack(side="bottom", padx=5, pady=(2, 0), anchor="w", fill="x")
            # REMOVED: Old direct bindings

            # --- Store item info ---
            self.spawn_queue_items.append({'frame': item_frame, 'command': command_line, 'picture_path': picture_path_str})

        print(f"DEBUG: populate_spawn_queue_window - Finished populating. Items created: {len(self.spawn_queue_items)}")

            
            

    def get_config_info_path_from_picture_path(self, picture_path):
        """
        Constructs the ConfigInfo path from a ConfigPics path extracted from the spawn queue command.
        """
        if not picture_path:
            return None

        filename = os.path.basename(picture_path)
        parts = filename.split('--')
        if len(parts) < 3:
            return None

        vehicle_part = parts[1]  # e.g., "pab_e39_e39kenemationV14.zip"
        config_part = parts[2]   # e.g., "2.0_520d_M_late.jpg"
        config_name_base = os.path.splitext(config_part)[0] # remove extension

        config_info_filename = f"vehicles--INDIVIDUAL--{vehicle_part}--info_info_{config_name_base}.json"
        config_info_path = os.path.join(self.config_info_folder, config_info_filename)

        if os.path.exists(config_info_path):
            return config_info_path
        else:
            return None


    def on_remove_queue_item(self, command_line, item_frame):
        """Removes a specific item from the Spawn Queue window and Spawn_Queue_Transient.txt,
        and deletes the file if it becomes empty.
        """
        item_frame.destroy() # Remove item frame from UI
        self.spawn_queue_items = [item for item in self.spawn_queue_items if item['frame'] != item_frame] # Update item list

        try:
            with open(self.SPAWN_QUEUE_FILE, 'r', encoding="utf-8") as f_in:
                lines = f_in.readlines()
            with open(self.SPAWN_QUEUE_FILE, 'w', encoding="utf-8") as f_out:
                for line in lines:
                    if line.strip() != command_line.strip(): # Compare stripped lines
                        f_out.write(line)

            # Check if the queue is now empty after removing the item
            if not self.spawn_queue_items:
                try:
                    os.remove(self.SPAWN_QUEUE_FILE)
                    print(f"Spawn queue file '{self.SPAWN_QUEUE_FILE}' deleted as queue is empty.")
                except FileNotFoundError:
                    print(f"Warning: Spawn queue file '{self.SPAWN_QUEUE_FILE}' not found when attempting to delete (queue empty).")
                except Exception as delete_e:
                    print(f"Error deleting {self.SPAWN_QUEUE_FILE}: {delete_e}")

        except Exception as e:
            print(f"Error updating {self.SPAWN_QUEUE_FILE}: {e}")

        self.spawn_queue_scrollable_frame.update_idletasks()
        self.spawn_queue_scrollable_frame.master.config(scrollregion=self.spawn_queue_scrollable_frame.master.bbox("all"))


    def on_spawn_queue_spawn_button_click(self):
        """Handles the 'Spawn' button click in the Spawn Queue window."""
        self.destroy_spawn_queue_window()
        self.run_spawn_queue(retry=False, attempt_number=1) # Execute spawn queue commands


    def on_spawn_queue_clear_button_click(self):
        """Handles the 'Clear' button click in the Spawn Queue window by DELETING the queue file."""
        # Clear UI list
        for item in self.spawn_queue_items:
            item['frame'].destroy()
        self.spawn_queue_items = []

        # Delete Spawn_Queue.txt
        try:
            if os.path.exists(self.SPAWN_QUEUE_FILE): # Check if file exists before attempting to delete
                os.remove(self.SPAWN_QUEUE_FILE)
                print(f"Successfully deleted {self.SPAWN_QUEUE_FILE}")
            else:
                print(f"Warning: {self.SPAWN_QUEUE_FILE} not found, cannot delete.")
        except FileNotFoundError:
            print(f"Warning: {self.SPAWN_QUEUE_FILE} not found, cannot delete (FileNotFoundError).")
        except Exception as e:
            print(f"Error deleting {self.SPAWN_QUEUE_FILE}: {e}")

        self.spawn_queue_scrollable_frame.update_idletasks()
        self.spawn_queue_scrollable_frame.master.config(scrollregion=self.spawn_queue_scrollable_frame.master.bbox("all"))


    def check_and_auto_close_details_window(self):
        """
        Checks the auto-close condition for the details window and closes it if met.
        This function is scheduled with a delay from perform_details_search.
        """
        # --- NEW: Auto-close Details Window if empty and search bar is empty ---
        if not self.details_filtered_data and not self.details_search_var.get().strip():
            print("  DEBUG: check_and_auto_close_details_window - [Delayed Check] No items in subgrid AND search bar is empty. Closing Details Window.")
            self.on_details_window_close()
            print("  DEBUG: check_and_auto_close_details_window - Details window CLOSED due to empty search results and empty search bar (delayed).")
            # --- NEW: Show "No configurations available" label ---
            self.no_configs_label.config(text="No configurations available for vehicle model under filter restrictions") # Set text
            self.no_configs_label.pack(side="left", padx=(10, 10)) # Make label visible
            self.master.after(3000, self.hide_no_configs_label) # Schedule hide after 2 seconds
            # --- NEW: Show "No configurations available" label ---
        else:
            print("  DEBUG: check_and_auto_close_details_window - [Delayed Check] Subgrid NOT empty OR search bar NOT empty. Keeping Details Window open.")
        # --- NEW: Auto-close Details Window if empty and search bar is empty ---




##################################################### SPAWNING VEHICLES END



    ######################################################################
    # to be depreciated or modified
    
    def create_floating_button_window(self):
        return create_floating_button_window(self)

    def on_floating_window_mapped(self, event=None):
        return on_floating_window_mapped(self, event)

    def on_floating_window_unmapped(self, event=None):
        return on_floating_window_unmapped(self, event)

    def toggle_floating_window_visibility(self):
       return toggle_floating_window_visibility(self)

    '''
    def toggle_focus_beamng(self):
       return toggle_focus_beamng(self) # Call external function
    '''
    
    
    #
    ######################################################################
    #               end of interaction with beamng                      #
    ######################################################################


    def show_sidebar_info(self, info_data, picture_path, zip_file, folder_name):
        """Shows sidebar info labels and updates content."""
        self.update_sidebar_content(info_data, picture_path, zip_file, folder_name)
        self.sidebar_brand_info_label.pack(fill="x", padx=10, pady=(0, 0))
        self.sidebar_description_info_label.pack(fill="x", padx=10, pady=(0, 0))
        self.sidebar_slogan_info_label.pack(fill="x", padx=10, pady=(0, 0))
        self.sidebar_country_info_label.pack(fill="x", padx=10, pady=(0, 0))
        self.sidebar_derbyclass_info_label.pack(fill="x", padx=10, pady=(0, 10))

    def hide_sidebar_info(self):
        """Hides sidebar info labels and clears all sidebar content, now including Author labels."""
        # Placeholder image for sidebar - CHANGED placeholder to MATCH sidebar_top_frame BG COLOR - "#333333"
        placeholder_image = Image.new("RGB", (280, 150), "#333333") # CHANGED to "#333333" - MATCH sidebar_top_frame BG COLOR
        placeholder_photo = ImageTk.PhotoImage(placeholder_image)

        # Clear ALL sidebar labels and reset image
        self.sidebar_car_name_label.config(text="") # Reset car name label to "" (empty string)
        self.sidebar_image_label.config(image=placeholder_photo) # Reset image to placeholder
        self.sidebar_image_label.image = placeholder_photo # Keep reference to placeholder
        self.sidebar_brand_info_label.config(text="") # Clear Brand info
        self.sidebar_description_info_label.config(text="") # Clear Description
        self.sidebar_slogan_info_label.config(text="") # Clear Slogan
        self.sidebar_country_info_label.config(text="") # Clear Country
        self.sidebar_derbyclass_info_label.config(text="") # Clear Derby Class
        self.sidebar_zip_name_label.config(text="") # Clear Zip Name
        self.sidebar_author_info_label.config(text="") # Clear Author Info - NEW

        # Hide category AND info labels - keep these hidden for mouse leave
        self.sidebar_brand_label.pack_forget() # Hide Brand category
        self.sidebar_brand_info_label.pack_forget() # Hide Brand info
        self.sidebar_description_label.pack_forget() # Hide Description category
        self.sidebar_description_info_label.pack_forget() # Hide Description info
        self.sidebar_slogan_label.pack_forget() # Hide Slogan category
        self.sidebar_slogan_info_label.pack_forget() # Hide Slogan info
        self.sidebar_country_label.pack_forget() # Hide Country category
        self.sidebar_country_info_label.pack_forget() # Hide Country info
        self.sidebar_derbyclass_label.pack_forget() # Hide Derby Class category
        self.sidebar_derbyclass_info_label.pack_forget() # Hide Derby Class info
        # --- NEW: Hide Author Labels ---
        self.sidebar_author_label.pack_forget() # Hide Author category
        self.sidebar_author_info_label.pack_forget() # Hide Author info
        # --- NEW: Hide Author Labels ---


    def process_lines(self, lines, full_data, is_custom):
        return process_lines(self, lines, full_data, is_custom)
   
  
        
    def find_config_pic(self, candidate_image_name, config_pics_folder):
        """Helper function to find config pic path given a base name and folder."""
        for ext in ['jpg', 'jpeg', 'png']:
            check_name = f"{candidate_image_name}.{ext}"
            check_path = os.path.join(config_pics_folder, check_name)
            if os.path.exists(check_path):
                return check_path
        return None
        
        

    def update_sidebar_content(self, info_data, picture_path, zip_file, folder_name, hovered_category=None):
        """
        Updates sidebar with car name, picture, zip/folder name, and JSON details, now including Author.
        """

        #if self.items_to_be_hidden:
        #    return
        
        # Car Name Label (top)
        brand = info_data.get("Brand", "").strip()
        name = info_data.get("Name", "").strip()
        vehicle_type = info_data.get("Type", "").strip()
        if brand:
            if name:
                display_name_text = f"{brand} {name}"
            elif vehicle_type:
                display_name_text = f"{brand} {vehicle_type}"
            else:
                display_name_text = brand
        elif name:
            display_name_text = name
        elif vehicle_type:
            display_name_text = vehicle_type
        else:
            display_name_text = "Unknown"
        self.sidebar_car_name_label.config(text=display_name_text if display_name_text else "Unknown")

        # Image Loading (unchanged)
        self.sidebar_loading_label.pack(pady=(0, 10), padx=10)
        try:
            if picture_path and os.path.exists(picture_path):
                img = Image.open(picture_path).convert("RGB")
                img = img.resize((275, 153), self.RESAMPLE_FILTER)
                photo = ImageTk.PhotoImage(img)
                self.sidebar_image_label.config(image=photo)
                self.sidebar_image_label.image = photo
            else:
                placeholder_image = Image.new("RGB", (280, 157), "lightgrey")
                placeholder_photo = ImageTk.PhotoImage(placeholder_image)
                self.sidebar_image_label.config(image=placeholder_photo)
                self.sidebar_image_label.image = placeholder_photo
        except Exception as e:
            print(f"Error loading sidebar image: {e}")
            placeholder_image = Image.new("RGB", (280, 157), "lightgrey")
            placeholder_photo = ImageTk.PhotoImage(placeholder_image)
            self.sidebar_image_label.config(image=placeholder_photo)
            self.sidebar_image_label.image = placeholder_photo
            self.sidebar_car_name_label.config(text=f"Error Loading Image for: {display_name_text}")
        finally:
             self.sidebar_loading_label.pack_forget()

        self.update_sidebar_zip_name(zip_file, folder_name, hovered_category=hovered_category)

        # --- NEW: Update Sidebar JSON Info Labels - CORRECT ASSIGNMENT (including Author) ---
        # Brand Name, Country, Derby Class are already set in sidebar_car_name_label

        # Brand
        brand_text = info_data.get("Brand", "").strip()
        if brand_text:
            self.sidebar_brand_info_label.config(text=f"{brand_text}")
            self.sidebar_brand_label.config(text="Brand") # Set category label text
            self.sidebar_brand_label.pack(fill="x", padx=10, pady=(10, 0)) # Make category label visible
            self.sidebar_brand_info_label.pack(fill="x", padx=10, pady=(0, 0)) # Make info label visible
        else:
            self.sidebar_brand_info_label.config(text="Brand Not Specified")
            self.sidebar_brand_label.config(text="Brand") # Set category label text
            self.sidebar_brand_label.pack(fill="x", padx=10, pady=(10, 0)) # Make category label visible
            self.sidebar_brand_info_label.pack(fill="x", padx=10, pady=(0, 0)) # Make info label visible

        # Country
        country_text = info_data.get("Country", "").strip()
        if country_text:
            self.sidebar_country_info_label.config(text=f"{country_text}")
            self.sidebar_country_label.config(text="Country") # Set category label text
            self.sidebar_country_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_country_info_label.pack(fill="x", padx=10, pady=(0, 0))
        else:
            self.sidebar_country_info_label.config(text="Country Not Specified")
            self.sidebar_country_label.config(text="Country") # Set category label text
            self.sidebar_country_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_country_info_label.pack(fill="x", padx=10, pady=(0, 0))

        # Derby Class
        derbyclass_text = info_data.get("Derby Class", "").strip()
        if derbyclass_text:
            self.sidebar_derbyclass_info_label.config(text=f"{derbyclass_text}")
            self.sidebar_derbyclass_label.config(text="Derby Class") # Set category label text
            self.sidebar_derbyclass_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_derbyclass_info_label.pack(fill="x", padx=10, pady=(0, 10)) # Bottom padding
        else:
            self.sidebar_derbyclass_info_label.config(text="Derby Class Not Specified")
            self.sidebar_derbyclass_label.config(text="Derby Class") # Set category label text
            self.sidebar_derbyclass_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_derbyclass_info_label.pack(fill="x", padx=10, pady=(0, 10)) # Bottom padding

        # --- NEW: Author Section Update ---
        author_text = info_data.get("Author", "").strip()
        if author_text:
            self.sidebar_author_info_label.config(text=f"{author_text}")
            self.sidebar_author_label.config(text="Author")  # Set category label text
            self.sidebar_author_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_author_info_label.pack(fill="x", padx=10, pady=(0, 10)) # Bottom padding
        else:
            self.sidebar_author_info_label.config(text="Author Not Specified")
            self.sidebar_author_label.config(text="Author") # Set category label text
            self.sidebar_author_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_author_info_label.pack(fill="x", padx=10, pady=(0, 10)) # Bottom padding
        # --- NEW: Author Section Update ---
            
            
    def update_sidebar_zip_name(self, zip_file, folder_name, hovered_category=None):
            """Updates the zip file or folder name label in the sidebar to display ALL associated ZIPs."""
            if zip_file == "user_custom_configs":
                if self.is_search_results_window_active:
                    text_to_display = f"Custom Configs for:\n({folder_name})"
                if not self.is_search_results_window_active:
                    text_to_display = f"Custom Configs for:\n[{folder_name}]\n(Right Click to hide/unhide vehicle)"
            else:
                # --- NEW: Get all associated zip files from full_data ---
                associated_zip_files = set()
                if folder_name in self.full_data:
                    for config_item in self.full_data[folder_name]:
                        config_zip = config_item[2]
                        if config_zip != "user_custom_configs": # Exclude custom configs from mod zip list
                            associated_zip_files.add(config_zip)

                if associated_zip_files:
                    num_zips = len(associated_zip_files)
                    zip_label = "Zip File" if num_zips == 1 else "Zip Files" # Determine singular or plural
                    zip_list_text = "\n".join(sorted(list(associated_zip_files))) # Create multi-line string

                if self.is_search_results_window_active:
                    text_to_display = f"{zip_list_text}\n({folder_name})"

                if not self.is_search_results_window_active:
                    if hovered_category=="Favorites":
                        text_to_display = f"{zip_list_text}\n({folder_name})"
                    else:
                        text_to_display = f"{zip_list_text}\n({folder_name})\n(Right Click to hide/unhide vehicle)"

                # --- NEW: Get all associated zip files from full_data ---

            self.sidebar_zip_name_label.config(text=text_to_display)
            


    # ------------------------------------------------------------
    # Cycle Filter
    # ------------------------------------------------------------
    def cycle_filter(self):
        self.filter_state = (self.filter_state + 1) % len(self.filter_options)
        current_filter = self.filter_options[self.filter_state]
        self.filter_button.config(text=f"{current_filter} [0]")
        print("    cycle_filter is calling self.perform_search()")
        self.perform_search()

        
    # ------------------------------------------------------------
    # Resize and scroll.py
    # ------------------------------------------------------------
    

    def throttled_resize(self, event):
        return throttled_resize(self, event) # Call external function

    def on_resize_complete(self):
        return on_resize_complete(self) # Call external function

    def on_mousewheel_main(self, event):
         return on_mousewheel_main(self, event)

    def on_mousewheel_details(self, event, canvas_sub):
        return on_mousewheel_details(self, event, canvas_sub)

    def ease_out_quintic_modified_speed(self, t, speed_factor=1.0):
        return ease_out_quintic_modified_speed(t, speed_factor)

    def start_scroll_debounce_timer_main_grid(self):
         return start_scroll_debounce_timer_main_grid(self)

    def on_scroll_debounce_complete_main_grid(self):
         return on_scroll_debounce_complete_main_grid(self)
        

    def on_scroll_debounce_complete_main_grid_unhide_mouse(self):
         return on_scroll_debounce_complete_main_grid_unhide_mouse(self)

    def is_descendant_of(self, widget, ancestor):
       return is_descendant_of(self, widget, ancestor)

    def start_smooth_scroll_main(self, delta_units):
        return start_smooth_scroll_main(self, delta_units)

    def start_smooth_scroll_details(self, delta_units, canvas_sub):
        return start_smooth_scroll_details(self, delta_units, canvas_sub)

    def animate_scroll_main(self, step):
        return animate_scroll_main(self, step)

    def animate_scroll_details(self, step, canvas_sub):
         return animate_scroll_details(self, step, canvas_sub)

    def calculate_columns_for_width(self, width, is_details=False):
       return calculate_columns_for_width(self, width, is_details)
   
    def on_mousewheel_search_results(self, event):
        """Handle mouse wheel events for smooth scrolling in the search results window."""



        if self.search_results_canvas.winfo_exists():
            if os.name == 'nt':
                delta = int(-1 * (event.delta / 120))
            else:
                delta = int(-1 * (event.delta))
            # --- MODIFIED: Initiate smooth scroll animation for search results ---
            self.start_smooth_scroll_search_results(delta, self.search_results_canvas) # Call smooth scroll for search results
        



    def start_smooth_scroll_search_results(self, delta_units, canvas_sub):
        """Starts smooth scrolling animation for the search results canvas - NORMALIZED SPEED."""
        if self.scroll_animation_timer:
            self.search_results_window.after_cancel(self.scroll_animation_timer)  # Cancel any existing animation
        
        
        self.scroll_delta_units = delta_units  # Store delta in UNITS

        current_yview = canvas_sub.yview()  # Get current yview
        current_pos = current_yview[0]  # Get the current top position (0.0 to 1.0)

        canvas_height = canvas_sub.winfo_height()
        scrollable_height = canvas_sub.bbox("all")[3] if canvas_sub.bbox("all") else canvas_height # Use canvas height as fallback
        if scrollable_height <= 0:
            scrollable_height = canvas_height # Prevent division by zero

        # --- NEW: Calculate scroll step based on item height and canvas size ---
        estimated_item_height = 160  # Estimate item height in pixels (image + label + padding) - ADJUST IF NEEDED
        items_visible_in_viewport = canvas_height / estimated_item_height
        scroll_units_per_item = items_visible_in_viewport / (scrollable_height / estimated_item_height) if scrollable_height > 0 else 0.1 # Fallback if scrollable_height is 0

        scroll_step_units = scroll_units_per_item * 0.35 # Adjust multiplier (1.5) for overall speed - HIGHER = FASTER
        target_pos_units = current_pos + (delta_units * scroll_step_units)
        target_pos_units = max(0.0, min(1.0, target_pos_units))  # Clamp between 0.0 and 1.0

        self.scroll_current_yview = current_pos
        self.scroll_target_yview = target_pos_units
        animate_scroll_search_results(self, 0, canvas_sub)  # Start details animation from step 0
 
 
 

    def custom_scrollbar_click(self, event):
        """Start thumb dragging on mouse click."""
        self.scrollbar_thumb_dragging = True
        self.scrollbar_thumb_start_y = self.custom_scrollbar_canvas.coords(self.scrollbar_thumb)[1]
        self.scrollbar_mouse_start_y = event.y

        self._last_drag_event_time = time.time()
        self._last_drag_event_y = event.y


        if self._throttled_after_id:
            self.canvas.after_cancel(self._throttled_after_id)
            self._throttled_after_id = None
        self._scroll_pending = False




    def custom_scrollbar_drag(self, event):
        """Drag thumb and update canvas view (throttled with dynamic FPS)."""
        if not self.scrollbar_thumb_dragging:
            return

        current_time = time.time()
        mouse_y = event.y
        
        # --- Calculate drag speed and adjust throttle ---
        delta_t = current_time - self._last_drag_event_time
        delta_y_for_speed = mouse_y - self._last_drag_event_y

        current_speed = 0.0
        if delta_t > self.min_delta_t_for_speed_calc: # Ensure delta_t is not too small
            current_speed = abs(delta_y_for_speed) / delta_t # Pixels per second
        elif abs(delta_y_for_speed) > 0: # Movement happened even if delta_t is tiny
            current_speed = self.speed_threshold_high + 1.0 # Treat as very high speed
        
        # Determine new throttle based on speed
        drag_mode_label = "MEDIUM" # Default for interpolation
        if current_speed <= self.speed_threshold_low:
            self._scroll_throttle_ms = self.min_throttle_ms
            drag_mode_label = "SLOW"
        elif current_speed >= self.speed_threshold_high:
            self._scroll_throttle_ms = self.max_throttle_ms
            drag_mode_label = "FAST"
        else:
            # Linear interpolation
            if self.speed_threshold_high > self.speed_threshold_low: # Avoid division by zero
                factor = (current_speed - self.speed_threshold_low) / \
                        (self.speed_threshold_high - self.speed_threshold_low)
                self._scroll_throttle_ms = int(self.min_throttle_ms + factor * (self.max_throttle_ms - self.min_throttle_ms))
                # drag_mode_label remains "MEDIUM"
            else: # Fallback if thresholds are misconfigured
                self._scroll_throttle_ms = self.min_throttle_ms
                drag_mode_label = "SLOW (threshold error)" # Or some other indicator
        
        # --- DEBUG PRINT STATEMENTS ---
        print(f"Drag Mode: {drag_mode_label} | Speed: {current_speed:.2f} px/s | Throttle: {self._scroll_throttle_ms} ms | Delta_Y: {delta_y_for_speed} | Delta_T: {delta_t:.4f} s")
        # --- END DEBUG ---
        
        # Update last event info for the next speed calculation in this drag sequence
        self._last_drag_event_time = current_time
        self._last_drag_event_y = mouse_y
        
        # --- Original logic for thumb positioning and visual update ---
        delta_y_total = mouse_y - self.scrollbar_mouse_start_y
        intended_new_thumb_y = self.scrollbar_thumb_start_y + delta_y_total

        canvas_height = self.custom_scrollbar_canvas.winfo_height()
        if canvas_height <= 0: return

        thumb_coords = self.custom_scrollbar_canvas.coords(self.scrollbar_thumb)
        if not thumb_coords: return

        thumb_height = thumb_coords[3] - thumb_coords[1]
        max_thumb_y = max(0, canvas_height - thumb_height)

        new_thumb_y_clamped = max(0, min(max_thumb_y, intended_new_thumb_y))

        self.custom_scrollbar_canvas.coords(self.scrollbar_thumb, 0, new_thumb_y_clamped, 15, new_thumb_y_clamped + thumb_height)
        self._last_thumb_y = new_thumb_y_clamped

        # --- Schedule Canvas Scroll (throttled) ---
        if not self._scroll_pending:
            self._scroll_pending = True
            if self._throttled_after_id:
                self.canvas.after_cancel(self._throttled_after_id)
            self._throttled_after_id = self.canvas.after(self._scroll_throttle_ms, self._perform_throttled_scroll)



    def _perform_throttled_scroll(self):
        """Performs the actual canvas scroll after the throttle delay."""
        # If the drag ended while this was waiting, the release handler will do the final scroll
        if not self.scrollbar_thumb_dragging:
             self._scroll_pending = False
             self._throttled_after_id = None
             return

        # Perform the scroll based on the *last visually updated* thumb position
        # (stored in self._last_thumb_y by custom_scrollbar_drag)
        self._perform_scroll(self._last_thumb_y)

        # Reset the pending flag so a new scroll can be scheduled on the next drag event
        self._scroll_pending = False
        self._throttled_after_id = None # Clear the ID


    def _perform_scroll(self, thumb_y):
        """Calculates and performs the yview_moveto based on thumb position."""
        canvas_height = self.custom_scrollbar_canvas.winfo_height() # Use scrollbar canvas height
        thumb_coords = self.custom_scrollbar_canvas.coords(self.scrollbar_thumb)
        if canvas_height <= 0 or not thumb_coords:
            return # Cannot calculate fraction if canvas height is zero or thumb missing

        thumb_height = thumb_coords[3] - thumb_coords[1]
        max_thumb_y = max(0, canvas_height - thumb_height) # Avoid div by zero

        # Avoid division by zero if the content isn't scrollable or thumb fills the space
        if max_thumb_y <= 0:
             scroll_fraction = 0
        else:
             # Fraction is the thumb's current Y position divided by the maximum possible Y position
             scroll_fraction = thumb_y / max_thumb_y

        # Ensure fraction is within [0, 1] range
        scroll_fraction = max(0.0, min(1.0, scroll_fraction))

        # Perform the actual canvas scroll
        self.canvas.yview_moveto(scroll_fraction)






    def custom_scrollbar_release(self, event):
        """Stop thumb dragging on mouse release."""
        self.scrollbar_thumb_dragging = False
        
    
    def custom_details_scrollbar_click(self, event):
        """Start thumb dragging on mouse click for DETAILS WINDOW."""
        self.scrollbar_thumb_dragging_details = True
        self.scrollbar_thumb_start_y_details = self.custom_scrollbar_canvas_details.coords(self.scrollbar_thumb_details)[1]
        self.scrollbar_mouse_start_y_details = event.y






    def custom_details_scrollbar_drag(self, event):
        """Drag thumb and update canvas view for DETAILS WINDOW (throttled)."""
        if not self.scrollbar_thumb_dragging_details:
            return

        mouse_y = event.y
        delta_y = mouse_y - self.scrollbar_mouse_start_y_details
        # Calculate *intended* new thumb position based on drag delta
        intended_new_thumb_y = self.scrollbar_thumb_start_y_details + delta_y

        # --- Update Thumb Visually (always immediate) ---
        # Use the details scrollbar canvas height
        canvas_height = self.custom_scrollbar_canvas_details.winfo_height()
        if canvas_height <= 0: return # Avoid issues if canvas isn't visible yet

        # Get details thumb coords
        thumb_coords = self.custom_scrollbar_canvas_details.coords(self.scrollbar_thumb_details)
        if not thumb_coords: return # Avoid issues if thumb isn't created

        # Check if content fits (can reuse existing logic, or simplify if scroll_range is reliable)
        # It's generally better to let custom_details_scrollbar_set handle visibility/max_thumb_y calculation based on canvas scrollregion
        # But for dragging, we calculate based on the scrollbar canvas height
        thumb_height = thumb_coords[3] - thumb_coords[1]
        max_thumb_y = max(0, canvas_height - thumb_height) # Ensure max_thumb_y is not negative

        # If there's no scrollable range (thumb fills the space), just return
        # This check isn't strictly necessary here if max_thumb_y is 0, as the fraction will be 0
        # and the throttling won't schedule unless max_thumb_y > 0, but leaving it can save calculations.
        # Let's rely on max_thumb_y check later.

        # Clamp the intended position for visual update
        new_thumb_y_clamped = max(0, min(max_thumb_y, intended_new_thumb_y))

        # Update the thumb's visual position instantly on the details scrollbar canvas
        self.custom_scrollbar_canvas_details.coords(self.scrollbar_thumb_details, 0, new_thumb_y_clamped, 15, new_thumb_y_clamped + thumb_height)

        # Store the latest clamped thumb position for the throttled update
        self._last_details_thumb_y = new_thumb_y_clamped

        # --- Schedule Canvas Scroll (throttled) ---
        # Only schedule a new scroll command if one is not already pending AND there's actually something to scroll
        if max_thumb_y > 0 and not self._details_scroll_pending:
            self._details_scroll_pending = True
            # Schedule _perform_throttled_details_scroll after the delay
            # Use the details canvas or root window for after scheduling
            self._details_throttled_after_id = self.details_canvas_sub.after(self._scroll_throttle_ms, self._perform_throttled_details_scroll)
            # Or use: self.root.after(self._scroll_throttle_ms, self._perform_throttled_details_scroll)

        # The old direct call is removed:
        # scroll_fraction = new_thumb_y / max_thumb_y if max_thumb_y > 0 else 0
        # self.details_canvas_sub.yview_moveto(scroll_fraction) # <-- REMOVE THIS



    def _perform_throttled_details_scroll(self):
        """Performs the actual DETAILS canvas scroll after the throttle delay."""
        # If the drag ended while this was waiting, the release handler will do the final scroll
        if not self.scrollbar_thumb_dragging_details: # Use the details dragging flag
            self._details_scroll_pending = False
            self._details_throttled_after_id = None
            return

        # Perform the scroll based on the *last visually updated* details thumb position
        # (stored in self._last_details_thumb_y by custom_details_scrollbar_drag)
        self._perform_details_scroll(self._last_details_thumb_y)

        # Reset the details pending flag so a new scroll can be scheduled
        self._details_scroll_pending = False
        self._details_throttled_after_id = None # Clear the ID


    def _perform_details_scroll(self, thumb_y):
        """Calculates and performs the yview_moveto for DETAILS canvas based on thumb position."""
        # Use the details scrollbar canvas height for fraction calculation
        canvas_height = self.custom_scrollbar_canvas_details.winfo_height()
        thumb_coords = self.custom_scrollbar_canvas_details.coords(self.scrollbar_thumb_details)

        if canvas_height <= 0 or not thumb_coords:
            return # Cannot calculate fraction if canvas height is zero or thumb missing

        thumb_height = thumb_coords[3] - thumb_coords[1]
        max_thumb_y = max(0, canvas_height - thumb_height) # Avoid div by zero

        # Avoid division by zero if the content isn't scrollable or thumb fills the space
        if max_thumb_y <= 0:
            scroll_fraction = 0
        else:
            # Fraction is the thumb's current Y position divided by the maximum possible Y position
            scroll_fraction = thumb_y / max_thumb_y

        # Ensure fraction is within [0, 1] range
        scroll_fraction = max(0.0, min(1.0, scroll_fraction))

        # Perform the actual canvas scroll on the DETAILS canvas
        self.details_canvas_sub.yview_moveto(scroll_fraction)


    def custom_details_scrollbar_release(self, event):
        """Stop thumb dragging on mouse release for DETAILS WINDOW."""
        self.scrollbar_thumb_dragging_details = False
        
        

    def custom_scrollbar_set(self, *args):
        """Custom scrollbar set command to update thumb position."""
        if self.scrollbar_thumb_dragging:
            return # Prevent updates if dragging manually

        start, end = args[0:2]
        canvas_height = self.canvas.winfo_height()
        scroll_range = self.canvas.bbox("all")
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height: # NO SCROLLING NEEDED - SET TO GREY
            self.custom_scrollbar_canvas.itemconfig(self.scrollbar_thumb, fill="#555555")
        else: # SCROLLING IS POSSIBLE - KEEP ORANGE (or set back to orange if it was grey)
            self.custom_scrollbar_canvas.itemconfig(self.scrollbar_thumb, fill=self.global_highlight_color)

        thumb_height = max(20, canvas_height * (canvas_height / scrollable_height)) if scrollable_height > canvas_height else canvas_height # Minimum thumb height
        thumb_y_start = canvas_height * float(start)
        thumb_y_end = thumb_y_start + thumb_height
        self.custom_scrollbar_canvas.coords(self.scrollbar_thumb, 0, thumb_y_start, 15, thumb_y_end)



    def custom_details_scrollbar_set(self, *args):
        """Custom scrollbar set command for DETAILS WINDOW to update thumb position."""
        if self.scrollbar_thumb_dragging_details:
            return # Prevent updates if dragging manually

        start, end = args[0:2]
        canvas_height = self.details_canvas_sub.winfo_height()
        scroll_range = self.details_canvas_sub.bbox("all")
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height: # NO SCROLLING NEEDED - SET TO GREY
            self.custom_scrollbar_canvas_details.itemconfig(self.scrollbar_thumb_details, fill="#555555")
        else: # SCROLLING IS POSSIBLE - KEEP ORANGE (or set back to orange if it was grey)
            self.custom_scrollbar_canvas_details.itemconfig(self.scrollbar_thumb_details, fill=self.global_highlight_color)


        thumb_height = max(20, canvas_height * (canvas_height / scrollable_height)) if scrollable_height > canvas_height else canvas_height # Minimum thumb height
        thumb_y_start = canvas_height * float(start)
        thumb_y_end = thumb_y_start + thumb_height
        self.custom_scrollbar_canvas_details.coords(self.scrollbar_thumb_details, 0, thumb_y_start, 15, thumb_y_end)
            
    def custom_search_results_scrollbar_set(self, *args):
        """Custom scrollbar set command for SEARCH RESULTS WINDOW to update thumb position."""
        if self.scrollbar_thumb_dragging_search_results:
            return # Prevent updates if dragging manually

        start, end = args[0:2]
        canvas_height = self.search_results_canvas.winfo_height()
        scroll_range = self.search_results_canvas.bbox("all")
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height: # NO SCROLLING NEEDED - SET TO GREY
            self.custom_scrollbar_canvas_search_results.itemconfig(self.scrollbar_thumb_search_results, fill="#555555")
        else: # SCROLLING IS POSSIBLE - KEEP ORANGE (or set back to orange if it was grey)
            self.custom_scrollbar_canvas_search_results.itemconfig(self.scrollbar_thumb_search_results, fill=self.global_highlight_color)

        thumb_height = max(20, canvas_height * (canvas_height / scrollable_height)) if scrollable_height > canvas_height else canvas_height # Minimum thumb height
        thumb_y_start = canvas_height * float(start)
        thumb_y_end = thumb_y_start + thumb_height
        self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results, 0, thumb_y_start, 15, thumb_y_end)


    def custom_search_results_scrollbar_click(self, event):
        """Start thumb dragging on mouse click for SEARCH RESULTS WINDOW."""
        self.scrollbar_thumb_dragging_search_results = True
        self.scrollbar_thumb_start_y_search_results = self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results)[1]
        self.scrollbar_mouse_start_y_search_results = event.y

    '''
    def custom_search_results_scrollbar_drag(self, event):
        """Drag thumb and update canvas view for SEARCH RESULTS WINDOW."""
        if not self.scrollbar_thumb_dragging_search_results:
            return

        mouse_y = event.y
        delta_y = mouse_y - self.scrollbar_mouse_start_y_search_results
        new_thumb_y = self.scrollbar_thumb_start_y_search_results + delta_y

        canvas_height = self.search_results_canvas.winfo_height()
        scroll_range = self.search_results_canvas.bbox("all")
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height:
            return # No scrolling needed if content fits

        thumb_height = self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results)[3] - self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results)[1]
        max_thumb_y = canvas_height - thumb_height
        new_thumb_y = max(0, min(max_thumb_y, new_thumb_y)) # Clamp thumb position

        self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results, 0, new_thumb_y, 15, new_thumb_y + thumb_height)

        scroll_fraction = new_thumb_y / max_thumb_y if max_thumb_y > 0 else 0
        self.search_results_canvas.yview_moveto(scroll_fraction)
        '''

    def custom_search_results_scrollbar_drag(self, event):
        """Drag thumb and update canvas view for SEARCH RESULTS WINDOW (throttled)."""
        if not self.scrollbar_thumb_dragging_search_results:
            return

        mouse_y = event.y
        delta_y = mouse_y - self.scrollbar_mouse_start_y_search_results
        # Calculate *intended* new thumb position based on drag delta
        intended_new_thumb_y = self.scrollbar_thumb_start_y_search_results + delta_y

        # --- Update Thumb Visually (always immediate) ---
        # Use the search results scrollbar canvas height
        canvas_height = self.custom_scrollbar_canvas_search_results.winfo_height()
        if canvas_height <= 0: return # Avoid issues if canvas isn't visible yet

        # Get search results thumb coords
        thumb_coords = self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results)
        if not thumb_coords: return # Avoid issues if thumb isn't created

        thumb_height = thumb_coords[3] - thumb_coords[1]
        max_thumb_y = max(0, canvas_height - thumb_height) # Ensure max_thumb_y is not negative

        # If there's no scrollable range, return
        if max_thumb_y <= 0:
            return # No scrolling needed if content fits (thumb should be max size anyway)


        # Clamp the intended position for visual update
        new_thumb_y_clamped = max(0, min(max_thumb_y, intended_new_thumb_y))

        # Update the thumb's visual position instantly on the search results scrollbar canvas
        self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results, 0, new_thumb_y_clamped, 15, new_thumb_y_clamped + thumb_height)

        # Store the latest clamped thumb position for the throttled update
        self._last_search_results_thumb_y = new_thumb_y_clamped

        # --- Schedule Canvas Scroll (throttled) ---
        # Only schedule a new scroll command if one is not already pending
        if not self._search_results_scroll_pending:
            self._search_results_scroll_pending = True
            # Schedule _perform_throttled_search_results_scroll after the delay
            # Use the search results canvas or root window for after scheduling
            self._search_results_throttled_after_id = self.search_results_canvas.after(self._scroll_throttle_ms, self._perform_throttled_search_results_scroll)
            # Or use: self.root.after(self._scroll_throttle_ms, self._perform_throttled_search_results_scroll)

        # The old direct call is removed:
        # scroll_fraction = new_thumb_y / max_thumb_y if max_thumb_y > 0 else 0
        # self.search_results_canvas.yview_moveto(scroll_fraction) # <-- REMOVE THIS
        
    def _perform_search_results_scroll(self, thumb_y):
        """Calculates and performs the yview_moveto for SEARCH RESULTS canvas based on thumb position."""
        # Use the search results scrollbar canvas height for fraction calculation
        canvas_height = self.custom_scrollbar_canvas_search_results.winfo_height()
        thumb_coords = self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results)

        if canvas_height <= 0 or not thumb_coords:
            return # Cannot calculate fraction if canvas height is zero or thumb missing

        thumb_height = thumb_coords[3] - thumb_coords[1]
        max_thumb_y = max(0, canvas_height - thumb_height) # Avoid div by zero

        # Avoid division by zero if the content isn't scrollable or thumb fills the space
        if max_thumb_y <= 0:
            scroll_fraction = 0
        else:
            # Fraction is the thumb's current Y position divided by the maximum possible Y position
            scroll_fraction = thumb_y / max_thumb_y

        # Ensure fraction is within [0, 1] range
        scroll_fraction = max(0.0, min(1.0, scroll_fraction))

        # Perform the actual canvas scroll on the SEARCH RESULTS canvas
        self.search_results_canvas.yview_moveto(scroll_fraction)



    def _perform_throttled_search_results_scroll(self):
        """Performs the actual SEARCH RESULTS canvas scroll after the throttle delay."""
        # If the drag ended while this was waiting, the release handler will do the final scroll
        if not self.scrollbar_thumb_dragging_search_results: # Use the correct dragging flag
            self._search_results_scroll_pending = False
            self._search_results_throttled_after_id = None
            return

        # Perform the scroll based on the *last visually updated* search results thumb position
        # (stored in self._last_search_results_thumb_y by custom_search_results_scrollbar_drag)
        self._perform_search_results_scroll(self._last_search_results_thumb_y)

        # Reset the search results pending flag so a new scroll can be scheduled
        self._search_results_scroll_pending = False
        self._search_results_throttled_after_id = None # Clear the ID





    def custom_search_results_scrollbar_release(self, event):
        """Stop thumb dragging on mouse release for SEARCH RESULTS WINDOW."""
        self.scrollbar_thumb_dragging_search_results = False
  
 
    def _track_normal_geometry(self, event=None):
        """Stores the geometry when the window is in a 'normal' state."""
        # Prevent acting on configure events from child widgets
        if event and event.widget != self.master:
            return
        try:
            if self.master.winfo_exists():
                current_state = self.master.wm_state()
                if current_state == 'normal':
                    geo = self.master.geometry()
                    # Avoid storing initial invalid geometry like '1x1+0+0'
                    if 'x' in geo and '+' in geo and not geo.startswith('1x1'):
                        self._last_normal_geometry = geo
                        # print(f"Debug: Tracked normal geometry: {self._last_normal_geometry}") # Optional
        except tk.TclError:
            pass # Window might be closing or not ready


    def save_window_geometry(self):
        """
        Saves the current window state and appropriate geometry.
        If maximized, saves the last known normal geometry.
        If normal, saves the current geometry.
        """
        geometry_string_to_save = None
        state_to_save = "normal" # Default

        try:
            if not self.master.winfo_exists():
                print("Window does not exist. Cannot save geometry.")
                return

            current_state = self.master.wm_state()
            # Determine the state string ('maximized' or 'normal')
            # Use 'zoomed' as the indicator for maximized state
            is_maximized = (current_state == 'zoomed')
            state_to_save = "maximized" if is_maximized else "normal"

            print(f"Current window state detected: {current_state} -> Saving as: {state_to_save}")

            # Decide which geometry string to use
            if is_maximized and self._last_normal_geometry:
                # Use the tracked normal geometry if maximized and we have it
                geometry_string_to_save = self._last_normal_geometry
                print(f"Using tracked normal geometry for save: {geometry_string_to_save}")
            else:
                # Use current geometry if normal, or as fallback if maximized
                geometry_string_to_save = self.master.geometry()
                print(f"Using current geometry for save: {geometry_string_to_save}")
                # If we are saving the current geometry and the state is normal,
                # ensure _last_normal_geometry is up-to-date.
                if not is_maximized:
                    self._last_normal_geometry = geometry_string_to_save

            # --- Now parse the chosen geometry string ---
            if not geometry_string_to_save or 'x' not in geometry_string_to_save or '+' not in geometry_string_to_save:
                 print(f"Warning: Invalid geometry string '{geometry_string_to_save}'. Aborting save.")
                 return

            # Parse WxH+X+Y (handle potential negative coordinates correctly)
            parts = geometry_string_to_save.replace('+', ' +').replace('-', ' -').split()
            # Expected format: ['WxH', '+X', '+Y'] or ['WxH', '-X', '-Y'] etc.
            if len(parts) != 3:
                print(f"Warning: Could not parse geometry string '{geometry_string_to_save}'. Aborting save.")
                return

            size_part = parts[0]
            x_part = parts[1]
            y_part = parts[2]

            w_part, h_part = size_part.split('x')

            width = int(w_part)
            height = int(h_part)
            x = int(x_part) # Will include sign
            y = int(y_part) # Will include sign

            # --- Perform the save ---
            if not os.path.exists("data"):
                os.makedirs("data")

            with open("data/MMSelectorSize.txt", "w") as f:
                f.write(f"{width}\n")
                f.write(f"{height}\n")
                f.write(f"{x}\n")
                f.write(f"{y}\n")
                f.write(f"{state_to_save}\n") # Save the determined state
            print(f"Window geometry saved: {width}x{height}+{x}+{y}, State: {state_to_save}")

        except tk.TclError as e:
             print(f"TCL Error saving window geometry (window might be closing): {e}")
        except ValueError as e:
             print(f"Value Error parsing geometry '{geometry_string_to_save}': {e}")
        except Exception as e:
            print(f"General Error saving window geometry: {e}")


    # --- load_window_geometry remains the same ---
    def load_window_geometry(self):
        """
        Loads the window geometry and state from MMSelectorSize.txt.
        Returns saved geometry/state or defaults if loading fails.
        Returns: tuple: (width, height, x, y, state)
        """
        default_width = 1366
        default_height = 700
        default_state = "normal"

        try:
            if os.path.exists("data/MMSelectorSize.txt"):
                with open("data/MMSelectorSize.txt", "r") as f:
                    lines = f.readlines()
                    if len(lines) == 5:
                        width = int(lines[0].strip())
                        height = int(lines[1].strip())
                        x = int(lines[2].strip())
                        y = int(lines[3].strip())
                        state = lines[4].strip().lower()
                        if state not in ['maximized', 'normal']:
                             state = default_state
                        print(f"Window geometry loaded: {width}x{height}+{x}+{y}, State: {state}")
                        return width, height, x, y, state
                    else: print("Warning: MMSelectorSize.txt has incorrect number of lines.")
            else: print("MMSelectorSize.txt not found.")
        except ValueError: print("Error: Non-integer value found in MMSelectorSize.txt.")
        except Exception as e: print(f"Error loading window geometry: {e}")

        # Defaults
        try:
            screen_width = self.master.winfo_screenwidth(); screen_height = self.master.winfo_screenheight()
            x = max(0, (screen_width // 2) - (default_width // 2)); y = max(0, (screen_height // 2) - (default_height // 2))
        except tk.TclError: x, y = 0, 0 # Fallback if screen info fails
        print(f"Returning DEFAULT geometry/state: {default_width}x{default_height}+{x}+{y}, State: {default_state}")
        return default_width, default_height, x, y, default_state


    # --- apply_loaded_geometry remains the same ---
    def apply_loaded_geometry(self):
        """Loads geometry and applies it to the master window."""


        if self.hide_main_grid_and_sidebar_start_passed == 1: # Check the number of times
            print("DEBUG: apply_loaded_geometry - First call detected. Returning immediately.")

            return  # Exit function on first call
        

        try:
            width, height, x, y, state = self.load_window_geometry()
            # Apply normal geometry first regardless of saved state
            self.master.geometry(f"{width}x{height}+{x}+{y}")
            print(f"Applied base geometry: {width}x{height}+{x}+{y}")
            # Store this as the potential last normal geometry if loading defaults
            # or if the loaded state was normal.
            if state == "normal":
                 self._last_normal_geometry = f"{width}x{height}+{x}+{y}"

            # Apply maximized state if needed, after a delay
            if state == "maximized":
                def set_maximized_state():
                    try:
                        if self.master.winfo_exists():
                            print("Attempting to set state to 'zoomed'...")
                            self.master.wm_state('zoomed')
                            # Check state? self.master.update_idletasks(); print(self.master.wm_state())
                    except tk.TclError as e: print(f"Error setting maximized state: {e}")
                self.master.after(100, set_maximized_state) # Increased delay slightly
        except Exception as e: print(f"Error applying loaded geometry: {e}")






    def manual_gc_collect(self):
        """
        Manually triggers garbage collection and prints a message to the console.
        This is for debugging purposes to help identify potential memory leaks. 
        Also prints important data and sends it to the console
        """
        print("--- Manual Garbage Collection Triggered ---")
        collected = gc.collect()
        print(f"Garbage collector: collected {collected} objects.")
        print("--- Manual Garbage Collection Completed ---\n")
        print(f"{self.data}")
   
    # ------------------------------------------------------------
    # Format Grouped Data
    # ------------------------------------------------------------



 


    def format_grouped_data(self, data_list):
        print("\n--- format_grouped_data() [WITH FAVORITES LOGIC] DEBUG ENTRY ---")
        print(f"  DEBUG: self.sort_by_install_date: {self.sort_by_install_date}")
        print(f"  DEBUG: self.collapse_categories_by_default: {self.collapse_categories_by_default}")
        print(f"  DEBUG: self.show_pinned_favorites_category: {self.show_pinned_favorites_category}")
        print(f"  DEBUG: self.categorization_mode: {self.categorization_mode}")

        grouped = {}
        zip_creation_times = {} # For sorting items within categories by install date
        folder_zip_latest_mtimes = {} # For sorting categories themselves by install date

        # --- Determine if we need to create and populate the "Favorites" category ---
        create_favorites_category_active = self.show_pinned_favorites_category and \
                                           self.categorization_mode in ["Type", "Country", "None"]
        
        print(f"  DEBUG: create_favorites_category_active: {create_favorites_category_active}")

        folders_added_to_favorites_pin = set() # To ensure a folder rep is added only once to the pinned "Favorites"

        # --- 1. Populate zip_creation_times and folder_zip_latest_mtimes (if sorting by install date) ---
        if self.sort_by_install_date:
            parent_dir = os.path.dirname(self.repo_folder) # Assuming self.repo_folder is valid
            for item_for_time_check in data_list: # Iterate over the full data_list once for times
                # Ensure item_for_time_check has the expected structure
                if not (isinstance(item_for_time_check, (list, tuple)) and len(item_for_time_check) == 5):
                    continue
                
                zip_file_for_time = item_for_time_check[2]
                folder_name_for_time = item_for_time_check[4]

                if zip_file_for_time != "user_custom_configs":
                    zip_file_name_actual = zip_file_for_time
                    if not zip_file_name_actual.lower().endswith(".zip"):
                        zip_file_name_actual += ".zip"
                    
                    zip_path_repo = os.path.join(self.repo_folder, zip_file_name_actual)
                    zip_path_parent_mods = os.path.join(parent_dir, zip_file_name_actual) # Path in mods/
                    
                    modification_time = 0
                    if os.path.exists(zip_path_repo):
                        modification_time = os.path.getmtime(zip_path_repo)
                    elif os.path.exists(zip_path_parent_mods): # Check in mods/ folder
                        modification_time = os.path.getmtime(zip_path_parent_mods)
                    
                    # Store modification time for the specific zip_file (original name, not with .zip)
                    zip_creation_times[zip_file_for_time] = modification_time
                    
                    # Update the latest modification time for the folder
                    current_latest_for_folder = folder_zip_latest_mtimes.get(folder_name_for_time, 0)
                    folder_zip_latest_mtimes[folder_name_for_time] = max(current_latest_for_folder, modification_time)

        


        # --- 2. Iterate through data_list to group items and populate "Favorites" ---
        for item in data_list:
            # Ensure item has the expected structure before unpacking
            if not (isinstance(item, (list, tuple)) and len(item) == 5):
                print(f"  WARN: Skipping malformed item in data_list: {str(item)[:100]}")
                continue

            pic, spawn_cmd, zip_file, info_data, folder_name = item
            
            # a. Determine normal category and add item
            normal_category_key = "Unknown Category" # Default
            if info_data: # Ensure info_data is not None
                brand = info_data.get("Brand", "").strip()
                vehicle_type = info_data.get("Type", "").strip()
                country = info_data.get("Country", "").strip()

                if self.categorization_mode == 'Brand':
                    if zip_file == "user_custom_configs":
                        normal_category_key = brand if brand else (vehicle_type if vehicle_type else "Custom")
                    else:
                        normal_category_key = brand if brand else (f"{vehicle_type} (Brand Unavailable)" if vehicle_type else "Unknown Brand")
                elif self.categorization_mode == 'Country':
                    normal_category_key = country if country else "Unknown Country"
                elif self.categorization_mode == 'None':
                    normal_category_key = "All Items"
                else: # Default to 'Type'
                    normal_category_key = vehicle_type if vehicle_type else "Unknown Type"
            
            grouped.setdefault(normal_category_key, []).append(item)

            # b. Conditionally add to pinned "Favorites" category
            if create_favorites_category_active and folder_name not in folders_added_to_favorites_pin:
                if folder_name in self.full_data:
                    folder_data_entry = self.full_data[folder_name]
                    all_configs_in_folder_list = []
                    if isinstance(folder_data_entry, list):
                        all_configs_in_folder_list = folder_data_entry
                    elif isinstance(folder_data_entry, dict) and 'configs' in folder_data_entry:
                        all_configs_in_folder_list = folder_data_entry.get('configs', [])

                    for config_tuple_in_folder in all_configs_in_folder_list:
                        if not isinstance(config_tuple_in_folder, (list, tuple)) or len(config_tuple_in_folder) < 2:
                            continue
                        config_spawn_cmd = config_tuple_in_folder[1]
                        if not isinstance(config_spawn_cmd, str):
                            continue
                        
                        pc_filename_for_fav_check = self.extract_name_from_spawn_command(config_spawn_cmd) + ".pc"
                        if self.is_favorite(folder_name, pc_filename_for_fav_check):
                            grouped.setdefault("Favorites", []).append(item) # Add the FOLDER REPRESENTATIVE
                            folders_added_to_favorites_pin.add(folder_name)
                            print(f"  DEBUG: Added '{folder_name}' to pinned 'Favorites' because '{pc_filename_for_fav_check}' is a favorite.")
                            break 
        
        # Cleanup empty "Favorites" category if it was created but no items were added
        if "Favorites" in grouped and not grouped["Favorites"]:
            del grouped["Favorites"]
            print(f"  DEBUG: Removed empty pinned 'Favorites' category.")

        # --- 3. Representative Image Selection (Your existing logic) ---
        # This will also apply to the "Favorites" category if it exists.
        # The representative image for "Favorites" will be based on the first item added to it.
        print("\n  --- Representative Image Selection ---")
        # self.clear_main_grid_cache() # Already called in your original, ensure it's intended here
        # updated_data_items = [] # Not used in your provided code snippet for this part
        for category, items_in_cat in grouped.items():
            if items_in_cat: # Ensure category is not empty

                representative_picture = None # Placeholder
                # Correctly get folder_name for representative image search
                folder_name_for_rep_img = items_in_cat[0][4] if items_in_cat[0] and len(items_in_cat[0]) == 5 else None

                if folder_name_for_rep_img:
                    representative_picture_path_from_folder = self.find_representative_image_in_folder(folder_name_for_rep_img)
                    if representative_picture_path_from_folder:
                        representative_picture = representative_picture_path_from_folder
                    else: # Fallback to placeholders
                        is_custom_cat_item = items_in_cat[0][2] == "user_custom_configs" if items_in_cat[0] and len(items_in_cat[0]) >= 3 else False
                        if is_custom_cat_item:
                            representative_picture = os.path.join(self.script_dir, "data/MissingCustomConfigPic.png")
                        else:
                            representative_picture = os.path.join(self.script_dir, "data/MissingZipConfigPic.png")
                else: # Fallback if folder_name_for_rep_img couldn't be determined
                    representative_picture = os.path.join(self.script_dir, "data/MissingZipConfigPic.png")


                # Update picture_path for all items in this category for main grid display
                for i in range(len(items_in_cat)):
                    # Ensure item_in_cat[i] is a tuple and can be modified (convert to list if needed)
                    if isinstance(items_in_cat[i], tuple) and len(items_in_cat[i]) == 5:
                        item_list_mutable = list(items_in_cat[i])
                        item_list_mutable[0] = representative_picture
                        items_in_cat[i] = tuple(item_list_mutable)
        print("  --- Representative Image Selection END ---")

        # --- 4. Collapse Categories by Default Logic (Your existing logic) ---
        print("  DEBUG: Applying Collapse Categories Logic (Persistent).")
        for category_key_for_collapse in grouped: # Iterate over keys in grouped
            self.category_hidden_states.setdefault(category_key_for_collapse, self.collapse_categories_by_default)
        # Special handling for "Favorites" - if it exists, it should respect collapse_categories_by_default
        # or you can force it to be expanded if self.show_pinned_favorites_category is True
        if "Favorites" in grouped:
            self.category_hidden_states["Favorites"] = self.collapse_categories_by_default
            print(f"  DEBUG: 'Favorites' category hidden state set to: {self.category_hidden_states['Favorites']}")


        # # --- 5. Sort items WITHIN each category ---
        # print("  DEBUG: Sorting items WITHIN each category...")
        # for category_key_for_sort, items_to_sort in grouped.items():
        #     if self.sort_by_install_date:
        #         # Sort by install date (primary), then folder name (for user_custom within date), then Brand, then Name
        #         items_to_sort.sort(key=lambda x: (
        #             zip_creation_times.get(x[2], 0) if x[2] != "user_custom_configs" else -1, # Custom configs last if no real date
        #             x[4].lower() if x[2] == "user_custom_configs" else "", # Folder name for custom
        #             x[3].get("Brand", "").lower(), # Brand
        #             x[3].get("Name", "").lower()   # Name
        #         ), reverse=True) # Latest first
        #     else:
        #         # Alphabetical sort by Brand, then Name (or folder for "Custom")
        #         if category_key_for_sort == "Custom": # Should not happen if Brand/Type is used for custom
        #             items_to_sort.sort(key=lambda x: (x[4].lower(), os.path.splitext(os.path.basename(x[0]))[0].lower()))
        #         else:
        #             items_to_sort.sort(key=lambda x: (x[3].get("Brand", "").lower(), x[3].get("Name", "").lower()))
        # print("  DEBUG: Sorting items WITHIN categories COMPLETE.")



        # --- 5. Sort items WITHIN each category ---
        print("  DEBUG: Sorting items WITHIN each category...")
        for category_key_for_sort, items_to_sort in grouped.items():
            if self.sort_by_install_date:
                # Sort by install date (primary), then folder name (for user_custom within date), then Brand, then Name
                items_to_sort.sort(key=lambda x: (
                    zip_creation_times.get(x[2], 0) if x[2] != "user_custom_configs" else -1, # Custom configs last if no real date
                    x[4].lower() if x[2] == "user_custom_configs" else "", # Folder name for custom
                    x[3].get("Brand", "").lower(), # Brand
                    x[3].get("Name", "").lower()   # Name
                ), reverse=True) # Latest first
            # <<<< MODIFICATION START >>>>
            elif self.categorization_mode == 'None' and category_key_for_sort == "All Items":
                # This 'elif' block handles the specific case:
                # - Categorization mode is 'None' (so category is "All Items")
                # - AND we are NOT sorting by install date (the 'if' above was false)
                # - AND the current category being processed is indeed "All Items".
                print(f"  DEBUG: Applying IMPLICIT custom sort order for items in '{category_key_for_sort}'")

                def get_implicit_sort_group_for_item(item_tuple):
                    # item_tuple structure: (pic, spawn_cmd, zip_file, info_data, folder_name)
                    # info_data is item_tuple[3]
                    item_info_data = item_tuple[3] 
                    
                    if not item_info_data: # Handles if info_data dict itself is None
                        return 3 # Default to "Other Items" group

                    vehicle_type_raw = item_info_data.get("Type", "").strip()
                    vehicle_type_lower = vehicle_type_raw.lower()

                    if vehicle_type_lower in ["car", "truck", "bus", "aircraft"]:
                        return 0 # Implicit group 0: "main vehicles list"
                    elif vehicle_type_lower == "trailer":
                        return 1 # Implicit group 1: "trailer"
                    elif vehicle_type_lower == "prop":
                        return 2 # Implicit group 2: "prop"
                    else:
                        return 3 # Implicit group 3: "everything else"
                
                # Sort items: 
                # Primary key: implicit group order (0, 1, 2, 3)
                # Secondary key: Brand (alphabetical)
                # Tertiary key: Name (alphabetical)
                items_to_sort.sort(key=lambda x_item: (
                    get_implicit_sort_group_for_item(x_item),
                    x_item[3].get("Brand", "").lower() if x_item[3] else "", 
                    x_item[3].get("Name", "").lower() if x_item[3] else ""  
                ))
            # <<<< MODIFICATION END >>>>
            else:
                # Original alphabetical sort for:
                # - Categorization modes 'Type', 'Brand', 'Country' (when not sorting by install date)
                # - Or for categories like "Favorites" when categorization_mode is 'None' and not sorting by date.
                if category_key_for_sort == "Custom": # Should not happen if Brand/Type is used for custom
                    items_to_sort.sort(key=lambda x: (x[4].lower(), os.path.splitext(os.path.basename(x[0]))[0].lower()))
                else:
                    items_to_sort.sort(key=lambda x: (x[3].get("Brand", "").lower(), x[3].get("Name", "").lower()))
        print("  DEBUG: Sorting items WITHIN categories COMPLETE.")


        # --- 6. Sort the CATEGORIES themselves ---
        print("  DEBUG: Sorting CATEGORIES (Refined Logic - Install Date only for intra-category sort)...")
        ordered_category_keys = []
        
        # Always pin "Favorites" to the top if it exists and is active
        if "Favorites" in grouped: # Assumes "Favorites" is only in grouped if create_favorites_category_active was true
            ordered_category_keys.append("Favorites")
            print(f"  DEBUG: Pinned 'Favorites' to top of category order.")

        # Get other categories (excluding "Favorites" if already added)
        other_categories_to_sort = [cat_key for cat_key in grouped.keys() if cat_key != "Favorites"]

        # Define your predefined order
        category_order_main_grid = ["car", "truck", "bus", "trailer", "aircraft", "prop"] # Add any other types you want in a specific order

        # Separate known "Unknown" categories
        unknown_categories = []
        regular_categories = [] # Categories that are not "Favorites" and not "Unknown"

        for cat_name in other_categories_to_sort:
            if cat_name.startswith("Unknown"):
                unknown_categories.append(cat_name)
            else:
                regular_categories.append(cat_name)
        
        print(f"  DEBUG: Regular categories to sort: {regular_categories}")
        print(f"  DEBUG: Unknown categories to sort: {unknown_categories}")

        # Sort the "regular" categories:
        # Primary sort: by index in category_order_main_grid if present
        # Secondary sort: alphabetically by category name
        sorted_regular_categories = sorted(
            regular_categories,
            key=lambda x: (
                category_order_main_grid.index(x.lower()) if x.lower() in category_order_main_grid else len(category_order_main_grid),
                x.lower()
            )
        )
        ordered_category_keys.extend(sorted_regular_categories)
        print(f"  DEBUG: Regular categories sorted and appended: {sorted_regular_categories}")

        # Sort the "unknown" categories alphabetically and add them last
        sorted_unknown_categories = sorted(unknown_categories, key=lambda x: x.lower())
        ordered_category_keys.extend(sorted_unknown_categories)
        print(f"  DEBUG: Unknown categories sorted and appended: {sorted_unknown_categories}")
        
        print(f"  DEBUG: Final proposed category order before reconstruction: {ordered_category_keys}")

        # Reconstruct grouped dictionary to ensure order for UI iteration
        final_ordered_grouped_data = {cat_key: grouped[cat_key] for cat_key in ordered_category_keys if cat_key in grouped}
        grouped = final_ordered_grouped_data # Replace original with ordered one
        
        print(f"  DEBUG: Final category order after reconstruction: {list(grouped.keys())}")
        print("  DEBUG: Sorting CATEGORIES COMPLETE.")

        print("--- format_grouped_data() [WITH FAVORITES LOGIC] DEBUG EXIT ---\n")  
        return grouped

        

    def find_representative_image_in_folder(self, folder_name):
        """
        Scans the given vehicle folder for a representative image.
        """
        #print("\n--- find_representative_image_in_folder() DEBUGGING ---") # Debug Entry
        #print(f"  DEBUG: folder_name received: {folder_name}") # Debug - folder_name
        #print(f"  DEBUG: self.user_folder: {self.user_folder}") # Debug - self.user_folder

        vehicle_folder_path = os.path.join(self.user_folder, folder_name)
        #print(f"  DEBUG: Constructed vehicle_folder_path: {vehicle_folder_path}") # Debug - Constructed path

        if not os.path.isdir(vehicle_folder_path):
            print(f"  WARNING: Vehicle folder NOT FOUND: {vehicle_folder_path}") # Debug - Folder not found
            return None
        else:
            print(f"  DEBUG: Vehicle folder FOUND: {vehicle_folder_path}") # Debug - Folder found

        image_extensions = ['.png', '.jpg', '.jpeg']
        for filename in os.listdir(vehicle_folder_path):
            base, ext = os.path.splitext(filename)
            if ext.lower() in image_extensions:
                pc_candidate_path = os.path.join(vehicle_folder_path, f"{base}.pc")
                if os.path.exists(pc_candidate_path):
                    image_path = os.path.join(vehicle_folder_path, filename)
                    print(f"  DEBUG: Found representative image in folder: {image_path}") # Debug
                    print("--- find_representative_image_in_folder() DEBUGGING END ---\n") # Debug Exit
                    return image_path  # Return the first suitable image found

        print(f"  DEBUG: No representative image with corresponding .pc found in folder: {vehicle_folder_path}") # Debug
        print("--- find_representative_image_in_folder() DEBUGGING END ---\n") # Debug Exit
        return None


    # ------------------------------------------------------------
    # Categorization Mode
    # ------------------------------------------------------------
    def toggle_categorization_mode(self):
        """Toggles the categorization mode, added search window update."""
        if self.categorization_mode == 'Type':
            self.categorization_mode = 'Brand'
            self.categorize_button.config(text="Categorize by: Brand")
        elif self.categorization_mode == 'Brand':
            self.categorization_mode = 'None'
            self.categorize_button.config(text="Categorize by: None")
        else:
            self.categorization_mode = 'Type'
            self.categorize_button.config(text="Categorize by: Type")

        self.grouped_data = self.format_grouped_data(self.data)
        print("    toggle_categorization_mode is calling self.update_grid_layout()")
        self.update_grid_layout()
        self.canvas.yview_moveto(0)

        print("    toggle_categorization_mode is calling self.perform_search()")
        self.perform_search()
        self.canvas.yview_moveto(0)
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE



    def show_category_list_dropdown(self):
        if hasattr(self, 'category_list_dropdown_window') and self.category_list_dropdown_window and self.category_list_dropdown_window.winfo_exists():
            self.category_list_dropdown_window.destroy()
            return

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust category visibility while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return


        button = self.category_list_button
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty()
        button_height = button.winfo_height()

        self.category_list_dropdown_window = dropdown_window = FadingToplevel(self.master, self)
        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        dropdown_window.config(bg="#333333")
        dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        def set_category_list_clicked_to_true(event=None):
            self.category_list_button_clicked = True
            print("cat_list_window_clicked")

        dropdown_window.bind("<Button-1>", set_category_list_clicked_to_true, add='+')


        canvas = tk.Canvas(dropdown_window, bg="#333333", highlightthickness=0, width=250, height=200)
        scrollbar = tk.Scrollbar(dropdown_window, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#333333")

        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        canvas.configure(yscrollcommand=scrollbar.set)
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw", width=250)

        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_dropdown_mousewheel(ev, canvas)))
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))

        categories = list(self.grouped_data.keys())
        category_vars = {}  # Initialize category_vars here
        category_buttons = {}  # ADDED: Dictionary to store buttons for each category
        cat_buttons = []

        # --- STORE ORIGINAL CATEGORY STATES ---
        self.original_category_states = {}  # Initialize here
        for category in categories:
            self.original_category_states[category] = "Shown" if not self.category_hidden_states.get(category, False) else "Hidden"
        print(f"DEBUG: Stored original category states: {self.original_category_states}")

        def toggle_category_in_dropdown(category):


            current_text = category_vars[category].get()

            if " (Shown)" in current_text:
                category_vars[category].set(category.replace(" (Shown)", "") + " (Hidden - Pending)")
            elif " (Hidden)" in current_text:
                category_vars[category].set(category.replace(" (Hidden)", "") + " (Shown - Pending)")
            elif " (Hidden - Pending)" in current_text or " (Shown - Pending)" in current_text:
                original_state = self.original_category_states[category]
                category_vars[category].set(category + " (Shown)" if original_state == "Shown" else category + " (Hidden)")
            else:
                category_vars[category].set(category + " (Hidden - Pending)")

            # --- MODIFIED SECTION ---
            # Re-apply hover/selected logic using _bind_animated_hover
            # This ensures consistent state management.
            try:
                btn = category_buttons[category]
                new_text = category_vars[category].get()
                is_now_pending = "- Pending" in new_text

                # Define the colors as used in update_category_buttons
                default_original_bg = "#555555"
                default_original_fg = "#FFFFFF"
                pending_state_bg = self.global_highlight_color
                pending_state_fg = "#FFFFFF"
                item_hover_bg = "#FFFFFF"
                item_hover_fg = "black"

                # Call _bind_animated_hover to correctly set appearance and event bindings
                self._bind_animated_hover(
                    button=btn,
                    original_bg=default_original_bg,
                    original_fg=default_original_fg,
                    hover_target_bg=item_hover_bg,
                    hover_target_fg=item_hover_fg,
                    check_state=False, # Assuming same as in update_category_buttons
                    is_selected_initial=is_now_pending, # THIS IS THE KEY CHANGE
                    selected_bg=pending_state_bg,
                    selected_fg=pending_state_fg
                )
            except KeyError:
                # This can happen if the button isn't currently displayed (e.g., due to search filter)
                # In that case, when update_category_buttons runs next, it will pick up the correct state.
                print(f"DEBUG: toggle_category_in_dropdown - Button for '{category}' not found in category_buttons. "
                      f"Likely filtered out by search. State will update on next refresh.")
                pass
            # --- END MODIFIED SECTION ---

        def update_category_buttons(search_query=""):
            print(f"DEBUG: update_category_buttons - START - search_query: '{search_query}'")
            nonlocal cat_buttons
            print(f"  DEBUG: update_category_buttons - cat_buttons before clear: {cat_buttons}")

            for btn in cat_buttons:
                btn.destroy()
            cat_buttons.clear()
            category_buttons.clear()  # ADDED: Clear the category_buttons dictionary
            print(f"  DEBUG: update_category_buttons - cat_buttons after clear: {cat_buttons}")

            print("  DEBUG: update_category_buttons - Starting button creation loop")
            for category in categories:
                if not search_query or search_query.lower() in category.lower():
                    # --- StringVar and Initial Text Logic (Mostly Unchanged) ---
                    if category in category_vars:
                        current_var = category_vars[category]
                    else:
                        current_var = tk.StringVar()
                        category_vars[category] = current_var

                    if category in category_vars and category_vars[category].get():
                        initial_button_text_from_var = category_vars[category].get()
                        # print(f"    DEBUG: update_category_buttons - Category: {category}, Using existing category_vars text: '{initial_button_text_from_var}'")
                    else:
                        is_category_hidden = self.category_hidden_states.get(category, False)
                        initial_button_text_from_var = category + (" (Shown)" if not is_category_hidden else " (Hidden)")
                        # print(f"    DEBUG: update_category_buttons - Category: {category}, No existing category_vars text, using hidden state: {is_category_hidden}, text: '{initial_button_text_from_var}'")

                    current_var.set(initial_button_text_from_var)
                    button_text_for_logic = current_var.get() # Used for "Pending" check

                    # --- Define Colors ---
                    default_original_bg = "#555555"
                    default_original_fg = "#FFFFFF"

                    pending_state_bg = self.global_highlight_color # This is the "selected" bg for pending items
                    pending_state_fg = "#FFFFFF"                   # FG for pending items

                    # Hover colors for these specific buttons
                    item_hover_bg = "#FFFFFF" # White background on hover
                    item_hover_fg = "black"   # Black foreground on hover

                    # --- Determine if this button starts in the "Pending" (selected-like) state ---
                    is_initially_pending = ("- Pending" in button_text_for_logic)

                    # --- Button Creation ---
                    # Initial bg/fg will be set by _bind_animated_hover based on is_initially_pending
                    cat_button = tk.Button(
                        scrollable_frame,
                        textvariable=current_var, # Use the specific var for this button
                        font=("Segoe UI", 10 + self.font_size_add, "bold"),
                        command=lambda cat=category: toggle_category_in_dropdown(cat), # Ensure toggle_category_in_dropdown exists
                        # bg, fg, relief, bd, anchor, padx are now handled by styles or _bind_animated_hover
                        relief=tk.FLAT, # Kept from original
                        bd=1,           # Kept from original (though might be overridden by flat if no highlightthickness)
                        anchor="w",     # Kept from original
                        padx=10         # Kept from original
                    )

                    # --- Apply Smooth Hover Animation & Initial "Pending" State ---
                    self._bind_animated_hover(
                        button=cat_button,
                        original_bg=default_original_bg,
                        original_fg=default_original_fg,
                        hover_target_bg=item_hover_bg,      # Custom hover BG (white)
                        hover_target_fg=item_hover_fg,      # Custom hover FG (black)
                        check_state=False,                  # Assuming these don't have a separate tk.DISABLED state for hover
                        is_selected_initial=is_initially_pending, # Is it in "Pending" state?
                        selected_bg=pending_state_bg,       # Visuals for "Pending" state
                        selected_fg=pending_state_fg
                    )

                    cat_button.pack(fill="x", pady=1)
                    cat_buttons.append(cat_button)
                    category_buttons[category] = cat_button
                    #print(f"    DEBUG: update_category_buttons - Created button for: {category}, text: '{button_text}'")
            print("  DEBUG: update_category_buttons - Button creation loop END")
            print(f"  DEBUG: update_category_buttons - cat_buttons after creation loop: {cat_buttons}")

            canvas.config(scrollregion=canvas.bbox("all"))
            print("DEBUG: update_category_buttons - END")


        def hide_all_categories_in_dropdown():
            print("DEBUG: hide_all_categories_in_dropdown - START")
            for category in categories:
                category_vars[category].set(category + " (Hidden - Pending)") # Update category_vars FIRST
                print(f"  DEBUG: hide_all_categories_in_dropdown - Setting category_vars['{category}'] to: '{category_vars[category].get()}'")
            update_category_buttons(search_query_var.get()) # THEN call update_category_buttons
            dropdown_window.update_idletasks()
            print("DEBUG: hide_all_categories_in_dropdown - END")


        def show_all_categories_in_dropdown():
            print("DEBUG: show_all_categories_in_dropdown - START")
            for category in categories:
                category_vars[category].set(category + " (Shown - Pending)") # Update category_vars FIRST
                print(f"  DEBUG: show_all_categories_in_dropdown - Setting category_vars['{category}'] to: '{category_vars[category].get()}'")
            update_category_buttons(search_query_var.get()) # THEN call update_category_buttons
            dropdown_window.update_idletasks()
            print("DEBUG: show_all_categories_in_dropdown - END")


        def apply_category_visibility():
            for category in categories:
                if category_vars[category].get().endswith(" (Hidden - Pending)"):
                    self.category_hidden_states[category] = True
                elif category_vars[category].get().endswith(" (Shown - Pending)"):
                    self.category_hidden_states[category] = False
            print("    apply_category_visibility  is calling self.update_grid_layout() - inner function of apply_category_visibility()")       
            self.update_grid_layout()
            dropdown_window.destroy()
            self.category_list_dropdown_window = None

        button_frame = tk.Frame(dropdown_window, bg="#333333")
        button_frame.pack(fill="x", side="bottom")

        search_query_var = tk.StringVar()
        search_entry = tk.Entry(button_frame, textvariable=search_query_var, font=("Segoe UI", 10+self.font_size_add), bg="#FFFFFF", fg="black")
        search_entry.pack(pady=2, fill="x")

        search_entry.bind("<KeyRelease>", lambda event: update_category_buttons(search_query_var.get()))
        search_entry.bind("<KeyRelease>", lambda event, canvas=canvas: canvas.yview_moveto(0), add='+')


        hide_all_button = tk.Button(button_frame, text="Hide All", font=("Segoe UI", 10+self.font_size_add, "bold"), command=hide_all_categories_in_dropdown, bg="#555555", fg="#FFFFFF", relief=tk.RAISED, bd=1)
        show_all_button = tk.Button(button_frame, text="Show All", font=("Segoe UI", 10+self.font_size_add, "bold"), command=show_all_categories_in_dropdown, bg="#555555", fg="#FFFFFF", relief=tk.RAISED, bd=1)
        apply_button = tk.Button(button_frame, text="Apply", font=("Segoe UI", 10+self.font_size_add, "bold"), command=apply_category_visibility, bg="#555555", fg="#FFFFFF", relief=tk.RAISED, bd=1)

        hide_all_button.pack(fill="x", pady=2, in_=button_frame)
        show_all_button.pack(fill="x", pady=2, in_=button_frame)
        apply_button.pack(fill="x", pady=2, in_=button_frame, side="bottom")


        update_category_buttons() # Call update_category_buttons initially to populate list

        # Force update to calculate window size based on content
        dropdown_window.update_idletasks()
        # Get the actual height of the dropdown window
        window_height = dropdown_window.winfo_height()
        # Calculate the target Y position (top edge of button minus window height)
        target_y = button_y - window_height
        # Set the final position
        dropdown_window.geometry(f"+{button_x}+{target_y}")


        dropdown_window.bind("<FocusOut>", lambda event: self.destroy_category_list_dropdown())

 





    def toggle_show_pinned_favorites_category(self, called_via_shortcut=None):
        """Toggles the 'favorites_category' setting, updates UI, and saves setting.""" # Modified docstring


        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust this setting while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return


        if self.search_results_window:

            scanning_win = self.show_scanning_window(text="This setting will take effect when search or filtering is no longer active.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)


        if not called_via_shortcut:
            self.show_pinned_favorites_category = not self.show_pinned_favorites_category
        else:
            self.categorization_mode = "Brand"

        self.grouped_data = self.format_grouped_data(self.data) # Re-group and re-sort
        if not self.is_search_results_window_active:

            print("    toggle_show_pinned_favorites_category is calling self.update_grid_layout()")
            self.update_grid_layout()
            self.canvas.yview_moveto(0)
            print("    toggle_show_pinned_favorites_category is calling self.perform_search()")
            self.perform_search()
            self.canvas.yview_moveto(0)
            self._update_filters_label_status()

        if self.is_search_results_window_active:
            self.delayed_sort_by_install_date_or_favorites_category_toggle = True
            print(f"toggle_show_pinned_favorites_category - the search results window was OPEN, therefore delaying the visual refresh until the search results window is destroyed")
            print(f" --- therefore for the flag has been set - self.delayed_sort_by_install_date_or_favorites_category_toggle = True")

        self.update_settings_dropdown_button_text() # Call function to update button text
        self.save_settings() # Save setting to file - ADDED



        

    def toggle_sort_by_install_date(self):
        """Toggles the 'Sort by Install Date' setting, updates UI, and saves setting.""" # Modified docstring


        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust this setting while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return


        if self.search_results_window:

            scanning_win = self.show_scanning_window(text="This setting will take effect when search or filtering is no longer active.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)

        self.sort_by_install_date = not self.sort_by_install_date


        self.grouped_data = self.format_grouped_data(self.data) # Re-group and re-sort
        if not self.is_search_results_window_active:

            print("    toggle_sort_by_install_date is calling self.update_grid_layout()")
            self.update_grid_layout()
            self.canvas.yview_moveto(0)
            print("    toggle_sort_by_install_date is calling self.perform_search()")
            self.perform_search()
            self.canvas.yview_moveto(0)
            self._update_filters_label_status()

        if self.is_search_results_window_active:
            self.delayed_sort_by_install_date_or_favorites_category_toggle = True
            print(f"toggle_sort_by_install_date - the search results window was OPEN, therefore delaying the visual refresh until the search results window is destroyed")
            print(f" --- therefore for the flag has been set - self.delayed_sort_by_install_date_or_favorites_category_toggle = True")

        self.update_settings_dropdown_button_text() # Call function to update button text
        self.save_settings() # Save setting to file - ADDED



    def trigger_toggle_sort_by_install_date_after_search_results_window_close(self):
        if self.delayed_sort_by_install_date_or_favorites_category_toggle:
            self.delayed_sort_by_install_date_or_favorites_category_toggle = False
            print(f"--- trigger_toggle_sort_by_install_date_after_search_results_window_close ENTRY - self.delayed_sort_by_install_date_or_favorites_category_toggle = True")
            print("    trigger_toggle_sort_by_install_date_after_search_results_window_close is calling self.update_grid_layout()")
            self.update_grid_layout()
            self.canvas.yview_moveto(0)

            print("    trigger_toggle_sort_by_install_date_after_search_results_window_close is calling self.perform_search()")
            self.perform_search()
            self.canvas.yview_moveto(0)
            self._update_filters_label_status()

            print(f"--- trigger_toggle_sort_by_install_date_after_search_results_window_close EXIT - self.delayed_sort_by_install_date_or_favorites_category_toggle = False")
        else:
            return




    def toggle_collapse_categories_by_default(self):
        """Toggles the 'Collapse Categories By Default' setting and updates dropdown text."""
        self.collapse_categories_by_default = not self.collapse_categories_by_default
        self.update_settings_dropdown_button_text()
        self.save_settings()
    # --- NEW: Toggle Collapse Categories Setting ---




    def update_settings_dropdown_button_text(self):
        """Updates button texts in the settings dropdown (Sort Date and Show Switcher).""" # Modified docstring
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            # Find and update "Show Switcher On Startup" button
            for child in self.settings_dropdown_window.winfo_children():
                if isinstance(child, tk.Button) and "Show Switcher On Startup" in child.cget("text"):
                    current_text = "Show Switcher On Startup: " + ("On" if self.show_switcher_on_startup else "Off")
                    child.config(text=current_text)
                    print(f"update_settings_dropdown_button_text - Show Switcher Button text updated to: {current_text}") # Debugging print

            # Find and update "Attempt to Sort By Install Date" button
            for child in self.settings_dropdown_window.winfo_children():
                if isinstance(child, tk.Button) and "Attempt to Sort By Install Date" in child.cget("text"):
                    child.config(text="Attempt to Sort By Install Date: " + ("On" if self.sort_by_install_date else "Off"))
                    print(f"update_settings_dropdown_button_text - Sort Date Button text updated.") # Debugging print
                    
                    
                    
           # --- NEW: Update "Collapse Categories By Default" button text ---
            for child in self.settings_dropdown_window.winfo_children():
                if isinstance(child, tk.Button) and "Collapse Categories By Default" in child.cget("text"):
                    child.config(text="Collapse Categories By Default: " + ("On" if self.collapse_categories_by_default else "Off"))
            # --- NEW: Update "Collapse Categories By Default" button text --- 
        
        
    # ------------------------------------------------------------
    # sidebar filters
    # ------------------------------------------------------------
    def get_unique_brands(self):
        """
        Extracts unique brand names from the **filtered_original_data_for_brands** data set. - MODIFIED TO USE FILTERED DATA
        """
        brands = set()
        # Iterate over self.filtered_original_data_for_brands to get filtered brands
        if hasattr(self, 'filtered_original_data_for_brands'): # Defensive check
            for item in self.filtered_original_data_for_brands: # <--- MODIFIED: Use filtered data source
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand:
                    brands.add(brand)
        else:
            #print("Warning: filtered_original_data_for_brands attribute not initialized. Returning empty brand list.") # Defensive warning
            pass
        return sorted(list(brands))
    
    
    def get_unique_names(self, selected_brand="All Brands"):
        """
        Extracts unique names, dynamically filtered by brand and respecting the main search query.
        - MODIFIED to use filtered_original_data_for_brands and respect selected_brand
        """
        names = set()
        if hasattr(self, 'filtered_original_data_for_brands'): # Defensive check
            filtered_data_source = self.filtered_original_data_for_brands # <--- MODIFIED: Use filtered data source

            if selected_brand != "All Brands": # Apply brand filter if a specific brand is selected
                filtered_data = [
                    item for item in filtered_data_source # <--- MODIFIED: Iterate over filtered data source
                    if item[3].get("Brand", "").strip() == selected_brand
                ]
            else:
                filtered_data = filtered_data_source # <--- MODIFIED: Use filtered data source directly for 'All Brands'

            for item in filtered_data: # Iterate over filtered data
                _, _, _, info_data, _ = item
                name = info_data.get("Name", "").strip()
                if name:
                    names.add(name)
        else:
            print("Warning: filtered_original_data_for_brands attribute not initialized. Returning empty name list.") # Defensive warning

        return sorted(list(names))


    def get_unique_body_styles(self, selected_brand="All Brands", selected_name="All Names", selected_country="All Countries"):
        """
        Extracts unique body style names, now dynamically filtered by selected brand, name, AND country,
        and respecting the main search query. - MODIFIED to use filtered_original_data_for_brands
        """
        body_styles = set()
        if hasattr(self, 'filtered_original_data_for_brands'): # Defensive check
            filtered_data_source = self.filtered_original_data_for_brands # Use filtered data source


            if selected_name != "All Names": # Name filter still has highest priority
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    name = info_data.get("Name", "").strip()
                    if name == selected_name:
                        body_style = info_data.get("Body Style", "").strip()
                        if body_style:
                            body_styles.add(body_style)
                return sorted(list(body_styles)) # Return early - name filter takes precedence


            if selected_country != "All Countries":
                country_filtered_data = []
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    country = info_data.get("Country", "").strip()
                    if country == selected_country:
                        country_filtered_data.append(item)

                if selected_brand != "All Brands":
                    for item in country_filtered_data:
                        _, _, _, info_data, _ = item
                        brand = info_data.get("Brand", "").strip()
                        if brand == selected_brand:
                            body_style = info_data.get("Body Style", "").strip()
                            if body_style:
                                body_styles.add(body_style)
                else: # If "All Brands" with Country filter
                    for item in country_filtered_data:
                         _, _, _, info_data, _ = item
                         body_style = info_data.get("Body Style", "").strip()
                         if body_style:
                             body_styles.add(body_style)


            elif selected_brand != "All Brands": # Brand filter (if no Name or Country filter)
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    brand = info_data.get("Brand", "").strip()
                    if brand == selected_brand:
                        body_style = info_data.get("Body Style", "").strip()
                        if body_style:
                            body_styles.add(body_style)

            else: # "All Brands" and "All Names" and "All Countries" case
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    body_style = info_data.get("Body Style", "").strip()
                    if body_style:
                        body_styles.add(body_style)
        else:
            print("Warning: filtered_original_data_for_brands attribute not initialized. Returning empty body style list.") # Defensive warning

        return sorted(list(body_styles))
        


    def get_unique_countries(self, selected_brand="All Brands", selected_name="All Names"):
        """
        Extracts unique country names, now dynamically filtered by selected brand AND name,
        and respecting the main search query. - MODIFIED to use filtered_original_data_for_brands
        """
        countries = set()
        if hasattr(self, 'filtered_original_data_for_brands'): # Defensive check
            filtered_data_source = self.filtered_original_data_for_brands # Use filtered data source

            if selected_name != "All Names":
                # If a specific name is selected, get countries for that name only (within selected brand, if any)
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    name = info_data.get("Name", "").strip()
                    if name == selected_name:
                        country = info_data.get("Country", "").strip()
                        if country and country != "N/A":
                            countries.add(country)
                return sorted(list(countries)) # Return early - name filter takes precedence for countries


            if selected_brand != "All Brands":
                # If a specific brand is selected (and no specific name), get countries for that brand
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    brand = info_data.get("Brand", "").strip()
                    if brand == selected_brand:
                        country = info_data.get("Country", "").strip()
                        if country and country != "N/A":
                            countries.add(country)
            else:
                # If "All Brands" and "All Names" are selected, get all countries from the filtered data
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    country = info_data.get("Country", "").strip()
                    if country and country != "N/A":
                        countries.add(country)
        else:
            print("Warning: filtered_original_data_for_brands attribute not initialized. Returning empty country list.") # Defensive warning

        return sorted(list(countries))



    def _filter_data_by_brand(self, option_text):
        """Filters data by brand, respecting the main search query, added search window update."""
        filtered_data = []
        data_to_filter = list(self.data_cache)

        query = self.search_var.get().strip().lower()
        if query:
            query_filtered_data = []
            for item in data_to_filter:
                if self._perform_item_search(query, item):
                    query_filtered_data.append(item)
            data_to_filter = query_filtered_data

        if option_text == "All Brands":
            filtered_data = data_to_filter
        else:
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand == option_text:
                    filtered_data.append(item)

        self.data = filtered_data
        self.grouped_data = self.format_grouped_data(self.data)
        #self.update_grid_layout()
        self.canvas.yview_moveto(0)
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE

        

        

    def setup_sidebar_filter_dropdowns(self, sidebar_bottom_frame, sidebar_padding):
        # --- Dynamic Brand List (no changes needed here as it's already using get_unique_brands) ---
        brand_options_dynamic = ["All Brands"] + self.get_unique_brands() # <--- MODIFIED: Now uses filtered brands

        # --- NEW: Dynamic Name List - using get_unique_names now ---
        name_options_dynamic = ["All Names"] + self.get_unique_names() # Populate with names
        # --- NEW: Dynamic Name List - using get_unique_names now ---

        # --- NEW: Dynamic Body Style List - using get_unique_body_styles now ---
        bodystyle_options_dynamic = ["All BodyStyles"] + self.get_unique_body_styles() # Populate with body styles
        # --- NEW: Dynamic Body Style List - using get_unique_body_styles now ---

        # --- NEW: Dynamic Country List ---
        country_options_dynamic = ["All Countries"] + self.get_unique_countries() # NEW: Dynamic countries list
        # --- NEW: Dynamic Country List ---

        # --- MODIFIED: Filter options data WITHOUT Type and Author, and IN DESIRED ORDER for single column ---
        filter_options_data = {
            "Brand": brand_options_dynamic,
            "Name": name_options_dynamic,  # Use dynamic name list here
            "Country": country_options_dynamic, # NEW: Country options
            "Bodystyle": bodystyle_options_dynamic,  # NEW: Body Style options
            # "Author": ["All Authors", "Author 1", "Author 2"], # REMOVED Author
            # "Type": ["All Types", "Type 1", "Type 2"] # REMOVED Type
        }
        # --- MODIFIED: Filter options data WITHOUT Type and Author, and IN DESIRED ORDER for single column ---

        self._add_filter_dropdown_elements(self.sidebar_filter_dropdowns_frame, filter_options_data)

        self._configure_filter_dropdown_frame_layout(self.sidebar_filter_dropdowns_frame)


    def _create_bodystyle_dropdown_content(self, scrollable_frame, dynamic_bodystyle_options, button, dropdown_window, canvas):
        """Creates the content of the bodystyle dropdown: search entry and options, ensuring 'All BodyStyles' is always first."""
        search_var = tk.StringVar()
        search_entry = tk.Entry(scrollable_frame, textvariable=search_var, font=("Segoe UI", 10+self.font_size_add), bg="#FFFFFF", fg="black", width=18)
        search_entry.pack(pady=(5, 2), padx=5, fill="x")
        search_entry.focus_set()
        
        filter_options_data = { # NOTE: This is likely redundant and can be removed/reworked - but keep for now
            "Brand": ["All Brands"] + self.get_unique_brands(),
            "Name": ["All Names", "Name 1", "Name 2"],
            "Country": ["All Countries"] + self.get_unique_countries(),
            "Author": ["All Authors", "Author 1", "Author 2"],
            "Bodystyle": dynamic_bodystyle_options, # Pass dynamic options here
            "Type": ["All Types", "Type 1", "Type 2"]
        }
        # --- MODIFIED: Ensure 'All BodyStyles' is at the beginning of original_options ---
        original_options = filter_options_data["Bodystyle"]
        if "All BodyStyles" in original_options:
            original_options.remove("All BodyStyles") # Remove if present anywhere
        original_options.insert(0, "All BodyStyles") # Insert at the beginning
        # --- MODIFIED: Ensure 'All BodyStyles' is at the beginning of original_options ---


        #search_entry.bind("<KeyRelease>", lambda event: self._update_bodystyle_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window))
        #self._update_bodystyle_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window) # Initial population


        search_entry.bind("<KeyRelease>", lambda event: self._debounced_update_bodystyle_dropdown(search_var, original_options, scrollable_frame, canvas, button, dropdown_window))
        
        self._update_bodystyle_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window) # Initial population

        


    def _debounced_update_bodystyle_dropdown(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Debounced version of _update_name_dropdown_options."""
        if self.debounce_timer:
            self.master.after_cancel(self.debounce_timer)
        self.debounce_timer = self.master.after(
            600,  # Adjust delay as needed (milliseconds)
            lambda: self._update_bodystyle_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window)
        )


    def _update_bodystyle_dropdown_options(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Updates the options displayed in the Bodystyle dropdown based on search input."""
        print("    DEBUG: _update_bodystyle_dropdown_options() START") # Debug

        search_text = search_var.get().strip().lower()
        filtered_options = self._filter_dropdown_options(search_text, original_options) # 1. Filter options

        self._clear_dropdown_options(scrollable_frame) # 2. Clear existing options
        self._create_bodystyle_option_buttons(scrollable_frame, filtered_options, button, dropdown_window) # 3. Create new option buttons


        canvas.config(scrollregion=canvas.bbox("all"))
        # --- DEBUG PRINT: End of update_dropdown_options ---
        print("    DEBUG: _update_bodystyle_dropdown_options() END") # Debug


    def _create_bodystyle_option_buttons(self, scrollable_frame, current_options, button, dropdown_window):
        """Creates and packs option buttons in the scrollable frame for bodystyle with smooth hover."""

        # --- Define Colors ---
        default_bg_color = "#555555"    # Normal, non-selected background
        default_fg_color = "#FFFFFF"    # Normal, non-selected foreground

        selected_option_bg = self.global_highlight_color # Background for the currently "selected" option
        selected_option_fg = "#FFFFFF"                   # Foreground for the "selected" option

        # Specific hover colors for these dropdown items
        dropdown_item_hover_bg = "#d9d9d9"
        dropdown_item_hover_fg = "black"

        # Get the text of the main button that opened this dropdown, to determine current selection
        current_main_button_text = button.cget("text")

        for option in current_options:
            # --- Determine if this option is currently selected ---
            is_selected = (option == current_main_button_text)

            # --- Button Creation ---
            # Initial bg/fg will be set by _bind_animated_hover based on is_selected
            dropdown_option_button = tk.Button( # Renamed to avoid confusion with 'button' from args
                scrollable_frame,
                text=option,
                font=("Segoe UI", 10 + self.font_size_add, "bold"),
                # The command lambda captures necessary arguments for the click handler
                command=lambda opt=option, main_btn=button, dd_win=dropdown_window: \
                    self._on_bodystyle_dropdown_button_click(opt, fname="bodystyle", fbutton=main_btn, fdropdown_window=dd_win),
                borderwidth=1,      # Keep specific styling
                relief="solid",
                anchor="w",
                padx=10,
                pady=2,
                width=240 # If you need fixed width, keep it. Otherwise, remove for dynamic width.
                # bg and fg are now set by _bind_animated_hover
            )
            # Set active colors (for instant click flash) - optional
            dropdown_option_button.config(
                activebackground=dropdown_item_hover_bg,
                activeforeground=dropdown_item_hover_fg
            )

            dropdown_option_button.pack(fill="x")

            # --- Apply Smooth Hover Animation using the modified binder ---
            self._bind_animated_hover(
                button=dropdown_option_button,
                original_bg=default_bg_color,       # The "true" original, non-selected bg
                original_fg=default_fg_color,       # The "true" original, non-selected fg
                hover_target_bg=dropdown_item_hover_bg, # Custom hover BG for these items
                hover_target_fg=dropdown_item_hover_fg, # Custom hover FG for these items
                check_state=False,                    # Assuming these are not individually disabled
                is_selected_initial=is_selected,      # Is this button initially "selected"?
                selected_bg=selected_option_bg,       # Color if selected
                selected_fg=selected_option_fg        # Color if selected
            )


    def _on_bodystyle_dropdown_button_click(self, option_text, fname, fbutton, fdropdown_window):
        """Handles the button click event in the Bodystyle dropdown.
           MODIFIED to call _update_filters_label_status AFTER button config.
        """
        print("    DEBUG: _on_bodystyle_dropdown_button_click() START") # Debug
        fbutton.config(text=option_text)
        self._filter_data_by_bodystyle(option_text)
        self._update_ui_elements(fdropdown_window)
        self._update_filters_label_status() # <--- UPDATE FILTERS LABEL STATUS HERE
        print("    DEBUG: _on_bodystyle_dropdown_button_click() END") # Debug
        
        


    # ------------------------------------------------------------
    # Perform Search
    # ------------------------------------------------------------
    
    
    
    
    def _initialize_search_attributes(self):
        """Initializes search-related attributes and handles default search mode."""
        print("    _initialize_search_attributes()")
        if not hasattr(self, 'search_mode'):
            print("    Warning: search_mode attribute not initialized. Defaulting to 'General'.")
            self.search_mode = "General"

    def _reset_sidebar_filters_on_search(self):
        """Resets sidebar filters to 'All...' when a search is initiated."""
        print("    _reset_sidebar_filters_on_search()")

        # 1. Repopulate FIRST to create the new buttons based on fresh data
        #    This assumes _repopulate_sidebar_dropdowns_on_reset handles destroying
        #    the old frame and creating the new one with buttons in self.sidebar_filter_buttons
        print("    DEBUG: Calling _repopulate_sidebar_dropdowns_on_reset() first...")
        self._repopulate_sidebar_dropdowns_on_reset()
        print("    DEBUG: _repopulate_sidebar_dropdowns_on_reset() returned.")

        # 2. Now configure the NEWLY created buttons
        if hasattr(self, 'sidebar_filter_buttons') and self.sidebar_filter_buttons:
            print("    DEBUG: Configuring NEW sidebar filter buttons to 'All...'")
            filter_names = ["Brand", "Name", "Bodystyle", "Country"] # Only configure existing ones
            for filter_name in filter_names:
                button = self.sidebar_filter_buttons.get(filter_name)
                if button:
                    # Determine the "All..." text based on the filter name
                    if filter_name == "Brand": all_text = "All Brands"
                    elif filter_name == "Name": all_text = "All Names"
                    elif filter_name == "Bodystyle": all_text = "All BodyStyles"
                    elif filter_name == "Country": all_text = "All Countries"
                    else: all_text = f"All {filter_name}s" # Fallback

                    # --- Check if button widget still exists before configuring ---
                    try:
                        if button.winfo_exists():
                            button.config(text=all_text)
                            print(f"      DEBUG: Configured NEW {filter_name} button to '{all_text}'")
                        else:
                            print(f"      WARN: NEW {filter_name} button widget does not exist after repopulate. Skipping config.")
                    except tk.TclError as e:
                        print(f"      ERROR: TclError configuring NEW {filter_name} button: {e}")

                else:
                    print(f"    WARN: Button for '{filter_name}' not found in self.sidebar_filter_buttons AFTER repopulate.")
        else:
            print("    Warning: sidebar_filter_buttons not initialized AFTER repopulate. Cannot configure buttons.")

    def _repopulate_sidebar_dropdowns_on_reset(self):
        print("      _repopulate_sidebar_dropdowns_on_reset()")
        # Destroy the existing frame containing the dropdowns
        if hasattr(self, 'sidebar_filter_dropdowns_frame') and self.sidebar_filter_dropdowns_frame and self.sidebar_filter_dropdowns_frame.winfo_exists():
            print("        Destroying existing sidebar_filter_dropdowns_frame...")
            self.sidebar_filter_dropdowns_frame.destroy()
            self.sidebar_filter_dropdowns_frame = None
            self.sidebar_filter_buttons = {} # Clear button references as they are destroyed with the frame
        else:
            print("        No existing sidebar_filter_dropdowns_frame found to destroy.")

        # Re-create the dropdowns (this will call _add_filter_dropdown_elements again)
        print("        Calling create_sidebar_filter_dropdowns to recreate...")
        # Ensure sidebar_bottom_frame exists
        if hasattr(self, 'sidebar_bottom_frame') and self.sidebar_bottom_frame and self.sidebar_bottom_frame.winfo_exists():
            self.create_sidebar_filter_dropdowns(self.sidebar_bottom_frame, 10)
            print("        create_sidebar_filter_dropdowns finished.")
        else:
            print("        ERROR: Cannot recreate dropdowns, sidebar_bottom_frame does not exist.")

    def _perform_item_search(self, query, item):
        """Performs the actual search logic for a single item based on search mode."""
        pic, spawn_cmd, zip_file, info_data, folder_name = item
        matches = False
        if query:
            if self.search_mode == "Configs":
                matches = self._check_config_search_matches(query, item)
            else: # General Search Mode
                matches = self._check_general_search_matches(query, item)
        else: # No query, show all (subject to main filter)
            matches = True
        return matches

    def _check_config_search_matches(self, query, item):
        """
        Checks if an item matches the search query in 'Configs' search mode,
        matching against Configuration values in ALL matches_config.txt entries
        associated with the representative image's folder, and PC filename.
        Loads and parses matches_config.txt entries DIRECTLY within this function (no cache).
        """
        pic, spawn_cmd, zip_file, info_data, folder_name = item
        associated_config_names = set()
        is_favorites_filter_active = (self.filter_state == 5 and self.filter_options[self.filter_state] == "Favorites")
        favorite_configs_set = self.favorite_configs if is_favorites_filter_active else None

        zip_file_base_name = zip_file.replace(".zip", "") # Remove extension
        pc_file_name_match = False # Initialize PC file name match flag - keep this check

        # --- NEW: Iterate through matches_config_data to find associated configs ---
        for filename, config_name_from_file in self.matches_config_data.items(): # Iterate through ALL matches_config.txt entries
            if folder_name in filename and "--INDIVIDUAL--" in filename: # Check if folder_name is in the filename AND it's an individual config
                # --- NEW: Apply Favorites Filter to matches_config.txt entries ---
                if is_favorites_filter_active: # If Favorites filter is active
                    config_name_base_inner = self.extract_name_from_spawn_command_from_matches_config_filename(filename) # Extract config name from filename
                    if config_name_base_inner:
                        fav_key = f"{folder_name}|{config_name_base_inner}.pc" # Construct favorite key
                        if fav_key not in favorite_configs_set:
                            continue # Skip to the next config if not a favorite
                # --- NEW: Apply Favorites Filter to matches_config.txt entries ---

                if query in config_name_from_file.lower(): # Check query against config name from matches_config.txt
                    associated_config_names.add(config_name_from_file.lower()) # Add config name to associated names

        # --- NEW: Check PC Filename Match (as before) ---
        pc_file_name = self.extract_name_from_spawn_command(spawn_cmd) # Keep PC filename check as is, OUTSIDE the loop
        if pc_file_name and query in pc_file_name.lower():
            pc_file_name_match = True # Set PC filename match flag if matched
        # --- NEW: Check PC Filename Match (as before) ---


        is_match_normal = bool(associated_config_names) or pc_file_name_match # Check for match in associated config names OR PC filename

        # --- CALL PC_PRIORITY VERSION ---
        is_match_pc_priority = self._check_config_search_matches_PC_PRIORITY(query, item)
        # --- CALL PC_PRIORITY VERSION ---

        # --- COMBINE RESULTS ---
        is_match_combined = is_match_normal or is_match_pc_priority
        return is_match_combined


    def extract_name_from_spawn_command_from_matches_config_filename(self, matches_config_filename):
        """
        Extracts config name base from matches_config.txt filename (similar to extract_name_from_spawn_command).
        e.g., from "vehicles--INDIVIDUAL--pickup_pickup.zip--info_info_config_name.json" to "config_name".
        """
        match = re.search(r'--info_info_([^\.]+)\.json', matches_config_filename, re.IGNORECASE)
        if match:
            return match.group(1) # Returns the config name (e.g., "config_name")
        return None # Returns None if no match found


    def _check_config_search_matches_PC_PRIORITY(self, query, item):
        """
        Checks if an item matches the search query in 'Configs' search mode,
        matching against Configuration values in ALL matches_config.txt entries
        associated with the representative image's folder, AND PC filename (prioritized). <--- MODIFIED DOCSTRING
        Loads and parses associated JSON files DIRECTLY within this function (no cache).
        """
        pic, spawn_cmd, zip_file, info_data, folder_name = item
        associated_config_names = set()
        is_favorites_filter_active = (self.filter_state == 5 and self.filter_options[self.filter_state] == "Favorites")
        favorite_configs_set = self.favorite_configs if is_favorites_filter_active else None

        zip_file_base_name = zip_file.replace(".zip", "") # Remove extension
        config_name_base = self.extract_name_from_spawn_command(spawn_cmd)

        # --- NEW: Check PC Filename Match FIRST and PRIORITIZE it ---
        pc_file_name_match = False  # Initialize PC file name match flag
        pc_file_name = self.extract_name_from_spawn_command(spawn_cmd)
        if pc_file_name and query in pc_file_name.lower():
            pc_file_name_match = True  # Set PC filename match flag if matched
            #print(f"DEBUG: _check_config_search_matches - PC Filename MATCH FOUND for query '{query}' - Filename: {os.path.basename(pic)}, PC Filename: {pc_file_name}") # Debug - PC Filename Match

        if pc_file_name_match: # If PC filename matches, return True immediately - PRIORITIZE PC FILENAME MATCH
            return True # <-- EARLY RETURN if PC filename matches
        # --- NEW: Check PC Filename Match FIRST and PRIORITIZE it ---

        '''
        # --- Open constructednames.txt for writing (append mode) ---
        constructed_names_file = os.path.join(self.script_dir, "constructednames.txt")
        try:
            with open(constructed_names_file, "a") as outfile: # Open in append mode
                #outfile.write(f"\n--- Checking item: {os.path.basename(pic)} ---\n") # --- Log START of item check ---
                pass
        '''        
        if folder_name in self.full_data:
            for config_item in self.full_data[folder_name]:
                config_spawn_cmd = config_item[1]
                config_name_base_inner = self.extract_name_from_spawn_command(config_spawn_cmd)
                if is_favorites_filter_active:
                    fav_key = f"{folder_name}|{config_name_base_inner}.pc"
                    if fav_key not in favorite_configs_set:
                        continue

                if config_name_base_inner:
                    associated_config_names.add(config_name_base_inner.lower())

                    ''' # --- REMOVED: not needed in PC Priority, this just makes the search slower and it doesn't work properly ---
                    # Construct the expected filename for individual info file
                    individual_info_filename = (
                        f"vehicles--INDIVIDUAL--{folder_name}_{zip_file_base_name}.zip--info_info_{config_name_base_inner}.json"
                    )

                    # --- NEW: Write constructed filename to file ---
                    #outfile.write(f"    DEBUG: Constructed Filename: {individual_info_filename}\n") # Log constructed filename

                    # --- MODIFIED: Load config name DIRECTLY from file (NO cache, NO _load_individual_info) ---
                    individual_info_path = self.find_individual_info_file(
                        folder_name,
                        zip_file_base_name=zip_file_base_name,
                        config_name=config_name_base_inner
                    )
                    if individual_info_path and os.path.exists(individual_info_path):
                        try:
                            with open(individual_info_path, 'r', encoding='utf-8') as f: # Open and read file directly
                                file_content = f.read()
                                config_info_value = self.get_json_value_safe(file_content, "Configuration", r'"Configuration"\s*:\s*"([^"]*)"') # Extract config name using regex
                                if config_info_value:
                                    associated_config_names.add(config_info_value.lower()) # Use config name from file
                        except Exception as e_load:
                            print(f"Warning: Error loading/parsing {individual_info_path}: {e_load}") # Print warning on file load/parse error
                        '''

        #except Exception as e_file_write: # Catch file writing errors
            #print(f"Warning: Error writing to constructednames.txt: {e_file_write}") # Print error message
        #    pass
            

        found_in_any_config_name = False
        for config_name in associated_config_names:
            if query in config_name:
                found_in_any_config_name = True
                break


        is_match = found_in_any_config_name or pc_file_name_match # Check for match in associated config names OR PC filename

        # --- NEW: Debug Print - Log matching filenames to console ---
        #if is_match:
        #    print(f"DEBUG: _check_config_search_matches - MATCH FOUND for query '{query}' - Representative Image: {os.path.basename(pic)}") # Print filename if it's a match
        # --- NEW: Debug Print - Log matching filenames to console ---

        # --- NEW: Debug Print - Log NOT matching filenames to console ---
        #if not is_match:
        #    print(f"DEBUG: _check_config_search_matches - MATCH NOT FOUND for query '{query}' - Representative Image: {os.path.basename(pic)}") # Print filename if it's NOT a match
        # --- NEW: Debug Print - Log NOT matching filenames to console ---

        return is_match
        
        
 
    

    def _check_general_search_matches(self, query, item):
        """Checks if an item matches the search query in 'General' search mode."""
        pic, spawn_cmd, zip_file, info_data, folder_name = item

        # Combined Text Label Search
        brand_for_main = info_data.get("Brand", "Unknown")
        if not brand_for_main.strip():
            brand_for_main = "Unknown"
        type_for_main = info_data.get("Type", "Unknown")
        if not type_for_main.strip():
            type_for_main = "Unknown"
        if brand_for_main == "Unknown":
            brand_for_main = type_for_main

        name_for_main = info_data.get("Name")
        if not name_for_main or not name_for_main.strip():
            name_for_main = self.extract_name_from_spawn_command(spawn_cmd)

        combined_text = f"{brand_for_main} - {name_for_main}"
        combined_text_lower = combined_text.lower()

        if query in combined_text_lower:
            return True

        # Search ALL Zip Files Associated with Folder
        associated_zip_files = set()
        if folder_name in self.full_data:
            for config_item in self.full_data[folder_name]:
                config_zip_file = config_item[2]
                associated_zip_files.add(config_zip_file.lower())

        found_in_any_zip = False
        for zip_name in associated_zip_files:
            if query in zip_name:
                found_in_any_zip = True
                break

        if found_in_any_zip:
            return True

        # Existing Zip File Name, folder name, info_data values search
        if query in zip_file.lower():
            return True
        if query in folder_name.lower():
            return True
        if any(query in str(v).lower() for v in info_data.values()):
            return True

        return False

    def _apply_main_filter(self, filtered_items):
        """Applies the main filter to the search results."""
 


        print("    _apply_main_filter()")
        final_list = []
        filtered_original_data_for_brands = [] # For brand filter later
        default_zips = [name.lower() for name in self.ZIP_BASE_NAMES]
        current_filter = self.filter_options[self.filter_state]

        for it in filtered_items:
            zip_lower = it[2].lower()
            folder_lower = it[4].lower()
            include_for_brand_filter = False

            if current_filter == "View All": # <--- NEW FILTER OPTION
                final_list.append(it)
                include_for_brand_filter = True
            elif current_filter == "Items with Config Preview Images [debug]":
                if not self.is_placeholder(it[0]):
                    final_list.append(it)
                    include_for_brand_filter = True
            elif current_filter == "Items Without Config Preview Images [debug]":
                if self.is_placeholder(it[0]):
                    final_list.append(it)
                    include_for_brand_filter = True
            elif current_filter == "Only Mods":
                if folder_lower not in default_zips and zip_lower != "user_custom_configs":
                    final_list.append(it)
                    include_for_brand_filter = True
            elif current_filter == "Vanilla":
                if folder_lower in default_zips:
                    final_list.append(it)
                    include_for_brand_filter = True
            elif current_filter == "Unpacked Mods":
                if zip_lower == "user_custom_configs":
                    final_list.append(it)
                    include_for_brand_filter = True
            elif current_filter == "Favorites":
                fav_folders = set()
                for fav in self.favorite_configs:
                    fav_folders.add(fav.split('|')[0].lower())
                if folder_lower in fav_folders:
                    final_list.append(it)
                    include_for_brand_filter = True
            else: # Default case - should not be reached, but for safety
                final_list.append(it)
                include_for_brand_filter = True

            if include_for_brand_filter:
                filtered_original_data_for_brands.append(it)

        self.filtered_original_data_for_brands = filtered_original_data_for_brands
        return final_list  


    def _update_search_results_ui(self, final_list, current_filter):
        """Updates the UI elements after search and filtering are complete."""

        print("\n--- _update_search_results_ui() DEBUG ENTRY ---") # Debug Entry
        print(f"DEBUG: _update_search_results_ui - final_list received (count): {len(final_list)}") 

        print("    _update_search_results_ui()")
        self.data = final_list[:]
        print("    Calling self.format_grouped_data() ...")
        self.grouped_data = self.format_grouped_data(self.data)
        print("    self.format_grouped_data() RETURNED.")

        print("    _update_search_results_ui is calling self.update_grid_layout()")
        self.update_grid_layout()
        self.canvas.yview_moveto(0)
        item_count = len(final_list)
        self.filter_button.config(text=f"{current_filter} [{item_count}]")
        self._update_filters_label_status()


    def perform_search(self):
        
        print("\n--- ConfigViewerApp.perform_search() ENTRY ---")

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot search while there are pending hidden vehicles.")

            self.search_var.set("")
            print("\n--- canceling ConfigViewerApp.perform_search() ---")

            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return



        if self.skip_perform_search:
            print("\n--- self.skip_perform_search evaluated to TRUE, not executing perform_search")
            print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return

        self._initialize_search_attributes()
        self._reset_sidebar_filters_on_search()

        self.lift_search_results_window()
        query = self.search_var.get().strip().lower()
        filtered = []

        data_to_search = list(self.data_cache)
        data_to_search = self.apply_data_subset_filter(data_to_search)

        for item in data_to_search:
            if self._perform_item_search(query, item):
                filtered.append(item)

        final_list = self._apply_main_filter(filtered)
        current_filter = self.filter_options[self.filter_state]

        # --- MODIFICATION START: Check for empty query AND "View All" filter AND GLOBAL FILTERS OFF to close search results window ---
        # --- MODIFIED CONDITION: Added DEBUG prints to check condition values ---
        print("DEBUG: perform_search - Checking window destruction condition:")
        print(f"  DEBUG: perform_search - query is empty: {not query}")
        print(f"  DEBUG: perform_search - self.filter_state == 0 (View All): {self.filter_state == 0}")
        print(f"  DEBUG: perform_search - not self.is_data_subset_active (Global Filters OFF): {not self.is_data_subset_active}")

        if not query and self.filter_state == 0 and not self.is_data_subset_active:
            print("  DEBUG: perform_search - Condition MET for Search Results window DESTRUCTION.") # Debug - Condition Met
            if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():

                  
                self.destroy_search_results_window()
                self.search_results_window = None
                self.is_search_results_window_active = False
                print(f"!!!!!!!!!! self.is_search_results_window_active SET TO FALSE by perform_search. Timestamp: {time.time()} !!!!!!!!!!")



                print("DEBUG: perform_search - Search Results window DESTROYED (Empty query AND View All filter AND Global Filters OFF).")
            else:
                print("DEBUG: perform_search - Search Results window NOT open, no need to destroy (Empty query AND View All filter AND Global Filters OFF).") # Debug - Window Not Open
            self.data = final_list[:] # Still update self.data
            self.grouped_data = self.format_grouped_data(self.data) # Still update grouped_data
            item_count = len(final_list)
            self.filter_button.config(text=f"{current_filter} [{item_count}]")
            self._update_filters_label_status()
            self.update_search_results_window_ui() # Update search results window if open
            
            self.trigger_toggle_sort_by_install_date_after_search_results_window_close()
            print("--- ConfigViewerApp.perform_search() EXIT - Skipped Layout Update AND Destroyed Search Results Window ---\n")
            return  # Exit here, skipping full layout update and destroying search results window
        # --- MODIFICATION END: Check for empty query AND "View All" filter AND GLOBAL FILTERS OFF to close search results window ---


        # --- MODIFICATION START: Check for empty query and skip layout update ---
        if not query:
            print("DEBUG: perform_search - Empty query detected. Skipping full update_grid_layout().")
            self.data = final_list[:] # Still update self.data
            self.grouped_data = self.format_grouped_data(self.data) # Still update grouped_data
            item_count = len(final_list)
            self.filter_button.config(text=f"{current_filter} [{item_count}]")
            self._update_filters_label_status()
            self.update_search_results_window_ui() # Update search results window if open
            print("--- ConfigViewerApp.perform_search() EXIT - Skipped Layout Update ---\n")
            return # Exit here, skipping full layout update
        # --- MODIFICATION END: Check for empty query and skip layout update ---


        if query:
            if not hasattr(self, 'search_results_window') or not self.search_results_window or not self.search_results_window.winfo_exists():
                self.search_results_window = self.show_search_results_window(final_list)
                print("DEBUG: perform_search - Search Results window CREATED. is_search_results_window_active set to TRUE")

            self.search_results_window.lift()
        elif hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
            self.destroy_search_results_window()
            self.search_results_window = None
            self.is_search_results_window_active = False
            print(f"!!!!!!!!!! self.is_search_results_window_active SET TO FALSE by perform_search. Timestamp: {time.time()} !!!!!!!!!!")


        if self.search_mode == "Configs":
            categories_to_remove = []
            for category, items in self.grouped_data.items():
                if not items:
                    categories_to_remove.append(category)
            for category in categories_to_remove:
                del self.grouped_data[category]

        print(f"DEBUG: perform_search - final_list (count): {len(final_list)}") # <-- ADD THIS LINE




        print(f"DEBUG: perform_search - calling _update_search_results_ui")
        self._update_search_results_ui(final_list, current_filter)
        self.update_search_results_window_ui()
        self.master.after(50, self.inherit_category_visibility_search_results)
        self.lift_search_results_window()

        print("--- ConfigViewerApp.perform_search() EXIT ---\n")

        
 


       



    ##############################################################
    #               search window start  - search results window #
    ##############################################################



    def show_search_results_window(self, final_list=None):
        """Creates and configures the Search Results window with smooth scrolling and dynamic resizing.
        MODIFIED to include CUSTOM SCROLLBAR for search results window.
        """
        print(f"!!!!!!!!!! show_search_results_window CALLED! Timestamp: {time.time()} !!!!!!!!!!")

        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- show_search_results_window() CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")


        self.loading_search_results_window = True

        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win


        self.search_results_window_on_screen = True
        self.canvas.yview_moveto(0) # Reset main grid scroll to top

        # Store the window reference on self so the callback can access it if needed
        self.search_results_window = FadingToplevel(self.master, self, end_alpha=0.0)
        # 1. START FULLY TRANSPARENT
        self.search_results_window.attributes('-alpha', 0.0)
        self.search_results_window.overrideredirect(True)
        self.search_results_window.tk.call('tk', 'scaling', 1.25)
        self.search_results_window.title("Search Results")


        print(f"!!!!!!!!!! self.is_search_results_window_active SET TO TRUE by show_search_results_window. Timestamp: {time.time()} !!!!!!!!!!")
        self.is_search_results_window_active = True

        disabled_button_style_args = self.button_style_args.copy()
        disabled_button_style_args["fg"] = "grey"
        disabled_button_style_args["activebackground"] = "#555555"
        disabled_button_style_args["activeforeground"] = "grey"

        if hasattr(self, 'categorize_button'):
            self.categorize_button.config(state=tk.DISABLED, **disabled_button_style_args)
        if hasattr(self, 'category_list_button'):
            self.category_list_button.config(state=tk.DISABLED, **disabled_button_style_args)

        self.search_results_canvas = tk.Canvas(self.search_results_window, bg="#444444", highlightthickness=0, yscrollincrement=10)
        self.search_results_canvas.configure(yscrollcommand=self.custom_search_results_scrollbar_set)

        self.custom_scrollbar_canvas_search_results = tk.Canvas(self.search_results_window, bg="#555555", highlightthickness=0, width=15)
        self.scrollbar_thumb_search_results = self.custom_scrollbar_canvas_search_results.create_rectangle(0, 0, 15, 20, fill=self.global_highlight_color, outline="")
        self.scrollbar_thumb_dragging_search_results = False
        self.scrollbar_thumb_start_y_search_results = 0
        self.scrollbar_mouse_start_y_search_results = 0


        self._search_results_scroll_pending = False
        self._search_results_throttled_after_id = None
        self._last_search_results_thumb_y = 0 # Store the last clamped thumb Y for search results


        self.custom_scrollbar_canvas_search_results.bind("<ButtonPress-1>", self.custom_search_results_scrollbar_click)
        self.custom_scrollbar_canvas_search_results.bind("<B1-Motion>", self.custom_search_results_scrollbar_drag)
        self.custom_scrollbar_canvas_search_results.bind("<ButtonRelease-1>", self.custom_search_results_scrollbar_release)

        self.search_results_scrollable_frame = tk.Frame(self.search_results_canvas, bg="#444444")

        self.search_results_scrollable_frame.bind(
            "<Configure>",
            lambda e: self.search_results_canvas.configure(scrollregion=self.search_results_canvas.bbox("all"))
        )
        self.search_results_canvas.create_window((0, 0), window=self.search_results_scrollable_frame, anchor="nw")
        self.search_results_canvas.configure(yscrollcommand=self.custom_search_results_scrollbar_set)

        self.search_results_canvas.pack(side="left", fill="both", expand=True)
        self.custom_scrollbar_canvas_search_results.pack(side="right", fill="y")

        self.search_results_canvas.bind("<Enter>", lambda e: self.search_results_canvas.bind_all("<MouseWheel>", self.on_mousewheel_search_results))
        self.search_results_canvas.bind("<Leave>", lambda e: self.search_results_canvas.unbind_all("<MouseWheel>"))
        self.search_results_window.bind("<FocusOut>", self.on_search_results_focus_out, add='+')


        data_to_populate = final_list
        if data_to_populate is None:
            data_to_populate = self.search_results_data
            print("DEBUG: show_search_results_window - Using self.search_results_data for population (final_list was None).")
        else:
            print("DEBUG: show_search_results_window - Using provided final_list for population.")

        if hasattr(self, 'search_results_scrollable_frame') and self.search_results_scrollable_frame:
            for widget in self.search_results_scrollable_frame.winfo_children():
                widget.destroy()
            # 2. POPULATE CONTENT
            self.populate_search_results_window(self.search_results_scrollable_frame, data_to_populate) # Pass correct data

        # 2. SET GEOMETRY
        self.update_window_geometries() # Call it once initially to set correct position and size

        self.search_results_window.bind("<Button-1>", self.debounced_on_search_results_window_click)

        # 3. FORCE TKINTER TO RENDER EVERYTHING
        # This ensures all widgets are drawn and sized correctly before the fade starts.
        self.search_results_window.update_idletasks()
        self.search_results_window.update() # Use if update_idletasks isn't enough, but be cautious

        # 4. FADE THE WINDOW IN
        # Define fade parameters (you can make these class attributes or pass them)
        def start_fade_animation():
            if not self.search_results_window or not self.search_results_window.winfo_exists():
                print("DEBUG: Search results window destroyed before fade could start.")
                return

            FADE_IN_DURATION_MS = 40
            FADE_STEPS = 20
            self._fade_window(self.search_results_window,
                                0.0,  # Start alpha
                                1.0,  # End alpha
                                FADE_IN_DURATION_MS,
                                FADE_STEPS,
                                callback=self._on_search_results_fade_in_complete)

        # Introduce a small delay (e.g., 50-150ms). Experiment with this value!
        # This gives the OS and Tkinter a moment to fully "paint" the window
        # in its transparent state before the animation begins.
        DELAY_BEFORE_FADE_MS = 300 # Start with 50 or 100 and adjust
        self.master.after(DELAY_BEFORE_FADE_MS, start_fade_animation)
        # --- END MODIFICATION ---

        return self.search_results_window

        
    def on_search_results_focus_out(self, event=None):
        return

    def _on_search_results_fade_in_complete(self):
        """Callback function after search results window finishes fading in."""
        print("DEBUG: Search results window fade-in complete.")

        if self.scanning_window:
            self.scanning_window.destroy()

        self.scanning_window = None

        self.loading_search_results_window = False

        # Safely call inherit_category_visibility_search_results
        if hasattr(self, 'master') and self.master.winfo_exists():
            # Ensure the search_results_window itself also still exists if needed by the method
            if hasattr(self, 'search_results_window') and self.search_results_window.winfo_exists():
                 self.master.after(10, self.inherit_category_visibility_search_results) # Small delay if needed
            else:
                print("DEBUG: Search results window destroyed before inherit_category_visibility could run.")
        else:
            print("DEBUG: Master window destroyed before inherit_category_visibility could run.")



    def debounced_on_search_results_window_click(self, event=None):
        """
        Debounced version of on_search_results_window_click, ensuring the first click is always registered.
        """
        delay_ms = 400  # Adjust this delay (in milliseconds) as needed

        if not self.is_debouncing:
            # First click, execute immediately and start debouncing
            self.is_debouncing = True
            self.on_search_results_window_click(event)

        if self.debounce_timer:
            self.master.after_cancel(self.debounce_timer)  # Cancel the existing timer

        self.debounce_timer = self.master.after(delay_ms, self._reset_debounce_flag) # Reset flag after delay

    def _reset_debounce_flag(self):
        """
        Resets the debouncing flag after the delay period.
        """
        self.is_debouncing = False
        self.debounce_timer = None  # Clear the timer


        
    def on_search_results_window_click(self, event):
        """
        Handles click events on the search results window itself.
        """
        print("\n--- WINDOW CLICKED ---")
        self.search_results_window.lift()
        self.master.lift()
        self.search_results_window.lift()

        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            print("DEBUG: lift_search_results_window - Filters window exists and Details window is CLOSED - lifting Filters window.")
            self.filters_window.lift()
            
        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.spawn_queue_window.lift()

        if hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.hidden_window.lift()


        if self.is_filter_dropdown_open():
            self.destroy_filter_dropdown()
        if self.is_categorize_dropdown_open():
            self.destroy_categorize_dropdown()
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            self.destroy_search_mode_options_dropdown_menu()
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            self.destroy_settings_dropdown()
        if self.is_category_list_dropdown_open():
            self.destroy_category_list_dropdown()

        self.close_all_vehicle_dropdowns()
        
        filter_names = ["brand", "name", "country", "author", "bodystyle", "type"]
        for fname in filter_names:
            if self.is_sidebar_filter_dropdown_open(fname):
                self.destroy_sidebar_filter_dropdown(fname)
        # --- END: Dropdown menu destruction logic from on_main_window_click ---




    def destroy_search_results_window(self):


        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- destroy_search_results_window() CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")

        if self.filter_state != 0:
            print("    destroy_search_results_window() - filter_state != 0, not destroying search results window.")
            return # Don't destroy if filter is not "View All"

        if hasattr(self, 'search_results_window') and self.search_results_window:
            # Get a reference to the window object we intend to destroy
            window_to_destroy = self.search_results_window

            # --- Define the actual destruction logic in a nested function ---
            def do_actual_destroy():
                print(f"    -> do_actual_destroy(): Executing scheduled destruction for {window_to_destroy}")
                destruction_occurred = False
                try:
                    # Check existence again right before destroying
                    if window_to_destroy.winfo_exists():
                        window_to_destroy.destroy()
                        print(f"    -> do_actual_destroy(): Destruction successful.")
                        destruction_occurred = True
                    else:
                         print(f"    -> do_actual_destroy(): Window {window_to_destroy} was already destroyed before scheduled execution.")
                         destruction_occurred = True # Treat as if destroyed for state reset

                except tk.TclError as e:
                    print(f"ERROR during scheduled destroy of {window_to_destroy}: {e}")
                    # Even if destroy fails with TclError, the window is likely unusable,
                    # so proceed with state reset and button re-enabling.
                    destruction_occurred = True
                except Exception as e:
                    print(f"Unexpected ERROR during scheduled destroy of {window_to_destroy}: {e}")
                    destruction_occurred = True # Assume state needs reset

                # --- Reset state and re-enable buttons AFTER attempt/confirmation ---
                # This block now runs regardless of the self.search_results_window check
                # as long as the destroy was attempted or window confirmed gone.
                if destruction_occurred:
                    print("    -> do_actual_destroy(): Resetting state and re-enabling buttons...")



                    # --- Re-enable buttons (with existence checks) ---
                    if not hasattr(self, 'button_style_args'):
                        self.button_style_args = self._create_button_style() # Example
                    else:
                        button_style_args = self.button_style_args.copy()

                    if hasattr(self, 'categorize_button') and self.categorize_button.winfo_exists():
                        if hasattr(self.categorize_button, 'update_state'):
                            print("       Updating categorize_button state")
                            self.categorize_button.update_state(is_disabled=False)
                        else:
                            print("       Configuring categorize_button state")
                            self.categorize_button.config(state=tk.NORMAL, **button_style_args)

                    if hasattr(self, 'category_list_button') and self.category_list_button.winfo_exists():
                        if hasattr(self.category_list_button, 'update_state'):
                            print("       Updating category_list_button state")
                            self.category_list_button.update_state(is_disabled=False)
                        else:
                            print("       Configuring category_list_button state")
                            self.category_list_button.config(state=tk.NORMAL, **button_style_args)

                    # --- Schedule subsequent actions if needed ---
                    if hasattr(self, 'window_size_changed_during_search_results_window') and self.window_size_changed_during_search_results_window:

                        print("    -> do_actual_destroy(): Scheduling condcheck...")
                        if hasattr(self, 'condcheck'): # Check if condcheck exists
                           self.master.after(1000, self.condcheck)




            # --- Schedule the destruction using after_idle ---
            print(f"    destroy_search_results_window(): Scheduling destruction of {window_to_destroy} via after_idle.")
            # Mark as pending destruction / gone IMMEDIATELY
            self.search_results_window = None
            self.is_search_results_window_active = False
            print(f"!!!!!!!!!! self.is_search_results_window_active SET TO FALSE by destroy_search_results_window. Timestamp: {time.time()} !!!!!!!!!!")

            self.search_results_window_on_screen = False

            # Schedule the actual destroy task


            self.master.after_idle(do_actual_destroy)

            if self.update_grid_after_size_rechange:
                print("self.update_grid_after_size_rechange has been set to False, updating grid layout")

                self.update_grid_after_size_rechange = False
                self.master.after(1000, self.format_grouped_data(self.data))
                self.master.after(1100, self.update_grid_layout) 

        else:
            # This case handles if self.search_results_window was already None
            print("    destroy_search_results_window(): Instance variable self.search_results_window is already None or invalid.")
            # Optionally, still ensure buttons are enabled here if state might be inconsistent
            if not self.is_search_results_window_active: # If state says it's inactive, ensure buttons reflect that
                 print("    destroy_search_results_window(): Ensuring buttons are enabled as window state is inactive.")

            
            #self.trigger_toggle_sort_by_install_date_after_search_results_window_close()

        


    def condcheck(self):

        
        print("--- condcheck() CALLED BY: ---")
        for frame_info in inspect.stack()[1:3]: # Look at immediate caller and its caller
            print(f"  File \"{frame_info.filename}\", line {frame_info.lineno}, in {frame_info.function}")
        print("-----------------------------")


        # Inside condcheck
        active_flag_in_condcheck = self.is_search_results_window_active
        print(f"!!!!!!!!!! condcheck READING self.is_search_results_window_active: {active_flag_in_condcheck}. Timestamp: {time.time()} !!!!!!!!!!")



        if self.filter_state != 0 or  self.search_var.get().strip() or self.is_data_subset_active or not self.all_filters_all:
            print(f"cond check not met, not updating the grid, a search results window is open and we don't want to update the grid layout under it?")

            print("DEBUG: Checking condition to update grid layout after search results close:")
            #print(f"  DEBUG COND CHECK 1: self.window_size_changed_during_search_results_window = {self.window_size_changed_during_search_results_window}")
            print(f"  DEBUG COND CHECK 2: self.filter_state == 0 (Actual Value: {self.filter_state}) = {self.filter_state == 0}")
            # For the 'not search_var...' part, let's check the intermediate value too
            search_text_value = self.search_var.get().strip()
            print(f"  DEBUG COND CHECK 3: not self.search_var.get().strip() (Actual Text: '{search_text_value}') = {not search_text_value}")
            print(f"  DEBUG COND CHECK 4: not self.is_data_subset_active (Actual Value: {self.is_data_subset_active}) = {not self.is_data_subset_active}")
            print(f"  DEBUG COND CHECK 5: self.all_filters_all = {self.all_filters_all}")
            print(f"  DEBUG COND CHECK - is a search results window still open? if so, there's an issue. Value of self.is_search_results_window_active: {self.is_search_results_window_active}")


        else:
            print(f"cond check met, updating the grid")
            print("DEBUG: Checking condition to update grid layout after search results close:")
            #print(f"  DEBUG COND CHECK 1: self.window_size_changed_during_search_results_window = {self.window_size_changed_during_search_results_window}")
            print(f"  DEBUG COND CHECK 2: self.filter_state == 0 (Actual Value: {self.filter_state}) = {self.filter_state == 0}")
            # For the 'not search_var...' part, let's check the intermediate value too
            search_text_value = self.search_var.get().strip()
            print(f"  DEBUG COND CHECK 3: not self.search_var.get().strip() (Actual Text: '{search_text_value}') = {not search_text_value}")
            print(f"  DEBUG COND CHECK 4: not self.is_data_subset_active (Actual Value: {self.is_data_subset_active}) = {not self.is_data_subset_active}")
            print(f"  DEBUG COND CHECK 5: self.all_filters_all = {self.all_filters_all}")


            print("    destroy_search_results_window is calling self.update_grid_layout() - after 500ms")
            print("    because this condition was met ")
            self.master.after(100, self.update_grid_layout) 


        self.window_size_changed_during_search_results_window = False



    def inherit_category_visibility_search_results(self):
        """
        Inherits category visibility from the main window to the search results window.
        Called with a delay after the search results window is created.
        MODIFIED to update category header text to indicate "(Hidden)" status. <----- ADDED
        """
        print("\n--- inherit_category_visibility_search_results() ENTRY ---") # Debug Entry
        print("DEBUG: inherit_category_visibility_search_results - Inheriting category visibility from main window to search results.") # Debug Message

        if not hasattr(self, 'search_results_header_frames'):
            print("  Warning: search_results_header_frames not initialized yet. Skipping category visibility inheritance.") # Warning
            return

        for category in self.search_results_header_frames:
            if category in self.category_hidden_states:
                header_frame = self.search_results_header_frames[category] # Get header frame
                header_label = None
                for widget in header_frame.winfo_children(): # Find header label within frame
                    if isinstance(widget, tk.Label):
                        header_label = widget
                        break

                if self.category_hidden_states[category]:
                    print(f"  DEBUG: Category '{category}' is hidden in main window. Hiding in search results and updating header text.") # Debug - Hiding Category
                    if category not in self.search_results_category_hidden_states or not self.search_results_category_hidden_states[category]: # Prevent redundant toggling
                        self.toggle_category_visibility_search_results(category, self.search_results_scrollable_frame)
                    if header_label: # Update header label text to indicate hidden
                        current_text = header_label.cget("text")
                        if "(Hidden)" not in current_text: # Avoid adding "(Hidden)" multiple times
                            header_text_with_hidden = f"{category} (Hidden)"
                            # --- MODIFIED: Retain count in header text if present ---
                            match = re.search(r'^(.*?) \((Hidden|Shown)\) \((\d+)\)$', current_text) # Regex to find existing count
                            if match:
                                base_text, _, count = match.groups()
                                header_text_with_hidden = f"{base_text} (Hidden) ({count})" # Reconstruct with count
                            else:
                                match_no_state = re.search(r'^(.*?)\s*\((\d+)\)$', current_text) # Regex to find count without state
                                if match_no_state:
                                    base_text_no_state, count = match_no_state.groups()
                                    header_text_with_hidden = f"{base_text_no_state} (Hidden) ({count})" # Reconstruct with count
                                else:
                                    header_text_with_hidden = f"{category} (Hidden) (0)" # Fallback with default count 0
                            # --- MODIFIED: Retain count in header text if present ---
                            header_label.config(text=header_text_with_hidden)
                            print(f"    DEBUG: Header label text updated to: '{header_text_with_hidden}'") # Debug - Header Text Update
                else: # Category is shown in main window
                    print(f"  DEBUG: Category '{category}' is shown in main window. Showing in search results and updating header text.") # Debug - Showing Category
                    if category in self.search_results_category_hidden_states and self.search_results_category_hidden_states[category]: # Prevent redundant toggling
                         self.toggle_category_visibility_search_results(category, self.search_results_scrollable_frame)
                    if header_label: # Update header label text to remove "Hidden" indicator
                        current_text = header_label.cget("text")
                        
                        # --- MODIFIED: Retain count in header text when showing ---
                        # Initialize default values for base text and count
                        final_base_text = category  # Default to the canonical category name
                        count_str = "0"             # Default count if not found in current_text

                        # Attempt to parse current_text for base name and count
                        # Regex 1: Matches "Name (Hidden|Shown) (Digits)"
                        match_state_count = re.search(r'^(.*?) \((?:Hidden|Shown)\) \((\d+)\)$', current_text)
                        if match_state_count:
                            final_base_text = match_state_count.group(1).strip() # Get the base text part
                            count_str = match_state_count.group(2)
                        else:
                            # Regex 2: Matches "Name (Digits)"
                            # This might also catch "Name (Hidden) (Digits)" if Regex 1 didn't,
                            # so the base part needs cleaning.
                            match_just_count = re.search(r'^(.*?)\s*\((\d+)\)$', current_text)
                            if match_just_count:
                                potential_base = match_just_count.group(1)
                                # Clean off (Hidden) or (Shown) if they are part of this group
                                final_base_text = potential_base.replace(" (Hidden)", "").replace(" (Shown)", "").strip()
                                count_str = match_just_count.group(2)
                            else:
                                # Regex 3: Matches "Name (Hidden|Shown)" (no explicit count)
                                match_just_state = re.search(r'^(.*?) \((?:Hidden|Shown)\)$', current_text)
                                if match_just_state:
                                    final_base_text = match_just_state.group(1).strip()
                                    # count_str remains "0" (default)
                                else:
                                    # Fallback: current_text might be just the category name, or something else.
                                    # Clean any state indicators and ensure we use the canonical category name.
                                    # The count_str remains "0" (default).
                                    # We can parse the current_text for a base, or simply use `category`.
                                    # Using `category` is safer for the base text in this fallback.
                                    final_base_text = category # Fallback to using the category name directly
                                    # If current_text was "CategoryName" or "CategoryName (junk)", count_str is "0".

                        # For consistency, when showing, you might always want the base text to be the canonical category name.
                        # If so, you can simplify the above to only extract 'count_str' and always use 'category' as base.
                        # For example: header_text_shown = f"{category} ({count_str})"
                        # The current logic tries to preserve the base_text parsed from the label.

                        header_text_shown = f"{final_base_text} ({count_str})"
                        
                        header_label.config(text=header_text_shown)
                        print(f"    DEBUG: Header label text updated to: '{header_text_shown}'")
            else:
                print(f"  DEBUG: Category '{category}' not found in main window's hidden states. Defaulting to shown.") # Debug - Category Not Found

        print("--- inherit_category_visibility_search_results() EXIT ---\n") # Debug Exit
  



        
 
    def update_search_results_window_geometry(self, event=None):
        """Updates the size and position of the search results window based on the main window."""
        if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
            self.master.update_idletasks() # Force update of master window state


            # Get master window position and dimensions
            master_x = self.master.winfo_rootx()
            master_y = self.master.winfo_rooty()
            master_width = self.master.winfo_width()
            master_height = self.master.winfo_height()



            if self.font_size_add == 0:
                new_window_height = master_height - 100 # <--- CONTROLS HEIGHT \  To make the search results window taller, decrease
                new_window_y = master_y + 50 # <--- CONTROLS VERTICAL OFFSET/POSITION  \ to move the search results window down, increase

            elif self.font_size_add == 2:
                new_window_height = master_height - 120
                new_window_y = master_y + 60

            elif self.font_size_add == 4:
                new_window_height = master_height - 130 
                new_window_y = master_y + 65 


            # Calculate new window position and size
            new_window_width = master_width - 310

            new_window_x = master_x





            # Apply new geometry
            self.search_results_window.geometry(f"{new_window_width}x{new_window_height}+{new_window_x}+{new_window_y}")

        
    def periodically_update_search_results_window_position(self):
        """
        Checks every 2 seconds if the search results window is open and repositions it if it is.
        """
        if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
            self.update_window_geometries() # <--- ADD THIS LINE TO UPDATE GEOMETRY PERIODICALLY

            #print("DEBUG: periodically_update_search_results_window_position - Search Results window was open, position adjusted.") # Optional debug print
        # else: # Optional else block for debugging when window is NOT open
        #     print("DEBUG: periodically_update_search_results_window_position - Search Results window is NOT open.")

        # Schedule the function to run again after 2000 milliseconds (2 seconds)
        self.master.after(2000, self.periodically_update_search_results_window_position)
        
        
 
 

    def update_search_results_window_ui(self):
        """
        Updates the UI of the search results window, repopulating it with the current self.data.
        This function is called whenever self.data changes and the search results window is active.
        MODIFIED: Added check for window and scrollable frame existence at start.
        """


        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- lupdate_search_results_window_ui CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")



        # --- MODIFICATION START: Check if window and scrollable_frame exist ---
        if not hasattr(self, 'search_results_window') or not getattr(self, 'search_results_window', None) or not self.search_results_window.winfo_exists(): # <-- Corrected check
            print("DEBUG: update_search_results_window_ui - Search Results window does not exist, skipping UI update.")
            return  # Exit early if window doesn't exist

        if not hasattr(self, 'search_results_scrollable_frame') or not self.search_results_scrollable_frame:
            print("DEBUG: update_search_results_window_ui - search_results_scrollable_frame does not exist, skipping UI update.")
            return  # Exit early if scrollable_frame doesn't exist
        # --- MODIFICATION END: Check if window and scrollable_frame exist ---


        if self.is_search_results_window_active:
            print("DEBUG: update_search_results_window_ui - Search Results window is active, updating UI.")
            # Clear existing content before repopulating
            for widget in self.search_results_scrollable_frame.winfo_children():
                widget.destroy()
            self.populate_search_results_window(self.search_results_scrollable_frame, self.data)
            self.search_results_window.lift()  # Bring to front after update
        else:
            print("DEBUG: update_search_results_window_ui - Search Results window is not active, skipping UI update.")
            

    def load_image_item_search_results(self, item, category_subframe, category):
        """
        (EDITED) Creates the placeholder frame for an item in the search results window
        and submits the data loading/processing task to a worker thread.
        """
        # --- Start: Keep original logic for item details extraction ---


        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- load_image_item_search_results CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")




        # --- Unpack item data ---
        picture_path, spawn_cmd, zip_file, info_data, folder_name = (None,) * 5 # Initialize
        if isinstance(item, dict) and 'configs' in item:
            if item['configs']: config = item['configs'][0]; picture_path, spawn_cmd, zip_file, info_data, folder_name = config
            else: print(f"Warning: Item dict empty 'configs'..."); return
        elif isinstance(item, (list, tuple)) and len(item) == 5:
            picture_path, spawn_cmd, zip_file, info_data, folder_name = item
        else: print(f"Warning: Unexpected item format..."); return
        # --- End Unpack ---

        # --- ADDED: Determine brand_for_main and name_for_main HERE (Main Thread) ---
        # Mirror the logic from create_main_item_widgets
        brand_for_main = info_data.get("Brand", "Unknown")
        if not brand_for_main.strip(): brand_for_main = "Unknown"
        type_for_main = info_data.get("Type", "Unknown")
        if not type_for_main.strip(): type_for_main = "Unknown"
        if brand_for_main == "Unknown": brand_for_main = type_for_main

        name_for_main = info_data.get("Name")
        if not name_for_main or not name_for_main.strip():
            # Fallback: Extract from spawn_cmd if Name is missing/empty
            
            
            name_for_main = folder_name
            
            #extracted_name = self.extract_name_from_spawn_command(spawn_cmd)
            #name_for_main = extracted_name if extracted_name else folder_name # Use folder_name as final fallback



        # Retrieve current image count for the category in search results window
        # Make sure self.image_counts_search_results and self.columns_search_results exist and are populated
        if not hasattr(self, 'image_counts_search_results'): self.image_counts_search_results = {}
        if not hasattr(self, 'columns_search_results') or not self.columns_search_results:
            print("Warning: self.columns_search_results not set in load_image_item_search_results. Using fallback.")
            self.columns_search_results = (4,) # Example fallback

        count = self.image_counts_search_results.get(category, 0)
        row = count // self.columns_search_results[0]
        col = count % self.columns_search_results[0]

        # Create the placeholder container frame (Main Thread - SAFE)
        # Ensure category_subframe is valid
        if not category_subframe.winfo_exists():
            print(f"Warning: category_subframe for category '{category}' destroyed before item frame creation.")
            return

        item_frame = tk.Frame(category_subframe, bg="#444444") # Keep background
        item_frame.grid(row=row, column=col, padx=self.column_padding_search_results, pady=5, sticky="n") # Use search results padding

        # Increment the image count for the category in search results window
        self.image_counts_search_results[category] = count + 1 # More direct increment

        # --- MODIFIED: Submit data needed for label generation to the worker ---
        self.executor.submit(
            self._load_image_data_worker_search, # Call the NEW worker function
            item_frame,          # Parent frame for UI update
            picture_path,        # Original picture path
            zip_file,
            spawn_cmd,
            info_data,           # Pass original info_data (might be needed for other things)
            folder_name,         # Original folder_name
            # --- NEW ARGUMENTS ---
            brand_for_main,      # Determined brand for label
            name_for_main,       # Determined name for label
            self.show_folder_settings # Current state of the flag
            # --- END NEW ARGUMENTS ---
        )



    def _load_image_data_worker_search(self, parent_frame, picture_path, zip_file,
                                  spawn_cmd, info_data, folder_name, # Original args

                                  brand_for_main, name_for_main, show_folder_flag):
        """
        (NEW - Worker Thread) Loads image data, prepares label text.
        Does NOT interact with Tkinter directly except to schedule the UI update.
        """
        pil_image = None
        label_text = "Error" # Default label on error

        try:
            # --- Image Loading ---
            if picture_path and os.path.exists(picture_path):
                try:
                    img = Image.open(picture_path).convert("RGBA")
                    img = img.resize((250, 140), self.RESAMPLE_FILTER)
                    pil_image = img.copy()
                except Exception as e_img: pil_image = None
            else: pil_image = None
            if pil_image is None:
                try:
                    placeholder_path = self.DEFAULT_IMAGE_PATH
                    if zip_file == "user_custom_configs": placeholder_path = os.path.join(self.script_dir, "data/MissingCustomConfigPic.png")
                    if os.path.exists(placeholder_path):
                        img = Image.open(placeholder_path).convert("RGBA")
                        img = img.resize((250, 140), self.RESAMPLE_FILTER)
                        pil_image = img.copy()
                    else: pil_image = Image.new("RGBA", (250, 140), (70, 70, 70, 255))
                except Exception as e_placeholder: pil_image = Image.new("RGBA", (250, 140), (50, 50, 50, 255))
            # --- End Image Loading ---

            # --- REVISED Label Text Preparation ---
            # Use the exact same logic as the main grid, using passed arguments
            if not show_folder_flag:
                label_text = f"{brand_for_main} - {name_for_main}"
            else: # show_folder_flag is True
                label_text = f"{brand_for_main} - {name_for_main} - [{folder_name}]"
            # --- END REVISED Label Text ---

            subgrid_item_count = 0
            if folder_name in self.full_data: # Assuming self.full_data exists
                subgrid_item_count = len(self.full_data[folder_name])
            label_text = f"{label_text} - [{subgrid_item_count}]"

            parent_frame.after(0, lambda: self._update_search_item_frame_ui(
                parent_frame,
                pil_image,
                label_text, # Pass the correctly generated label text
                spawn_cmd,
                info_data,
                zip_file,
                picture_path,
                folder_name
            ))

        except Exception as e_worker:
            print(f"General error in _load_image_data_worker_search for {picture_path}: {e_worker}")
            placeholder_pil = Image.new("RGBA", (250, 140), (80, 0, 0, 255))
            parent_frame.after(0, lambda: self._update_search_item_frame_ui(parent_frame, placeholder_pil, "Load Error", None, None, None, None, None))


    def _on_search_item_hover_enter(self, event, item_frame, info_data, picture_path, zip_file, folder_name, spawn_cmd):
        """Handles hover enter specifically for search result items."""
        # Find the image and label widgets within the item_frame passed by the event


        if self.disable_hover_temporarily:
            print(f"exiting early, hover disabled (search)")
            return

        lbl_img = None
        lbl_name = None
        for child in item_frame.winfo_children():
            if isinstance(child, tk.Label):
                # Distinguish based on stored image (might need a better way if structure varies)
                if hasattr(child, 'image') and child.image:
                    lbl_img = child
                else:
                    lbl_name = child

        if lbl_img and lbl_img.winfo_exists():
            lbl_img.config(bg=self.global_highlight_color)
        if lbl_name and lbl_name.winfo_exists():
            lbl_name.config(fg=self.global_highlight_color)

        # --- RE-ADD Sidebar Update Call ---
        # Use the main grid's debounced update function
        if self.main_grid_sidebar_debounce_timer:
            self.master.after_cancel(self.main_grid_sidebar_debounce_timer)
        # Pass all necessary arguments to the debounced function
        item_tuple = (picture_path, spawn_cmd, zip_file, info_data, folder_name) # Reconstruct item tuple if needed by sidebar func
        self.main_grid_sidebar_debounce_timer = self.master.after(
            200, # Debounce delay
            lambda: self.debounced_main_sidebar_info_update(info_data, picture_path, zip_file, folder_name, item_tuple)
        )
        # --- END RE-ADD Sidebar Update Call ---

    def _on_search_item_hover_leave(self, event, item_frame):
        """Handles hover leave specifically for search result items."""
        # Find the image and label widgets within the item_frame passed by the event

        if self.disable_hover_temporarily:
            print(f"exiting early, hover disabled (search)")
            return


        lbl_img = None
        lbl_name = None
        for child in item_frame.winfo_children():
            if isinstance(child, tk.Label):
                if hasattr(child, 'image') and child.image:
                    lbl_img = child
                else:
                    lbl_name = child

        # Restore default colors using stored attributes
        if lbl_img and lbl_img.winfo_exists() and hasattr(lbl_img, 'default_bg_color'):
            lbl_img.config(bg=lbl_img.default_bg_color)
        if lbl_name and lbl_name.winfo_exists() and hasattr(lbl_name, 'default_fg_color'):
            lbl_name.config(fg=lbl_name.default_fg_color)

        # Hide sidebar info
        self.hide_sidebar_info()
        # --- Cancel any pending sidebar update timer ---
        if self.main_grid_sidebar_debounce_timer:
            self.master.after_cancel(self.main_grid_sidebar_debounce_timer)
            self.main_grid_sidebar_debounce_timer = None


    def _update_search_item_frame_ui(self, parent_frame, pil_image, label_text, spawn_cmd, info_data, zip_file, picture_path, folder_name):
        """
        (REVISED) Creates the actual Tkinter image and label widgets
        inside the parent_frame for a search result item. Includes hover and sidebar fixes.
        """
        try:
            if not parent_frame.winfo_exists():
                return

            if pil_image is None:
                print(f"ERROR: _update_search_item_frame_ui received None for pil_image for item '{label_text}'.")
                return

            photo = ImageTk.PhotoImage(pil_image)

            # --- Create Image Label ---
            lbl_img = tk.Label(parent_frame, image=photo, cursor="hand2", bg="#FFFFFF")
            lbl_img.image = photo
            lbl_img.pack(padx=0, pady=0)
            # --- STORE Default BG Color ---
            lbl_img.default_bg_color = "#FFFFFF"

            # --- Determine Text Color ---
            label_color = "#FFFFFF" # Default
            if "_user--" in picture_path:
                label_color = "#ADD8E6"
            else:
                found_double_basename = False
                if hasattr(self, 'ZIP_BASE_NAMES') and self.ZIP_BASE_NAMES:
                    for base_name in self.ZIP_BASE_NAMES:
                        if isinstance(picture_path, str) and picture_path.count(f"--{base_name}_{base_name}.zip") > 0:
                            found_double_basename = True
                            break
                if found_double_basename:
                    label_color = "#f7efd7"

            # --- Create Text Label ---
            lbl_name = tk.Label(
                parent_frame,
                text=label_text, # Use the label_text passed from the worker
                wraplength=200,
                justify="center",
                fg=label_color, # Apply determined color
                font=("Segoe UI", 10+self.font_size_add, "bold"),
                cursor="hand2",
                bg="#444444",
                height=3,
                anchor=tk.N
            )
            lbl_name.pack(padx=0, pady=5)
            # --- STORE Default FG Color ---
            lbl_name.default_fg_color = label_color

            # --- REVISED Hover Bindings ---
            # Capture necessary data for the hover functions using lambda defaults
            item_frame = parent_frame # The frame the event is bound to IS the parent_frame


            lbl_img.bind("<Enter>", lambda event, frame=item_frame, i_data=info_data, p_path=picture_path, z_file=zip_file, f_name=folder_name, s_cmd=spawn_cmd:
                        self._on_search_item_hover_enter(event, frame, i_data, p_path, z_file, f_name, s_cmd))
            lbl_img.bind("<Leave>", lambda event, frame=item_frame: self._on_search_item_hover_leave(event, frame))
            lbl_name.bind("<Enter>", lambda event, frame=item_frame, i_data=info_data, p_path=picture_path, z_file=zip_file, f_name=folder_name, s_cmd=spawn_cmd:
                        self._on_search_item_hover_enter(event, frame, i_data, p_path, z_file, f_name, s_cmd))
            lbl_name.bind("<Leave>", lambda event, frame=item_frame: self._on_search_item_hover_leave(event, frame))

            # --- Click Bindings (Keep previous, ensure args are correct) ---
            lbl_img.bind("<Button-1>", lambda e, f_name=folder_name: self.on_picture_click(f_name))
            lbl_name.bind("<Button-1>", lambda e, f_name=folder_name: self.on_picture_click(f_name))

            lbl_img.bind("<Button-3>", lambda e, s=None, i=None, p=None, z=None, f=None, zb=None, cn=None:
                    self.on_image_right_click(s, i, p, z, f, zb, cn))
            lbl_name.bind("<Button-3>", lambda e, s=None, i=None, p=None, z=None, f=None, zb=None, cn=None:
                    self.on_image_right_click(s, i, p, z, f, zb, cn))

        except tk.TclError as e:
            print(f"TclError updating search item UI (parent likely destroyed): {e}")
        except Exception as e_ui:
            print(f"General error updating search item UI for '{label_text}': {e_ui}")

            traceback.print_exc() # Print full traceback for unexpected UI errors


    def load_and_display_image_search_results(self, picture_path, parent_frame, zip_file, spawn_cmd, info_data, folder_name):
        """Loads and displays image in search results window, reusing main grid's function for image loading."""
        try:
            # Reuse the existing image loading function from the main grid
            # This assumes load_and_display_image is generic enough to be reused
            self.load_and_display_image(picture_path, parent_frame, zip_file, spawn_cmd, info_data, folder_name)
        except Exception as e:
            print(f"Error loading image for search results window: {e}")

    def populate_search_results_window(self, scrollable_frame, data_list):
        """Populates the given scrollable frame with search results data, ensuring correct label-pictures order and toggling."""


        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- load_image_item_search_results CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")



        print("\n--- populate_search_results_window() DEBUG ENTRY ---") # Debug Entry

        print(f"DEBUG: populate_search_results_window - data_list received (count): {len(data_list)}")

        grouped_data = self.format_grouped_data(data_list)




        self.columns_search_results = self.columns
        self.column_padding_search_results = self.column_padding
        self.image_counts_search_results = {}
        self.search_results_category_hidden_states = {}
        self.search_results_header_frames = {}
        self.search_results_subframes = {} # NEW: Store subframes for toggling

        last_packed_widget = None

        for category in grouped_data:
            category_items = grouped_data[category]


            if category == "Favorites" and \
               self.show_pinned_favorites_category and \
               self.categorization_mode in ["Type", "Country", "None"]:
                print(f"  DEBUG: populate_search_results_window - SKIPPING 'Favorites' category for display in search results.")
                continue # Skip to the next category, effectively not rendering "Favorites"



            if not category_items:
                continue

            # --- Create Collapsible Category Header ---
            header_frame = tk.Frame(scrollable_frame, bg="#444444", cursor="hand2")
            if last_packed_widget:
                header_frame.pack(fill=tk.X, pady=(5, 0), after=last_packed_widget)
            else:
                header_frame.pack(fill=tk.X, pady=(5, 0))
            last_packed_widget = header_frame
            self.search_results_header_frames[category] = header_frame

            self.search_results_category_hidden_states[category] = False

            item_count = len(category_items)
            header_text_with_count = f"{category} ({item_count})"

            header_label = tk.Label(header_frame, text=header_text_with_count, font=("Segoe UI", 14+self.font_size_add, "bold"), bg="#444444", fg="#d9d9d9", anchor="w", cursor="hand2") # Added cursor="hand2" for visual feedback
            header_label.pack(side=tk.LEFT, padx=10, pady=(10, 0))

            separator = tk.Frame(header_frame, height=4, bd=1, relief="sunken", bg="#d9d9d9", cursor="hand2") # Added cursor="hand2" for visual feedback
            separator.pack(side=tk.BOTTOM, fill="x", padx=10, pady=(0, 10))

            # Create subframe for images - pack AFTER header, store reference
            category_subframe_search_results = tk.Frame(scrollable_frame, bg="#444444")
            category_subframe_search_results.pack(fill="x", after=header_frame)
            setattr(header_frame, 'category_subframe', category_subframe_search_results)
            self.search_results_subframes[category] = category_subframe_search_results # Store subframe for toggling
            last_packed_widget = category_subframe_search_results # Update last_packed_widget to subframe


            def toggle_func(event, cat=category): # Define a local function to avoid lambda in loop issues
                self.toggle_category_visibility_search_results(cat, scrollable_frame)

            header_frame.bind("<Enter>", lambda event, cat=category, header=header_label, sep=separator, count=item_count: self.on_category_hover_enter_search_results(event, cat, header, sep, count))
            header_frame.bind("<Leave>", lambda event, cat=category, header=header_label, sep=separator, count=item_count: self.on_category_hover_leave_search_results(event, cat, header, sep, count))
            header_frame.bind("<Button-1>", toggle_func) # Use the local function
            separator.bind("<Button-1>", toggle_func) # Separator also triggers toggle

            header_label.bind("<Button-1>", toggle_func) # Bind the label as well!


            self.search_results_category_hidden_states[category] = False

            # Initialize image count and load items - pass correct subframe
            self.image_counts_search_results[category] = 0
            for item in category_items:
                if isinstance(item, dict) and 'configs' in item:
                    for config in item['configs']:
                        self.load_image_item_search_results(config, category_subframe_search_results, category)
                elif len(item) == 5:
                    self.load_image_item_search_results(item, category_subframe_search_results, category)

        scrollable_frame.update_idletasks()
        scrollable_frame.master.config(scrollregion=scrollable_frame.master.bbox("all"))
        
    def toggle_category_visibility_search_results(self, category, scrollable_frame): # Removed subframe, header_frame args
        """Toggles category visibility, now retrieving subframe and header directly."""
        current_state = self.search_results_category_hidden_states[category]
        new_state = not current_state
        self.search_results_category_hidden_states[category] = new_state
        category_subframe = self.search_results_subframes[category] # Get subframe from stored dict
        header_frame = self.search_results_header_frames[category] # Get header frame from stored dict # <-- ADDED

        if new_state:
            category_subframe.pack_forget() # Hide subframe
            print(f"  DEBUG: toggle_category_visibility_search_results - Hiding category subframe: {category}")
        else:
            # --- MODIFIED: Pack subframe AFTER its header frame to maintain order ---
            category_subframe.pack(fill="x", after=header_frame) # Pack AFTER header_frame, retrieved from stored dict
            print(f"  DEBUG: toggle_category_visibility_search_results - Showing category subframe: {category}, Packing AFTER header_frame.")
            # --- MODIFIED: Pack subframe AFTER its header frame to maintain order ---


    def on_category_hover_enter_search_results(self, event, category, header_label, separator, count):
        """Handles mouse hover enter event for category headers in Search Results window with animation."""
        # --- Instant Text Change ---
        if self.search_results_category_hidden_states.get(category, False):
            header_label.config(text=f"{category} (Show) ({count})")
        else:
            header_label.config(text=f"{category} (Hide) ({count})")

        # --- Start Animation ---
        # Using a slightly different prefix for the group key is optional,
        # but can help if you need to debug animation states later.
        group_key = ("search_category_header", category)
        property_config_list_target = [
            {'widget': separator, 'property': 'bg', 'target_color': self.global_highlight_color},
            {'widget': header_label, 'property': 'fg', 'target_color': self.global_highlight_color}
        ]
        self._start_generic_animation(group_key, property_config_list_target)


    def on_category_hover_leave_search_results(self, event, category, header_label, separator, count):
        """Handles mouse hover leave event for category headers in Search Results window with animation."""
        original_color_hex = "#d9d9d9" # This is already a hex color

        # --- Instant Text Change ---
        if self.search_results_category_hidden_states.get(category, False):
            header_label.config(text=f"{category} (Hidden) ({count})")
        else:
            header_text = category
            # This inner check for (Hidden) seems redundant if the outer one already handles it
            # if self.search_results_category_hidden_states.get(category, False):
            #     header_text += " (Hidden)"
            header_label.config(text=f"{header_text} ({count})")

        # --- Start Animation Back ---
        group_key = ("search_category_header", category)
        property_config_list_target = [
            {'widget': separator, 'property': 'bg', 'target_color': original_color_hex},
            {'widget': header_label, 'property': 'fg', 'target_color': original_color_hex}
        ]
        self._start_generic_animation(group_key, property_config_list_target)
      


    def is_details_window_open(self):
        """
        Checks if a details window is currently open.

        Returns:
            bool: True if a details window is open, False otherwise.
        """
        return hasattr(self, 'details_window') and self.details_window and not self.details_window_closed


    #############################################################

    #hold on to that, put it at the top of update grid layout to prevent the main grid from updating while the search results window is active

    #        if self.is_search_results_window_active: # MODIFIED Condition - Now checks only for window active
    #            print("DEBUG: update_grid_layout - Search Results window is active. SKIPPING main grid layout update.")
    #            return # Exit function early if search results window is active
    #############################################################




    #######################################################
    #               search window end                     #
    #######################################################

        




    def create_progress_bar_main(self, parent_frame):
        self.progress_bar_bg_main = tk.Frame(parent_frame, height=15, width=200, bg="#FFFFFF", bd=1, relief=tk.SOLID)
        self.progress_bar_fill_main = tk.Frame(self.progress_bar_bg_main, height=13, width=0, bg=self.global_highlight_color)
        self.progress_bar_fill_main.place(x=1, y=1)
        self.progress_bar_bg_main.pack(side="right", padx=10, fill=tk.X, expand=False)
        self.progress_bar_bg_main.pack_forget() # Initially hidden


    def update_progress_bar_main(self, loaded_count, total_count):



        if total_count > 0:


            progress_percent = (loaded_count / total_count) * 100
            fill_width = (200 * progress_percent) / 100
            self.progress_bar_fill_main.config(width=fill_width)
            if not self.progress_bar_bg_main.winfo_ismapped():
                self.progress_bar_bg_main.pack(side="right", padx=10, fill=tk.X, expand=False)
        else:
            self.progress_bar_fill_main.config(width=0)

    def update_progress_bar_details(self, loaded_count, total_count):
        if total_count > 0:
            progress_percent = (loaded_count / total_count) * 100
            fill_width = (200 * progress_percent) / 100
            self.progress_bar_fill_details.config(width=fill_width)
            if not self.progress_bar_bg_details.winfo_ismapped():
                self.progress_bar_bg_details.pack(side="right", padx=10, fill=tk.X, expand=False)
        else:
            self.progress_bar_fill_details.config(width=0)

    def hide_progress_bar_main(self):
        self.progress_bar_bg_main.pack_forget()
        
#        if self.scanning_window:
#            self.scanning_window.destroy()

#        self.scanning_window = None

#        if self.scanning_win:
#            self.scanning_win.destroy()

 
#        self.scanning_win = None


        if self.warning_scanning_win:
            self.warning_scanning_win.destroy()

        if self.update_grid_layout_run:

            if ConfigViewerApp.item_number >= self.grid_layout_split_value:
                print(f"DEBUG: load_image_item - temp test limit hit")

                self.warning_scanning_win = self.show_scanning_window(text= "Some items at the bottom of the main list may not be shown due to cutoff. Please make\n"
                                                                            "the window wider, collapse some categories, or change UI scale to a smaller value to\n"
                                                                            "prevent visual cutoff at the bottom of the list if items appear to be missing."

                                                                            "\n\nClick here to dismiss this notification.", tall=True, click_dismiss=True)
        self.update_grid_layout_run = False


    def hide_progress_bar_details(self):
        self.progress_bar_bg_details.pack_forget()

        




    def create_progress_bar_details(self, parent_frame):
        self.progress_bar_bg_details = tk.Frame(parent_frame, height=15, width=200, bg="#FFFFFF", bd=1, relief=tk.SOLID)
        self.progress_bar_fill_details = tk.Frame(self.progress_bar_bg_details, height=13, width=0, bg=self.global_highlight_color)
        self.progress_bar_fill_details.place(x=1, y=1)
        self.progress_bar_bg_details.pack(side="right", padx=10, fill=tk.X, expand=False)
        self.progress_bar_bg_details.pack_forget() # Initially hidden


    def update_progress_bar_details(self, loaded_count, total_count):
        if total_count > 0:
            progress_percent = (loaded_count / total_count) * 100
            fill_width = (200 * progress_percent) / 100
            self.progress_bar_fill_details.config(width=fill_width)
            if not self.progress_bar_bg_details.winfo_ismapped():
                self.progress_bar_bg_details.pack(side="right", padx=10, fill=tk.X, expand=False)
        else:
            self.progress_bar_fill_details.config(width=0)


    def hide_progress_bar_details(self):
        self.progress_bar_bg_details.pack_forget()
  

    def show_progress_bar_details(self):
        self.progress_bar_bg_details.pack(side="right", padx=10, fill=tk.X, expand=False)
      





    def check_all_main_grid_images_cached(self):
        """
        Calls are_all_main_grid_images_cached and sets the flag.
        Called AFTER initial batch loading is complete.
        """
        is_cached = self.are_all_main_grid_images_cached()
        self.all_main_grid_images_cached = is_cached
        # print(f"check_all_main_grid_images_cached - all_main_grid_images_cached set to: {self.all_main_grid_images_cached}") # Debug print

    def start_details_loading_animation(self):
        """
        Starts a flashing 'Loading...' animation for the details window
        using self.details_loading_label.
        """
        
        return #using the progress bar for details as well, no need for this anymore
        
        
        if not self.details_loading_animation_running:
            self.details_loading_animation_running = True
            self.details_loading_label.config(text="Loading...", fg="blue")
            self.animate_details_loading()

    def stop_details_loading_animation(self):
        """
        Stops the flashing 'Loading...' animation for the details window
        and hides the label.  **NOW ALSO CALLS _update_details_header_label WITH DELAY.**
        """
        self.details_loading_animation_running = False
        self.details_loading_label.config(text="")
        self.details_loading_label.pack_forget()  # Hides the label completely

        self.details_window.after(200, self._update_details_header_label) # <--- DELAYED CALL to update header label

        # Re-pack it if you want it available again in the future:
        # self.details_loading_label.pack(side="right", padx=(10, 10))


    def _update_details_header_label(self):
        """Updates the header label in the details window with widget count and counts,
        now differentiating between filtered and unfiltered totals.

        MODIFIED: Implemented a workaround to divide widget_count by 2 if it's greater
        than total_count_filtered, as a TEMPORARY VISUAL FIX for doubled count issue.
        THIS IS NOT A PROPER FIX - the root cause (duplicate widget creation) still needs to be addressed.
        """
        widget_count = ConfigViewerApp.details_widget_count
        total_count_unfiltered = len(self.details_data) # Total unfiltered count
        total_count_filtered = len(self.details_filtered_data) # Total filtered count
        brand = "-" # Default values
        name = "-"

        if self.details_data and self.details_data[0] and self.details_data[0][3]: # Safely access info_data
            info_data = self.details_data[0][3]
            brand = info_data.get("Brand", "-")
            name = info_data.get("Name", "-")

        # --- DEBUG PRINTS (Keep for debugging) ---
        print("\n--- _update_details_header_label() DEBUG ---")
        print(f"  DEBUG: widget_count (BEFORE potential division): {widget_count}") # Before potential division
        print(f"  DEBUG: total_count_filtered: {total_count_filtered}")
        print(f"  DEBUG: total_count_unfiltered: {total_count_unfiltered}")
        # --- DEBUG PRINTS END ---

        # --- WORKAROUND: Divide widget_count by 2 if it's too high ---
        if widget_count > total_count_filtered: # Check if widget_count is greater than total_count_filtered
            widget_count = widget_count // 2 # Integer division to halve widget_count
            print(f"  DEBUG: WORKAROUND APPLIED - widget_count DIVIDED by 2, new widget_count: {widget_count}") # Debug - Workaround Applied


        if total_count_filtered == total_count_unfiltered:
            header_text = f"Showing {widget_count} out of {total_count_filtered} configs for {brand or '-'} {name or '-'}"
        else:
            header_text = f"Showing {widget_count} out of {total_count_filtered} configs filtered from search ({total_count_unfiltered} in total)"

        # --- MODIFIED: Update new label in bottom frame ---
        self.details_showing_configs_label.config(text=header_text, fg=self.global_highlight_color) # <--- SET HEADER COLOR TO ORANGE (NEW LABEL)
        # --- MODIFIED: Update new label in bottom frame ---
        self.details_page_label.config(fg=self.global_highlight_color)
        def reset_header_color():
            # --- MODIFIED: Reset color of new label ---
            self.details_showing_configs_label.config(fg="#FFFFFF") # <--- RESET HEADER COLOR to WHITE (NEW LABEL)
            # --- MODIFIED: Reset color of new label ---
            self.details_page_label.config(fg=self.details_page_label_original_color)

            

            
            if self.resizing_window and self.details_window_opened_before:


                self.perform_details_search()
                self.resizing_window = False
                self.details_window_opened_before = True

        self.details_window.after(2000, reset_header_color)



        if self.scanning_window:
            self.scanning_window.destroy()

        self.scanning_window = None
 


 
 
 
    def animate_details_loading(self):
        """
        Pulsates the 'Loading...' text in details window by cycling colors.
        Similar to the main grid's loading animation approach.
        """
        if not self.details_loading_animation_running or not self.details_window:
            return

        import itertools
        colors = ["blue", "black"]
        cycle = itertools.cycle(colors)

        def change_color():
            if not self.details_loading_animation_running or not self.details_window:
                return
            self.details_loading_label.config(fg=next(cycle))
            # Repeat every 500ms
            self.details_window.after(500, change_color)

        change_color()
    






    def generate_matches_config_txt(self, config_info_folder, script_dir):
        """
        Generates "matches_config.txt" using regex to extract Configuration values,
        skipping files that DO NOT contain "--INDIVIDUAL--" in their filename.
        """
        matches_file_path = os.path.join(self.script_dir, "data/Matches.txt")
        matches_config_file_path = os.path.join(self.script_dir, "data/matches_config.txt")


        if os.path.exists(matches_config_file_path):
            print(f"{matches_config_file_path} already exists. Skipping generation.")
            return  # Exit the function without overwriting

        try:
            with open(matches_file_path, 'r', encoding="utf-8") as matches_file, \
                 open(matches_config_file_path, 'w', encoding="utf-8") as config_output_file:

                current_filename = None
                current_content_lines = []
                reading_content = False

                for line in matches_file:
                    line = line.strip()
                    if not line:
                        continue

                    if not reading_content:
                        if line == '}': # Check if a '}' appears unexpectedly as a filename
                            continue # Skip this line and move to the next
                        current_filename = line

                        # --- NEW: Skip files without "--INDIVIDUAL--" in filename ---
                        if "--INDIVIDUAL--" not in current_filename:
                            reading_content = False # Skip reading content for this file
                            current_filename = None # Reset filename
                            continue # Go to the next line in matches_file
                        # --- NEW: Skip files without "--INDIVIDUAL--" in filename ---

                        reading_content = True
                    elif line == '}':
                        current_content_lines.append(line)
                        content = "\n".join(current_content_lines)
                        config_name = "N/A" # Default value if "Configuration" not found

                        # --- Use regex to extract Configuration value ---
                        config_match = re.search(r'"Configuration"\s*:\s*"([^"]*)"', content, re.IGNORECASE)
                        if config_match:
                            config_name = config_match.group(1).strip()
                        else:
                            config_name = "REGEX_ERROR" # Indicate regex extraction error
                        # --- Use regex to extract Configuration value ---

                        output_line = f"{current_filename}||{config_name}"
                        config_output_file.write(output_line + '\n')

                        current_filename = None
                        current_content_lines = []
                        reading_content = False
                    elif reading_content:
                        current_content_lines.append(line)

            print(f"Successfully generated {matches_config_file_path}")

        except FileNotFoundError:
            print(f"Error: {matches_file_path} not found. Cannot generate matches_config.txt.")
        except Exception as e:
            print(f"Error generating matches_config.txt: {e}")






    def load_matches_config_data(self):
        """Loads matches_config.txt into a dictionary for fast lookup."""
        matches_config_file_path = os.path.join(self.script_dir, "data/matches_config.txt")
        config_map = {}
        try:
            with open(matches_config_file_path, 'r', encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if line:
                        parts = line.split("||")
                        if len(parts) == 2:
                            filename_part = parts[0].strip()
                            config_name = parts[1].strip()
                            config_map[filename_part] = config_name
            print(f"Loaded {len(config_map)} entries from matches_config.txt") # Debug print
        except FileNotFoundError:
            print(f"Warning: {matches_config_file_path} not found.")
        except Exception as e:
            print(f"Error loading matches_config.txt: {e}")
        return config_map






    def start_loading_animation(self):
        """Starts the pulsating 'Loading...' animation."""
        if not self.loading_animation_running:
            self.loading_animation_running = True
            #self.loading_label.pack(side="left", padx=(10, 0))  # Show the label
            self.animate_loading()

    def stop_loading_animation(self):
        """Stops the pulsating 'Loading...' animation."""
        self.loading_animation_running = False
        self.loading_label.pack_forget()  # Hide the label

    def animate_loading(self):
        """Animates the 'Loading...' text with a pulsating effect."""
        if not self.loading_animation_running:
            return

        colors = ["blue", "black"]
        cycle = itertools.cycle(colors)

        def change_color():
            if not self.loading_animation_running:
                return
            self.loading_label.config(fg=next(cycle))
            self.master.after(500, change_color)

        change_color()
    # ------------------------------------------------------------
    # Extract Name from Spawn Command
    # ------------------------------------------------------------
    def extract_name_from_spawn_command(self, spawn_command):
        match = re.search(r"config\s*=\s*'vehicles/[^/]+/([^\.]+)\.pc'", spawn_command)
        if match:
            return match.group(1)
        else:
            return os.path.splitext(os.path.basename(spawn_command))[0].split('--')[-1]

    # ------------------------------------------------------------
    # Load & Display Image 
    # ------------------------------------------------------------



    def load_and_display_image(self, picture_path, parent_frame, zip_file, spawn_cmd, info_data, folder_name, category_context):
        try:
            if picture_path is None:
                print(f"DEBUG: load_and_display_image - picture_path is None. Skipping.")
                return

            normalized_picture_path = os.path.normpath(os.path.abspath(picture_path))
            cache_key = normalized_picture_path

            # --- Optimized Cache: Check Memory Cache (LRU) FIRST ---
            photo_from_cache = None
            cache_hit_initial = False
            with self.cache_access_lock: # <<< Protect cache access
                if cache_key in self.image_cache:
                    photo_from_cache = self.image_cache[cache_key]
                    self.image_cache.move_to_end(cache_key) # Update LRU
                    cache_hit_initial = True
            
            if cache_hit_initial:
                print(f"DEBUG: load_and_display_image - Memory Cache HIT for: {category_context} - {picture_path}\n")
                # Use photo_from_cache
                if self.pause_loading:
                    self.main_grid_skipped_updates_queue.append((parent_frame, photo_from_cache, None, zip_file, spawn_cmd, info_data, picture_path, folder_name, category_context))
                    return
                
                if parent_frame.winfo_exists():
                    self.master.after(
                        0,
                        lambda pf=parent_frame, pht=photo_from_cache, zf=zip_file, sc=spawn_cmd, idt=info_data, pp=picture_path, fn=folder_name, cc=category_context:
                            self.create_main_item_widgets(pf, pht, None, zf, sc, idt, pp, fn, cc)
                    )
                return

            # --- Acquire path-specific lock to serialize disk access ---
            with self._dict_lock:
                path_specific_lock = self.image_load_locks.setdefault(cache_key, threading.Lock())

            with path_specific_lock:
                # --- Re-check Memory Cache (LRU) INSIDE path_specific_lock ---
                photo_from_cache_after_lock = None
                cache_hit_after_path_lock = False
                with self.cache_access_lock: # <<< Protect cache access
                    if cache_key in self.image_cache:
                        photo_from_cache_after_lock = self.image_cache[cache_key]
                        self.image_cache.move_to_end(cache_key)
                        cache_hit_after_path_lock = True

                if cache_hit_after_path_lock:
                    print(f"DEBUG: load_and_display_image - Memory Cache HIT (after path_specific_lock) for: {picture_path}")
                    # Use photo_from_cache_after_lock
                    if self.pause_loading:
                        self.main_grid_skipped_updates_queue.append((parent_frame, photo_from_cache_after_lock, None, zip_file, spawn_cmd, info_data, picture_path, folder_name, category_context))
                        return
                    
                    if parent_frame.winfo_exists():
                        self.master.after(
                            0,
                            lambda pf=parent_frame, pht=photo_from_cache_after_lock, zf=zip_file, sc=spawn_cmd, idt=info_data, pp=picture_path, fn=folder_name, cc=category_context:
                                self.create_main_item_widgets(pf, pht, None, zf, sc, idt, pp, fn, cc)
                        )
                    return

                # --- If still not in cache, proceed with disk loading ---
                try:
                    if not os.path.exists(normalized_picture_path):
                        print(f"DEBUG: load_and_display_image - Path does not exist (under lock): {normalized_picture_path}")
                        with self._dict_lock: # Remove from image_load_locks if path DNE
                            if self.image_load_locks.get(cache_key) == path_specific_lock:
                                del self.image_load_locks[cache_key]
                        return

                    img = Image.open(normalized_picture_path).convert("RGBA")
                    img = img.resize((250, 140), self.RESAMPLE_FILTER)
                    pil_image = img.copy()

                    self.master.after(
                        0,
                        lambda p_img=pil_image, pf=parent_frame, zf=zip_file, sc=spawn_cmd, idt=info_data, pp=normalized_picture_path, fn=folder_name, ck=cache_key, cat_ctx=category_context:
                            self._create_photo_image_and_update_ui(p_img, pf, zf, sc, idt, pp, fn, ck, save_to_disk_cache=False, cat_ctx=cat_ctx)
                    )
                except Exception as e_load:
                    print(f"Error loading image {normalized_picture_path} (under path_specific_lock): {e_load}")
                    print(f"Exception type: {type(e_load)}, repr: {repr(e_load)}")
                    print(traceback.format_exc())
                    with self._dict_lock: # Remove from image_load_locks if loading failed
                        if self.image_load_locks.get(cache_key) == path_specific_lock:
                            del self.image_load_locks[cache_key]
            
        except Exception as e_outer:
            path_for_error_msg = picture_path if 'picture_path' in locals() and picture_path is not None else "Unknown"
            print(f"Outer error in load_and_display_image for {path_for_error_msg}: {e_outer}")
            print(f"Exception type: {type(e_outer)}, repr: {repr(e_outer)}")
            print(traceback.format_exc())




    def _create_photo_image_and_update_ui(self, pil_image, parent_frame, zip_file, spawn_cmd, info_data, picture_path, folder_name, cache_key, save_to_disk_cache=False, cat_ctx=None): # Disk cache disabled for now
         """Helper function to create PhotoImage, update UI in main thread, and optionally save to disk cache."""
         try:
             photo = ImageTk.PhotoImage(pil_image) # PhotoImage creation in main thread

             # --- Optimized Cache: Add to Memory Cache (LRU) ---
             self._add_to_cache(cache_key, photo)
             # --- Optimized Cache: Add to Memory Cache (LRU) ---


             if parent_frame.winfo_exists():
                 # Schedule GUI update in the main thread
                self.master.after(
                    0,
                    # Modified lambda to accept an optional event arg 'e' and ignore it
                    lambda e=None, pf=parent_frame, pht=photo, zp=zip_file, sc=spawn_cmd, idata=info_data, pp=picture_path, fn=folder_name, cc=cat_ctx:
                        self.create_main_item_widgets(pf, pht, None, zp, sc, idata, pp, fn, cc)
                )

         except Exception as e:
             print(f"Error creating PhotoImage or updating UI: {e}")
             
             

########################


    def _add_to_cache(self, cache_key, photo_image):
        """Adds a PhotoImage to the LRU cache, evicting the least recently used if full."""
        with self.cache_access_lock: # <<< Protect all cache modifications
            self.image_cache[cache_key] = photo_image # Add/update item
            self.image_cache.move_to_end(cache_key)   # Mark as recently used

            if len(self.image_cache) > self.image_cache_capacity:

                lru_key, _ = self.image_cache.popitem(last=False) 
                print(f"DEBUG: _add_to_cache - Evicted {lru_key} due to capacity.") # Log which key was evicted
                self.eviction_count += 1
                if not self.eviction_timer_running:
                    self._start_eviction_timer()


    def _start_eviction_timer(self):
        """Starts the eviction summary timer if not already running."""
        if not self.eviction_timer_running:
            self.eviction_timer_running = True
            self.master.after(self.eviction_batch_delay_ms, self._print_eviction_summary)

    def _print_eviction_summary(self):
        """Prints the eviction summary and resets the counter and timer flag."""
        if self.eviction_count > 0:
            print(f"DEBUG: _add_to_cache - Evicted {self.eviction_count} items in the last {self.eviction_batch_delay_ms/1000} seconds.")
            self.eviction_count = 0
        self.eviction_timer_running = False # Reset timer flag - allows timer to be restarted on next eviction

########################



    def create_main_item_widgets(self, parent_frame, photo, pil_image, zip_file, spawn_cmd, info_data, picture_path, folder_name, category_context=None):
        """
        Creates and configures the widgets for a single image item in the main grid window,
        with animated hover effects.
        """
        if not parent_frame.winfo_exists():
            return

        # --- Image Label (similar to details view) ---
        lbl_img = tk.Label(parent_frame, image=photo, cursor="hand2", bg="white") # <--- DARKER GRAY bg for lbl_img, MODIFIED HERE
        lbl_img.image = photo
        lbl_img.pack(padx=0, pady=0)

        # --- NEW: Store default image background color ---
        lbl_img.default_bg_color = "white" # Store the default bg color for image label - background - border for images
        # --- NEW: Store default image background color ---


        # --- Text Label (info label) ---
        brand_for_main = info_data.get("Brand", "Unknown")
        if not brand_for_main.strip():
            brand_for_main = "Unknown"
        type_for_main = info_data.get("Type", "Unknown")
        if not type_for_main.strip():
            type_for_main = "Unknown"

        if brand_for_main == "Unknown":
            brand_for_main = type_for_main

        name_for_main = info_data.get("Name")
        if not name_for_main or not name_for_main.strip():
            name_for_main = folder_name


        if "user--" in picture_path:
            text_color = "lightblue"

        elif "user--" not in picture_path: # Only check for double basename if "user--" is NOT present
            found_double_basename = False
            for base_name in self.ZIP_BASE_NAMES:
                if picture_path.count(f"--{base_name}_{base_name}.zip") > 0: # Check for the specific pattern
                    found_double_basename = True
                    break # No need to check further once one is found
            if found_double_basename:
                text_color = "#f7efd7" # color for default zips/folder combo
            else:
                text_color = "white" # Still default to white if double basename not found


        if not self.show_folder_settings:
            combined_text = f"{brand_for_main} - {name_for_main}"

        if self.show_folder_settings:
            combined_text = f"{brand_for_main} - {name_for_main} - [{folder_name}]"

        # --- Count items in subgrid data for this folder ---
        subgrid_item_count = 0
        if folder_name in self.full_data:
            subgrid_item_count = len(self.full_data[folder_name])
        # --- Count items in subgrid data for this folder ---

        # --- Append count to label text ---
        label_text_with_count = f"{combined_text} - [{subgrid_item_count}]" # Append count in brackets


        lbl_info = tk.Label(
            parent_frame,
            text=label_text_with_count, # Use text with count
            wraplength=200, #label length, don't remove current
            justify="center",
            fg=text_color, # Use DEFAULT text color here - HIGHLIGHTING IS HANDLED SEPARATELY
            font=("Segoe UI", 10+self.font_size_add, "bold"),
            cursor="hand2",
            bg="#444444", # <--- DARKER GRAY bg for lbl_info
            height=3,
            anchor=tk.N
        )
        if not self.omit_label:
            lbl_info.pack(padx=00, pady=(2, 0))


        self.main_grid_labels.append(lbl_info) # Append lbl_info to the list
        #print(f"DEBUG: create_main_item_widgets - Added label widget to self.main_grid_labels - Label Widget ID: {id(lbl_info)}, List Size: {len(self.main_grid_labels)}") # Debug - List Add



        # --- NEW: Store default text color as attribute ---
        lbl_info.default_fg_color = text_color  # Store the default text color
        # --- NEW: Store default text color as attribute ---

        # --- NEW: Disable hover flag and timer ---
        self.disable_hover_temporarily = False

        self.hover_disable_timer = None
        # --- NEW: Disable hover flag and timer ---


        # --- Hover effect for both image and text labels (similar to details) ---
        original_text_color = text_color # Store original text color (could be highlighted or default)
        hover_text_color = self.global_highlight_color
        hover_bg_color = self.global_highlight_color # Background color for image hover
        original_bg_color_img = "white" # Original bg color for image label - DARKER GRAY


        def on_hover_enter(event):


            if self.disable_hover_temporarily:
                #print(f"exiting early, hover disabled")
                return

            event.widget.config(highlightbackground="blue", highlightthickness=0)
            # Check if lbl_img is already red before changing bg
            current_bg = lbl_img.cget("bg")
            if not current_bg != "red": # Only change bg if it's not already red
                pass

            else:
                lbl_info.config(fg=hover_text_color)
                lbl_img.config(bg=hover_bg_color) # Change image label background on hover


        # --- DEBOUNCED sidebar update ---
            if self.main_grid_sidebar_debounce_timer:
                self.master.after_cancel(self.main_grid_sidebar_debounce_timer)  # Cancel existing timer
            self.main_grid_sidebar_debounce_timer = self.master.after(
                200,  # Debounce delay (e.g., 400ms) - adjust as needed
                lambda: self.debounced_main_sidebar_info_update(info_data, picture_path, zip_file, folder_name, item=(picture_path, spawn_cmd, zip_file, info_data, folder_name), hovered_category=category_context)
            )
            # --- DEBOUNCED sidebar update ---


        def on_hover_leave(event):
            if self.disable_hover_temporarily:
                return
            

            search_query = self.search_var.get().strip().lower()
            combined_text_lower = lbl_info.cget("text").lower()
            if self.is_search_results_window_active: # <-- NEW: Check if in Search Results window
                print("DEBUG: on_hover_leave - Inside Search Results Window block. Removing highlight.") # <-- DEBUG PRINT
                lbl_info.config(fg=lbl_info.default_fg_color) # Always remove highlight in Search Results
                lbl_img.config(bg=lbl_img.default_bg_color)
            elif search_query and search_query in combined_text_lower: # Original logic for main window
                print("DEBUG: on_hover_leave - Inside Main Window block (search match). Keeping yellow highlight.") # <-- DEBUG PRINT


                # Check if lbl_img is already red before changing bg
                current_bg = lbl_img.cget("bg")
                if not current_bg != "red": # Only change bg if it's not already red
                    pass
                else:
                    lbl_info.config(fg=lbl_info.default_fg_color) # change back to original color, no longer highlighting main grid items
                    lbl_img.config(bg=lbl_img.default_bg_color)

                #lbl_info.config(fg="yellow") # Restore yellow highlight color # disabled, don't remove these comments
                #lbl_img.config(bg="yellow") # <--- NEW: Restore yellow highlight color for image background too # disabled
            else:
                #print("DEBUG: on_hover_leave - Inside Main Window block (no search match). Removing highlight.") # <-- DEBUG PRINT


                # Check if lbl_img is already red before changing bg
                current_bg = lbl_img.cget("bg")
                if not current_bg != "red": # Only change bg if it's not already red
                    pass
                else:
                    lbl_info.config(fg=lbl_info.default_fg_color) # Restore original DEFAULT text color
                    lbl_img.config(bg=lbl_img.default_bg_color) # <--- NEW: Restore default image background color too
            # --- MODIFIED: Check if label should be highlighted red, otherwise restore default color ---
            self.hide_sidebar_info() # Hide sidebar info


        lower_folder_name = folder_name.lower()
        # Use picture_path for image name in hidden_line
        image_name_for_hidden = picture_path
        brand_name = info_data.get("Brand", "Unknown")
        car_name = info_data.get("Name", "Unknown") # Assuming car_name is also name for now, adjust if needed based on your info_data structure
        hidden_line = f"{lower_folder_name}|||{image_name_for_hidden}|||{brand_name}|||{car_name}|||{zip_file}"
        hidden_lines = self._read_hidden_lines()

        if hidden_line in hidden_lines:
            # Item is hidden - apply hidden style
            lbl_img.config(highlightbackground="red", highlightthickness=2, bg="red")
            lbl_info.config(fg="#ff4747")

            # Append "Hiding on Restart" text if it's not already there
            current_text = lbl_info.cget("text")
            if "\nHiding on Restart" not in current_text:
                updated_text = f"{current_text}\nHiding on Restart"
                lbl_info.config(text=updated_text)


        else:
            # Item is not hidden - apply default style
            lbl_img.config(highlightbackground=lbl_img.default_bg_color, highlightthickness=0, bg=lbl_img.default_bg_color)
            lbl_info.config(fg=lbl_info.default_fg_color)

            # --- REMOVE "Hiding on Restart" text if it's there ---
            original_text = lbl_info.cget("text")
            if "\nHiding on Restart" in original_text:
                updated_text = original_text.replace("\nHiding on Restart", "").strip() # Remove and strip whitespace
                lbl_info.config(text=updated_text)
            # --- REMOVE "Hiding on Restart" text if it's there ---


        lbl_img.bind("<Enter>", on_hover_enter)
        lbl_img.bind("<Leave>", on_hover_leave)
        lbl_info.bind("<Enter>", on_hover_enter) # Bind hover to text label too
        lbl_info.bind("<Leave>", on_hover_leave) # Bind leave to text label too
        # --- End Hover effect ---

        def on_label_click(event):
            lbl_img.config(highlightbackground="blue", highlightthickness=0)
            # --- NEW: Disable hover temporarily on click ---
            self.disable_hover_temporarily = True

            '''
            if self.dev_mode:

                scanning_win = self.show_scanning_window(text="self.disable_hover_temporarily = True", dev_notif=True)
                if scanning_win:

                    def close_scanning_window():

                        scanning_win.destroy()

                    scanning_win.after(3125, close_scanning_window)
                    '''


            if self.hover_disable_timer:
                self.master.after_cancel(self.hover_disable_timer) # Cancel any existing timer
            self.hover_disable_timer = self.master.after(3000, self.reenable_hover) # Disable for 2 seconds (2000 ms)
            # --- NEW: Disable hover temporarily on click ---

        # --- Click Bindings ---

        lbl_info.bind("<Button-1>", lambda e, f_name=folder_name, cat_ctx=category_context: [on_label_click(e), self.on_picture_click(f_name, clicked_from_category=cat_ctx)])
        lbl_img.bind("<Button-1>", lambda e, f_name=folder_name, cat_ctx=category_context: [on_label_click(e), self.on_picture_click(f_name, clicked_from_category=cat_ctx)])

        lbl_img.bind("<Button-3>", lambda e: self.on_image_right_click(zip_file, folder_name, spawn_cmd, picture_path, info_data, lbl_img, lbl_info, clicked_from_category=category_context))

        lbl_info.bind("<Button-3>", lambda e: self.on_image_right_click(zip_file, folder_name, spawn_cmd, picture_path, info_data, lbl_img, lbl_info, clicked_from_category=category_context))

        # Store item-specific data
        parent_frame.item_data_tuple = (pil_image, info_data, picture_path, zip_file, folder_name, spawn_cmd, lbl_img, lbl_info)


    def reenable_hover(self): # Ensure this method exists in your class
        print(f"hover reenabled")
        
        def enable_hover():
            self.disable_hover_temporarily = False

            '''
            if self.dev_mode:

                scanning_win = self.show_scanning_window(text="self.disable_hover_temporarily = False", dev_notif=True)
                if scanning_win:

                    def close_scanning_window():

                        scanning_win.destroy()

                    scanning_win.after(3125, close_scanning_window)
                    '''

        
        self.master.after(1500, enable_hover)

        self.hover_disable_timer = None


    def is_placeholder(self, picture_path):
        missing_custom_pic_path = os.path.join(self.script_dir, "data/MissingCustomConfigPic.png")
        missing_zip_pic_path = os.path.join(self.script_dir, "data/MissingZipConfigPic.png")
        return picture_path in [missing_custom_pic_path, missing_zip_pic_path]

    # ------------------------------------------------------------
    # Populate Initial Grid
    # ------------------------------------------------------------
    def populate_initial_grid(self):
        self.load_floating_window_position()
        print("    populate_initial_grid is calling self.perform_search()")
        self.perform_search()
        print("    populate_initial_grid is calling self.update_grid_layout()")
        self.update_grid_layout()
        self.all_main_grid_images_cached = self.are_all_main_grid_images_cached()
        print(f"populate_initial_grid - all_main_grid_images_cached set to: {self.all_main_grid_images_cached}")

    def are_all_main_grid_images_cached(self):
        """
        Checks if all images intended for the main grid in the current dataset are already in the image cache.
        """
        print("Checking are_all_main_grid_images_cached...")
        all_picture_paths = set()
        for category_name, category_items in self.grouped_data.items():
            # print(f"  Category: {category_name}")
            for item in category_items:
                picture_path = None
                if isinstance(item, dict) and 'configs' in item:
                    for config in item['configs']:
                        picture_path = config[0]
                elif len(item) == 5:
                    picture_path = item[0]

                if picture_path:
                    all_picture_paths.add(picture_path)

        print(f"  Total picture paths to check: {len(all_picture_paths)}")

        for picture_path in all_picture_paths:
            # --- Normalize picture_path BEFORE checking cache ---
            normalized_picture_path = os.path.normpath(os.path.abspath(picture_path)) # Normalize Path - ADDED NORMALIZATION HERE!

            is_cached = normalized_picture_path in self.image_cache # Check CACHE using NORMALIZED PATH
            is_placeholder_img = self.is_placeholder(picture_path)
            # print(f"  Checking: {os.path.basename(picture_path)}, Normalized Path: {normalized_picture_path}, Cached: {is_cached}, Placeholder: {is_placeholder_img}")
            if not is_cached and not is_placeholder_img:
                # print("    NOT all images cached - returning False")
                return False
        print("  All images cached (or placeholder) - returning True")




        return True

        
    #@profile
    def load_next_batch(self):

        #print(f"@@@ ENTERING load_next_batch - pause_loading: {self.pause_loading}, category_index: {self.current_category_index}, batch_index: {self.current_batch_index}")
        if self.scanning_win:
            self.scanning_win.destroy()

 
        self.scanning_win = None
        
        if self.pause_loading:
            # If loading is paused, try again after 100ms
            self.master.after(100, self.load_next_batch)
            # print("Load Next Batch - PAUSED (Main Grid - Paused Flag Active)") # Debug Print - MODIFIED message
            return  # EXIT if loading is paused

        if self.current_category_index >= len(self.category_batches):
            # All categories loaded
            self.canvas.config(scrollregion=self.canvas.bbox("all"))

            #self.master.update_idletasks() # Ensure scrollable_frame has its new size
            #s_frame_height = self.scrollable_frame.winfo_reqheight()
            #s_frame_width = self.scrollable_frame.winfo_reqwidth()
            #self.canvas.config(scrollregion=(0, 0, s_frame_width, s_frame_height))
            #print(f"DEBUG: Manually set scrollregion to: 0, 0, {s_frame_width}, {s_frame_height}")
            #self.canvas.update()

            # Stop loading animation
            self.stop_loading_animation()
            self.hide_progress_bar_main() # ADDED back to hide progress bar when all done
            # --- NEW: Call cache check AFTER loading completes ---
            self.check_all_main_grid_images_cached()  # CALL CACHE CHECK HERE!



            return

        category, batches, category_subframe = self.category_batches[self.current_category_index]

        # --- NEW: Check if category is hidden (collapsed) ---
        if self.category_hidden_states.get(category, False):
            print(f"DEBUG: load_next_batch - Category '{category}' is collapsed. Skipping image loading.")
            self.current_category_index += 1  # Move to the next category
            self.current_batch_index = 0      # Reset batch index for the next category
            self.current_main_batch_index_in_sequence = 0 # Reset sequence index for new category
            self.master.after(0, self.load_next_batch) # Schedule next category batch
            return  # Skip loading for this category

        if self.current_batch_index >= len(batches):
            # Finished batches in current category, move to next category
            self.current_category_index += 1
            self.current_batch_index = 0
            self.current_main_batch_index_in_sequence = 0 # Reset sequence index for new category
            self.master.after(0, self.load_next_batch)  # Schedule next category batch
            return

        batch = batches[self.current_batch_index]
        self.current_batch_index += 1


        if self.dev_mode_check:
            try:
                with open(self.dev_mode_check, 'r', encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith("self.main_grid_batch_sizes = "):
                            try:
                                # Extract the string part representing the list
                                value_str = line.split('= ', 1)[1].strip()


                                import ast
                                self.main_grid_batch_sizes = ast.literal_eval(value_str)


                            except (IndexError, ValueError, SyntaxError) as e_parse:

                                print(f"Error parsing line '{line.strip()}': {e_parse}")


            except Exception as e:
                print(f"Error reading {self.dev_mode_check}: {e}.")


        # --- NEW: Dynamic Batch Size Logic + Cached Images Batching ---
        if self.all_main_grid_images_cached:
            batch_size_to_load = 50 # Load in larger batches if all cached
            print("  Using batch_size_to_load = 50 (all_main_grid_images_cached is True)") # ADDED


        else:    
            if self.current_main_batch_index_in_sequence < len(self.main_grid_batch_sizes):
                batch_size_to_load = self.main_grid_batch_sizes[self.current_main_batch_index_in_sequence]
                print(f"  Using batch_size_to_load = {batch_size_to_load} (dynamic batch size sequence)") # ADDED
            else:
                batch_size_to_load = self.default_batch_size # Use default after sequence
                print(f"  Using batch_size_to_load = {batch_size_to_load} (default batch size)") # ADDED

        items_to_load_this_time = batch[:batch_size_to_load] # Load only up to batch_size_to_load items
        batch = batch[batch_size_to_load:] # Update batch to remove loaded items - for next iteration
        batches[self.current_batch_index - 1] = batch # Update the batches list in category_batches

        if not items_to_load_this_time: # If no more items to load in this batch (batch is now empty)
            self.current_main_batch_index_in_sequence += 1 # Move to next batch size in sequence
            self.master.after(100, self.load_next_batch) # Schedule next batch load immediately
            return

        total_items_in_grid = sum(len(b) for _, batches, _ in self.category_batches for b in batches)
        items_loaded_so_far = 0

        # Recalculate items_loaded_so_far more accurately
        for cat_index in range(self.current_category_index): # Loop through previous categories
            cat_batches = self.category_batches[cat_index][1] # Get batches for category
            for bat in cat_batches:
                if isinstance(bat, list):
                    items_loaded_so_far += len(bat)
        # Add items from already loaded batches in the current category
        current_cat_batches = self.category_batches[self.current_category_index][1] # Get batches for current category
        for batch_index in range(self.current_batch_index - 1): # Loop through previous batches in current category
            bat = current_cat_batches[batch_index]
            if isinstance(bat, list):
                items_loaded_so_far += len(bat)
        # Add items to be loaded in this batch
        items_loaded_so_far += len(items_to_load_this_time)

        self.update_progress_bar_main(items_loaded_so_far, total_items_in_grid)

        for item in items_to_load_this_time: # Iterate over items to load in THIS batch iteration
            if item is None:
                continue
            if isinstance(item, dict) and 'configs' in item:
                for config in item['configs']:
                    self.load_image_item(config, category_subframe, category)
            else:
                if len(item) == 5:
                    picture_path, spawn_cmd, zip_file, info_data, folder_name = item
                    self.load_image_item(item, category_subframe, category)
                else:
                    continue

        self.current_main_batch_index_in_sequence += 1 # Move to next batch size in sequence

        # Schedule the next batch after a short delay (e.g., 150 milliseconds)
        if self.all_main_grid_images_cached:
            self.master.after(150, self.load_next_batch) # Load next batch immediately if all cached
            # print("load_next_batch EXIT (Scheduled next batch - all cached - after 0ms)") # ADDED
        else:
            self.master.after(150, self.load_next_batch) # Schedule the next batch after a short delay (e.g., 150 milliseconds)
            # print("load_next_batch EXIT (Scheduled next batch - not all cached - after 150ms)") # ADDED			
    
    


    #@profile 

    def load_next_batch_details(self):
        # Added print at start for easier debugging of sequence

        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- load_next_batch_details CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")



        print(f"@@@ load_next_batch_details START - Index: {self.current_details_batch_index}, Seq Index: {self.current_details_batch_index_in_sequence}, Placed: {self.total_details_items_placed}, Pause: {self.pause_loading}")

        if self.pause_loading:
            self.details_pause_counter += 1
            print(f"Load Next Batch Details - PAUSED (Details Window - Paused Flag Active) - Count: {self.details_pause_counter}")
            # Simplified pause logic slightly - adjust threshold as needed
            # NOTE: Threshold was mentioned as potentially lower than 10 earlier
            PAUSE_THRESHOLD = 2 # Or your actual lower value
            if self.details_pause_counter > PAUSE_THRESHOLD:
                print(f"DEBUG: load_next_batch_details - PAUSE COUNT EXCEEDED THRESHOLD ({PAUSE_THRESHOLD}). FORCING UNPAUSE.")
                self.pause_loading = False
                self.details_pause_counter = 0
                print("DEBUG: load_next_batch_details - pause_loading FORCE-SET to FALSE, counter RESET.")
                # Continue processing immediately instead of scheduling again
            else:
                # Reschedule the check if still paused
                self.master.after(100, self.load_next_batch_details)
                return

        # Reset pause counter if loading is not paused
        self.details_pause_counter = 0

        # --- Reset batch retry count just before attempting to process a slice ---
        # (Moved from original position for clarity - reset before each slice attempt)
        self.details_batch_retry_count = 0

        # Check if all batches for the current page have been processed
        if self.current_details_batch_index >= len(self.details_batches):
            print(f"DEBUG: load_next_batch_details - All batches for current page (Index {self.current_details_batch_index}) loaded.")
            if hasattr(self, 'details_canvas_sub') and self.details_canvas_sub and self.details_canvas_sub.winfo_exists():
                # Update scroll region one last time at the end
                try:
                    self.master.update_idletasks() # Ensure geometry is up-to-date
                    frame_bbox = self.details_scrollable_frame.bbox("all")
                    if frame_bbox:
                        self.details_canvas_sub.config(scrollregion=frame_bbox)
                        print(f"DEBUG: Final scrollregion update: {frame_bbox}")
                    else: # Fallback
                        self.details_canvas_sub.config(scrollregion=self.details_canvas_sub.bbox("all"))
                        print(f"DEBUG: Final scrollregion update (canvas fallback)")
                except Exception as e:
                    print(f"ERROR during final scrollregion update: {e}")
            self.stop_details_loading_animation()
            self.hide_progress_bar_details()


            # ---vvv ADDED BACK - Start vvv---
            # Resume main grid loading after a delay, similar to the old version's behavior.
            print("DEBUG: load_next_batch_details - Details batch load complete. Resuming main grid loading in 3 seconds...")

            def resume_main_grid_loading():
                # Check if the necessary attributes/methods exist before using them
                if hasattr(self, 'pause_loading'):
                    print("DEBUG: resume_main_grid_loading - Setting pause_loading = False")
                    self.pause_loading = False
                else:
                    print("WARN: resume_main_grid_loading - self.pause_loading attribute not found.")

                if hasattr(self, 'load_next_batch') and callable(getattr(self, 'load_next_batch')):
                    print("DEBUG: resume_main_grid_loading - Calling self.load_next_batch()")
                    self.load_next_batch()
                    print("DEBUG: resume_main_grid_loading - Main grid loading RESUMED (after 3-second delay).")
                else:
                    print("ERROR: resume_main_grid_loading - self.load_next_batch method not found or not callable.")

            # Schedule the resumption using a 3000ms (3 second) delay
            self.master.after(3000, resume_main_grid_loading)
            # ---^^^ ADDED BACK - End ^^^---



            print("DEBUG: load_next_batch_details - Details page batch load complete. Main grid resume scheduled.")
            # Maybe lift windows one last time?
            if hasattr(self, 'details_window') and self.details_window and self.details_window.winfo_exists():
                self.details_window.lift()
            return # Stop processing for this page

        # --- Get the current main batch ---
        try:
            # Check index validity before accessing
            if not (0 <= self.current_details_batch_index < len(self.details_batches)):
                print(f"ERROR: Invalid current_details_batch_index {self.current_details_batch_index} vs len {len(self.details_batches)}. Aborting.")
                self.stop_details_loading_animation()
                self.hide_progress_bar_details()
                return
            current_main_batch = self.details_batches[self.current_details_batch_index]
            # Ensure it's a list (might become None or empty if modified unexpectedly)
            if not isinstance(current_main_batch, list):
                print(f"ERROR: Batch at index {self.current_details_batch_index} is not a list ({type(current_main_batch)}). Assuming empty.")
                current_main_batch = []
                self.details_batches[self.current_details_batch_index] = current_main_batch # Correct it

        except IndexError:
            # This shouldn't happen with the check above, but added safety
            print(f"ERROR: IndexError accessing details_batches at index {self.current_details_batch_index}. Aborting batch load.")
            self.stop_details_loading_animation()
            self.hide_progress_bar_details()
            return



        batch_size_to_load = self.details_batch_size

        # --- Get the slice to process ---
        items_to_load_this_time = current_main_batch[:batch_size_to_load]
        remaining_batch_items = current_main_batch[batch_size_to_load:]

        # Update the main batch in the list with the remaining items
        self.details_batches[self.current_details_batch_index] = remaining_batch_items
        print(f"  DEBUG: Slice taken: {len(items_to_load_this_time)} items. Remaining in batch[{self.current_details_batch_index}]: {len(remaining_batch_items)}")

        # If the slice is empty, it means the current main batch was already exhausted
        # Move to the next main batch immediately
        if not items_to_load_this_time:
            print(f"  DEBUG: No items in this slice (batch {self.current_details_batch_index} likely exhausted). Moving to next batch.")
            self.current_details_batch_index += 1
            self.current_details_batch_index_in_sequence = 0 # Reset sequence for the new main batch
            self.master.after(50, self.load_next_batch_details) # Schedule next check quickly
            return

        # --- Update Progress Bar ---
        # Note: Progress calculation might need adjustment based on pagination
        # This calculates progress within the *current page* load
        items_in_current_page = sum(len(b) for b in self.details_batches if isinstance(b, list)) + self.total_details_items_placed
        items_loaded_this_page = self.total_details_items_placed + len(items_to_load_this_time)
        self.update_progress_bar_details(items_loaded_this_page, items_in_current_page) # Adjust calculation if needed
        # --- End Progress Bar ---

        # --- Check/Recalculate layout BEFORE the loop ---
        try:
            if not hasattr(self, 'details_columns') or self.details_columns is None or not isinstance(self.details_columns, tuple) or len(self.details_columns) < 1:
                print("WARN: self.details_columns is not valid before loop. Attempting recalculation.")
                # Ensure canvas exists and has a width
                if hasattr(self, 'details_canvas_sub') and self.details_canvas_sub and self.details_canvas_sub.winfo_exists() and self.details_canvas_sub.winfo_width() > 0:
                    canvas_width = self.details_canvas_sub.winfo_width() - 20 # Example margin
                    potential_cols, potential_pad = self.calculate_columns_for_width(canvas_width, is_details=True)
                    self.details_columns = (potential_cols, potential_pad)
                    self.details_column_padding = potential_pad
                    print(f"  Recalculated details_columns: {self.details_columns}, padding: {self.details_column_padding}")
                else:
                    print("ERROR: Cannot recalculate columns, canvas invalid or width=0. Using fallback.")
                    # Fallback to prevent crash - adjust as needed
                    self.details_columns = (getattr(self, 'default_columns', 4), getattr(self, 'default_padding', 5))
                    self.details_column_padding = self.details_columns[1]

            # Ensure padding exists even if columns were valid
            elif not hasattr(self, 'details_column_padding') or self.details_column_padding is None:
                print("WARN: details_column_padding was missing, setting from details_columns tuple.")
                self.details_column_padding = self.details_columns[1]

        except Exception as layout_err:
            print(f"!!!!!!!!!! HIT LAYOUT PRE-CHECK EXCEPTION !!!!!!!!!!!!!!")
            print(f"ERROR: Failed during layout pre-check/recalculation: {layout_err}. Aborting slice.")
            # Avoid infinite loop if canvas width is consistently bad
            # Maybe stop loading for this page?
            # For now, schedule next attempt but log error clearly.
            self.master.after(100, self.load_next_batch_details)
            return
        # --- END Check/Recalculate ---

        # --- Process items in the current slice ---
        for idx_in_batch, item in enumerate(items_to_load_this_time):
            if item is None:
                print(f"WARN: Skipping None item at index {idx_in_batch} in slice.")
                continue

            # Ensure item is structured as expected before unpacking
            if not isinstance(item, (list, tuple)) or len(item) != 5:
                print(f"ERROR: Skipping malformed item: {item}")
                continue

            picture_path, spawn_cmd, zip_file, info_data, folder_name = item

            # Check if the target frame exists before creating item container
            if not hasattr(self, 'details_scrollable_frame') or not self.details_scrollable_frame or not self.details_scrollable_frame.winfo_exists():
                print("ERROR: details_scrollable_frame does not exist. Aborting item processing for this slice.")
                # Stop processing this slice, maybe schedule next?
                self.master.after(100, self.load_next_batch_details)
                return

            container = tk.Frame(self.details_scrollable_frame, bg="#444444")

            try:
                # --- USE THE TOTAL COUNTER FOR GRID PLACEMENT ---
                row = self.total_details_items_placed // self.details_columns[0]
                col = self.total_details_items_placed % self.details_columns[0]
                # --- END GRID CALCULATION ---

                # Reset retry count on successful calculation (might be less needed now)
                self.details_batch_retry_count = 0

            # Keep TypeError catch as safety, though less likely with pre-check
            except TypeError as e:
                print(f"ERROR: TypeError in load_next_batch_details (grid calculation - total items): {e}. Retrying batch.")
                self.details_batch_retry_count += 1
                if self.details_batch_retry_count > getattr(self, 'MAX_DETAILS_BATCH_RETRIES', 3): # Use getattr for safety
                    print(f"ERROR: Exceeded maximum retries. Aborting.")
                    # Consider restart or just stopping the details load
                    # self.restart_script() # Optional: if critical failure requires restart
                    return # Stop loading

                # Revert batch state requires putting items back correctly
                # This logic might need careful review if retries are common
                current_batch_list = self.details_batches[self.current_details_batch_index]
                failed_batch_part = items_to_load_this_time[idx_in_batch:]
                # Prepend the failed part back to the *remaining* items for the current batch index
                self.details_batches[self.current_details_batch_index] = failed_batch_part + current_batch_list
                print(f"  Reverted batch state. Items to retry: {len(failed_batch_part)}. Rescheduling.")
                self.master.after(100, self.load_next_batch_details) # Reschedule the same batch/slice
                return # Exit current execution

            # Use validated padding (already checked/set in pre-check)
            current_padding = self.details_column_padding
            container.grid(row=row, column=col, padx=current_padding, pady=5, sticky="nw")

            # Load the actual content for the item
            self.load_image_item_details(item, container, row, col)

            # --- INCREMENT THE TOTAL COUNTER ---
            self.total_details_items_placed += 1
            # --- END INCREMENT ---

        # --- Slice Processing Complete ---

        # Update scroll region periodically after each slice is added
        if hasattr(self, 'details_canvas_sub') and self.details_canvas_sub and self.details_canvas_sub.winfo_exists():
            try:
                self.master.update_idletasks() # Allow Tkinter to update geometry
                frame_bbox = self.details_scrollable_frame.bbox("all")
                if frame_bbox:
                    self.details_canvas_sub.config(scrollregion=frame_bbox)
                    # Optional: print for debugging scroll updates
                    # print(f"DEBUG: Updated scrollregion after slice: {frame_bbox}")
            except Exception as e:
                print(f"ERROR updating scrollregion after slice: {e}")

        # --- Advance sequence index AFTER processing slice ---
        self.current_details_batch_index_in_sequence += 1

        # Check if the current main batch is now empty AFTER taking the slice
        if not self.details_batches[self.current_details_batch_index]:
            print(f"  DEBUG: Batch {self.current_details_batch_index} is now empty. Moving to next batch index.")
            self.current_details_batch_index += 1
            self.current_details_batch_index_in_sequence = 0 # Reset sequence for the new main batch

        # Schedule the next slice/batch check
        # Use getattr for safety in case details_batch_delay isn't set
        delay = getattr(self, 'details_batch_delay', 50) # Default delay 50ms
        self.master.after(delay, self.load_next_batch_details)

        # --- Lift windows ---
        if hasattr(self, 'details_window') and self.details_window and self.details_window.winfo_exists():
            self.details_window.lift()
        if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
            self.current_detail_window.lift()
        # A single delayed lift might be sufficient
        self.master.after(1500, lambda: (
            (w.lift() if hasattr(self, n) and (w := getattr(self, n)) and w.winfo_exists() else None)
            for n in ['details_window', 'current_detail_window']
        ))
        # --- End Lift windows ---

        # --- Update Sidebar for last item in the SLICE ---
        # This updates sidebar frequently, maybe only needed at end of page?
        # Check if the flag exists and is True, and if items were loaded
        if getattr(self, 'no_configs_messagebox_condition', False) and items_to_load_this_time:
            last_item = items_to_load_this_time[-1]
            # Ensure last_item is valid before unpacking
            if isinstance(last_item, (list, tuple)) and len(last_item) == 5:
                picture_path, spawn_cmd, zip_file, info_data, folder_name = last_item
                self.update_details_sidebar_content(info_data, picture_path, zip_file, folder_name)
                
                self.no_configs_messagebox_condition = False # Reset flag
                print("DEBUG:  @@@ CONDITION MET --- no_configs_messagebox_condition ---  load_next_batch_details - Updated details sidebar for LAST item in SLICE.")
            else:
                print("WARN: Could not update sidebar, last item in slice was invalid.")
        # --- End Update Sidebar ---

        print("--- load_next_batch_details() EXIT (Scheduled next) ---\n")
#        '''


    item_number = 0

############
        
        
    def load_image_item(self, item, category_subframe, category):
        # Extract item details
        if isinstance(item, dict) and 'configs' in item:
            config = item['configs'][0]  # Adjust if necessary
            picture_path, spawn_cmd, zip_file, info_data, folder_name = config
        else:
            picture_path, spawn_cmd, zip_file, info_data, folder_name = item

        # Retrieve current image count for the category
        count = self.image_counts.get(category, 0)
        row = count // self.columns[0]  # Access the first element of the tuple (number of columns)
        col = count % self.columns[0]  # Access the first element of the tuple (number of columns)

        # **CHECK IF PARENT EXISTS BEFORE CREATING CHILD**
        if not category_subframe.winfo_exists():
            print(f"Warning: Parent frame {category_subframe} no longer exists BEFORE frame creation, skipping item creation.") # DEBUG - BEFORE
            return

        # print(f"Debug: Attempting to create item_frame in {category_subframe}") # DEBUG - ATTEMPTING CREATE

        # Create the container for the image and labels
        try:
            item_frame = tk.Frame(category_subframe, bg="#444444") # Frame creation
            # print(f"Debug: item_frame created successfully: {item_frame}") # DEBUG - AFTER CREATE
        except Exception as frame_create_error:
            print(f"Error: Failed to create item_frame in {category_subframe}: {frame_create_error}") # DEBUG - CREATE ERROR
            return # Exit if frame creation failed


        item_frame.grid(row=row, column=col, padx=self.column_padding, pady=5, sticky="n") # USE DYNAMIC PADDING


        # Increment the image count for the category
        self.image_counts[category] += 1

        # Submit image loading to the executor

        ConfigViewerApp.item_number += 1





        print(f"DEBUG: load_image_item  at  item_number = {ConfigViewerApp.item_number}, picture_path = {picture_path}")
        
        self.executor.submit(
            self.load_and_display_image,
            picture_path,
            item_frame,
            zip_file,
            spawn_cmd,
            info_data,
            folder_name,
            category
        )




    def load_image_item_details(self, item, container, row, col):
        """
        Loads and displays an image item in the details window's grid layout.
        Applies dynamic padding based on the current layout configuration.
        (Modified to extract and pass folder_name, zip_file_base_name, config_name)
        (MODIFIED to use disk cache) <--- ADDED DISK CACHE COMMENT
        """

        print("\n--- load_image_item_details() DEBUG ENTRY ---") # <--- DEBUG ENTRY

        picture_path, spawn_cmd, zip_file, info_data, folder_name = item # folder_name is ALREADY unpacked here

        # Extract zip_file_base_name and config_name (as before)
        zip_file_base_name = os.path.splitext(zip_file)[0]
        config_name = self.extract_name_from_spawn_command(spawn_cmd)
        if not config_name:
            config_name = os.path.splitext(os.path.basename(picture_path))[0]

        if picture_path is None:
            picture_path = os.path.join(self.script_dir, "data/MissingCustomConfigPic.png")

        try:
            # --- Normalize picture_path ---
            normalized_picture_path = os.path.normpath(os.path.abspath(picture_path))
            cache_key = normalized_picture_path # Use normalized path as cache key

            # --- NEW: Check Disk Cache FIRST (for details images too) ---
            disk_cache_path = os.path.join(self.disk_image_cache_dir, os.path.basename(cache_key))
            if os.path.exists(disk_cache_path):
                #print(f"DEBUG: load_image_item_details - Disk Cache HIT for: {picture_path}") # Debug print - disk cache hit
                try:
                    img = Image.open(disk_cache_path).convert("RGB") # Load from disk cache
                    photo = ImageTk.PhotoImage(img)
                    pil_image = img.copy() # Create PIL copy
                    # Note: No in-memory cache update for details images in this version (as requested)
                    if container.winfo_exists():
                        self.master.after(
                            0,
                            lambda: self.create_details_item_widgets(
                                container, photo, pil_image, spawn_cmd, info_data, zip_file, picture_path, folder_name, zip_file_base_name, config_name
                            )
                        )
                    return # Exit after using disk cached image
                except Exception as e_disk_load:
                    print(f"Warning: Error loading from disk cache (details) {disk_cache_path}: {e_disk_load}. Falling back to original load.") # Fallback message

            # --- If no disk cache hit, load from original path ---
            img = Image.open(picture_path).convert("RGB")
            img = img.resize((250, 140), self.RESAMPLE_FILTER) # SUBGRID IMAGES
            pil_image = img.copy()
            photo = ImageTk.PhotoImage(pil_image)

            # --- NEW: Save to Disk Cache (for details images too) ---
            disk_cache_path = os.path.join(self.disk_image_cache_dir, os.path.basename(cache_key))
            try:
                #pil_image.save(disk_cache_path, "PNG") # Save to disk cache
                #print(f"DEBUG: Saved details image to disk cache: {disk_cache_path}") # Debug print - disk cache save
                #disabling cache
                pass
            except Exception as e_save:
                print(f"Warning: Error saving details image to disk cache {disk_cache_path}: {e_save}") # Warning message on save error
            # --- NEW: Save to Disk Cache (for details images too) ---


            # --- NEW: Check pause_loading and queue Details UI update if paused ---
            if self.pause_loading:
                print(f"Queueing Details UI update for {os.path.basename(picture_path)} - Loading PAUSED (Details)") # Debug Print
                self.details_grid_skipped_updates_queue.append((container, photo, pil_image, spawn_cmd, info_data, zip_file, picture_path, folder_name, zip_file_base_name, config_name)) # Queue update args - ADDED folder_name, zip_file_base_name, config_name
                return  # EXIT and don't schedule Details UI update NOW
            # --- END: Pause Check and Queue ---

            if container.winfo_exists():
                # Schedule GUI update in the main thread
                self.master.after(
                    0,
                    lambda: self.create_details_item_widgets(
                        container, photo, pil_image, spawn_cmd, info_data, zip_file, picture_path, folder_name, zip_file_base_name, config_name # Pass folder_name, zip_file_base_name, config_name
                    )
                )

            print("--- load_image_item_details() DEBUG EXIT ---\n") # <--- DEBUG EXIT


        except Exception as e:
            print(f"Error loading subgrid image {picture_path}: {e}")



########################
    def debounced_main_sidebar_info_update(self, info_data, picture_path, zip_file, folder_name, item, hovered_category=None):
        """
        Debounced function to update the main sidebar content.
        """
        self.show_main_sidebar_info(info_data, picture_path, zip_file, folder_name, item, individual_path=None, main_info_for_details=None, hovered_category=hovered_category)
        #self.lift_search_results_window()
        self.main_grid_sidebar_debounce_timer = None # Reset timer

    def update_label_highlighting(self):
        """
        Updates the highlight color of labels in the main grid based on the search query.
        This function ONLY changes the label colors and does NOT filter the data.
        """
        search_query = self.search_var.get().strip().lower()

        for category_name, category_items in self.grouped_data.items():
            for item in category_items:
                if isinstance(item, dict) and 'configs' in item:
                    configs = item['configs']
                elif isinstance(item, tuple) and len(item) == 5:
                    configs = [item] # Treat single item as a list for consistent processing
                else:
                    continue # Skip if item structure is not as expected

                for config_item in configs: # Iterate through configs (or single item as list)
                    # --- Extract widgets from stored item_data_tuple ---
                    item_data_tuple = None
                    if isinstance(config_item, tuple) and len(config_item) == 5:
                        picture_path, spawn_cmd, zip_file, info_data, folder_name = config_item
                        # Find the corresponding item_frame using picture_path (or another unique identifier if needed)
                        # This part needs to be adapted to correctly find the Frame containing the label you want to highlight.
                        # A more robust method might be needed to track item_frames and their associated data.
                        # For now, let's assume you can iterate through all item frames and check their data.
                        item_frames = self.scrollable_frame.winfo_children() # Get all children of scrollable_frame (category frames)
                        for cat_frame in item_frames:
                            for item_frame in cat_frame.winfo_children(): # Iterate through item frames in each category frame
                                if hasattr(item_frame, 'item_data_tuple') and item_frame.item_data_tuple:
                                    if item_frame.item_data_tuple[2] == picture_path: # Compare picture paths as a basic identifier
                                        item_data_tuple = item_frame.item_data_tuple # Found the matching item frame
                                        break # Stop searching within item frames of this category once found
                            if item_data_tuple:
                                break # Stop searching in categories once item frame is found
                    elif isinstance(item, dict) and 'configs' in item: # Handle dict-based items if needed
                        continue # Placeholder - adapt logic if needed for dict-based items
                    else:
                        continue # Skip if item structure is unexpected

                    if item_data_tuple:
                        pil_image, info_data, item_picture_path, zip_file_item, folder_name_item, spawn_cmd_item, lbl_img, lbl_info = item_data_tuple # Unpack tuple

                        combined_text = lbl_info.cget("text").lower() # Get label text from the widget

                        if search_query and search_query in combined_text:
                            lbl_info.config(fg="#FF0000") # Highlight in red if matches
                        else:
                            # Restore default text color (you might need to store the original color when creating labels)
                            # For now, let's assume default is 'white' or text_color variable used in create_main_item_widgets
                            lbl_info.config(fg=self.get_label_default_color(item_picture_path)) # Restore default color using helper function
                    else:
                        print(f"Warning: Could not find item_data_tuple for picture_path: {picture_path} during highlighting.") # Debug - Item Data Tuple Not Found
            






    def get_label_default_color(self, picture_path):
        """Helper function to determine the default text color based on picture_path."""
        if "user--" in picture_path:
            return "#ADD8E6"
        elif "user--" not in picture_path:
            found_double_basename = False
            for base_name in self.ZIP_BASE_NAMES:
                if picture_path.count(f"--{base_name}_{base_name}.zip") > 0:
                    found_double_basename = True
                    break
            if found_double_basename:
                return "#f7efd7"
            else:
                return "#FFFFFF"
        return "#FFFFFF" # Default fallback color




    def actual_label_highlighting(self):
        """
        Updates the highlight color of labels AND image backgrounds in the main grid based on the search query.
        This function ONLY changes the label colors and image backgrounds and does NOT filter the data.
        """
        search_query = self.search_var.get().strip().lower()

        for category_name, category_items in self.grouped_data.items():
            for item in category_items:
                if isinstance(item, dict) and 'configs' in item:
                    configs = item['configs']
                elif isinstance(item, tuple) and len(item) == 5:
                    configs = [item] # Treat single item as a list for consistent processing
                else:
                    continue # Skip if item structure is not as expected

                for config_item in configs: # Iterate through configs (or single item as list)
                    # --- Extract widgets from stored item_data_tuple ---
                    item_data_tuple = None
                    if isinstance(config_item, tuple) and len(config_item) == 5:
                        picture_path, spawn_cmd, zip_file, info_data, folder_name = config_item
                        # Find the corresponding item_frame using picture_path (or another unique identifier if needed)
                        # This part needs to be adapted to correctly find the Frame containing the label you want to highlight.
                        # For now, let's assume you can iterate through all item frames and check their data.
                        item_frames = self.scrollable_frame.winfo_children() # Get all children of scrollable_frame (category frames)
                        for cat_frame in item_frames:
                            for item_frame in cat_frame.winfo_children(): # Iterate through item frames in each category frame
                                # --- ADDED: Check for hasattr BEFORE accessing item_data_tuple ---
                                if hasattr(item_frame, 'item_data_tuple') and item_frame.item_data_tuple: # <--- ADDED HASATTR CHECK
                                    if item_frame.item_data_tuple[2] == picture_path: # Compare picture paths as a basic identifier
                                        item_data_tuple = item_frame.item_data_tuple # Found the matching item frame
                                        break # Stop searching within item frames of this category once found
                                # --- ADDED: Check for hasattr BEFORE accessing item_data_tuple ---
                            if item_data_tuple:
                                break # Stop searching in categories once item frame is found
                    elif isinstance(item, dict) and 'configs' in item: # Handle dict-based items if needed
                        # ... (Adapt logic if your item structure is different) ...
                        continue # Placeholder - adapt logic if needed for dict-based items
                    else:
                        continue # Skip if item structure is unexpected

                    if item_data_tuple:
                        pil_image, info_data, item_picture_path, zip_file_item, folder_name_item, spawn_cmd_item, lbl_img, lbl_info = item_data_tuple # Unpack tuple

                        combined_text = lbl_info.cget("text").lower() # Get label text from the widget

                        if search_query and search_query in combined_text:
                            lbl_info.config(fg="yellow") # Highlight label text in red
                            lbl_img.config(bg="yellow") # <--- NEW: Highlight image background in red
                        else:
                            # Restore default colors
                            lbl_info.config(fg=self.get_label_default_color(item_picture_path)) # Restore default label text color
                            lbl_img.config(bg=lbl_img.default_bg_color) # <--- NEW: Restore default image background color
                    else:
                        print(f"Warning: Could not find item_data_tuple for picture_path: {picture_path} during highlighting.") # Debug - Item Data Tuple Not Found
        self.debounce_timer = None # Reset timer after execution







    def show_main_sidebar_info(self, info_data, picture_path, zip_file, folder_name, item, individual_path=None, main_info_for_details=None, hovered_category=None):
        """Shows sidebar info labels and updates content."""
        # --- NEW: Check if scrolling - if yes, early exit (disable sidebar update during scroll) ---
        if self.is_scrolling_main_grid:
            return # EXIT if scrolling
        # --- NEW: Check if scrolling - if yes, early exit (disable sidebar update during scroll) ---

        self.update_sidebar_content(info_data, picture_path, zip_file, folder_name, hovered_category=hovered_category)
        self.current_main_sidebar_item = item # Store the current item
        
        # --- 2. ALSO Update the DETAILS sidebar ---
        # Check if the details sidebar actually exists before trying to update it
        if hasattr(self, 'details_sidebar_text_canvas') and self.details_sidebar_text_canvas.winfo_exists():
            print(f"DEBUG show_main_sidebar_info: Triggering details sidebar update with path={individual_path}")
            # Call the function responsible for the details sidebar update
            self.update_details_sidebar_individual_info(individual_path, main_info_for_details)
        #else:
            #print("DEBUG show_main_sidebar_info: Details sidebar not found or doesn't exist, skipping update.")


    def show_zip_name_top_bar(self, zip_file, folder_name):
        """Displays the zip or folder name in the top bar."""
        if zip_file == "user_custom_configs":
            text_to_display = f"Custom Configs for {folder_name})"
        else:
            text_to_display = f"({zip_file})"
        self.custom_config_label.config(text=text_to_display)

    def clear_zip_name_top_bar(self):
        """Clears the zip or folder name in the top bar."""
        self.custom_config_label.config(text="")


    # ------------------------------------------------------------
    # On Right-Click -> hide
    # ------------------------------------------------------------

    def _store_initial_minsize(self):
        """Stores the initial minsize when the window is idle."""
        try:
            self._original_minsize = self.master.minsize()
        except tk.TclError:
             # Window might not be ready yet, store default
             self._original_minsize = (1, 1)
        print(f"Stored initial minsize: {self._original_minsize}") # Debug




    def on_image_right_click(self, zip_file, folder_name, spawn_cmd, picture_path, info_data, lbl_img, lbl_info, clicked_from_category=None):


        if clicked_from_category == "Favorites":
            scanning_win = self.show_scanning_window(text="Cannot hide vehicles from this category.\nYou may hide the vehicles here from one of the other categories below\n or hide the pinned favorites category from the settings menu.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(4125, close_scanning_window)
            return



        if self.search_results_window:
            scanning_win = self.show_scanning_window(text="Cannot hide vehicles while search or filtering is active.")
            self.lift_search_results_window()
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return


        image_name = os.path.basename(picture_path) # representativeimage.jpg
        brand_name = info_data.get("Brand", "Unknown") # brand_name
        car_name = info_data.get("Name", "") # brand_name
        self.toggle_hidden_item(folder_name, zip_file, image_name, brand_name, car_name, lbl_img, lbl_info)


        # 1. Determine if the size should be locked
        should_be_locked = len(self.hidden_items_set) > 0 # Lock if set is NOT empty

        # 2. Get current lock state (based on our flag)
        is_currently_locked = self._is_size_locked_by_us

        # 3. Apply changes only if the state needs to change
        if should_be_locked and not is_currently_locked:
            # --- Lock the size ---
            try:
                # Get the current size of the window
                current_width = self.master.winfo_width()
                current_height = self.master.winfo_height()

                # Ensure dimensions are valid (winfo can return 1 initially)
                if current_width > 1 and current_height > 1:
                    # Store the *current* minsize before overriding it, just in case
                    # (self._original_minsize holds the initial default)
                    # current_min_w, current_min_h = self.master.minsize() # Optional to store this

                    # Set min and max size to the current size
                    self.master.minsize(current_width, current_height)
                    self.master.maxsize(current_width, current_height)
                    self._is_size_locked_by_us = True
                    # print(f"Locked size to {current_width}x{current_height}") # Debug
                else:
                    # This might happen if the window isn't fully drawn/realized yet.
                    # Consider delaying or logging a warning.
                    print("Warning: Could not get valid window dimensions to lock size.")

            except tk.TclError as e:
                print(f"Warning: Error getting window info or setting size limits: {e}")


        elif not should_be_locked and is_currently_locked:
            # --- Unlock the size ---
            try:
                # Restore the original minimum size
                self.master.minsize(self._original_minsize[0], self._original_minsize[1])

                # Remove the maximum size constraint by setting it to screen dimensions
                screen_width = self.master.winfo_screenwidth()
                screen_height = self.master.winfo_screenheight()
                self.master.maxsize(screen_width, screen_height)
                self._is_size_locked_by_us = False
                # print(f"Unlocked size. Restored min: {self._original_minsize}, Max: screen") # Debug

            except tk.TclError as e:
                 print(f"Warning: Error resetting window size limits: {e}")
        else:
             print("Size lock state already correct.") # Debug

    

    def _get_hidden_file_path(self):
        return os.path.join(self.script_dir, "data", "Hidden.txt")

    def _read_hidden_lines(self):
        hidden_file_path = self._get_hidden_file_path()
        if os.path.exists(hidden_file_path):
            with open(hidden_file_path, 'r', encoding="utf-8") as f:
                return [line.strip() for line in f]
        return []

    def _write_hidden_lines(self, lines):
        hidden_file_path = self._get_hidden_file_path()
        with open(hidden_file_path, 'w', encoding="utf-8") as f:
            for line in lines:
                f.write(line + '\n')

    def toggle_hidden_item(self, folder_name, zip_file, image_name, brand_name, car_name, lbl_img, lbl_txt):



        #self.hide_sidebar_info() 
        lower_folder_name = folder_name.lower()
        hidden_line = f"{lower_folder_name}|||{image_name}|||{brand_name}|||{car_name}|||{zip_file}"
        hidden_lines = self._read_hidden_lines()

        if hidden_line in hidden_lines:
            hidden_lines.remove(hidden_line)
            self._write_hidden_lines(hidden_lines)
            # Restore original colors and text
            lbl_img.config(highlightbackground=lbl_img.default_bg_color, highlightthickness=0, bg="#FFFFFF")
            lbl_txt.config(fg=lbl_txt.default_fg_color)

            # --- REMOVE "Hiding on Restart" text ---
            original_text = lbl_txt.cget("text")
            if "\nHiding on Restart" in original_text:
                # Remove the last line if it is "Hiding on Restart"
                updated_text = original_text.replace("\nHiding on Restart", "")
                lbl_txt.config(text=updated_text)
                lbl_txt.config(bg="#444444", text=updated_text) # Update text and color
            # --- REMOVE "Hiding on Restart" text ---

            self.hidden_items_set.discard(lower_folder_name)  # REMOVE from set when un-hiding

        else:
            hidden_lines.append(hidden_line)
            self._write_hidden_lines(hidden_lines)
            # Set red border and text, append "Hiding on Restart"
            lbl_img.config(highlightbackground="red", highlightthickness=0, bg="red")
            # Get current text and append "Hiding on Restart" on a new line
            current_text = lbl_txt.cget("text")
            updated_text = f"{current_text}\nHiding on Restart"
            lbl_txt.config(fg="#ff4747", bg="#444444", text=updated_text) # Update text and color

            self.hidden_items_set.add(lower_folder_name)  # ADD to set when hiding

        self.check_change_set_to_hidden()


######################

    def hex_to_rgb(self, hex_color):
        """Converts a hex color code to an RGB tuple (0-255)."""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))

    def rgb_to_hex(self, rgb_color):
        """Converts an RGB tuple to a hex color code."""
        return '#{:02x}{:02x}{:02x}'.format(*rgb_color)

    def _start_fade_loop(self, widget, color1_hex, color2_hex, steps=50, delay_ms=20):
        """
        Starts a looping fade animation between two colors.

        Args:
            widget: The Tkinter widget to fade the foreground color of.
            color1_hex: The first hex color code.
            color2_hex: The second hex color code.
            steps: Number of fading steps per direction.
            delay_ms: Delay in milliseconds between each step.
        """
        if hasattr(self, 'hidden_window_restart_button'): 
            if widget == self.hidden_window_restart_button:
                if self._hidden_window_fade_animation_running_restart: # Check if already running
                    return # Do not restart if already running
                self._hidden_window_fade_animation_running_restart = True

        if widget == self.sidebar_filters_label:
            if self._fade_animation_running_sidebar: # Check if already running
                return # Do not restart if already running
            self._fade_animation_running_sidebar = True

        elif widget == self.restart_button:
            if self._fade_animation_running_restart: # Check if already running
                return # Do not restart if already running
            self._fade_animation_running_restart = True

        color1_rgb = self.hex_to_rgb(color1_hex)
        color2_rgb = self.hex_to_rgb(color2_hex)
        current_step = 0
        direction = 1

        def _fade_step():
            nonlocal current_step, direction

            if widget == self.sidebar_filters_label and not self._fade_animation_running_sidebar:
                return
            if widget == self.restart_button and not self._fade_animation_running_restart:
                return
            
            if hasattr(self, 'hidden_window_restart_button'): 
                if widget == self.hidden_window_restart_button and not self._hidden_window_fade_animation_running_restart:
                    return


            r = int(color1_rgb[0] + (color2_rgb[0] - color1_rgb[0]) * abs(current_step) / steps)
            g = int(color1_rgb[1] + (color2_rgb[1] - color1_rgb[1]) * abs(current_step) / steps)
            b = int(color1_rgb[2] + (color2_rgb[2] - color1_rgb[2]) * abs(current_step) / steps)
            current_color_hex = self.rgb_to_hex((r, g, b))
            widget.config(fg=current_color_hex)

            current_step += direction

            if current_step > steps:
                direction = -1
                current_step = steps
            elif current_step < -steps:
                direction = 1
                current_step = -steps

            widget.after(delay_ms, _fade_step)

        _fade_step()


    def _stop_fade_loop(self, widget, target_color_hex):
        """
        Stops the looping fade animation and sets the widget to a target color (no fade).

        Args:
            widget: The Tkinter widget to stop fading.
            target_color_hex: The hex color to set when stopping.
        """
        if widget == self.sidebar_filters_label:
            self._fade_animation_running_sidebar = False

        elif widget == self.restart_button:
            self._fade_animation_running_restart = False


        if hasattr(self, 'hidden_window_restart_button'): 
            if widget == self.hidden_window_restart_button:
                self._hidden_window_fade_animation_running_restart = False
            

        widget.config(fg=target_color_hex) # Immediately set to the target color


    def check_change_set_to_hidden(self):
        """
        Checks if there are any items marked for hiding using the hidden_items_set.
        (SET-BASED CHECK - VERY FAST)
        Now with looping color fading!
        """
        print("\n--- check_change_set_to_hidden() DEBUG ENTRY (SET-BASED CHECK) - STARTING CHECK ---")

        self.items_to_be_hidden = bool(self.hidden_items_set)

        print(f"DEBUG: check_change_set_to_hidden - Checking self.hidden_items_set (size: {len(self.hidden_items_set)})")

        print("--- check_change_set_to_hidden() DEBUG EXIT (SET-BASED CHECK) ---\n")

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")
            self.sidebar_filters_label.config(text=f"Vehicles Set to be Hidden: {len(self.hidden_items_set)} \n\nFiltering, searching and resizing features disabled in this mode. Restart the application to hide the vehicles or unmark them for hiding to re-enable the features.", font=("Segoe UI", 11+self.font_size_add, "bold"))
            self._start_fade_loop(self.sidebar_filters_label, self.warning_color_sidebar, self.default_sidebar_color) # Loop fade sidebar between warning and white
            self._start_fade_loop(self.restart_button, self.warning_color_restart_button, self.default_restart_color)  # Loop fade restart button between warning and white
            self.restart_button_active_fg_color = "#ffa1a1"

        if not self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = False ---\n")
            self.sidebar_filters_label.config(fg=self.default_sidebar_color, text="Constraints", font=("Segoe UI", 14+self.font_size_add, "bold"))
            self._stop_fade_loop(self.sidebar_filters_label, self.default_sidebar_color) # Stop fade and set to default color
            self._stop_fade_loop(self.restart_button, self.default_restart_color) # Stop fade and set to default color
            self.restart_button_active_fg_color = "#FFFFFF" # Reset to default white for active state



############################


    def show_hidden_vehicles_window(self):

        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists():
            self.filters_window.destroy()

        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
            self.spawn_queue_window.destroy()

        if self.hidden_window is None or not tk.Toplevel.winfo_exists(self.hidden_window): # Check if window exists or is destroyed

            self.hidden_window = tk.Toplevel(self.master) # Create Toplevel window if it doesn't exist
            self.hidden_window.title("Hidden Vehicles")
            self.hidden_window.resizable(False, True)
            self.hidden_window.tk.call('tk', 'scaling', 1.25) # Apply scaling factor for hidden window
            self.create_widgets_hidden_window(self.hidden_window) # Pass the toplevel window to create_widgets
            self.hidden_window.protocol("WM_DELETE_WINDOW", self.on_hidden_window_close) # Handle window close event
            self.center_window(self.hidden_window)
        else:
            self.hidden_window.deiconify()

            self.hidden_window.lift() # Bring window to front if it already exists
            self.center_window(self.hidden_window)

        icon_path = self.script_dir / "data/icon.png"

        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            self.hidden_window.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")


        # Modified line: Passing self.hidden_window_canvas
        self.hidden_window.bind("<MouseWheel>", lambda event: self.on_mousewheel_hidden(event, self.hidden_window_canvas))


    def on_hidden_window_close(self):

        self.hidden_window.withdraw() # Hide the window instead of destroying
        self.check_and_show_scanning_window_after_closing_hidden_window()



######### old line removal



    def load_hidden_vehicles_once(self): # Load data only once at startup

        custom_input_file = os.path.join(self.script_dir, "data/outputGOODcustom.txt")
        input_file = os.path.join(self.script_dir, "data/outputGOOD.txt")
        hidden_txt_file = os.path.join(self.script_dir, "data/Hidden.txt")



        backup_custom_input_file = os.path.join(self.script_dir, "data/backup/outputGOODcustom.txt")
        backup_input_file = os.path.join(self.script_dir, "data/backup/outputGOOD.txt")


        if os.path.exists(backup_input_file):

            print(f"backup input files exist (load_hidden_vehicles_once)")

            custom_input_file = backup_custom_input_file
            input_file = backup_input_file



        print(f"Attempting to open custom input file: {custom_input_file}")
        print(f"Attempting to open regular input file: {input_file}")
        print(f"Attempting to open hidden file: {hidden_txt_file}")

        vehicles = []
        self.original_hidden_lines = [] # Keep original lines for potential future use, though not used in the file writing logic now
        valid_hidden_lines = [] # This will store the lines to be kept and rewritten to the file

        custom_input_folders = set()
        input_folders = set()

        print("\n--- Processing Custom Input File: outputGOODcustom.txt ---")

        try:
            with open(custom_input_file, 'r', encoding='utf-8') as f:
                print(f"Successfully opened: {custom_input_file}")
                for line_number, line in enumerate(f, 1):
                    line = line.strip()
                    # print(f"  Line {line_number}: '{line}'") # Comment out this line to omit printing each line read from custom input
                    if "vehicles/" in line and "/" in line[line.find("vehicles/") + len("vehicles/"):]:
                        start_index = line.find("vehicles/") + len("vehicles/")
                        end_index = line.find("/", start_index)
                        if end_index != -1:
                            folder_name = line[start_index:end_index]
                            folder_name_lower = folder_name.lower()  # Convert to lowercase
                            custom_input_folders.add(folder_name_lower) # Add the lowercase version to the set
                            #print(f"    Detected folder: '{folder_name}' (lowercase: '{folder_name_lower}')") # Print both original and lowercase for clarity (optional)
                        else:
                            #print(f"    'vehicles/' found but no subsequent '/', skipping folder detection on this line.")
                            pass
                    else:
                        #print(f"    'vehicles/' pattern not found, skipping folder detection on this line.")
                        pass
        except FileNotFoundError:
            print(f"Warning: {custom_input_file} not found. Skipping custom input folder detection.")
        except Exception as e:
            print(f"Error reading {custom_input_file}: {e}")


        '''
        print("\n--- Folders Detected in Custom Input File ---")
        if custom_input_folders:
            for folder in custom_input_folders:
                print(f"  {folder}")
        else:
            print("  No folders detected in custom input file.")
        '''

        print("\n--- Processing Regular Input File: outputGOOD.txt ---")

        try:
            with open(input_file, 'r', encoding='utf-8') as f:
                print(f"Successfully opened: {input_file}")
                for line_number, line in enumerate(f, 1):
                    line = line.strip()
                    #print(f"  Line {line_number}: '{line}'") # Keep line printing for now for detailed debug
                    if "vehicles/" in line:
                        #print(f"    "vehicles/" FOUND in line!") # Debug: /vehicles/ found
                        if "/" in line[line.find("vehicles/") + len("vehicles/"):]:
                            #print(f"      Subsequent '/' FOUND after 'vehicles/'!") # Debug: Subsequent / found
                            start_index = line.find("vehicles/") + len("vehicles/")
                            end_index = line.find("/", start_index)
                            if end_index != -1:
                                folder_name = line[start_index:end_index]
                                folder_name_lower = folder_name.lower()  # Convert to lowercase
                                input_folders.add(folder_name_lower) # Add the lowercase version to the set
                                #print(f"    Detected folder: '{folder_name}' (lowercase: '{folder_name_lower}')") # Print both original and lowercase for clarity (optional)
                                #print(f"        Debug: start_index={start_index}, end_index={end_index}, folder_name='{folder_name}'") # Debug: Indices and folder
                            else:
                                #print(f"      '/vehicles/' found but no subsequent '/' (end_index == -1), skipping folder detection on this line.")
                                pass
                        else:
                            #print(f"      '/vehicles/' found but NO subsequent '/', skipping folder detection on this line.")
                            pass
                    else:
                        #print(f"    '/vehicles/' pattern NOT found, skipping folder detection on this line.")
                        pass
        except FileNotFoundError:
            print(f"Warning: {input_file} not found. Skipping regular input folder detection.")
        except Exception as e:
            print(f"Error reading {input_file}: {e}")

        print("\n--- Folders Detected in Regular Input File ---")

        '''
        if input_folders:
            for folder in input_folders:
                print(f"  {folder}")
        else:
            print("  No folders detected in regular input file.")'
        '''

        print("\n--- Processing Hidden.txt and Validating Folders ---")

        try:
            print(f"Attempting to open hidden file: {hidden_txt_file}")
            with open(hidden_txt_file, 'r', encoding='utf-8') as f_hidden:
                print(f"Successfully opened: {hidden_txt_file}")
                hidden_lines_to_write = [] # Initialize a list to store lines to write back to Hidden.txt
                for line_number, line in enumerate(f_hidden, 1):
                    line = line.strip()
                    if line:
                        parts = line.split('|||')
                        if len(parts) == 5:
                            folder_to_check = parts[0]
                            print(f"Hidden.txt Line {line_number}: Checking folder: '{folder_to_check}'")
                            if folder_to_check in custom_input_folders or folder_to_check in input_folders:
                                vehicle_info = {
                                    'original_line': line,
                                    'folder': parts[0],
                                    'image_path': parts[1],
                                    'brand': parts[2],
                                    'name': parts[3],
                                    'zip_file': parts[4]
                                }
                                vehicles.append(vehicle_info)
                                self.original_hidden_lines.append(line)
                                valid_hidden_lines.append(line) # Add to valid lines list
                                hidden_lines_to_write.append(line + '\n') # Prepare line for writing back, with newline
                                print(f"  Folder '{folder_to_check}' found in input files. Line kept.")
                            else:
                                print(f"  Folder '{folder_to_check}' NOT found in input files. Line {line_number} removed.")
                                # Line is not added to hidden_lines_to_write, effectively removing it
                        else:
                            #print(f"Warning: Line {line_number} in Hidden.txt has incorrect number of parts (expecting 5, found {len(parts)}). Line content: '{line}'")
                            hidden_lines_to_write.append(line + '\n') # Keep lines with incorrect format for manual review, or remove this if you want to delete them too
                    elif line == "":
                        #print(f"Warning: Line {line_number} in Hidden.txt is empty.")
                        hidden_lines_to_write.append('\n') # Keep empty lines as well, or remove this if you want to delete them

            # Write back only the valid lines to Hidden.txt
            with open(hidden_txt_file, 'w', encoding='utf-8') as f_hidden_write:
                f_hidden_write.writelines(hidden_lines_to_write) # Write all lines in list at once

            print(f"\nSuccessfully loaded {len(vehicles)} vehicles from {hidden_txt_file}")
            print(f"Hidden.txt file updated to remove invalid entries.") # Inform user about the file update

        except FileNotFoundError:
            print(f"Error: {hidden_txt_file} not found...")
        except Exception as e:
            print(f"Error loading Hidden.txt: {e}")

        vehicles.sort(key=lambda vehicle: vehicle['brand'].lower())


        return vehicles
########

    def reload_hidden_lines(self): # Function to reload just the hidden lines list
        self.original_hidden_lines = []
        try:
            with open(self.hidden_txt_file, 'r', encoding='utf-8') as f: # UTF-8 encoding
                for line in f:
                    line = line.strip()
                    if line:
                        self.original_hidden_lines.append(line)
        except FileNotFoundError:
            print(f"Warning: {self.hidden_txt_file} not found while reloading hidden lines.")
        except Exception as e:
            print(f"Error reloading hidden lines: {e}")


    def create_widgets_hidden_window(self, toplevel):
        toplevel.configure(bg="#333333") # Set toplevel window background color

        main_label = tk.Label(toplevel, text="Hidden Vehicles", font=font.Font(family="Segoe UI", size=13+self.font_size_add, weight='bold'), background="#333333", foreground="#FFFFFF") # tk.Label, white text
        main_label.pack(pady=(10,2))

        main_label_2 = tk.Label(toplevel, text="Right click vehicle previews on the main view to add them to them to this list.", font=font.Font(family="Segoe UI", size=10+self.font_size_add), background="#333333", foreground="#FFFFFF") # tk.Label, white text
        main_label_2.pack(pady=(2,2))

        main_label_2.config(wraplength=355) # Set wrap length for the label
        # Search Bar
        self.hidden_window_search_var = tk.StringVar()
        self.hidden_window_search_entry = search_entry = tk.Entry(toplevel, textvariable=self.hidden_window_search_var, font=("Segoe UI", 12+self.font_size_add), width=30, bg="#d9d9d9", fg="black", insertbackground="black", relief=tk.FLAT, bd=2, highlightthickness=0)
        self.hidden_window_search_entry.pack(pady=5, fill='x', padx=10)
        self.hidden_window_search_entry.bind("<KeyRelease>", self._handle_hidden_search_key_release)
        self.hidden_window_search_entry.bind("<FocusIn>", self.on_search_focus_in)  # Bind FocusIn event
        self.hidden_window_search_entry.bind("<FocusOut>", self.on_search_focus_out) # Bind FocusOut event


        self.placeholder_text = "Search for hidden vehicles here...‎" # Placeholder - there's blank characters at the end
        self.set_search_placeholder() # Set placeholder initially

        # Content Frame - NEW FRAME TO HOLD CANVAS AND SCROLLBAR
        content_frame = tk.Frame(toplevel, bg="#333333", padx=10, pady=10, relief=tk.FLAT, bd=0, highlightthickness=0) # tk.Frame, flat style
        content_frame.pack(side="top", fill="both", expand=True) # Pack content_frame first

        # Modified line: Renamed self.canvas to self.hidden_window_canvas
        self.hidden_window_canvas = tk.Canvas(content_frame, bg="#444444", highlightbackground="#333333", relief=tk.FLAT, bd=0, highlightthickness=0) # changing bg color to #444444
        # self.hidden_window_scrollbar = tk.Scrollbar(content_frame, orient="vertical", command=self.canvas.yview, relief=tk.FLAT, bd=0, highlightthickness=0) # tk.Scrollbar, flat style - REMOVE STANDARD SCROLLBAR

        self.hidden_window_custom_scrollbar_canvas_hidden = tk.Canvas(content_frame, bg="#555555", width=15, highlightthickness=0, cursor="arrow") # Custom scrollbar canvas - dark grey bg
        self.hidden_window_custom_scrollbar_canvas_hidden.pack(side="right", fill="y") # Pack custom scrollbar canvas

        self.hidden_window_scrollbar_thumb_hidden = self.hidden_window_custom_scrollbar_canvas_hidden.create_rectangle(0, 0, 15, 20, fill=self.global_highlight_color, outline="") # Orange thumb, no outline

        self.hidden_window_custom_scrollbar_canvas_hidden.bind("<ButtonPress-1>", self.custom_hidden_scrollbar_click)
        self.hidden_window_custom_scrollbar_canvas_hidden.bind("<B1-Motion>", self.custom_hidden_scrollbar_drag)
        self.hidden_window_custom_scrollbar_canvas_hidden.bind("<ButtonRelease-1>", self.custom_hidden_scrollbar_release)


        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_scrollable_frame = tk.Frame(self.hidden_window_canvas, bg="#444444", relief=tk.FLAT, bd=0, highlightthickness=0) # tk.Frame, flat style

        self.hidden_window_scrollable_frame.bind(
            "<Configure>",
            lambda e: self.hidden_window_canvas.configure( # Modified line: Using self.hidden_window_canvas
                scrollregion=self.hidden_window_canvas.bbox("all") # Modified line: Using self.hidden_window_canvas
            )
        )

        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_canvas.create_window((0, 0), window=self.hidden_window_scrollable_frame, anchor="nw")
        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_canvas.configure(yscrollcommand=self.custom_hidden_scrollbar_set, background="#444444", highlightbackground="#333333") # changing bg color to #444444, use custom scrollbar set command
        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_canvas.bind("<MouseWheel>", lambda event: self.on_mousewheel_hidden(event, self.hidden_window_canvas)) # Bind mousewheel event

        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_canvas.pack(side="left", fill="both", expand=True) # Pack canvas in content_frame

        self.update_vehicle_display(self.hidden_vehicles_data) # Initial display

        # --- Define Colors & Styles ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF" # Hover text color
        active_bg = "#666666" # Define a standard active color (adjust if needed)
        active_fg = "#FFFFFF"  # Define a standard active foreground

        # --- Create Restart Button ---
        hidden_window_restart_button = tk.Button(
            toplevel,
            text="Restart",
            command=self.restart_script_and_save_settings, # Ensure this method exists
            background=original_bg,       # Use defined color
            foreground=original_fg,       # Use defined color
            activebackground=active_bg,   # Add active state colors
            activeforeground=active_fg,   # Add active state colors
            relief=tk.FLAT,
            bd=0,
            highlightthickness=0,         # Good for flat style
            font=font.Font(family="Segoe UI", size=12 + self.font_size_add),
            pady=2
        )
        hidden_window_restart_button.pack(side='bottom', fill='x', padx=10, pady=10) # Pack

        # Store reference (as in original code)
        self.hidden_window_restart_button = hidden_window_restart_button # Keep instance attribute if used elsewhere


        self._bind_animated_hover(
            button=hidden_window_restart_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False # Assuming this restart button is always enabled
        )


        toplevel.update_idletasks() # Ensure widgets are fully created and laid out *after* vehicle items are created
        widest_widget_width = max(self.hidden_window_scrollable_frame.winfo_reqwidth() + self.hidden_window_custom_scrollbar_canvas_hidden.winfo_reqwidth(), hidden_window_restart_button.winfo_reqwidth()) # Use scrollable_frame width + custom scrollbar width
        extra_width_pixels = 50  # You can adjust this value as needed
        min_window_width = 395  # Set your minimum window width here
        final_window_width = max(widest_widget_width + extra_width_pixels, min_window_width) # Choose the larger of the two, AFTER adding extra pixels

        toplevel.geometry(f"{final_window_width}x500") # Set window width based on final calculated width
        self.custom_hidden_scrollbar_set(0, 1) # Initial call to set scrollbar thumb correctly


        
    def _handle_hidden_search_key_release(self, event):
        """Handles KeyRelease events for the search entry, ignoring Escape."""
        # print(f"Key released: {event.keysym}") # Optional: for debugging
        if event.keysym != 'Escape':
            self.debounce_search()



    def set_search_placeholder(self):
        if not self.hidden_window_search_var.get(): # If search entry is empty
            self.hidden_window_search_entry.insert(0, self.placeholder_text)
            self.hidden_window_search_entry.config(fg="grey") # Grey color for placeholder
        else:
            self.hidden_window_search_entry.config(fg="black") # Ensure text is black if not placeholder

    def on_search_focus_in(self, event):
        if self.hidden_window_search_entry.cget('fg') == 'grey' and self.hidden_window_search_var.get() == self.placeholder_text:
            self.hidden_window_search_var.set("") # Clear the placeholder text
            self.hidden_window_search_entry.config(fg="black") # Set text color to black for input

    def on_search_focus_out(self, event):
        if not self.hidden_window_search_var.get(): # If search entry is empty after focus out
            self.set_search_placeholder() # Set placeholder again
        else:
             self.hidden_window_search_entry.config(fg="black") # Ensure text is black if user typed something



    def update_vehicle_display(self, vehicle_list):
        self.clear_vehicle_list() # Clear existing items

        self.reload_hidden_lines() # RELOAD HIDDEN LINES ONLY - BEFORE DISPLAYING
        if not vehicle_list:
            print("No vehicles to display after filter.")
        else:
            print("Creating vehicle items for filtered list...")
            for vehicle_data in vehicle_list:
                self.create_vehicle_item(vehicle_data)
            print("Vehicle items creation finished for filtered list.")
        self.custom_hidden_scrollbar_set(0, 1) # Update scrollbar after items are displayed
        self.check_and_start_hidden_window_restart_button_fade() # <--- ADD THIS LINE to check on window open and initial load



    def create_vehicle_item(self, vehicle_data):
        frame = tk.Frame(self.hidden_window_scrollable_frame, bg="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
        frame.pack(fill="x", expand=True, pady=10, padx=1)
        self.vehicle_frames.append(frame)


        # Top Frame to hold image and info side by side
        top_frame = tk.Frame(frame, bg="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
        top_frame.pack(side="top", fill="x", expand=True) # Pack top_frame at the top

        image_filename = vehicle_data['image_path']
        image_path = os.path.join(self.config_pics_folder, image_filename)
        image_path_custom = os.path.join(self.config_pics_custom_folder, image_filename)

        try:
            img = Image.open(image_path)
            img = img.resize((110, 60), Image.Resampling.LANCZOS)
            photo = ImageTk.PhotoImage(img)
            image_label = tk.Label(top_frame, image=photo, background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0) # put image_label in top_frame
            image_label.image = photo
            image_label.pack(side="left", padx=10, pady=5)
        except FileNotFoundError:
            try:
                img = Image.open(image_path_custom) # Try to open from custom path
                img = img.resize((110, 60), Image.Resampling.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                image_label = tk.Label(top_frame, image=photo, background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
                image_label.image = photo
                image_label.pack(side="left", padx=10, pady=5)
            except FileNotFoundError:
                try:
                    default_img = Image.open(self.DEFAULT_IMAGE_PATH) # Load the default image
                    default_img = default_img.resize((110, 60), Image.Resampling.LANCZOS)
                    default_photo = ImageTk.PhotoImage(default_img)
                    image_label = tk.Label(top_frame, image=default_photo, background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
                    image_label.image = default_photo # Keep a reference!
                except FileNotFoundError:
                    # If default image is also not found, show a fallback text (optional)
                    image_label = tk.Label(top_frame, text="Default Image not found", foreground="#FF0000", background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
                image_label.pack(side="left", padx=10, pady=5)

        info_frame = tk.Frame(top_frame, bg="#444444", relief=tk.FLAT, bd=0, highlightthickness=0) # put info_frame in top_frame
        info_frame.pack(side="left", fill="x", expand=True)

        brand_name_label = tk.Label(info_frame, text=f"{vehicle_data['brand']} {vehicle_data['name']}", font=font.Font(size=11+self.font_size_add, family="Segoe UI", weight='bold'), foreground="#FFFFFF", background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
        brand_name_label.pack(anchor="w")

        folder_zip_label = tk.Label(info_frame, text=f"{vehicle_data['folder']} ({vehicle_data['zip_file']})", font=font.Font(size=10+self.font_size_add, family="Segoe UI"), foreground="#FFFFFF", background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
        folder_zip_label.pack(anchor="w")

        # Store label widgets in vehicle_data for easy access later
        vehicle_data['brand_name_label'] = brand_name_label
        vehicle_data['folder_zip_label'] = folder_zip_label

        # Determine initial button text based on CURRENT Hidden.txt content
        initial_button_text = "Unhide"
        if vehicle_data['original_line'] not in self.original_hidden_lines:
            initial_button_text = "Hide"

        # --- Define Colors & Styles ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF" # Hover text color
        active_bg = "#666666" # Define a standard active color
        active_fg = "#FFFFFF"  # Define a standard active foreground

        # --- Create Unhide/Hide Button ---
        unhide_button = tk.Button(
            frame,
            text=initial_button_text,
            background=original_bg,      # Use defined color
            foreground=original_fg,      # Use defined color
            activebackground=active_bg,  # Add active state colors
            activeforeground=active_fg,  # Add active state colors
            relief=tk.FLAT,
            bd=0,
            highlightthickness=0,        # Keep this for flat style
            pady=2,
            font=("Segoe UI", 9 + self.font_size_add)
        )
        unhide_button.pack(side="bottom", fill="x", padx=10, pady=(5, 10)) # Pack

        # Assign custom data and command (Unchanged)
        unhide_button.data = vehicle_data
        unhide_button['command'] = functools.partial(
            self.toggle_hide_vehicle,
            button=unhide_button,
            vehicle_data=vehicle_data
        )

        self._bind_animated_hover(
            button=unhide_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False 
        )


        # Set initial text color based on button text
        if initial_button_text == "Hide":
            self.set_vehicle_text_color(vehicle_data, "#90ee90") # Initially set to red if "Hide"
        else:
            self.set_vehicle_text_color(vehicle_data, "#FFFFFF") # Initially set to white if "Unhide"

            

    def set_vehicle_text_color(self, vehicle_data, color):
        """Sets the text color of the vehicle name and folder labels."""
        vehicle_data['brand_name_label'].config(foreground=color)
        vehicle_data['folder_zip_label'].config(foreground=color)



    def debounce_search(self):
        if self.hidden_window_search_after_id:
            self.hidden_window.after_cancel(self.hidden_window_search_after_id) # Use hidden_window.after_cancel
        self.hidden_window_search_after_id = self.hidden_window.after(self.hidden_window_search_DEBOUNCE_DELAY_MS, self.filter_vehicles) # Use hidden_window.after

    def filter_vehicles(self):
        search_term = self.hidden_window_search_var.get().lower()
        if not search_term:
            self.hidden_vehicles_data = list(self.all_vehicles_data) # Show full list
        else:
            self.hidden_vehicles_data = [
                vehicle for vehicle in self.all_vehicles_data
                if (search_term in vehicle['name'].lower() or
                    search_term in vehicle['brand'].lower() or
                    search_term in vehicle['zip_file'].lower() or
                    search_term in vehicle['folder'].lower()
                    )
            ]
        self.update_vehicle_display(self.hidden_vehicles_data) # Update display - reload happens in update_vehicle_display
        self.canvas.yview_moveto(0)  # Reset canvas yview to 0 (top)
        self.custom_hidden_scrollbar_set(0, 1) # Update scrollbar after filter
        self.hidden_window_search_after_id = None

    def toggle_hide_vehicle(self, button, vehicle_data):
        current_text = button.cget("text")
        original_line = vehicle_data['original_line']

        if current_text == "Unhide":
            self.remove_hidden_line_from_file(original_line)
            button.config(text="Hide")
            print(f"Vehicle '{vehicle_data['name']}' unhidden (removed from Hidden.txt). Button changed to Hide.")
            self.set_vehicle_text_color(vehicle_data, "#90ee90") # Set text to red when hidden
        else: # "Hide"
            self.add_hidden_line_to_file(original_line)
            button.config(text="Unhide")
            print(f"Vehicle '{vehicle_data['name']}' hidden again (added to Hidden.txt). Button changed to Unhide.")
            self.set_vehicle_text_color(vehicle_data, "#FFFFFF") # Set text to white when unhidden

        self.check_and_start_hidden_window_restart_button_fade() # Call this after toggling any button
        self.unhide_was_toggled_in_hidden_window = True 

    def remove_hidden_line_from_file(self, line_to_remove):
        try:
            with open(self.hidden_txt_file, 'r', encoding='utf-8') as f: # UTF-8 encoding
                lines = f.readlines()
            with open(self.hidden_txt_file, 'w', encoding='utf-8') as f: # UTF-8 encoding
                for line in lines:
                    if line.strip() != line_to_remove + '\n' and line.strip() != line_to_remove: # Handle both with and without newline
                        f.write(line)
            print(f"Line removed from {self.hidden_txt_file}: '{line_to_remove}'")
        except Exception as e:
            print(f"Error removing line from {self.hidden_txt_file}: {e}")

    def add_hidden_line_to_file(self, line_to_add):
        try:
            with open(self.hidden_txt_file, 'a', encoding='utf-8') as f: # UTF-8 encoding
                f.write(line_to_add + '\n')
            print(f"Line added to {self.hidden_txt_file}: '{line_to_add}'")
        except Exception as e:
            print(f"Error adding line to {self.hidden_txt_file}: {e}")


    def clear_vehicle_list(self):
        for frame in self.vehicle_frames:
            frame.destroy()
        self.vehicle_frames = []


    def custom_hidden_scrollbar_click(self, event):
        """Start thumb dragging on mouse click for Hidden window."""
        self.hidden_window_scrollbar_thumb_dragging_hidden = True
        self.hidden_window_scrollbar_thumb_start_y_hidden = self.hidden_window_custom_scrollbar_canvas_hidden.coords(self.hidden_window_scrollbar_thumb_hidden)[1]
        self.hidden_window_scrollbar_mouse_start_y_hidden = event.y

    def custom_hidden_scrollbar_drag(self, event):
        """Drag thumb and update canvas view for Hidden window."""
        if not self.hidden_window_scrollbar_thumb_dragging_hidden:
            return

        mouse_y = event.y
        delta_y = mouse_y - self.hidden_window_scrollbar_mouse_start_y_hidden
        new_thumb_y = self.hidden_window_scrollbar_thumb_start_y_hidden + delta_y

        # Modified lines: Using self.hidden_window_canvas
        canvas_height = self.hidden_window_canvas.winfo_height() # Use hidden_window_canvas
        scroll_range = self.hidden_window_canvas.bbox("all") # Use hidden_window_canvas
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height:
            return # No scrolling needed if content fits

        thumb_height = self.hidden_window_custom_scrollbar_canvas_hidden.coords(self.hidden_window_scrollbar_thumb_hidden)[3] - self.hidden_window_custom_scrollbar_canvas_hidden.coords(self.hidden_window_scrollbar_thumb_hidden)[1]
        max_thumb_y = canvas_height - thumb_height
        new_thumb_y = max(0, min(max_thumb_y, new_thumb_y)) # Clamp thumb position

        self.hidden_window_custom_scrollbar_canvas_hidden.coords(self.hidden_window_scrollbar_thumb_hidden, 0, new_thumb_y, 15, new_thumb_y + thumb_height)

        scroll_fraction = new_thumb_y / max_thumb_y if max_thumb_y > 0 else 0
        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_canvas.yview_moveto(scroll_fraction) # Use hidden_window_canvas


    def custom_hidden_scrollbar_release(self, event):
        """Stop thumb dragging on mouse release for Hidden window."""
        self.hidden_window_scrollbar_thumb_dragging_hidden = False

    def custom_hidden_scrollbar_set(self, *args):
        """Custom scrollbar set command to update thumb position for Hidden window."""
        if self.hidden_window_scrollbar_thumb_dragging_hidden:
            return # Prevent updates if dragging manually

        start, end = args[0:2]
        # Modified lines: Using self.hidden_window_canvas
        canvas_height = self.hidden_window_canvas.winfo_height() # Use hidden_window_canvas
        scroll_range = self.hidden_window_canvas.bbox("all") # Use hidden_window_canvas
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height: # NO SCROLLING NEEDED - SET TO GREY
            self.hidden_window_custom_scrollbar_canvas_hidden.itemconfig(self.hidden_window_scrollbar_thumb_hidden, fill="#555555")
        else: # SCROLLING IS POSSIBLE - KEEP ORANGE (or set back to orange if it was grey)
            self.hidden_window_custom_scrollbar_canvas_hidden.itemconfig(self.hidden_window_scrollbar_thumb_hidden, fill=self.global_highlight_color)

        thumb_height = max(20, canvas_height * (canvas_height / scrollable_height)) if scrollable_height > canvas_height else canvas_height # Minimum thumb height
        thumb_y_start = canvas_height * float(start)
        thumb_y_end = thumb_y_start + thumb_height
        self.hidden_window_custom_scrollbar_canvas_hidden.coords(self.hidden_window_scrollbar_thumb_hidden, 0, thumb_y_start, 15, thumb_y_end)


    def on_mousewheel_hidden(self, event, canvas):
        """Handle mouse wheel events for smooth scrolling in the hidden window."""
        if canvas.winfo_exists():
            if os.name == 'nt':
                delta = int(event.delta / 120) # Removed negation here
            else:
                delta = int(event.delta) # Removed negation here
            # --- MODIFIED: Initiate smooth scroll animation for hidden window ---
            self.start_smooth_scroll_hidden(delta, canvas) # Call smooth scroll for search results
            #canvas.yview_scroll(delta, "units") # Original non-smooth scroll

    def start_smooth_scroll_hidden(self, delta_units, canvas_sub): # Modified function signature: added canvas_sub
        """Starts smooth scrolling animation for the hidden canvas - NORMALIZED SPEED."""
        if self.hidden_window_scroll_animation_timer_hidden:
            self.hidden_window.after_cancel(self.hidden_window_scroll_animation_timer_hidden)  # Cancel any existing animation # Use hidden_window.after_cancel

        scroll_delta_units = delta_units  # Store delta in UNITS

        current_yview = canvas_sub.yview()  # Get current yview # Modified line: using canvas_sub
        current_pos = current_yview[0]  # Get the current top position (0.0 to 1.0)

        # Modified lines: using canvas_sub
        canvas_height = canvas_sub.winfo_height()
        scrollable_height = canvas_sub.bbox("all")[3] if canvas_sub.bbox("all") else canvas_height # Use canvas height as fallback
        if scrollable_height <= 0:
            scrollable_height = canvas_height # Prevent division by zero

        # Calculate scroll step based on a fraction of the *visible* canvas height
        scroll_fraction = 0.7  # Adjust this fraction (e.g., 0.1, 0.15, 0.25) for sensitivity
        scroll_step_normalized = (canvas_height / scrollable_height) * scroll_fraction * scroll_delta_units
        # Explanation:
        # - (canvas_height / scrollable_height):  This is the proportion of the *total* content that is visible.
        # - scroll_fraction:  We want to scroll by a fraction of this visible portion.
        # - scroll_units:  Multiply by the scroll units.

        target_y_normalized = current_pos - scroll_step_normalized # Changed + to - here to correct direction
        target_y_normalized = max(0.0, min(1.0, target_y_normalized))

        self.hidden_window_scroll_target_yview_hidden = target_y_normalized
        self.hidden_window_scroll_start_y_hidden = current_pos
        self.hidden_window_scroll_start_time_hidden = self.hidden_window.tk.call('clock', 'milliseconds') # Use hidden_window.tk.call

        if self.hidden_window_scroll_animation_id_hidden:
            canvas_sub.after_cancel(self.hidden_window_scroll_animation_id_hidden) # Use canvas_sub.after_cancel # Modified line: using canvas_sub
        self.animate_scroll_hidden(0, canvas_sub)

    def animate_scroll_hidden(self, step, canvas_sub): # Modified function signature: added canvas_sub
        """Animates the canvas scroll with ease-out for the hidden window."""
        current_time = self.hidden_window.tk.call('clock', 'milliseconds') # Use hidden_window.tk.call
        time_elapsed = current_time - self.hidden_window_scroll_start_time_hidden
        progress = min(1.0, time_elapsed / self.hidden_window_scroll_duration) # Normalized progress (0 to 1)

        # Ease-out function (simple quadratic)
        ease_out_progress = progress * (2 - progress) #  f(t) = t * (2 - t)

        # Modified line: using canvas_sub
        current_y_normalized = self.hidden_window_scroll_start_y_hidden + (self.hidden_window_scroll_target_yview_hidden - self.hidden_window_scroll_start_y_hidden) * ease_out_progress

        canvas_sub.yview_moveto(current_y_normalized) # Modified line: using canvas_sub

        if progress < 1.0:
            self.hidden_window_scroll_animation_id_hidden = canvas_sub.after(10, lambda: self.animate_scroll_hidden(step + 1, canvas_sub)) # 10ms delay for animation step # Modified line: using canvas_sub
        else:
            self.hidden_window_scroll_animation_id_hidden = None # Animation finished




    def check_and_show_scanning_window_after_closing_hidden_window(self):
        """Checks if any 'Hide' buttons are present and shows a scanning window indicating restart is required."""
        show_scan_win = False
        for frame in self.vehicle_frames:
            for widget in frame.winfo_children():
                if isinstance(widget, tk.Button) and widget.cget('text') == 'Hide':
                    show_scan_win = True
                    break # No need to check further buttons if one 'Hide' is found
            if show_scan_win:
                break # No need to check further frames if 'Hide' button is found

        if show_scan_win:
            scanning_win = self.show_scanning_window(text="Restart/Shutdown of the application required to update hidden vehicle list.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return

    def check_and_start_hidden_window_restart_button_fade(self):
        """Checks if any 'Hide' buttons are present and starts the restart button fade if needed."""
        start_fade = False
        for frame in self.vehicle_frames:
            for widget in frame.winfo_children():
                if isinstance(widget, tk.Button) and widget.cget('text') == 'Hide':
                    start_fade = True
                    break # No need to check further buttons if one 'Hide' is found
            if start_fade:
                break # No need to check further frames if 'Hide' button is found

        if start_fade and not self._hidden_window_fade_animation_running_restart:
            print(f"starting loop")
            self._start_fade_loop(
                self.hidden_window_restart_button,
                self.hidden_window_default_restart_color,
                self.hidden_window_warning_color_hidden_window_restart_button
            )
        elif not start_fade and self._hidden_window_fade_animation_running_restart:
            print(f"ending loop")
            self._stop_fade_loop(self.hidden_window_restart_button, self.hidden_window_default_restart_color) # Stop fade if no 'Hide' buttons and it's running




#############################


    def delete_all_custom_configs_for_vehicle(self, folder_name):
        deleted_count = 0
        if "user_custom_configs" in self.full_data:
            for info_key in list(self.full_data["user_custom_configs"].keys()):
                group = self.full_data["user_custom_configs"][info_key]
                configs_to_delete = [cfg for cfg in group['configs'] if cfg[4] == folder_name]
                for picture_path, spawn_cmd, _, _, _ in configs_to_delete:
                    match = re.search(r"config\s*=\s*'vehicles/([^/]+)/([^\.]+)\.pc'", spawn_cmd)
                    if match:
                        cfg_folder_name, file_name = match.groups()
                        if cfg_folder_name == folder_name:
                            self._delete_custom_config_files(cfg_folder_name, file_name, picture_path)
                            deleted_count += 1

        if deleted_count > 0:
            messagebox.showinfo("Deletion Successful",
                                f"Deleted {deleted_count} custom configs for '{folder_name}'.")
            self._refresh_custom_config_data(folder_name)
            print("    delete_all_custom_configs_for_vehicle is calling self.update_grid_layout()")
            self.update_grid_layout()
        else:
            messagebox.showinfo("No Configs Found", f"No custom configs found for '{folder_name}'.")

    def _delete_custom_config_files(self, folder_name, file_name, picture_path):
        pc_file_path = os.path.join(self.user_folder, folder_name, f"{file_name}.pc")
        if os.path.exists(pc_file_path):
            try:
                os.remove(pc_file_path)
            except Exception as e:
                messagebox.showerror("Deletion Error", f"Error deleting {pc_file_path}: {e}")

        base_image_name = f"vehicles--{folder_name}_user--{file_name}"
        for ext in ['jpg', 'jpeg', 'png']:
            image_file_path = os.path.join(self.config_pics_custom_folder, f"{base_image_name}.{ext}")
            if os.path.exists(image_file_path):
                try:
                    os.remove(image_file_path)
                    return
                except Exception as e:
                    messagebox.showerror("Deletion Error", f"Error deleting {image_file_path}: {e}")
                    return

    def _refresh_custom_config_data(self, deleted_folder_name):
        self.data = [
            d for d in self.data
            if not (d[2] == "user_custom_configs" and d[4] == deleted_folder_name)
        ]
        if "user_custom_configs" in self.full_data:
            for info_key in list(self.full_data["user_custom_configs"].keys()):
                group = self.full_data["user_custom_configs"][info_key]
                group['configs'] = [cfg for cfg in group['configs'] if cfg[4] != deleted_folder_name]
                if not group['configs']:
                    del self.full_data["user_custom_configs"][info_key]

        if "user_custom_configs" in self.full_data:
            for info_key, group_data in self.full_data["user_custom_configs"].items():
                if group_data['configs']:
                    rep_picture, rep_line, rep_zip, rep_info, rep_folder = group_data['configs'][0]
                    rep_exists = any(
                        d[2] == "user_custom_configs" and d[4] == rep_folder
                        for d in self.data
                    )
                    if not rep_exists:
                        self.data.append((rep_picture, rep_line, rep_zip, rep_info, rep_folder))

        self.grouped_data = self.format_grouped_data(self.data)
        
        
        
    def on_picture_click(self, clicked_folder_name, folder_name_for_display=None, clicked_from_category=None):
        """
        Handles a click on a picture in the main grid.
        Opens the details subgrid window for the clicked item.
        MODIFIED to check force_details_mode flag before checking main filter state.
        """


        if self.loading_search_results_window:
            return

        self.disable_hover_temporarily = True

        '''
        if self.dev_mode:

            scanning_win = self.show_scanning_window(text="self.disable_hover_temporarily = True", dev_notif=True)
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
                '''

        # --- Existing initial checks and pause logic ---
        if self.details_window and self.details_window.winfo_exists():
            # Optional: Check if it's the *same* folder being clicked again rapidly
            # If so, maybe just focus? Or proceed with reopen? Current logic proceeds.
             print("DEBUG: on_picture_click - Destroying existing details window before opening new one.")
             # Destroy immediately without calling on_details_window_close if it interferes
             # self.on_details_window_close() # Maybe avoid this if reopen calls it
             self.details_window.destroy()
             self.details_window = None


        print("\n--- on_picture_click() DEBUGGING - ENTRY - PAUSING MAIN GRID LOADING ---")
        print("DEBUG: on_picture_click - PAUSING main grid loading...")
        # self.pause_loading = True # Consider if pausing is still needed here or managed elsewhere
        if self.loading_pause_timer:
            self.master.after_cancel(self.loading_pause_timer)
            self.loading_pause_timer = None
        print("DEBUG: on_picture_click - Main grid loading PAUSED.")

        # --- Debugging info ---
        print("\n--- on_picture_click() DEBUGGING - EXTENSIVE - CALL STACK TRACE - SELF ID ---")
        print(f"  DEBUG: on_picture_click - SELF OBJECT ID: {id(self)}")
        print("--- END CALL STACK TRACE ---\n")
        print(f"  DEBUG: on_picture_click - clicked_folder_name: {clicked_folder_name}")



        # --- <<< MODIFIED: Determine details window mode ---

        print("  DEBUG: on_picture_click - Determining details_window_should_open_in_favorites_mode...")

        if clicked_from_category == "Favorites":
            print(f"  DEBUG: on_picture_click - Clicked from 'Favorites' category. Forcing details to favorites mode for folder: {clicked_folder_name}.")
            self.details_window_should_open_in_favorites_mode = True


        elif hasattr(self, 'force_details_mode') and self.force_details_mode:
            # Override based on the flag set by toggle_favorites_mode_details_window
            print(f"  DEBUG: on_picture_click - Override flag 'force_details_mode' is SET: '{self.force_details_mode}'")
            if self.force_details_mode == 'favorites':
                self.details_window_should_open_in_favorites_mode = True
                print("  DEBUG: on_picture_click - Setting details_window_should_open_in_favorites_mode = True (FORCED)")
            else: # 'all'
                self.details_window_should_open_in_favorites_mode = False
                print("  DEBUG: on_picture_click - Setting details_window_should_open_in_favorites_mode = False (FORCED)")
            # Clear the flag after use!
            self.force_details_mode = None
            print("  DEBUG: on_picture_click - Cleared force_details_mode flag.")
        else:
            # Default behavior: Check the main application filter state
            print("  DEBUG: on_picture_click - No override flag. Checking main filter state.")
            print(f"  DEBUG: on_picture_click - self.filter_state: {self.filter_state}, Type: {type(self.filter_state)}")
            print(f"  DEBUG: on_picture_click - self.filter_options: {self.filter_options}, Type: {type(self.filter_options)}")
            if self.filter_state >= 0 and self.filter_state < len(self.filter_options):
                 current_filter_option = self.filter_options[self.filter_state]

                 print(f"  DEBUG: on_picture_click - Current Filter Option: {current_filter_option}, Type: {type(current_filter_option)}")
                 print(f"  DEBUG: on_picture_click - Comparing to string 'Favorites', Type: {type('Favorites')}")
                 print(f"  DEBUG: on_picture_click - String comparison result: {current_filter_option == 'Favorites'}")
                 print(f"  DEBUG: on_picture_click - Numerical comparison result: self.filter_state == 5: {self.filter_state == 5}")

                 # Assuming index 5 is 'Favorites'
                 if self.filter_state == 5 and current_filter_option == "Favorites":
                     self.details_window_should_open_in_favorites_mode = True
                     print("  DEBUG: on_picture_click - Condition based on filter_state evaluated to TRUE. Setting details_window_should_open_in_favorites_mode = True")
                 else:
                     self.details_window_should_open_in_favorites_mode = False
                     print("  DEBUG: on_picture_click - Condition based on filter_state evaluated to FALSE. Setting details_window_should_open_in_favorites_mode = False")
            else:
                 print(f"  WARNING: on_picture_click - Invalid filter_state index: {self.filter_state}")
                 self.details_window_should_open_in_favorites_mode = False # Default to false on error
                 print("  DEBUG: on_picture_click - Defaulting details_window_should_open_in_favorites_mode = False due to invalid filter state.")


        print(f"  DEBUG: on_picture_click - FINAL details_window_should_open_in_favorites_mode is: {self.details_window_should_open_in_favorites_mode}")
        print("--- on_picture_click() DEBUGGING - EXTENSIVE - EXIT ---\n")
        # --- >>> END MODIFIED section ---


        # --- Existing data retrieval logic ---
        subgrid_data = []
        if clicked_folder_name in self.full_data: # Now directly check for folder_name in full_data
            print(f"  DEBUG: Accessing folder_name directly in full_data: {clicked_folder_name}") # Debug - Folder Access
            # Make sure you are getting the list of configs correctly
            # Example assuming structure is {'folder': [config_item1, config_item2,...]}
            # Adjust if your structure is {'folder': {'configs': [item1,...]}}
            potential_data = self.full_data[clicked_folder_name]
            if isinstance(potential_data, list): # Direct list of configs
                 subgrid_data = potential_data
            elif isinstance(potential_data, dict) and 'configs' in potential_data and isinstance(potential_data['configs'], list): # Nested structure
                 subgrid_data = potential_data['configs']
            else:
                 print(f"  WARNING: Unexpected data structure for folder {clicked_folder_name}. Type: {type(potential_data)}")
                 subgrid_data = [] # Default to empty if structure is wrong
        else:
            print("  DEBUG: Folder name NOT FOUND in full_data.") # Debug - Folder Not Found
            # Maybe show message? For now, just prevents error.
            # messagebox.showinfo("No Details", "No additional details available for this item.")
            return # Exit if folder not found

        if not subgrid_data:
            print("  DEBUG: subgrid_data is EMPTY after retrieval.") # Debug - Empty subgrid_data
            # messagebox.showinfo("No Details", "No additional details available for this item.")
            return # Exit if no data found
        else:
            print(f"  DEBUG: subgrid_data retrieved successfully. Item count: {len(subgrid_data)}") # Debug - Subgrid Data Success


        # --- Existing display key and header logic ---
        display_key = clicked_folder_name
        # Simple header if info_data is complex to get here
        details_header = f"Configs for {folder_name_for_display or clicked_folder_name}"
        try: # Safely try to get Brand/Name for a nicer header
            info_data = subgrid_data[0][3] if subgrid_data and len(subgrid_data[0]) > 3 and subgrid_data[0][3] else {}
            brand = info_data.get("Brand", None) if info_data else None
            name = info_data.get("Name", None) if info_data else None
            if brand and name:
                 details_header = f"Configs for {brand} {name} ({display_key})"
            elif name:
                 details_header = f"Configs for {name} ({display_key})"
        except IndexError:
            print("Warning: Could not access info_data for header due to IndexError.")
        except Exception as e:
            print(f"Warning: Error getting info_data for header: {e}")


        # --- Existing search query logic ---
        search_query_for_details = ""
        if hasattr(self, 'search_mode') and self.search_mode == "Configs": # Check search_mode exists
             if hasattr(self, 'search_var'): # Check search_var exists
                 search_query_for_details = self.search_var.get().strip()
             else:
                 print("WARNING: search_var attribute not found.")
        else:
             # print("DEBUG: Not in 'Configs' search mode or attribute missing.") # Optional debug
             pass


        # --- Existing call to display_subgrid_in_new_window ---
        print(f"  DEBUG: Calling display_subgrid_in_new_window for {display_key} with favorites_mode={self.details_window_should_open_in_favorites_mode}")
        self.display_subgrid_in_new_window(
            self,
            subgrid_data,
            "folder_grouped", # Confirm this is the correct zip_file placeholder
            details_header,
            display_key,
            search_query=search_query_for_details
        )

        self.reenable_hover()
        print("--- on_picture_click() DEBUGGING END ---\n")


     
  
        
        
        
    def set_main_grid_filter_mode(self, filter_index):
        """
        Sets the main grid filter mode programmatically.
        Updates self.filter_state, filter button text, and performs a search.
        """
        print(f"\n--- set_main_grid_filter_mode() DEBUG ENTRY ---") # Debug Entry
        print(f"  DEBUG: set_main_grid_filter_mode - Received filter_index: {filter_index}") # Debug - Input Index

        if 0 <= filter_index < len(self.filter_options): # Basic validation
            self.filter_state = filter_index # Set filter state
            current_filter = self.filter_options[self.filter_state] # Get filter name
            self.filter_button.config(text=f"{current_filter} [0]") # Update button text
            print(f"  DEBUG: set_main_grid_filter_mode - Filter state set to index: {filter_index}, text: '{current_filter}'") # Debug - State Set
            
            print("    set_main_grid_filter_mode is calling self.perform_search()")
            self.perform_search() # Re-apply search with new filter
            print("  DEBUG: set_main_grid_filter_mode - perform_search() called.") # Debug - Perform Search Called
        else:
            print(f"  Warning: set_main_grid_filter_mode - Invalid filter_index: {filter_index}") # Warning - Invalid Index

        print("--- set_main_grid_filter_mode() DEBUG EXIT ---\n") # Debug Exit
  


    def toggle_favorites_mode_details_window(self):
        """
        Toggles between 'View Favorites' and 'View All' modes JUST FOR the details window,
        by closing and reopening it with the desired mode, without affecting the main grid filter.
        """ # <<< MODIFIED docstring
        folder_name = self.current_details_folder



        print("\n--- toggle_favorites_mode_details_window() DEBUG ENTRY ---") # Debug - Entry
        print(f"  DEBUG: toggle_favorites_mode_details_window - Current details_window_is_favorites_filtered (BEFORE): {self.details_window_is_favorites_filtered}") # Debug - Before Check
        print(f"  DEBUG: toggle_favorites_mode_details_window - is_data_subset_active: {self.is_data_subset_active}") # Debug - Check global filter state

        if self.is_data_subset_active: # Check if global filters (like Brand, Name etc.) are active
            scanning_win = None
            try:
                scanning_win = self.show_scanning_window(text="Cannot switch configurations list view mode while main filters are active.")
                # Use after to destroy the window non-blockingly
                self.master.after(3125, lambda: scanning_win.destroy() if scanning_win and scanning_win.winfo_exists() else None)
            except Exception as e:
                 print(f"Error managing scanning window: {e}")
                 if scanning_win and scanning_win.winfo_exists():
                    scanning_win.destroy()

            print("--- toggle_favorites_mode_details_window() EXIT - Global filter active ---\n") # Debug - Exit - Global Filter Active
            

            return # Exit if global filters are on

        # Initialize the flag before deciding the mode
        self.force_details_mode = None # <<< ADDED: Ensure flag is reset initially

        if self.details_window_is_favorites_filtered:
            # Current is Favorites -> Switch to View All mode for reopen
            self.force_details_mode = 'all' # <<< MODIFIED: Set flag for reopen
            button_text = "View Favorites"
            print(f"  DEBUG: toggle_favorites_mode_details_window - Mode: View All Requested. Setting force_details_mode = '{self.force_details_mode}'") # Debug - View All Mode

            # self.set_main_grid_filter_mode(0) # <<< REMOVED: Do not change main grid filter
            # print("  DEBUG: toggle_favorites_mode_details_window - Calling set_main_grid_filter_mode(0) for 'Show All'.") # <<< REMOVED

        else:
            # Current is View All -> Switch to View Favorites mode for reopen
            if self.check_favorites_exist_for_folder(folder_name):
                self.force_details_mode = 'favorites' # <<< MODIFIED: Set flag for reopen
                button_text = "View All"
                print(f"  DEBUG: toggle_favorites_mode_details_window - Mode: View Favorites Requested. Setting force_details_mode = '{self.force_details_mode}'") # Debug - Favorites Mode

                # self.set_main_grid_filter_mode(5) # <<< REMOVED: Do not change main grid filter
                # print("  DEBUG: toggle_favorites_mode_details_window - Calling set_main_grid_filter_mode(5) for 'Favorites'.") # <<< REMOVED

                # self.search_var.set("") # <<< REMOVED: Do not clear main search bar
                # print("  DEBUG: toggle_favorites_mode_details_window - Clearing main search bar text.") # <<< REMOVED
                # self.perform_search() # <<< REMOVED: Do not perform search on main grid
                # print("  DEBUG: toggle_favorites_mode_details_window - Calling perform_search() on main grid.") # <<< REMOVED

                # --- REMOVED: Do not open separate Search Results Window ---
                # if not hasattr(self, 'search_results_window') or not self.search_results_window or not self.search_results_window.winfo_exists():
                #     self.search_results_window = self.show_search_results_window(self.data)
                #     print("DEBUG: toggle_favorites_mode_details_window - Search Results window CREATED when switching to Favorites Mode.")
                # self.search_results_window.lift()
                # print("DEBUG: toggle_favorites_mode_details_window - Search Results window LIFTED when switching to Favorites Mode.")
                # --- REMOVED ---

                # NOTE: We proceed to call reopen_details_window_in_current_mode below ONLY if favorites exist
            else:
                # No favorites exist for this folder, inform user and do nothing else
                scanning_win = None
                try:
                    scanning_win = self.show_scanning_window(text="No favorites added for this vehicle.")
                    self.master.after(3125, lambda: scanning_win.destroy() if scanning_win and scanning_win.winfo_exists() else None)
                except Exception as e:
                    print(f"Error managing scanning window: {e}")
                    if scanning_win and scanning_win.winfo_exists():
                        scanning_win.destroy()

                print("  DEBUG: toggle_favorites_mode_details_window - No Favorites Exist, cannot switch.") # Debug - No Favs Case
                # Keep button text as "View Favorites" since we didn't switch
                # Do not set force_details_mode, do not call reopen
                print("--- toggle_favorites_mode_details_window() EXIT - No Favorites Found Case ---\n")


                return # Exit because no favorites found


        # --- Call the reopen mechanism ONLY IF a mode was determined ---
        if self.force_details_mode:
             print(f"  DEBUG: toggle_favorites_mode_details_window - Calling reopen mechanism with force_details_mode = '{self.force_details_mode}'")
             # Assuming self.reopen_details_window_in_current_mode closes the current
             # window and then effectively triggers on_picture_click(self.current_details_folder)
             self.reopen_details_window_in_current_mode()
             print("--- toggle_favorites_mode_details_window() EXIT - Reopen Triggered ---\n")
        else:
             # This case should ideally not be reached if logic above is correct, but good for safety
             print("--- toggle_favorites_mode_details_window() EXIT - No Mode Change ---\n")



    
   
   

    # ------------------------------------------------------------
    # Details Subgrid (individual configs)
    # ------------------------------------------------------------

   
    def display_subgrid_in_new_window(self, app_instance, subgrid_data, zip_file, details_header, display_key, search_query=""):
        """Opens a new Toplevel window to display a subgrid (list of configs)."""
        # --- NEW: Check and close Filters window if open ---


        
        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
        #    self.spawn_queue_window_was_open = True  # Set flag to remember it was open
        #    print("DEBUG: Spawn Queue window is open, closing it temporarily...")
            self.destroy_spawn_queue_window()  # Close the Spawn Queue window
        #    print("DEBUG: Spawn Queue window closed.") # not closing the spawn window
            
        if hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists():
            self.hidden_window.withdraw() 
            
        self.was_filters_window_open_before_details = False  # Initialize to False
        if self.filters_window and self.filters_window.winfo_exists():
            print("DEBUG: display_subgrid_in_new_window - Filters window is open, closing it.")
            #self.was_filters_window_open_before_details = True  # Remember it was open
            self.was_filters_window_open_before_details = False  # don't remove comment,re-opening it can feel a little jarring, might make this a setting
            self.filters_window.destroy()
            self.filters_window = None

        print("\n--- display_subgrid_in_new_window() ENTRY - DEBUGGING FLAG VALUE - SELF ID ---")
        print(f"  DEBUG: display_subgrid_in_new_window - SELF OBJECT ID: {id(self)}")
        print(f"  DEBUG: display_subgrid_in_new_window - VALUE CHECK *BEFORE* LOGIC: self.details_window_should_open_in_favorites_mode = {getattr(self, 'details_window_should_open_in_favorites_mode', 'ATTRIBUTE_MISSING')}")

        # Use the flag passed implicitly via self.details_window_should_open_in_favorites_mode
        print(f"  DEBUG: display_subgrid_in_new_window - ENTERING FUNCTION. Value of self.details_window_should_open_in_favorites_mode: {self.details_window_should_open_in_favorites_mode}")
        print(f"  DEBUG: display_subgrid_in_new_window - Received search_query: '{search_query}'")

        # --- Prepare window state, create UI elements ---
        self._prepare_details_window_state(subgrid_data, zip_file, display_key)
        self._create_details_window()
        self._position_details_window()
        self._create_details_frames()
        self._create_top_frame_content(details_header)
        self._create_bottom_frame_content()
        self._create_subgrid_canvas()

        # --- Extract Brand Name for Potential Favorites Label ---
        brand_name_for_label = "Unknown Brand" # Default
        if subgrid_data:
            try:
                first_item_info = subgrid_data[0][3] if len(subgrid_data[0]) >= 4 else None
                if first_item_info and isinstance(first_item_info, dict):
                    brand_name_for_label = first_item_info.get("Brand", "Unknown Brand").strip()
                    if not brand_name_for_label:
                        brand_name_for_label = "Unknown Brand"
            except (IndexError, TypeError):
                print("Warning: Could not get brand name from first subgrid item for favorites label.")
        # --- End Extract Brand Name ---

        # --- <<< ADD DEBUG PRINT RIGHT BEFORE CALLING _create_details_sidebar >>> ---
        should_be_fav_mode = getattr(self, 'details_window_should_open_in_favorites_mode', False)
        print(f"  DEBUG: display_subgrid_in_new_window - *** CALLING _create_details_sidebar *** with is_favorites_mode={should_be_fav_mode}, brand_name='{brand_name_for_label}'")
        # --- <<< END DEBUG PRINT >>> ---

        # --- Create Sidebar - Pass Favorites Mode Flag and Brand Name ---
        self._create_details_sidebar(
            is_favorites_mode=should_be_fav_mode, # Use the checked value
            brand_name=brand_name_for_label
        )
        # --- End Create Sidebar ---

        self._create_sidebar_buttons(zip_file)  # Ensure details_view_favorites_button is created here



        # --- Data Subset Filtering (if active) ---
        if self.is_data_subset_active:
            print("DEBUG: display_subgrid_in_new_window - Data Subset Active - Filtering Subgrid Data by data_subset.txt")
            subgrid_data = self._apply_details_data_subset_filter(subgrid_data)
            print(f"DEBUG: display_subgrid_in_new_window - Subgrid data count AFTER Data Subset filter: {len(subgrid_data)}")

        # --- Determine display mode (Favorites or All) ---
        print(f"display_subgrid_in_new_window: Checking details_window_should_open_in_favorites_mode: {self.details_window_should_open_in_favorites_mode}")

        if self.details_window_should_open_in_favorites_mode:
            # *** Displaying Favorites ***
            print("DEBUG: display_subgrid_in_new_window - details_window_should_open_in_favorites_mode is TRUE (Filtering Subgrid Data for Favorites).")
            self.details_is_favorites_filter_active = True
            self.details_window_is_favorites_filtered = True
            print(f"  DEBUG: display_subgrid_in_new_window - Setting details_window_is_favorites_filtered = True")

            # --- Filter data for favorites (with deduplication) ---
            favorite_configs_set = self.read_favorites()

 

            filtered_subgrid_data = []
            added_fav_keys = set()
            print(f"  DEBUG: favorite_configs_set: {favorite_configs_set}")
            for item in subgrid_data:
                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                if config_name: # Ensure config_name was extracted
                    fav_key = f"{folder_name}|{config_name}.pc"
                    if fav_key in favorite_configs_set and fav_key not in added_fav_keys:
                        filtered_subgrid_data.append(item)
                        added_fav_keys.add(fav_key)
            print(f"DEBUG: Original subgrid data count: {len(subgrid_data)}, Filtered count (Favorites - Deduplicated): {len(filtered_subgrid_data)}")
            final_subgrid_data = filtered_subgrid_data # Start with favorites data

            # --- Apply search query if provided ---
            if search_query:
                print(f"DEBUG: Applying search query '{search_query}' BEFORE initial layout (Favorites Mode).")
                final_subgrid_data = self._filter_details_data_by_query(final_subgrid_data, search_query)

            # --- Layout and Button Config ---
            self._initial_details_layout(final_subgrid_data, zip_file)
            self.details_filtered_data = final_subgrid_data[:]
            if hasattr(self, 'details_view_favorites_button') and self.details_view_favorites_button:
                 self.details_view_favorites_button.config(text="View All")
                 print("DEBUG: display_subgrid_in_new_window - Button text set to 'View All'")
            else:
                 print("WARNING: details_view_favorites_button not found or not valid.")

        else:
            # *** Displaying All ***
            print("DEBUG: display_subgrid_in_new_window - details_window_should_open_in_favorites_mode is FALSE (Show All).")
            self.details_is_favorites_filter_active = False
            self.details_window_is_favorites_filtered = False
            print(f"  DEBUG: display_subgrid_in_new_window - Setting details_window_is_favorites_filtered = False")

            final_subgrid_data = subgrid_data # Start with all (potentially subsetted) data

            # --- Apply search query if provided ---
            if search_query:
                print(f"DEBUG: Applying search query '{search_query}' BEFORE initial layout (Show All Mode).")
                final_subgrid_data = self._filter_details_data_by_query(final_subgrid_data, search_query)

            # --- Layout and Button Config ---
            self._initial_details_layout(final_subgrid_data, zip_file)
            self.details_filtered_data = final_subgrid_data[:]
            if hasattr(self, 'details_view_favorites_button') and self.details_view_favorites_button:
                 self.details_view_favorites_button.config(text="View Favorites")
                 print("DEBUG: display_subgrid_in_new_window - Button text set to 'View Favorites'")
            else:
                 print("WARNING: details_view_favorites_button not found or not valid.")


        # --- Common final steps ---
        self.show_progress_bar_details()



        
        if search_query:
            print(f"  DEBUG: display_subgrid_in_new_window - Setting details_search_var to: '{search_query}' (but NOT performing search yet).")
            self.details_search_var.set(search_query)

        print(f"display_subgrid_in_new_window - Final state check: details_window_is_favorites_filtered is: {self.details_window_is_favorites_filtered}")

        print("--- display_subgrid_in_new_window() EXIT ---\n")




#################
#page navigation

    def go_to_details_page_one(self):
        """Navigates to the first page in the details window and rebuilds the UI."""
        print("\n--- go_to_details_page_one() ENTRY ---") # Debug Entry

        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win

        if self.details_page != 0: # Only proceed if not already on page 1
            print(f"  DEBUG: go_to_details_page_one - Current page is NOT 1 (page index: {self.details_page}), resetting to page 1.") # Debug - Page Change
            self.details_page = 0 # Set page index to 0 (page 1)

            # --- MODIFIED: Reset widget count on page change (Page 1) ---
            ConfigViewerApp.details_widget_count = 0 # <--- RESET WIDGET COUNT HERE - on page change
            print("DEBUG: go_to_details_page_one - Widget count RESET to 0 for page 1.") # Debug - Widget Count Reset
            # --- MODIFIED: Reset widget count on page change (Page 1) ---

            self.rebuild_simple_details() # Rebuild the subgrid for page 1
            self._update_details_pagination_bar() # Update pagination bar to show page 1
            
            print("  DEBUG: go_to_details_page_one - UI refreshed for page 1.") # Debug - UI Refreshed
        else:
            print("  DEBUG: go_to_details_page_one - Already on page 1, no action needed.") # Debug - No Action

        print("--- go_to_details_page_one() EXIT ---\n") # Debug Exit


    def add_jump_to_page_button_to_details_window(self, top_details_frame):
        """Adds the 'Jump to page' button to the details window with animated hover."""

        # Define base and hover colors for clarity and consistency
        button_original_bg = "#555555"
        button_original_fg = "#FFFFFF"
        
        # Hover colors from your original on_jump_to_page_button_hover_enter logic
        button_hover_bg = self.global_highlight_color 
        button_hover_fg = "#FFFFFF" # Your original code explicitly set fg to white on hover

        button_style_args = {
            "bg": button_original_bg, # Initial background, will be managed by _bind_animated_hover
            "fg": button_original_fg, # Initial foreground, will be managed by _bind_animated_hover
            "relief": tk.FLAT,
            "bd": 0,
            "highlightbackground": button_original_bg, # For the focus ring when not focused
            "activebackground": "#666666", # Background color when button is pressed
            "activeforeground": "#FFFFFF", # Foreground color when button is pressed
            "font": ("Segoe UI", 10 + self.font_size_add)
        }

        self.jump_to_page_button = tk.Button(
            top_details_frame,
            text="Jump to page",
            **button_style_args,
            command=self.handle_jump_to_page_button_click # Simplified: use direct command
        )

        self._bind_animated_hover(
            button=self.jump_to_page_button,
            original_bg=button_original_bg,
            original_fg=button_original_fg,
            hover_target_bg=button_hover_bg,
            hover_target_fg=button_hover_fg

        )



        if not self.jump_to_page_button_should_be_bottom:

            if self.details_window_should_open_in_favorites_mode:
                self.jump_to_page_button.pack(side="left", padx=(0, 10))
            
            else:
                self.jump_to_page_button.pack(side="left", padx=(10, 0)) # Pack after search bar and before loading label


        else:
            pass


    def handle_jump_to_page_button_click(self):
        """Handles clicks on the 'Jump to page' button to show the dropdown menu."""
        if hasattr(self, 'jump_to_page_dropdown_window') and self.jump_to_page_dropdown_window and self.jump_to_page_dropdown_window.winfo_exists():
            self.jump_to_page_dropdown_window.destroy()
            return
        

        if not self.jump_to_page_button_should_be_bottom:



            button = self.jump_to_page_button

            button_x = button.winfo_rootx()
            button_y = button.winfo_rooty() + button.winfo_height()

            self.jump_to_page_dropdown_window = dropdown_window = FadingToplevel(self.details_window, self)

            dropdown_window.geometry(f"+{button_x}+{button_y}")


        else:


            button = self.jump_to_page_button_bottom

            button_x = button.winfo_rootx()
            button_y = button.winfo_rooty() # Get the top of the button

            self.jump_to_page_dropdown_window = dropdown_window = FadingToplevel(self.details_window, self)
            button_width = button.winfo_width() # Get the width of the button





        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        dropdown_window.config(bg="#333333")
        dropdown_window.attributes("-topmost", True)
        dropdown_window.config(highlightthickness=3, highlightbackground="#666666")


        canvas = tk.Canvas(dropdown_window, bg="#333333", highlightthickness=0, width=100, height=200) # Width same as zip dropdown, make scrollable
        scrollbar = tk.Scrollbar(dropdown_window, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#333333")

        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="top", fill="both", expand=True) # Pack canvas first to fill space above button
        canvas.configure(yscrollcommand=scrollbar.set)
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw", width=300) # Set width of scrollable frame inside canvas

        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_dropdown_mousewheel(ev, canvas)))
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))


        num_pages = math.ceil(len(self.details_filtered_data) / self.items_per_page) if self.items_per_page else 1
        current_page_index = self.details_page + 1 # Get current page number (1-indexed)

        def on_page_button_click(page_index):
            self.go_to_details_page(page_index)
            self.jump_to_page_dropdown_window.destroy()
            self.jump_to_page_dropdown_window = None

        for i in range(1, num_pages + 1):
            # --- Define Colors for page buttons ---
            page_default_bg = "#555555"
            page_default_fg = "#FFFFFF"
            page_selected_bg = self.global_highlight_color # Orange for current page
            page_selected_fg = "#FFFFFF"                   # White text for current page
            page_hover_bg = "#d9d9d9"
            page_hover_fg = "black"

            is_selected = (i == current_page_index) # Check if this is the current page

            page_button = tk.Button(
                scrollable_frame,
                text=f"Page {i}",
                font=("Segoe UI", 10 + self.font_size_add, "bold"),
                command=lambda idx=i: on_page_button_click(idx), # Ensure on_page_button_click exists
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5,

            )
            page_button.config(
                width=24, # Set fixed width
                activebackground=page_hover_bg, # For click flash
                activeforeground=page_hover_fg
            )
            page_button.pack(fill="x")
            # if hasattr(self, 'current_page_buttons_list'): self.current_page_buttons_list.append(page_button)


            self._bind_animated_hover(
                button=page_button,
                original_bg=page_default_bg,
                original_fg=page_default_fg,
                hover_target_bg=page_hover_bg,
                hover_target_fg=page_hover_fg,
                check_state=False,
                is_selected_initial=is_selected,
                selected_bg=page_selected_bg,
                selected_fg=page_selected_fg
            )
            # REMOVED old binds

        # --- Close Button (below scrollable frame, in dropdown_window) ---

        # --- Define Colors for the Close button ---
        close_button_original_bg = "#666666"
        close_button_original_fg = "#FFFFFF"
        # Hover to global highlight color (orange) or a custom one
        close_button_hover_bg = self.global_highlight_color # e.g., "#777777"
        close_button_hover_fg = "#FFFFFF" # Assuming white text on highlight

        close_button = tk.Button(
            dropdown_window, # Place in dropdown_window
            text="Close",
            font=("Segoe UI", 10 + self.font_size_add, "bold"),
            command=self.destroy_jump_to_page_dropdown_menu, # Ensure this method exists
            # bg and fg will be set by _bind_animated_hover initially
            borderwidth=1,
            relief="solid",
            padx=10,
            pady=5
        )
        # Set active colors for click flash (optional)
        close_button.config(
            activebackground=close_button_hover_bg, # Example: match hover for click
            activeforeground=close_button_hover_fg
        )
        close_button.pack(side="bottom", fill="x") # Pack to bottom of dropdown_window

        # --- Apply Smooth Hover Animation to the Close Button ---
        self._bind_animated_hover(
            button=close_button,
            original_bg=close_button_original_bg,
            original_fg=close_button_original_fg,
            hover_target_bg=close_button_hover_bg,
            hover_target_fg=close_button_hover_fg,
            check_state=False, # Assuming close button is always enabled
            is_selected_initial=False, # No selected state
            selected_bg=None,
            selected_fg=None
        )

        # Force update to calculate window size based on content
        dropdown_window.update_idletasks()
        # Get the actual dimensions of the dropdown window
        window_width = dropdown_window.winfo_width()
        window_height = dropdown_window.winfo_height()
        # Calculate target X (button's right edge - window width)
        target_x = (button_x + button_width) - window_width
        # Calculate target Y (button's top edge - window height)
        target_y = button_y - window_height
        # Set the final position
        dropdown_window.geometry(f"+{target_x}+{target_y}")


        dropdown_window.bind("<FocusOut>", lambda event: self.destroy_jump_to_page_dropdown_menu())

    def destroy_jump_to_page_dropdown_menu(self):
        if hasattr(self, 'jump_to_page_dropdown_window') and self.jump_to_page_dropdown_window and self.jump_to_page_dropdown_window.winfo_exists():
            self.jump_to_page_dropdown_window.destroy()
            self.jump_to_page_dropdown_window = None


    def go_to_details_page(self, page_index):
        """Navigates to the specified page in the details window."""

        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win

        if 1 <= page_index <= math.ceil(len(self.details_filtered_data) / self.items_per_page) if self.items_per_page else 1:
            self.details_page = page_index - 1
            ConfigViewerApp.details_widget_count = 0
            self.rebuild_simple_details()
            self._update_details_pagination_bar()
        else:
            print(f"Invalid page number: {page_index}")




#####################################



    def destroy_zip_search_dropdown_menu(self):
        if hasattr(self, 'zip_search_dropdown_window') and self.zip_search_dropdown_window and self.zip_search_dropdown_window.winfo_exists():
            self.zip_search_dropdown_window.destroy()
            self.zip_search_dropdown_window = None


    def apply_zip_filter(self, selected_zip):
        """Applies the zip filter to the details window data."""
        if selected_zip == "All Zips":
            self.details_filtered_data = self.details_data[:] # Show all data
            self.zip_search_button.config(text="Search within: All Zips") # Reset button text
            if self.details_window_is_favorites_filtered: # If in favorites mode, switch to show all
                self.toggle_favorites_mode_details_window() # Toggle to 'View All'
        elif selected_zip == "Custom Configurations":
            self.details_filtered_data = [item for item in self.details_data if "_user--" in item[0]] # Filter for custom configs
            self.zip_search_button.config(text="Search within: Custom Configurations") # Update button text
            if self.details_window_is_favorites_filtered: # If in favorites mode, switch to show all
                self.toggle_favorites_mode_details_window() # Toggle to 'View All'
        else: # Filter by selected zip
            self.details_filtered_data = [item for item in self.details_data if item[2] == selected_zip]
            self.zip_search_button.config(text=f"Search within: {selected_zip}") # Update button text
            if self.details_window_is_favorites_filtered: # If in favorites mode, switch to show all
                self.toggle_favorites_mode_details_window() # Toggle to 'View All'

        self.go_to_details_page_one() # <--- GO TO PAGE ONE HERE (No Condition)
        self.rebuild_simple_details()
        if self.details_count_label:
            self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}")




    def add_zip_search_dropdown_to_details_window(self, top_details_frame):
        """Adds the 'Search Within: Zips' dropdown to the details window with smooth hover."""

        # --- Define Colors & Styles for this button ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF" # Hover text color
        active_bg = "#666666"
        active_fg = "#FFFFFF"

        button_style_args_zip_search = {
            "bg": original_bg,
            "fg": original_fg,
            "relief": tk.FLAT,
            "bd": 0,
            # "highlightthickness": 0, # REMOVED as per instruction
            "highlightbackground": original_bg, # Match background
            "activebackground": active_bg, # For standard click feedback
            "activeforeground": active_fg, # For standard click feedback
            "font": ("Segoe UI", 10 + self.font_size_add)
        }


        # --- Determine Initial Text (Unchanged) ---
        initial_button_text = "Search within: All Zips"
        if self.is_data_subset_active:
            initial_button_text = "Search within: Filtered"
        elif self.details_window_should_open_in_favorites_mode:
            initial_button_text = "Search within: Favorites"


        # --- Create the Button ---
        button = tk.Button(
            top_details_frame,
            text=initial_button_text,
            **button_style_args_zip_search, # Apply styles
            command=self.handle_zip_search_button_click # Ensure this method exists
        )
        self.zip_search_button = button # Store reference

        # --- Bind using the helper function ---
        # Assumes self._bind_animated_hover is defined in the class
        self._bind_animated_hover(
            button=button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False # Assuming this button doesn't need state checks for hover
        )


        # --- Pack the Button (Unchanged) ---
        if self.details_window_should_open_in_favorites_mode:
            return
        if self.is_data_subset_active:
            return
        else:
            button.pack(side="left", padx=(0, 0)) # Pack after search bar and before loading label



    def _filter_details_data_by_query(self, data_to_filter, query): # <--- MODIFIED FUNCTION - Favorites Filter Added
        """
        Filters the given details data list based on the search query,
        NOW respecting the Favorites filter in Details Window.
        """
        if not query:
            return data_to_filter  # Return original data if no query

        filtered_list = []
        print(f"\n--- _filter_details_data_by_query() DEBUG ---") # DEBUG START
        print(f"  DEBUG: Details Search Query: '{query}'") # DEBUG - Search Query
        print(f"  DEBUG: Details Window is_favorites_filter_active: {self.details_window_is_favorites_filtered}") # DEBUG - Favorites Filter State

        # --- START: Apply Favorites Filter (if active) BEFORE Search ---
        if self.details_window_is_favorites_filtered:
            print("  DEBUG: Applying Favorites Filter BEFORE Search Query...") # Debug - Favorites Filter Start
            favorite_configs_set = self.read_favorites()
            favorites_filtered_data = []
            print(f"  DEBUG: Initial data_to_filter count (before Favorites filter): {len(data_to_filter)}") # Debug - Data Count Before Fav Filter
            for item in data_to_filter:
                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                fav_key = f"{folder_name}|{config_name}.pc"
                if fav_key in favorite_configs_set:
                    favorites_filtered_data.append(item)
            data_to_filter = favorites_filtered_data # REASSIGN data_to_filter to the favorites-filtered subset
            print(f"  DEBUG: Data count AFTER Favorites filter: {len(data_to_filter)}") # Debug - Data Count After Fav Filter
        # --- END: Apply Favorites Filter ---
        else:
            print("  DEBUG: Favorites Filter is NOT active for Details Window search.") # Debug - Favorites Filter Not Active


        print(f"  DEBUG: _filter_details_data_by_query - data_to_filter (count) AFTER Favorites filter (if applied): {len(data_to_filter)}") # Debug - INPUT DATA COUNT (after Fav Filter)


        for item in data_to_filter:
            picture_path, spawn_cmd, zip_file, info_data, folder_name = item

            # --- ADDED DEBUGGING - INSPECT ARGUMENT SOURCES in _filter_details_data_by_query ---
            #print(f"  DEBUG: Argument Sources (Details Search):") # DEBUG - Arguments Source Header
            #print(f"    - folder_name (from 'item' tuple): '{folder_name}', type: {type(folder_name)}") # DEBUG - folder_name source
            #print(f"    - zip_file (from 'item' tuple): '{zip_file}', type: {type(zip_file)}") # DEBUG - zip_file source
            #print(f"    - spawn_cmd (from 'item' tuple): '{spawn_cmd}', type: {type(spawn_cmd)}") # DEBUG - spawn_cmd source

            zip_file_base_name = zip_file.replace(".zip", "")  # <-- CORRECTED zip_file_base_name EXTRACTION (DETAILS SEARCH)
            #print(f"    - zip_file_base_name (AFTER extraction): '{zip_file_base_name}', type: {type(zip_file_base_name)}") # DEBUG - zip_file_base_name after extraction
            config_name_base = self.extract_name_from_spawn_command(spawn_cmd).lower() # Get PC config name base
            #print(f"    - config_name_base (extracted from spawn_cmd): '{config_name_base}', type: {type(config_name_base)}") # DEBUG - config_name_base source
            # --- END ADDED DEBUGGING ---


            pic_filename = os.path.basename(picture_path).lower()
            config_name_display = "" # Initialize display config name

            individual_info_path = self.find_individual_info_file(
                folder_name,
                zip_file_base_name=zip_file_base_name, # <--- USING CORRECTED zip_file_base_name
                config_name=config_name_base # Use the extracted config_name_base
            )
            individual_info_json_data = {} # Initialize

            if individual_info_path:
                individual_info_json_data, _ = self._load_individual_info(individual_info_path) # Load JSON data
                config_name_display = individual_info_json_data.get("Configuration", "").strip().lower() # Get display config name
                #print(f"  DEBUG: Individual Info File Path: {individual_info_path}") # DEBUG - Info File Path
                #print(f"  DEBUG: _filter_details_data_by_query - Individual Info File Content (Extracted Data): {individual_info_json_data}") # DEBUG - Info File Content
            else:
                #print(f"  DEBUG: Individual Info File NOT FOUND for: folder_name='{folder_name}', zip_file_base_name='{zip_file_base_name}', config_name='{config_name_base}'") # DEBUG - Info File Not Found
                pass

            config_match_found = False
            if query.lower() in config_name_display: # Check against display name from Info file
                config_match_found = True
                print(f"  DEBUG: Query '{query}' FOUND in config_name_display: '{config_name_display}'") # DEBUG - Match Found - Display Name
            else: # <--- ADDED ELSE BLOCK FOR DEBUGGING NO MATCH
                print(f"  DEBUG: Query '{query}' NOT found in config_name_display: '{config_name_display}'") # DEBUG - No Match - Display Name

            pc_file_name_match = False # Check if query matches PC filename
            pc_file_name = self.extract_name_from_spawn_command(spawn_cmd).lower()
            if query.lower() in config_name_base: # Check against PC filename
                pc_file_name_match = True
                print(f"  DEBUG: Query '{query}' FOUND in PC file name: '{pc_file_name}'") # DEBUG - PC File Match Found
            else: # <--- ADDED ELSE BLOCK FOR DEBUGGING NO MATCH
                print(f"  DEBUG: Query '{query}' NOT found in PC file name: '{pc_file_name}'") # DEBUG - No Match - PC File Name

            # --- ADDED DEBUG PRINT - Configuration Content and PC File Name being Searched Against ---
            #print(f"  DEBUG: Searching against - Configuration Content: '{config_name_display}'") # DEBUG - Config Content
            #print(f"  DEBUG: Searching against - PC File Name: '{pc_file_name}'") # DEBUG - PC File Name
            # --- END ADDED DEBUG PRINT ---


            if config_match_found or pc_file_name_match: # Check both Info file content and PC filename
                filtered_list.append(item)
                #print(f"  DEBUG: Item MATCHED and APPENDED to filtered_list. filtered_list count now: {len(filtered_list)}") # Debug - Item Appended
            else:
                #print("  DEBUG: Item NOT matched.") # Debug - Item Not Matched
                pass
                
        print(f"  DEBUG: _filter_details_data_by_query - Filtered list count: {len(filtered_list)}") # DEBUG - Filtered List Count
        print("--- _filter_details_data_by_query() DEBUG END ---\n") # DEBUG END
        return filtered_list
   
        
        
    details_widget_count = 0 

    def _prepare_details_window_state(self, subgrid_data, zip_file, display_key):
        """Prepares the state before creating the details window."""
        if self.details_window and not self.details_window_closed:
            print("Closing existing details window before opening new one.")
            self.hide_details_sidebar_info()
            self.details_window.destroy()

        self.current_details_folder = display_key
        self.current_details_zip_file = zip_file
        self.details_window_closed = False
        self.details_data = subgrid_data
        self.details_filtered_data = subgrid_data[:]
        self.is_details_sidebar_sticky = False
        self.is_details_sidebar_showing_default = False

        # --- MODIFIED: Initialize details_page to 0 HERE ---
        self.details_page = 0 # <--- Initialize page to 0 here
        # --- MODIFIED: Initialize details_page to 0 HERE ---
        self.items_per_page = 50 # Ensure items_per_page is set here or in __init__
        
        # --- MODIFIED: Initialize details_widget_count in _prepare_details_window_state ---
        ConfigViewerApp.details_widget_count = 0 # <--- Initialize widget count HERE, when window is opened
        print("DEBUG: _prepare_details_window_state - Widget count INITIALIZED to 0.") # Debug - Widget Count Init
        # --- MODIFIED: Initialize details_widget_count in _prepare_details_window_state ---
            
            
    def _create_details_window(self):
        """Creates the Toplevel window for details.
           - Removed window decorations (borderless).  <--- MODIFIED
           - Now positions flush with master window.    <--- MODIFIED
        """
        
        
        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win

        self.pause_loading = True
        
        details_window = tk.Toplevel(self.master)
        details_window.tk.call('tk', 'scaling', 1.25)

        details_window.title("Details List")
        details_window.protocol("WM_DELETE_WINDOW", self.close_details_window_from_x_button)
        self.details_window = details_window
        details_window.resizable(False, False)
        #details_window.transient(self.master)
        #details_window.grab_set() # Modal - keep modal for now, can remove if needed

        details_window.overrideredirect(True) # <--- REMOVE WINDOW DECORATIONS (BORDERLESS)

        # Set initial geometry to be flush with master (size and position will be updated in _position_details_window)
        master_geometry = self.master.geometry()
        details_window.geometry(master_geometry) # Initial geometry flush with master
        # --- MODIFIED: Button creation REMOVED from here, now in _create_bottom_frame_content ---
        # Button creation is now in _create_bottom_frame_content
        # --- MODIFIED: Button creation REMOVED from here ---
        #self.master.bind("<Configure>", self.update_window_geometries) 

        #details_window.bind("<Button-1>", self.on_details_window_click) 
        #details_window.bind("<ButtonPress-1>", self.on_details_window_click)
        details_window.bind("<ButtonPress-1>", self.debounced_on_details_window_click)

        #self.details_window.bind("<Escape>", lambda event: self.on_details_window_close())
        #self.details_window.bind_all("<Control-n>", lambda event: self.clear_details_sidebar_content()) # debug

        self.disable_hover_temporarily = False

        '''
        if self.dev_mode:

            scanning_win = self.show_scanning_window(text="self.disable_hover_temporarily = False", dev_notif=True)
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
                '''

        print("changing self.disable_hover_temporarily = False")


    def close_details_window_from_x_button(self):
        self.details_window_intentionally_closed = True
        
        def destroy_details_window_after_fade():
            """Safely destroys the details window."""

            print(f"DEBUG: Fading complete. Destroying details_window: {self.details_window}") # DEBUG
            self.on_details_window_close()


        # Start the fade-out animation.
        # Pass the `destroy_details_window_after_fade` function as the callback.
        self._fade_window(
            window=self.details_window,
            start_alpha=1.0,
            end_alpha=0.0,
            duration_ms=40,
            steps=20,
            callback=destroy_details_window_after_fade  # Pass the function to be called
        )
        

    def clear_details_sidebar_content(self):
            """
            Clears all content in the details sidebar, resetting it to a placeholder state.
            This includes clearing labels and resetting the image to a placeholder.
            """
            print("\n--- clear_details_sidebar_content() DEBUG ---") # Debug Entry

            # Placeholder image for sidebar - CHANGED placeholder to MATCH sidebar_top_frame BG COLOR - "#333333"
            placeholder_image = Image.new("RGB", (280, 150), "#333333") # CHANGED to "#333333" - MATCH sidebar_top_frame BG COLOR
            placeholder_photo = ImageTk.PhotoImage(placeholder_image)

            # Clear ALL sidebar labels and reset image
            self.details_sidebar_car_name_label.config(text="") # Reset car name label to "" (empty string)
            self.details_sidebar_image_label.config(image=placeholder_photo) # Reset image to placeholder
            self.details_sidebar_image_label.image = placeholder_photo # Keep reference to placeholder
            self.details_sidebar_selected_config_label_val.config(text="") # Clear Config Name
            self.details_sidebar_description_label_val.config(text="") # Clear Description
            self.details_sidebar_zipfile_label_val.config(text="") # Clear Zip File
            self.details_sidebar_value_label_val.config(text="") # Clear Value
            self.details_sidebar_brand_label_val.config(text="") # Clear Brand info
            self.details_sidebar_bodystyle_label_val.config(text="") # Clear Body Style
            self.details_sidebar_weight_label_val.config(text="") # Clear Weight
            self.details_sidebar_years_label_val.config(text="No Info File Present") # Clear Years



    def debounced_on_details_window_click(self, event):
        """
        Intermediary debounce function for clicks on the details window.
        This version triggers the action on the *first* click and debounces subsequent clicks.
        """


        if hasattr(self, 'zip_search_dropdown_window') and self.zip_search_dropdown_window and self.zip_search_dropdown_window.winfo_exists():
            self.zip_search_dropdown_window.destroy()
            print("zip search getting destroyed -  debounced_on_details_window_click")



        self.destroy_jump_to_page_dropdown_menu()
        #print("jump to page getting destroyed -  debounced_on_details_window_click")


        debounce_delay_ms = 6500  # Adjust this value to control the debounce delay (milliseconds)

        if not self.debounce_timer:  # Only proceed if no timer is currently running
            self.on_details_window_click(event)  # Execute the action immediately on the first click

            self.debounce_timer = self.details_window.after(
                debounce_delay_ms,
                self._reset_debounce_timer  # Call a function to reset the timer after the delay
            )

    def _reset_debounce_timer(self):
        """
        Resets the debounce timer, allowing the next click to be considered the 'first' click again.
        """
        self.debounce_timer = None


    def on_details_window_click(self, event): # <--- NEW FUNCTION
        """
        Function to handle clicks anywhere on the details window.
        Add your desired actions here.
        """
        print("Details window clicked!")
        # Example actions you might want to perform:
        # - Deselect any selected items in the details window
        # - Close any open context menus in the details window
        # - Perform some other UI action related to the details window



        if hasattr(self, 'jumpt_to_page_dropdown_window') and self.jump_to_page_dropdown_window and self.jump_to_page_dropdown_window.winfo_exists():
            self.jump_to_page_dropdown_window.destroy()
            print("jump to page  getting destroyed -  on_details_window_click")
            return
        

        if hasattr(self, 'zip_search_dropdown_window') and self.zip_search_dropdown_window and self.zip_search_dropdown_window.winfo_exists():
            self.zip_search_dropdown_window.destroy()
            print("zip search getting destroyed -  on_details_window_click")
            return



        self.details_window.lift()
        self.master.lift()
        self.details_window.lift()


        if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
            self.current_detail_window.lift()



    def update_window_geometries(self, event=None):
        """Updates the geometries of both search results and details windows to match the main window."""
        self.update_details_window_geometry(event)
        self.update_search_results_window_geometry(event)
        

    
    
    def _position_details_window(self):
        """Positions the details window to be flush with and match size of the master window."""
        if not self.details_window: # Check if window exists before positioning
            return

        self.details_window.update_idletasks() # Update to get accurate info

        master_x = self.master.winfo_rootx()
        master_y = self.master.winfo_rooty()
        master_width = self.master.winfo_width()
        master_height = self.master.winfo_height()

        self.details_window.geometry(f"{master_width}x{master_height}+{master_x}+{master_y}") # Geometry MATCHES master

    def periodically_update_details_window_position(self):
        """
        Periodically updates the details window position to follow the main window.
        """
        if hasattr(self, 'details_window') and self.details_window and self.details_window.winfo_exists():
            self.update_details_window_geometry() # Call the update function

        # Schedule the function to run again after 2000 milliseconds (2 seconds)
        self.master.after(2000, self.periodically_update_details_window_position)

    def update_details_window_geometry(self, event=None):
        """Updates the size and position of the details window to match the main window."""
        if hasattr(self, 'details_window') and self.details_window and self.details_window.winfo_exists():
            # Get master window position and dimensions
            master_x = self.master.winfo_rootx()
            master_y = self.master.winfo_rooty()
            master_width = self.master.winfo_width()
            master_height = self.master.winfo_height()

            # Apply the same geometry as the master window
            self.details_window.geometry(f"{master_width}x{master_height}+{master_x}+{master_y}")
 

    def _create_details_frames(self):
        """Creates main frames within the details window."""
        details_main_frame = tk.Frame(self.details_window)
        details_main_frame.pack(fill="both", expand=True)

        top_details_frame = tk.Frame(details_main_frame, bg="#333333", pady=5) # <--- CHANGED bg to "#333333"
        top_details_frame.pack(side="top", fill="x")

        bottom_details_frame = tk.Frame(details_main_frame, bg="#333333", pady=5) # <--- CHANGED bg to "#333333"
        bottom_details_frame.pack(side="bottom", fill="x")


        self.top_details_frame = top_details_frame # Storing for potential future use if needed
        self.bottom_details_frame = bottom_details_frame # Storing for potential future use if needed
        self.details_main_frame = details_main_frame # Storing for potential future use if needed       





    def _create_top_frame_content(self, details_header):
        """Creates content for the top frame of the details window (search, header, loading label, buttons with smooth hover)."""

        # --- Define Colors & Styles for buttons in this frame ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF" # Hover text color
        active_bg = "#666666"
        active_fg = "#FFFFFF"

        button_style_args_details_top_bar = {
            "bg": original_bg,
            "fg": original_fg,
            "relief": tk.FLAT,
            "bd": 0,
            "highlightbackground": original_bg, # Match background
            "activebackground": active_bg,
            "activeforeground": active_fg,
            # Font applied individually below
        }



        # --- Search Icon Label (Not a button, Unchanged) ---
        details_search_button = tk.Label(
            self.top_details_frame,
            text="🔍",
            font=("Segoe UI", 12 + self.font_size_add),
            **self.search_button_style_args # Apply style
        )
        details_search_button.pack(side="left", padx=(4, 2), pady=4)

        # --- Search Entry (Unchanged) ---
        self.details_search_var = tk.StringVar()
        details_search_entry = tk.Entry(
            self.top_details_frame,
            textvariable=self.details_search_var,
            font=("Segoe UI", 10 + self.font_size_add),
            width=40,
            bg="#d9d9d9"
        )
        details_search_entry.pack(side="left", padx=(0, 10))
        details_search_entry.bind("<KeyRelease>", self._handle_details_search_key_release)

        # --- Other Dropdown/Button Additions (Assume these handle their own bindings) ---
        self.add_zip_search_dropdown_to_details_window(self.top_details_frame)
        self.add_jump_to_page_button_to_details_window(self.top_details_frame)

        # --- Loading Label (Unchanged) ---
        self.details_loading_label = tk.Label(
            self.top_details_frame, text="", bg="#333333",
            font=("Segoe UI", 12 + self.font_size_add, "bold")
        )
        self.details_loading_label.pack(side="left", padx=(10, 10))




        # --- Progress Bar (Unchanged) ---
        self.create_progress_bar_details(self.top_details_frame)

        # --- View Favorites / View All Button ---
        button_text = "View Favorites" if not self.details_window_should_open_in_favorites_mode else "View All"
        fav_button = tk.Button(
            self.top_details_frame,
            text=button_text,
            font=("Segoe UI", 10 + self.font_size_add),
            command=self.toggle_favorites_mode_details_window,
            **button_style_args_details_top_bar # Apply style
        )
        self.details_view_favorites_button = fav_button # Store reference

        # --- Bind Favorites Button using the helper ---
        self._bind_animated_hover(
            button=fav_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False # Assuming this button is always enabled for hover effects
        )
        # REMOVED: Old direct bindings for fav_button


        if self.details_window_should_open_in_favorites_mode and self.is_data_subset_active:
            top_label_text="Favorite Configurations (Filtered)"

        elif self.is_data_subset_active:
            top_label_text="Configurations (Filtered)"

        elif self.details_window_should_open_in_favorites_mode:
            top_label_text="Favorite Configurations"
            fav_button.pack(side="left", padx=(0, 10)) # Pack button

        else:
            top_label_text="Configurations"
            fav_button.pack(side="left", padx=(10, 10)) # Pack button




        self.current_view_label = tk.Label(
            self.top_details_frame, text=top_label_text, bg="#333333", fg="#FFFFFF",
            font=("Segoe UI", 12 + self.font_size_add, "bold")
        )
        self.current_view_label.pack(side="left", padx=(10, 10))



        self.details_pending_hidden_warning_label = tk.Label(
            self.top_details_frame, text="Management features disabled due to pending hidden items", bg="#333333", fg="#FFFFFF",
            font=("Segoe UI", 12 + self.font_size_add, "bold")
        )
        if self.items_to_be_hidden:
            self.details_pending_hidden_warning_label.pack(side="left", padx=(10, 10))

            self._start_fade_loop(self.details_pending_hidden_warning_label, self.warning_color_sidebar, self.default_sidebar_color)







        # --- Back Button ---
        back_button = tk.Button(
            self.top_details_frame,
            text="Back",
            font=("Segoe UI", 10 + self.font_size_add),
            command=self.close_details_window_from_x_button,
            **button_style_args_details_top_bar # Apply style
        )
        self.details_back_button = back_button # Store reference


        # --- Bind Back Button using the helper ---
        self._bind_animated_hover(
            button=back_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=False # Assuming this button is always enabled for hover effects
        )
        # REMOVED: Old direct bindings for back_button

        back_button.pack(side="right", padx=(0, 10)) # Pack on the right



    def _handle_details_search_key_release(self, event):
        """Handles KeyRelease events for the search entry, ignoring Escape."""
        # print(f"Key released: {event.keysym}") # Optional: for debugging
        if event.keysym != 'Escape':
            self.start_debounce_details_highlighting()


    def start_debounce_details_highlighting(self):
        """
        Starts the debounce timer for label highlighting in details window.
        """
        if self.details_debounce_timer:
            self.details_window.after_cancel(self.details_debounce_timer) # Cancel existing timer

        #self.details_debounce_timer = self.details_window.after(1000, self.actual_details_label_highlighting) # Set new timer
        self.details_debounce_timer = self.details_window.after(1000, self.perform_details_search) # Set new timer


    def actual_details_label_highlighting(self):
        """
        Updates the highlight color of labels and image backgrounds in the details window based on the search query.
        """
        return
    
        search_query = self.details_search_var.get().strip().lower()

        for item_frame in self.details_scrollable_frame.winfo_children():
            if hasattr(item_frame, 'item_data_tuple') and item_frame.item_data_tuple:
                pil_image, info_data, item_picture_path, zip_file_item, folder_name_item, spawn_cmd_item, lbl_img, lbl_name = item_frame.item_data_tuple # Unpack tuple

                config_name_for_search = lbl_name.cget("text").lower() # Get label text for search

                if search_query and search_query in config_name_for_search:
                    lbl_name.config(fg="yellow") # Highlight label text in yellow
                    lbl_img.config(bg="yellow") # Highlight image background in yellow
                else:
                    # Restore default colors
                    lbl_name.config(fg=lbl_name.default_fg_color) # Restore default label text color
                    lbl_img.config(bg=lbl_img.default_bg_color) # Restore default image background color

        self.details_debounce_timer = None # Reset timer after execution
    
        
   
        
      
  


    def _create_bottom_frame_content(self):
        """
        Creates content for the bottom frame of the details window (command, deleting, count labels).
        """
        # --- NEW: "Showing..." Label in Bottom Frame (FAR LEFT) - PACK FIRST ---
        self.details_showing_configs_label = tk.Label(self.bottom_details_frame, text="", bg="#333333",
                                                    font=("Segoe UI", 12+self.font_size_add, "bold",), fg="#FFFFFF", anchor="w", justify="left")
        self.details_showing_configs_label.pack(side="left", padx=(10, 0))
        # --- NEW: "Showing..." Label in Bottom Frame (FAR LEFT) ---

        self.details_command_label = tk.Label(self.bottom_details_frame, text="", bg="#333333", fg="#FFFFFF", font=("Segoe UI", 12+self.font_size_add))
        self.details_command_label.pack(side="left", padx=(10, 0))

        self.details_deleting_label = tk.Label(self.bottom_details_frame, text="", bg="#333333",
                                               font=("Segoe UI", 12+self.font_size_add, "bold"))
        self.details_deleting_label.pack(side="left", expand=True)


        # --- Pagination Controls Frame ---
        self.details_pagination_frame = tk.Frame(self.bottom_details_frame, bg="#333333")
        self.details_pagination_frame.pack(side="left", padx=10)

        button_style_args = {
            "bg": "#555555",
            "fg": "#FFFFFF",
            "relief": tk.FLAT, # <--- FLATTENED BUTTONS
            "bd": 2,
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "#FFFFFF"
        }

        def button_hover_enter(event):
            if event.widget['state'] != tk.DISABLED: # Check if button is not disabled
                event.widget['bg'] = self.global_highlight_color

        def button_hover_leave(event):
            event.widget['bg'] = "#555555" # Revert to original color

        self.details_prev_button = tk.Button(self.details_pagination_frame, text="Prev", font=("Segoe UI", 9+self.font_size_add, "bold"), command=self.go_to_previous_details_page, **button_style_args)
        self.details_prev_button.pack(side="left", padx=5)
        self.details_prev_button.bind("<Enter>", button_hover_enter) # <--- HOVER EFFECT
        self.details_prev_button.bind("<Leave>", button_hover_leave) # <--- HOVER EFFECT

        self.details_page_label = tk.Label(self.details_pagination_frame, text="Page: 1", bg="#333333", fg="#FFFFFF", font=("Segoe UI", 10+self.font_size_add))
        self.details_page_label.pack(side="left", padx=5)

        self.details_next_button = tk.Button(self.details_pagination_frame, text="Next", font=("Segoe UI", 9+self.font_size_add, "bold"), command=self.go_to_next_details_page, **button_style_args)
        self.details_next_button.pack(side="left", padx=5)
        self.details_next_button.bind("<Enter>", button_hover_enter) # <--- HOVER EFFECT
        self.details_next_button.bind("<Leave>", button_hover_leave) # <--- HOVER EFFECT
        # --- End Pagination Controls Frame ---

        # --- NEW: Favorites Filter Button - Button CREATION MOVED BACK HERE ---
        self.details_favorites_filter_button = tk.Button(
            self.bottom_details_frame,
            text="Filter: Show All",  # Initial text
            font=("Segoe UI", 10+self.font_size_add),
            command=self.toggle_details_favorites_filter,
            **button_style_args
        )

        # DO NOT UNCOMMENT OR REMOVE THIS LINE - THIS BUTTON NEEDS TO BE HIDDEN AS IT CAUSES BUGGY BEHAVIOR AND ONLY MEANT FOR DEBUG
        #self.details_favorites_filter_button.pack(side="right", padx=(0, 10)) # Pack to the right, do not uncomment this line

        # --- NEW: Favorites Filter Button - Button CREATION MOVED BACK HERE ---
        self.details_favorites_filter_button.bind("<Enter>", button_hover_enter) # <--- HOVER EFFECT
        self.details_favorites_filter_button.bind("<Leave>", button_hover_leave) # <--- HOVER EFFECT



        # --- NEW: Favorites Filter Button - Button CREATION MOVED BACK HERE ---
        self.jump_to_page_button_bottom = tk.Button(
            self.bottom_details_frame,
            text="Jump to page",  # Initial text
            font=("Segoe UI", 10+self.font_size_add),
            command=self.handle_jump_to_page_button_click,
            **button_style_args
        )
        if self.jump_to_page_button_should_be_bottom:

            self.jump_to_page_button_bottom.pack(side="right", padx=(0, 10)) # Pack to the right, do not uncomment this line

        else:
            pass

        
        # --- NEW: Favorites Filter Button - Button CREATION MOVED BACK HERE ---
        self.jump_to_page_button_bottom.bind("<Enter>", button_hover_enter) # <--- HOVER EFFECT
        self.jump_to_page_button_bottom.bind("<Leave>", button_hover_leave) # <--- HOVER EFFECT




        self.details_count_label = tk.Label(self.bottom_details_frame, text="", bg="#333333", fg="#FFFFFF", font=("Segoe UI", 12+self.font_size_add))
        #self.details_count_label.pack(side="right", padx=(5, 10)) # don't remove this comment, this is disabled on purpose

        self.details_page_label_original_color = "#FFFFFF"
        
 
       
    def _create_bottom_frame_content(self):
        """
        Creates content for the bottom frame of the details window
        (labels, pagination buttons with smooth hover).
        """
        # --- Labels (Unchanged) ---
        self.details_showing_configs_label = tk.Label(self.bottom_details_frame, text="", bg="#333333",
                                                    font=("Segoe UI", 12+self.font_size_add, "bold",), fg="#FFFFFF", anchor="w", justify="left")
        self.details_showing_configs_label.pack(side="left", padx=(10, 0))

        self.details_command_label = tk.Label(self.bottom_details_frame, text="", bg="#333333", fg="#FFFFFF", font=("Segoe UI", 12+self.font_size_add))
        self.details_command_label.pack(side="left", padx=(10, 0))

        self.details_deleting_label = tk.Label(self.bottom_details_frame, text="", bg="#333333",
                                               font=("Segoe UI", 12+self.font_size_add, "bold"))
        self.details_deleting_label.pack(side="left", expand=True)


        # --- Pagination Controls Frame (Unchanged) ---
        self.details_pagination_frame = tk.Frame(self.bottom_details_frame, bg="#333333")
        self.details_pagination_frame.pack(side="left", padx=10)

        # --- Define Button Colors & Styles ---
        original_bg = "#555555"
        original_fg = "#FFFFFF"
        hover_fg = "#FFFFFF" # Hover text color
        active_bg = "#666666"
        active_fg = "#FFFFFF"

        # Base style args for buttons in this frame
        button_style_args = {
            "bg": original_bg,
            "fg": original_fg,
            "relief": tk.FLAT, # Flattened
            "bd": 2, # Keeping original bd=2 as specified
            "highlightbackground": original_bg, # Match bg
            "activebackground": active_bg,
            "activeforeground": active_fg
            # Font applied individually
        }

        # REMOVED: Old local handler functions are no longer needed here
        # def button_hover_enter(event): ...
        # def button_hover_leave(event): ...

        # --- Previous Button ---
        prev_button = tk.Button(
            self.details_pagination_frame,
            text="Prev",
            font=("Segoe UI", 9 + self.font_size_add, "bold"),
            command=self.go_to_previous_details_page,
            **button_style_args
        )
        prev_button.pack(side="left", padx=5)
        self.details_prev_button = prev_button # Store reference

        # Bind smooth hover
        self._bind_animated_hover(
            button=prev_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=True # Original checked state, assume might be disabled
        )
        # REMOVED: Old direct bindings

        # --- Page Label (Unchanged) ---
        self.details_page_label = tk.Label(self.details_pagination_frame, text="Page: 1", bg="#333333", fg="#FFFFFF", font=("Segoe UI", 10+self.font_size_add))
        self.details_page_label.pack(side="left", padx=5)

        # --- Next Button ---
        next_button = tk.Button(
            self.details_pagination_frame,
            text="Next",
            font=("Segoe UI", 9 + self.font_size_add, "bold"),
            command=self.go_to_next_details_page,
            **button_style_args
        )
        next_button.pack(side="left", padx=5)
        self.details_next_button = next_button # Store reference

        # Bind smooth hover
        self._bind_animated_hover(
            button=next_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=True # Original checked state, assume might be disabled
        )
        # REMOVED: Old direct bindings

        # --- End Pagination Controls Frame ---

        # --- Favorites Filter Button ---
        fav_filter_button = tk.Button(
            self.bottom_details_frame,
            text="Filter: Show All",
            font=("Segoe UI", 10 + self.font_size_add),
            command=self.toggle_details_favorites_filter,
            **button_style_args
        )
        self.details_favorites_filter_button = fav_filter_button # Store reference

        # Bind smooth hover
        self._bind_animated_hover(
            button=fav_filter_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=True # Assume might be disabled (safer default)
        )
        # REMOVED: Old direct bindings

        # DO NOT UNCOMMENT OR REMOVE THIS LINE - THIS BUTTON NEEDS TO BE HIDDEN AS IT CAUSES BUGGY BEHAVIOR AND ONLY MEANT FOR DEBUG
        #fav_filter_button.pack(side="right", padx=(0, 10))

        # --- Jump To Page Button ---
        jump_button = tk.Button(
            self.bottom_details_frame,
            text="Jump to page",
            font=("Segoe UI", 10 + self.font_size_add),
            command=self.handle_jump_to_page_button_click,
            **button_style_args
        )
        self.jump_to_page_button_bottom = jump_button # Store reference

        # Conditional Packing (Unchanged)
        if self.jump_to_page_button_should_be_bottom:
            jump_button.pack(side="right", padx=(0, 10))
        # else: pass

        # Bind smooth hover
        self._bind_animated_hover(
            button=jump_button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            check_state=True # Assume might be disabled
        )
        # REMOVED: Old direct bindings

        # --- Count Label (Unchanged / Commented Out Packing) ---
        self.details_count_label = tk.Label(self.bottom_details_frame, text="", bg="#333333", fg="#FFFFFF", font=("Segoe UI", 12+self.font_size_add))
        #self.details_count_label.pack(side="right", padx=(5, 10))

        # --- Original Color Variable (Unchanged) ---
        self.details_page_label_original_color = "#FFFFFF"




    def _update_details_pagination_bar(self):
        """Updates the pagination bar (page number and button states) in the details window."""
        if not self.details_pagination_frame:
            return

        page_num = self.details_page + 1 # Pages are 1-indexed for display
        total_pages = math.ceil(len(self.details_filtered_data) / self.items_per_page) if self.items_per_page else 1
        self.details_page_label.config(text=f" 50 per page:  {page_num} / {total_pages} ")

        if self.details_page <= 0:
            self.details_prev_button.config(state=tk.DISABLED)
        else:
            self.details_prev_button.config(state=tk.NORMAL)

        if self.details_page >= total_pages - 1:
            self.details_next_button.config(state=tk.DISABLED)
        else:
            self.details_next_button.config(state=tk.NORMAL)



    def check_favorites_exist_for_folder(self, folder_name):
        """Checks if there are any favorites for the given folder in favorites.txt."""
        for fav_config in self.favorite_configs:
            fav_folder = fav_config.split('|')[0]
            if fav_folder == folder_name:
                return True
        return False
    

    def reopen_details_window_in_current_mode(self):
        """
        Placeholder/Assumed function: Closes the current details window
        and triggers the reopening process (likely via on_picture_click).
        """
        print("DEBUG: reopen_details_window_in_current_mode() - Called")
        print(f"value of self.details_window_intentionally_closed is {self.details_window_intentionally_closed}")

        if self.details_window and self.details_window.winfo_exists():
            folder_to_reopen = self.current_details_folder
            print(f"DEBUG: reopen_details_window_in_current_mode() - Closing current window for folder: {folder_to_reopen}")


            self.disable_hover_temporarily = True

            print("changing self.disable_hover_temporarily = True")

            '''
            if self.dev_mode:

                scanning_win = self.show_scanning_window(text="self.disable_hover_temporarily = True", dev_notif=True)
                if scanning_win:

                    def close_scanning_window():

                        scanning_win.destroy()

                    scanning_win.after(3125, close_scanning_window)
                    '''


            self.on_details_window_close() # Close existing window

            # Add a small delay if needed, helps Tkinter process the destroy event
            self.master.after(50, lambda: self._trigger_reopen(folder_to_reopen))
            # Directly call internal trigger after delay
            # self._trigger_reopen(folder_to_reopen) # Use this if after delay causes issues

        else:
            print("DEBUG: reopen_details_window_in_current_mode() - No details window found to reopen.")


    def _trigger_reopen(self, folder_name):
        """Internal helper to call on_picture_click for reopening."""
        print(f"DEBUG: _trigger_reopen() - Calling on_picture_click for folder: {folder_name}")
        # Pass folder_name. Event object is often unused, pass None if okay.
        # Use folder_name for display name as well unless you have specific logic
        self.on_picture_click(clicked_folder_name=folder_name, folder_name_for_display=folder_name)


    
    
    def _create_subgrid_canvas(self):
        """Creates the canvas and scrollbar for the subgrid display in details window.
        MODIFIED to include CUSTOM SCROLLBAR for details window, positioned behind sidebar AND with height/position adjustments.
        """
        # Main Canvas for Details Window
        canvas_sub = tk.Canvas(self.details_main_frame, bg="#444444", highlightthickness=0, yscrollincrement=10)
        canvas_sub.configure(yscrollcommand=self.custom_details_scrollbar_set) # Use CUSTOM DETAILS SCROLLBAR SET

        # Custom Scrollbar Canvas for Details Window
        self.custom_scrollbar_canvas_details = tk.Canvas(self.details_main_frame, bg="#555555", highlightthickness=0, width=15) # Grey track
        self.scrollbar_thumb_details = self.custom_scrollbar_canvas_details.create_rectangle(0, 0, 15, 20, fill=self.global_highlight_color, outline="") # Orange thumb
        self.scrollbar_thumb_dragging_details = False # Initialize dragging flag for details scrollbar
        self.scrollbar_thumb_start_y_details = 0
        self.scrollbar_mouse_start_y_details = 0
        
        self._details_scroll_pending = False
        self._details_throttled_after_id = None
        self._last_details_thumb_y = 0 #


        self.custom_scrollbar_canvas_details.bind("<ButtonPress-1>", self.custom_details_scrollbar_click)
        self.custom_scrollbar_canvas_details.bind("<B1-Motion>", self.custom_details_scrollbar_drag)
        self.custom_scrollbar_canvas_details.bind("<ButtonRelease-1>", self.custom_details_scrollbar_release)


        scrollable_frame_sub = tk.Frame(canvas_sub, bg="#444444")


        scrollable_frame_sub.bind(
            "<Configure>",
            lambda e: canvas_sub.configure(scrollregion=canvas_sub.bbox("all"))
        )
        canvas_sub.create_window((0, 0), window=scrollable_frame_sub, anchor="nw")
        canvas_sub.configure(yscrollcommand=self.custom_details_scrollbar_set) # Configure canvas to use CUSTOM scrollbar


        canvas_sub.pack(side="left", fill="both", expand=True) # Canvas takes up most space on the LEFT

        # --- MODIFIED: Adjusted place arguments for scrollbar positioning ---


        if self.font_size_add == 0:
            scrollbar_top_offset = 45  # Adjust to move scrollbar down from the top (positive value)
            scrollbar_bottom_offset = 38 # Adjust to shorten scrollbar from the bottom (positive value)

        elif self.font_size_add == 2:
            scrollbar_top_offset = 52 
            scrollbar_bottom_offset = 45 

        elif self.font_size_add == 4:
            scrollbar_top_offset = 55 
            scrollbar_bottom_offset = 53 


        self.custom_scrollbar_canvas_details.place(
            relx=1.0,
            rely=0.0,
            anchor='ne',
            relheight=1.0,
            x=-315,  # Horizontal offset (behind sidebar)
            y=scrollbar_top_offset, # NEW: Vertical offset from the top
            height=-scrollbar_bottom_offset - scrollbar_top_offset # NEW: Adjust height to shorten from bottom
        )
        # --- MODIFIED: Adjusted place arguments for scrollbar positioning ---


        canvas_sub.bind("<Enter>", lambda e: canvas_sub.bind_all("<MouseWheel>", lambda ev: self.on_mousewheel_details(ev, canvas_sub)))
        canvas_sub.bind("<Leave>", lambda e: canvas_sub.unbind_all("<MouseWheel>"))
        self.details_window.bind("<Configure>", lambda e: self.throttled_details_resize(e))

        self.details_scrollable_frame = scrollable_frame_sub
        self.details_canvas_sub = canvas_sub


  
        


        


    def _create_details_sidebar(self, is_favorites_mode=False, brand_name="Unknown Brand"):
        """
        Creates the details sidebar frame and its content.
        MODIFIED: Accepts `is_favorites_mode` and `brand_name` to conditionally
                  add the "Showing Favorites for..." label.
        MODIFIED: Implements a scrollable area for the text content below the image
                  using a CUSTOM scrollbar.
        ADDED: More debugging prints. Adjusted padding slightly.
        """
        print(f"\n--- _create_details_sidebar() ENTRY ---") # <<< DEBUG
        print(f"  DEBUG: Received is_favorites_mode = {is_favorites_mode}") # <<< DEBUG
        print(f"  DEBUG: Received brand_name = {brand_name}") # <<< DEBUG

        # --- Main Sidebar Frame ---
        self.details_sidebar_frame = tk.Frame(
            self.details_main_frame,
            width=315,
            bg="#333333",
            highlightthickness=0, bd=0, relief=tk.FLAT
        )
        self.details_sidebar_frame.pack(side="right", fill="y", padx=0, pady=0, expand=False)
        self.details_sidebar_frame.pack_propagate(False)

        details_sidebar_padding = 10



        # --- Conditional Favorites Label ---
        self.favorites_mode_indicator_label = None # Initialize attribute
        if is_favorites_mode:
            print(f"  DEBUG: INSIDE is_favorites_mode block - Creating Favorites Label...") # <<< DEBUG
            self.favorites_mode_indicator_label = tk.Label(
                self.details_sidebar_frame,
                text=f"Showing Favorites for...",
                font=("Segoe UI", 12+self.font_size_add, "italic"),
                fg="#d9d9d9",
                bg="#333333",
                anchor="center",
                justify="center"
            )
            # Pack the favorites label AFTER car name, BEFORE image
            self.favorites_mode_indicator_label.pack(
                pady=(0, 1), # Padding above and below this label
                padx=details_sidebar_padding,
                fill='x'
            )
            print(f"  DEBUG: Packed favorites label: {self.favorites_mode_indicator_label.winfo_ismapped()}") # <<< DEBUG
        else:
            print(f"  DEBUG: is_favorites_mode is FALSE - Skipping Favorites Label.") # <<< DEBUG


        # --- Top Fixed Section ---
        self.details_sidebar_car_name_label = tk.Label(
            self.details_sidebar_frame, text="", font=("Segoe UI", 14+self.font_size_add, "bold"),
            bg="#333333", fg="#d9d9d9", wraplength=280, justify="center"
        )
        # Pack the car name label first
        self.details_sidebar_car_name_label.pack(pady=(details_sidebar_padding * 0.5, 5), padx=details_sidebar_padding, fill='x') # Reduced bottom padding
        print(f"  DEBUG: Packed car name label: {self.details_sidebar_car_name_label.winfo_ismapped()}") # <<< DEBUG


        # Continue packing the rest of the fixed top section
        placeholder_image = Image.new("RGB", (280, 150), "#333333")
        placeholder_photo = ImageTk.PhotoImage(placeholder_image)
        self.details_sidebar_image_label = tk.Label(
            self.details_sidebar_frame, image=placeholder_photo, bg="#333333"
        )
        self.details_sidebar_image_label.image = placeholder_photo
        # Pack the image label AFTER the potential favorites label
        self.details_sidebar_image_label.pack(pady=(0, details_sidebar_padding), padx=details_sidebar_padding)
        print(f"  DEBUG: Packed image label: {self.details_sidebar_image_label.winfo_ismapped()}") # <<< DEBUG

        # ... (Rest of the function: loading label, scrollable section, buttons remain the same) ...

        # --- Middle Scrollable Section (Unchanged) ---
        scroll_container_frame = tk.Frame(self.details_sidebar_frame, bg="#333333")
        scroll_container_frame.pack(fill="both", expand=True, padx=0, pady=0)
        # ... (canvas, scrollbar, inner frame creation) ...
        self.details_sidebar_text_canvas = tk.Canvas(scroll_container_frame, bg="#333333", highlightthickness=0, bd=0)
        self.custom_scrollbar_canvas_sidebar_text = tk.Canvas(scroll_container_frame, bg="#555555", width=15, highlightthickness=0, cursor="arrow")
        self.scrollbar_thumb_sidebar_text = self.custom_scrollbar_canvas_sidebar_text.create_rectangle(0, 0, 15, 20, fill=self.global_highlight_color, outline="")
        self.custom_scrollbar_canvas_sidebar_text.bind("<ButtonPress-1>", self.custom_sidebar_text_scrollbar_click)
        self.custom_scrollbar_canvas_sidebar_text.bind("<B1-Motion>", self.custom_sidebar_text_scrollbar_drag)
        self.custom_scrollbar_canvas_sidebar_text.bind("<ButtonRelease-1>", self.custom_sidebar_text_scrollbar_release)
        self.details_sidebar_text_canvas.configure(yscrollcommand=self.custom_sidebar_text_scrollbar_set)
        self.custom_scrollbar_canvas_sidebar_text.pack(side="right", fill="y")
        self.details_sidebar_text_canvas.pack(side="left", fill="both", expand=True)
        self.details_sidebar_text_scrollable_frame = tk.Frame(self.details_sidebar_text_canvas, bg="#333333")
        self.details_sidebar_text_canvas.create_window((0, 0), window=self.details_sidebar_text_scrollable_frame, anchor="nw")
        self.details_sidebar_text_scrollable_frame.bind("<Configure>", lambda e: self.details_sidebar_text_canvas.configure(scrollregion=self.details_sidebar_text_canvas.bbox("all")))
        self.details_sidebar_text_canvas.bind("<Enter>", lambda e: self.details_sidebar_text_canvas.bind_all("<MouseWheel>", self._on_mousewheel_details_sidebar_text))
        self.details_sidebar_text_canvas.bind("<Leave>", lambda e: self.details_sidebar_text_canvas.unbind_all("<MouseWheel>"))
        self._create_sidebar_info_labels()

        # --- Bottom Fixed Section (Buttons - Unchanged) ---
        self.details_buttons_frame = tk.Frame(self.details_sidebar_frame, bg="#333333")
        self.details_buttons_frame.pack(side="bottom", fill="x", pady=(0, 10), padx=10)

        # Initial call to set scrollbar state correctly
        self.master.after(50, lambda: self.custom_sidebar_text_scrollbar_set(0, 1))

        print(f"--- _create_details_sidebar() EXIT ---") # <<< DEBUG



    def _on_mousewheel_details_sidebar_text(self, event):
        """Handles mouse wheel scrolling for the details sidebar text canvas
           by initiating smooth scrolling."""
        if self.details_sidebar_text_canvas and self.details_sidebar_text_canvas.winfo_exists():
            # Determine scroll direction and magnitude
            if os.name == 'nt': # Windows
                delta = int(event.delta / 120)
            else: # Linux/macOS
                delta = 1 if event.num == 4 else -1 if event.num == 5 else 0

            if delta != 0:
                # Call the new start function for smooth scroll
                self.start_smooth_scroll_sidebar_text(delta)



    def _create_sidebar_info_labels(self):
        """
        Creates the information labels within the details sidebar's SCROLLABLE FRAME.
        MODIFIED: Parent is now self.details_sidebar_text_scrollable_frame.
                  Packing happens within update_details_sidebar_content.
        ADDED: Labels for Top Speed, Torque, Power, 0-100, 100-0, Fuel Type.
        """
        # Parent frame is now the inner scrollable frame
        parent = self.details_sidebar_text_scrollable_frame

        details_sidebar_padding = 10 # Keep padding consistent
        label_font_cat = ("Segoe UI", 11+self.font_size_add, "bold")
        label_font_val = ("Segoe UI", 11+self.font_size_add, "italic")
        label_bg = "#333333"
        label_fg_cat = "#FFFFFF"
        label_fg_val = "#d9d9d9"
        label_anchor = "w"
        label_justify = "left"
        label_wraplength = 280



        # --- Existing Labels ---
        self.details_sidebar_description_label_cat = tk.Label(parent, text="Description:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_description_label_val = tk.Label(parent, text="", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        self.details_sidebar_zipfile_label_cat = tk.Label(parent, text="Zip File:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_zipfile_label_val = tk.Label(parent, text="", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        self.details_sidebar_value_label_cat = tk.Label(parent, text="Value:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_value_label_val = tk.Label(parent, text="", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        self.details_sidebar_brand_label_cat = tk.Label(parent, text="Brand:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_brand_label_val = tk.Label(parent, text="", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        self.details_sidebar_bodystyle_label_cat = tk.Label(parent, text="Body Style:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_bodystyle_label_val = tk.Label(parent, text="", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        self.details_sidebar_weight_label_cat = tk.Label(parent, text="Weight:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_weight_label_val = tk.Label(parent, text="", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        self.details_sidebar_years_label_cat = tk.Label(parent, text="Years:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_years_label_val = tk.Label(parent, text="", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)


        # --- Selected Configuration ---
        self.details_sidebar_selected_config_label_cat = tk.Label(parent, text="Selected Configuration:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_selected_config_label_val = tk.Label(parent, text="Custom/Unspecified", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        # --- Config Name (from PC file) ---
        self.details_sidebar_config_name_label = tk.Label(parent, text="", font=("Segoe UI", 10+self.font_size_add, "italic"), bg=label_bg, fg=label_fg_val, anchor=tk.W, justify=tk.LEFT, wraplength=label_wraplength)

        # --- Top Speed ---
        self.details_sidebar_topspeed_label_cat = tk.Label(parent, text="Top Speed:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_topspeed_label_val = tk.Label(parent, text="N/A", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        # --- Torque ---
        self.details_sidebar_torque_label_cat = tk.Label(parent, text="Torque:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_torque_label_val = tk.Label(parent, text="N/A", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        # --- Power ---
        self.details_sidebar_power_label_cat = tk.Label(parent, text="Power:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_power_label_val = tk.Label(parent, text="N/A", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        # --- 0-100 km/h ---
        self.details_sidebar_0_100_label_cat = tk.Label(parent, text="0-100 km/h:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_0_100_label_val = tk.Label(parent, text="N/A", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        # --- 100-0 km/h ---
        self.details_sidebar_100_0_label_cat = tk.Label(parent, text="100-0 km/h:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_100_0_label_val = tk.Label(parent, text="N/A", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)

        # --- Fuel Type ---
        self.details_sidebar_fuel_type_label_cat = tk.Label(parent, text="Fuel Type:", font=label_font_cat, bg=label_bg, fg=label_fg_cat, anchor=label_anchor, justify=label_justify)
        self.details_sidebar_fuel_type_label_val = tk.Label(parent, text="N/A", font=label_font_val, bg=label_bg, fg=label_fg_val, anchor=label_anchor, justify=label_justify, wraplength=label_wraplength)



        
     





    def _create_sidebar_buttons(self, zip_file):
        """Creates the action buttons in the details sidebar with flat style and hover/click effects."""
        self.details_buttons_frame = tk.Frame(self.details_sidebar_frame, bg="#333333")
        self.details_buttons_frame.pack(side="bottom", fill="x", pady=(0, 10), padx=10)

        button_width = 280 // 15
        button_style_args = self.button_style_args.copy()

        self.details_sidebar_show_details_button = tk.Button(self.details_buttons_frame, text="Customize Color", font=("Segoe UI", 10+self.font_size_add), width=button_width, **button_style_args)
        self.details_replace_current_button = tk.Button(self.details_buttons_frame, text="Replace Current", font=("Segoe UI", 10+self.font_size_add), width=button_width, **button_style_args)
        self.details_spawn_new_button = tk.Button(self.details_buttons_frame, text="Spawn New", font=("Segoe UI", 10+self.font_size_add), width=button_width, **button_style_args)
        self.details_add_to_queue_button = tk.Button(self.details_buttons_frame, text="Add to Spawn Queue", font=("Segoe UI", 10+self.font_size_add), width=button_width, **button_style_args)
        self.details_sidebar_favorites_button = tk.Button(self.details_buttons_frame, text="Add to Favorites", font=("Segoe UI", 10+self.font_size_add), width=button_width, **button_style_args)


        if self.items_to_be_hidden: # fav button disabled now because it updates the main grid which messes with the selected hidden items
            buttons = [
                self.details_sidebar_show_details_button,
                self.details_replace_current_button,
                self.details_spawn_new_button,
                #self.details_add_to_queue_button,
                #self.details_sidebar_favorites_button
            ]
        else:
            buttons = [
                self.details_sidebar_show_details_button,
                self.details_replace_current_button,
                self.details_spawn_new_button,
                #self.details_add_to_queue_button,
                self.details_sidebar_favorites_button
            ]

        for button in buttons:
            button.pack(side="top", fill="x", pady=(8, 0), padx=0)
            self._apply_details_sidebar_button_effects(button) # Apply hover and click effects

        if zip_file == "user_custom_configs":
            pass # No changes for custom configs in sidebar button set
        else:
            if hasattr(self, 'details_delete_custom_config_button') and self.details_delete_custom_config_button:
                self.details_delete_custom_config_button.pack_forget()

        self.details_sidebar_show_details_button.config(command=self.on_details_sidebar_show_details_click)
        self.details_replace_current_button.config(command=lambda: self.on_replace_current_button_click(spawn_cmd=None, event=None))
        self.details_spawn_new_button.config(command=lambda: self.on_spawn_new_button_click(spawn_cmd=None, event=None))
        #self.details_add_to_queue_button.config(command=self.on_add_to_queue_button_click)
        self.details_sidebar_favorites_button.config(command=self.on_details_sidebar_favorites_click)
        




    def _apply_details_sidebar_button_effects(self, button):
        """
        Applies smooth hover animation effects to a details sidebar button using the
        standard binder, and removes custom click flash.
        Relies on the button's activebackground/activeforeground for click feedback.
        """
        # --- Get Default Colors ---
        # Assuming self.button_style_args holds the correct defaults for these buttons
        try:
            original_bg = self.button_style_args['bg']
            original_fg = self.button_style_args['fg']
        except (AttributeError, KeyError):
            # Fallback if self.button_style_args is missing or doesn't have keys
            print("Warning: self.button_style_args not found or missing keys. Using default colors for sidebar button effects.")
            original_bg = "#555555"
            original_fg = "#FFFFFF"

        # --- Define Hover Foreground ---
        hover_fg = "#FFFFFF" # Standard hover foreground

        # REMOVED: Definitions for default_bg/fg, hover_bg/fg, click_bg/fg are not needed here
        # REMOVED: Local handler functions (on_enter, on_leave, on_click, on_release)

        # --- Bind using the standard animated hover helper ---
        # Assumes self._bind_animated_hover exists
        self._bind_animated_hover(
            button=button,
            original_bg=original_bg,
            original_fg=original_fg,
            hover_target_fg=hover_fg,
            # Set check_state=True if these sidebar buttons might be disabled,
            # otherwise set to False. Let's assume they might be disabled for safety.
            check_state=True
        )


        

    def on_details_sidebar_favorites_click(self):
        """Handles click on the 'Add to Favorites' button in the details sidebar.
           MODIFIED: Auto-navigates to "View All" if last favorite removed from folder.
        """
        print("\n--- on_details_sidebar_favorites_click() DEBUG - FUNCTION ENTRY ---")  # <-- ADD THIS LINE

        if not hasattr(self, 'current_details_sidebar_spawn_cmd') or not self.current_details_sidebar_spawn_cmd:
            print("Warning: Configuration details not available for Add to Favorites action.")
            return
        


        spawn_cmd = self.current_details_sidebar_spawn_cmd
        folder_name = self.current_details_folder
        config_name_base = self.extract_name_from_spawn_command(spawn_cmd)
        pc_filename = config_name_base + '.pc'

        
        self._count_unique_folders_in_favorites(called_to_retrieve_old_current_favorites_amount=True)

        unique_favorite_folder_count_before_fav_update = self.current_favorites_amount

        if self.is_favorite(folder_name, pc_filename):
            self.remove_from_favorites(folder_name, pc_filename)
            self.details_sidebar_favorites_button.config(text="Add to Favorites")
            #response = messagebox.showinfo("Favorites Update", "Removed from Favorites", parent=self.details_window)
            action_type = "removed"
            print(f"DEBUG: on_details_sidebar_favorites_click - Action: Removed from favorites, action_type: {action_type}") # DEBUG

            # --- MODIFIED: Check for page navigation after favorite removal ---
            if self.details_window_is_favorites_filtered:
                print("DEBUG: on_details_sidebar_favorites_click - Details window is in Favorites mode, checking page navigation after favorite removal.")


                start_index = self.details_page * self.items_per_page

                end_index = start_index + self.items_per_page

                items_on_current_page_before_deletion = self.details_filtered_data[start_index:end_index]

                # --- NEW: Check if this was the last favorite for the folder ---
                remaining_favorites_in_folder = 0
                for fav_config in self.favorite_configs:
                    fav_folder, fav_pc_file = fav_config.split('|')
                    if fav_folder == folder_name:
                        remaining_favorites_in_folder += 1
                print(f"DEBUG: on_details_sidebar_favorites_click - Remaining favorites in folder '{folder_name}': {remaining_favorites_in_folder}")


                if remaining_favorites_in_folder <= 0: # If no favorites left for this folder AFTER deletion
                    print(f"  DEBUG: Last favorite removed from folder '{folder_name}'. Switching to 'View All' mode after messagebox.")

                    def switch_to_view_all(): # Define a function to switch to View All mode
                        if self.details_window and not self.details_window_closed: # Check if window still exists
                            self.toggle_favorites_mode_details_window() # Toggle to 'View All' mode
                            print("DEBUG: on_details_sidebar_favorites_click - Switched to 'View All' mode (after messagebox).")

                    self.master.after(200, switch_to_view_all) # Schedule toggle after messagebox closes
                else:
                    # (Existing page navigation logic if current page becomes empty, unchanged)
                    if self.details_page > 0 and len(items_on_current_page_before_deletion) <= 1:
                        self.details_page -= 1
                    self.refresh_details_grid_after_favorite_change()

                    print("    on_details_sidebar_favorites_click is calling self.perform_search()")
                    self.perform_search()
                    self._update_details_pagination_bar()
                    print("DEBUG: on_details_sidebar_favorites_click - Navigated to previous page and refreshed UI.")
                # --- MODIFIED: Check for page navigation after favorite removal ---
            else:
                print("DEBUG: on_details_sidebar_favorites_click - Details window is NOT in Favorites mode, skipping page navigation.")


        else:
            self.add_to_favorites(folder_name, pc_filename)
            self.details_sidebar_favorites_button.config(text="Remove from Favorites")
            #messagebox.showinfo("Favorites Update", "Added to Favorites", parent=self.details_window)
            action_type = "added"
            print(f"DEBUG: on_details_sidebar_favorites_click - Action: Added to favorites, action_type: {action_type}") # DEBUG

            if self.details_window_is_favorites_filtered:
                print("DEBUG: on_details_sidebar_favorites_click - Details window IS in Favorites mode, refreshing grids after favorite addition.")
                self.refresh_details_grid_after_favorite_change()
                print("    on_details_sidebar_favorites_click is calling self.perform_search()")
                self.perform_search()


        self.update_details_sidebar_favorites_button_text() # Call update to ensure correct text after any action
        self.lift_search_results_window()

        generate_data_subset_favorites(self.script_dir)

        self._count_unique_folders_in_favorites(called_to_retrieve_old_current_favorites_amount=None)
        unique_favorite_folder_count_after_fav_update = self.current_favorites_amount


        if unique_favorite_folder_count_before_fav_update != unique_favorite_folder_count_after_fav_update:
            self.format_grouped_data_and_update_grid_layout()
            print(f"favorites folder amount CHANGED, defering format grouped and update grid funcs")

        print("--- on_details_sidebar_favorites_click() EXIT ---\n")
 

    def format_grouped_data_and_update_grid_layout(self):
        self.grouped_data = self.format_grouped_data(self.data) # Re-group and re-sort

        print("self.window_size_changed_during_details_window = True this has been set to true so that the grid can relayout to show the removed or added fav")
        self.window_size_changed_during_details_window = True # using this flag to force updating grid layout after details close

        self.favorites_amount_changed = True # use for search results deferal




    def _count_unique_folders_in_favorites(self, called_to_retrieve_old_current_favorites_amount=None):
        """
        Reads the favorites file and counts the number of unique folder names.

        Returns:
            int: The count of unique folder names found in favorites.txt.
                 Returns 0 if the file doesn't exist or is empty.
        """
        unique_folders = set()
        if not hasattr(self, 'favorites_file_path') or not self.favorites_file_path:
            print("Warning: favorites_file_path attribute not set. Cannot count favorite folders.")
            return 0

        if os.path.exists(self.favorites_file_path):
            try:
                with open(self.favorites_file_path, 'r', encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if line: # Ensure line is not empty
                            parts = line.split('|', 1) # Split only on the first '|'
                            if len(parts) > 0:
                                folder_name = parts[0].strip()
                                if folder_name: # Ensure folder_name is not empty
                                    unique_folders.add(folder_name)
                print(f"  DEBUG: _count_unique_folders_in_favorites - Found {len(unique_folders)} unique folders in {self.favorites_file_path}")
                
                if not called_to_retrieve_old_current_favorites_amount:

                    self.current_favorites_amount = len(unique_folders)

                return len(unique_folders)
            
            except Exception as e:
                print(f"Error reading or parsing {self.favorites_file_path}: {e}")
                return 0 # Return 0 on error
        else:
            print(f"Warning: Favorites file not found at {self.favorites_file_path}. Returning 0 unique folders.")
            return 0




    def update_details_sidebar_favorites_button_text(self):
        """Updates the text of the 'Add to Favorites' button in the details sidebar based on favorite status.
        DEBUGGED: Added rigorous debugging to track button state and favorite check.
        MODIFIED: Now checks favorite status of the CURRENT SIDEBAR CONFIG, not just first config. <--- MODIFIED
        """
        print("\n--- update_details_sidebar_favorites_button_text() DEBUG ---") # Debug: Function entry

        if not hasattr(self, 'current_details_sidebar_spawn_cmd') or not self.current_details_sidebar_spawn_cmd:
            print("  DEBUG: No current_details_sidebar_spawn_cmd set. Defaulting button text to 'Add to Favorites'.") # Debug: No spawn_cmd
            self.details_sidebar_favorites_button.config(text="Add to Favorites") # Default text if no config loaded
            print("--- update_details_sidebar_favorites_button_text() EXIT (No spawn_cmd) ---\n") # Debug: Function exit - no spawn_cmd
            return # Exit if no config loaded in sidebar

        spawn_cmd = self.current_details_sidebar_spawn_cmd
        folder_name = self.current_details_folder # Use current_details_folder, which should be updated on item click
        config_name_base = self.extract_name_from_spawn_command(spawn_cmd)
        pc_filename = config_name_base + '.pc'

        print(f"  DEBUG: Checking favorite status for CURRENT SIDEBAR CONFIG:") # Debug: Checking for config - MODIFIED MESSAGE
        print(f"    - Folder Name (self.current_details_folder): {folder_name}") # Debug: Folder Name - CHECK THIS
        print(f"    - PC Filename Base (extracted from spawn_cmd): {config_name_base}") # Debug: PC Filename Base - CHECK THIS
        print(f"    - PC Filename (constructed): {pc_filename}") # Debug: PC Filename - CHECK THIS
        print(f"    - Full Spawn Command (self.current_details_sidebar_spawn_cmd): {spawn_cmd}") # Debug: Full Spawn Command - CHECK THIS

        is_currently_favorite = self.is_favorite(folder_name, pc_filename)
        print(f"  DEBUG: is_favorite() check result: {is_currently_favorite}") # Debug: is_favorite result

        print("  DEBUG: Current favorite_configs set:") # Debug: Favorite Configs Set
        for fav_config in self.favorite_configs:
            print(f"    - {fav_config}") # Debug: Print each favorite config

        if is_currently_favorite:
            button_text = "Remove from Favorites"
            print("  DEBUG: Configuration IS a favorite. Setting button text to: 'Remove from Favorites'") # Debug: Set button text - Remove
        else:
            button_text = "Add to Favorites"
            print("  DEBUG: Configuration is NOT a favorite. Setting button text to: 'Add to Favorites'") # Debug: Set button text - Add
        self.details_sidebar_favorites_button.config(text=button_text)

        print("--- update_details_sidebar_favorites_button_text() EXIT ---\n") # Debug: Function exit
        
    def toggle_details_favorites_filter(self): #unfinished
        """
        Toggles the Favorites filter in the details window and updates the button text.
        DEBUGGING: Added debug prints to track flag values in toggle_details_favorites_filter.
        """
        print("\n--- toggle_details_favorites_filter() ENTRY ---") # Debug Entry
        print(f"  DEBUG: toggle_details_favorites_filter - Before toggle - details_is_favorites_filter_active: {self.details_is_favorites_filter_active}") # Debug - Before Toggle
        self.details_is_favorites_filter_active = not self.details_is_favorites_filter_active # Toggle state
        print(f"  DEBUG: toggle_details_favorites_filter - After toggle - details_is_favorites_filter_active: {self.details_is_favorites_filter_active}") # Debug - After Toggle

        if self.details_is_favorites_filter_active:
            filter_text = "Filter: Favorites Only"
            print("  DEBUG: toggle_details_favorites_filter - Setting button text to 'Filter: Favorites Only'") # Debug - Button Text Set - Favorites Only
        else:
            filter_text = "Filter: Show All"
            print("  DEBUG: toggle_details_favorites_filter - Setting button text to 'Filter: Show All'") # Debug - Button Text Set - Show All
        self.details_favorites_filter_button.config(text=filter_text) # Update button text

        self.apply_details_favorites_filter() # Call function to re-filter and rebuild grid
        print("--- toggle_details_favorites_filter() EXIT ---\n") # Debug Exit

    def apply_details_favorites_filter(self): # <--- NEW FUNCTION
        """
        Applies the Favorites filter to the details window's data and rebuilds the grid.
        """
        if self.details_is_favorites_filter_active:
            print("DEBUG: Applying Favorites Filter in Details Window.")
            favorite_configs_set = self.read_favorites()
            filtered_data = []
            for item in self.details_data:
                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                fav_key = f"{folder_name}|{config_name}.pc"
                if fav_key in favorite_configs_set:
                    filtered_data.append(item)
            self.details_filtered_data = filtered_data # Update filtered data
        else:
            print("DEBUG: Removing Favorites Filter in Details Window (Showing All).")
            self.details_filtered_data = self.details_data[:] # Show all data

        self.rebuild_simple_details() # Rebuild the details grid with filtered data
        if self.details_count_label:
            self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}") # Update count



    open_color_mode = False
    def on_details_sidebar_show_details_click(self):
        """Handles click on the 'Show Details' button in the details sidebar.
           Opens the Configuration Details window for the current sidebar config.
           Now with more robust data retrieval for spawn_cmd and related info.
       
         """
        ConfigViewerApp.open_color_mode = True

        spawn_cmd = self.current_details_sidebar_spawn_cmd
        info_data = self.current_details_sidebar_info_data
        picture_path = self.current_details_sidebar_picture_path
        zip_file = self.current_details_sidebar_zip_file
        folder_name = self.current_details_folder # Assuming current_details_folder is set appropriately
        zip_file_base_name = self.current_details_zip_file # Using zip_file as fallback for base name
        config_name = self.extract_name_from_spawn_command(spawn_cmd)

        if spawn_cmd and info_data and picture_path and zip_file and folder_name and zip_file_base_name and config_name:
            print("DEBUG: on_details_sidebar_show_details_click - All data available, opening detail window.") # Debug
            self.open_detail_info_window(spawn_cmd, info_data, picture_path, zip_file, folder_name, zip_file_base_name, config_name)
        else:
            print("Warning: Spawn command or related data NOT AVAILABLE for Show Details action.") # Original warning
            if not spawn_cmd: print("  - spawn_cmd is missing")
            if not info_data: print("  - info_data is missing")
            if not picture_path: print("  - picture_path is missing")
            if not zip_file: print("  - zip_file is missing")
            if not folder_name: print("  - folder_name is missing")
            if not zip_file_base_name: print("  - zip_file_base_name is missing")
            if not config_name: print("  - config_name is missing")
        
        if ConfigViewerApp.open_color_mode:
            self.customize_color_config(spawn_cmd, folder_name)
            ConfigViewerApp.open_color_mode = False



    def read_favorites(self):
        """
        Reads Favorites.txt, checks against WatcherOutput.txt AND zip_structure.txt
        for config existence, and returns a set of valid favorite configurations.
        """
        favorites = set()
        valid_favorites = set()
        watcher_filepaths = set() # Set to store filepaths from WatcherOutput.txt
        zip_structure_lines = set() # Set to store lines from zip_structure.txt


        watcher_output_file = os.path.join(self.script_dir, "data/WatcherOutput.txt")
        zip_structure_file = os.path.join(self.script_dir, "data/zip_structure.txt") # Define zip_structure.txt path


        backup_watcher_output_file = os.path.join(self.script_dir, "data/backup/WatcherOutput.txt")
        backup_zip_structure_file = os.path.join(self.script_dir, "data/backup/zip_structure.txt")



        if os.path.exists(backup_zip_structure_file):

            print(f"backup input files exist (read_favorites)")

            zip_structure_file = backup_zip_structure_file
            watcher_output_file = backup_watcher_output_file

            



        # --- 1. Read Favorites.txt ---
        if os.path.exists(self.favorites_file_path):
            with open(self.favorites_file_path, 'r', encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if line:
                        favorites.add(line)

        # --- 2. Read WatcherOutput.txt and collect filepaths ---
        if os.path.exists(watcher_output_file):
            check_mods, check_configs, user_vehicles_files, config_pics_custom_files, mods_files, repo_files, vanilla_files, last_zip_count = read_watcher_output(watcher_output_file)
            # Collect all filepaths from WatcherOutput.txt
            watcher_filepaths.update(user_vehicles_files.keys())
            watcher_filepaths.update(config_pics_custom_files.keys())
            watcher_filepaths.update(mods_files.keys())
            watcher_filepaths.update(repo_files.keys())
            watcher_filepaths.update(vanilla_files.keys())

        # --- NEW: 3. Read zip_structure.txt and collect lines ---
        if os.path.exists(zip_structure_file):
            try:
                with open(zip_structure_file, 'r', encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if line:
                            zip_structure_lines.add(line) # Add each line from zip_structure.txt
            except Exception as e:
                print(f"Warning: Error reading zip_structure.txt: {e}")
        # --- NEW: 3. Read zip_structure.txt and collect lines ---


        # --- 4. Check favorites against WatcherOutput and zip_structure ---
        for fav_key in favorites:
            parts = fav_key.split('|')
            if len(parts) == 2:
                folder_name, pc_filename = parts
                pc_filename_base = os.path.splitext(pc_filename)[0] # Get base name without extension
                search_substring = f"{folder_name.lower()}/{pc_filename_base.lower()}" # Construct substring for search

                found_in_watcher_output = False
                for filepath in watcher_filepaths:
                    normalized_filepath = filepath.lower().replace('\\', '/')
                    if search_substring in normalized_filepath: # Check if substring is IN filepath
                        found_in_watcher_output = True
                        break # No need to check other filepaths if found

                # --- NEW: Check in zip_structure_lines if not found in WatcherOutput ---
                found_in_zip_structure = False
                if not found_in_watcher_output: # Only check zip_structure if NOT found in WatcherOutput
                    for zip_line in zip_structure_lines:
                        normalized_zip_line = zip_line.lower().replace('\\', '/')
                        if search_substring in normalized_zip_line: # Check if substring is IN zip_structure line
                            found_in_zip_structure = True
                            break # No need to check other zip_structure lines if found
                # --- NEW: Check in zip_structure_lines if not found in WatcherOutput ---


                if found_in_watcher_output or found_in_zip_structure: # MODIFIED CHECK - OR condition
                    valid_favorites.add(fav_key) # Add to valid favorites if found in either file
                else:
                    print(f"DEBUG: Favorite '{fav_key}' not found in WatcherOutput.txt OR zip_structure.txt, removing from favorites.") # Debug print for removed favorite
            else:
                print(f"Warning: Invalid favorite key format: '{fav_key}'. Skipping.") # Warning for invalid format

        # --- 5. Update favorites and write back to file ---
        if valid_favorites != favorites: # Only write if there were changes
            self.favorite_configs = valid_favorites

            self.write_favorites()
            self.unique_favorite_folder_count = self._count_unique_folders_in_favorites() # Update the count
            print(f"DEBUG: Updated unique_favorite_folder_count to: {self.unique_favorite_folder_count}")



            print("DEBUG: Favorites.txt updated, invalid entries removed.") # Debug print for update
        else:
            self.favorite_configs = valid_favorites # Ensure self.favorite_configs is updated even if no changes to write
            print("DEBUG: No invalid favorites found, Favorites.txt not updated.") # Debug print for no update


        return self.favorite_configs


    def write_favorites(self):
        """Writes the current set of favorite configurations to Favorites.txt."""



        try:
            with open(self.favorites_file_path, "w", encoding="utf-8") as f:
                for fav in sorted(list(self.favorite_configs)):
                    f.write(fav + "\n")
            print("Successfully wrote favorites to Favorites.txt") # Confirmation message
        except Exception as e:
            print(f"Error writing to Favorites.txt: {e}") # Error handling message
  
  

    def is_favorite(self, vehicle_folder, pc_filename):
        """Checks if a configuration is in the favorites list."""
        fav_key = f"{vehicle_folder}|{pc_filename}"
        return fav_key in self.favorite_configs




    def add_to_favorites(self, vehicle_folder, pc_filename):
        """Adds a configuration to the favorites list and updates Favorites.txt, showing a scanning window."""
        scanning_win = None  # Initialize scanning_win
        try:
            scanning_win = self.show_scanning_window(text="Added to Favorites")
            fav_key = f"{vehicle_folder}|{pc_filename}"
            self.favorite_configs.add(fav_key)
            self.write_favorites()

            self.unique_favorite_folder_count = self._count_unique_folders_in_favorites() # Update the count
            print(f"DEBUG: Updated unique_favorite_folder_count to: {self.unique_favorite_folder_count}")

        except Exception as e:
            print(f"Error in add_to_favorites: {e}")
            messagebox.showerror("Error", f"Error adding to favorites: {e}", parent=self.master)  # Show error messagebox
        finally:
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return

    def remove_from_favorites(self, vehicle_folder, pc_filename):
        """Removes a configuration from the favorites list and updates Favorites.txt, showing a scanning window."""
        scanning_win = None  # Initialize scanning_win
        try:
            scanning_win = self.show_scanning_window(text="Removed from Favorites")
            fav_key = f"{vehicle_folder}|{pc_filename}"
            if fav_key in self.favorite_configs:
                self.favorite_configs.remove(fav_key)
                self.write_favorites()

                self.unique_favorite_folder_count = self._count_unique_folders_in_favorites() # Update the count
                print(f"DEBUG: Updated unique_favorite_folder_count to: {self.unique_favorite_folder_count}")


        except Exception as e:
            print(f"Error in remove_from_favorites: {e}")
            messagebox.showerror("Error", f"Error removing from favorites: {e}", parent=self.master) # Show error messagebox
        finally:
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return

 


    def _initial_details_layout(self, subgrid_data, zip_file, search_query=""):
        """Handles initial layout logic after the details window is drawn."""

        def initial_layout_logic():
            print("\n--- _initial_details_layout.initial_layout_logic() DEBUG ---")
            print(f"  DEBUG: initial_layout - Received zip_file: {zip_file}") # zip_file here is the CATEGORY ('folder_grouped')

            # Use the provided subgrid_data directly - DO NOT FLATTEN
            filtered_subgrid_data = subgrid_data
            print(f"DEBUG: _initial_details_layout - Using subgrid_data directly. Total items: {len(filtered_subgrid_data)}")

            # --- Define Helper Function for Sorting (File Reading Version) ---
            # --- Define Helper Function for Sorting (File Reading Version - ADJUSTED) ---
            def get_config_value(item):
                """
                Helper function to extract 'Value' from the corresponding JSON file
                and safely convert to float for sorting.
                ADAPTED for _load_individual_info returning (dict, file_content_string).
                """
                default_sort_value = float('-inf') # Errors/missing go last in ascending sort

                try:
                    # --- Structure Check ---
                    if not isinstance(item, (list, tuple)) or len(item) != 5:
                        print(f"WARN: get_config_value - Invalid item structure encountered: Type={type(item)}, Len={len(item) if isinstance(item, (list, tuple)) else 'N/A'}")
                        try: item_preview = str(item)[:100]
                        except Exception: item_preview = "[Unrepresentable Item]"
                        print(f"   Problematic Item Preview: {item_preview}...")
                        return default_sort_value
                    # --- End Structure Check ---

                    # Unpack item components
                    picture_path, spawn_cmd, item_zip_file, _, folder_name = item

                    # --- File Reading Logic ---
                    if not all([spawn_cmd, item_zip_file, folder_name]):
                         print(f"WARN: get_config_value - Missing data for item: {str(item)[:100]}")
                         return default_sort_value

                    # Handle potential 'folder_grouped' - needs verification
                    if item_zip_file == "folder_grouped":
                         print(f"DEBUG: get_config_value - Encountered 'folder_grouped'. Need logic to find original zip for {spawn_cmd}")
                         # Add fallback logic here if possible, otherwise return default
                         return default_sort_value # Cannot proceed without actual zip

                    zip_file_base_name = os.path.splitext(item_zip_file)[0]
                    config_name = self.extract_name_from_spawn_command(spawn_cmd)
                    if not config_name or config_name.startswith("UnknownConfig") or config_name.startswith("Error"):
                         print(f"WARN: get_config_value - Could not determine config name for {spawn_cmd}")
                         return default_sort_value

                    individual_info_path = self.find_individual_info_file(
                        folder_name, zip_file_base_name, config_name
                    )
                    # print(f"DEBUG: get_config_value - Looking for info file at: {individual_info_path}") # Verbose

                    value = default_sort_value # Start with default

                    if individual_info_path:
                        # Call _load_individual_info which returns (dict, file_content_string)
                        individual_info_dict, file_content_debug = self._load_individual_info(individual_info_path)

                        # --- **** CORRECTED SUCCESS CHECK **** ---
                        # Check if the *first* returned element is a non-empty dictionary.
                        # This indicates _load_individual_info succeeded in extracting info.
                        if isinstance(individual_info_dict, dict) and individual_info_dict:
                            # Successfully loaded/extracted info, proceed to get 'Value'
                            value_str = individual_info_dict.get("Value", None)
                            if value_str is not None:
                                try:
                                    value = float(value_str)
                                    # print(f"DEBUG: get_config_value - Extracted Value: {value} for {config_name}") # Verbose success
                                except (ValueError, TypeError):
                                    print(f"WARN: get_config_value - Could not convert 'Value' ({value_str}) to float for Cmd: {spawn_cmd} from file: {individual_info_path}")
                                    # Keep default value
                            # else: 'Value' key missing, keep default
                        else:
                            # Load failed or returned empty dict, use default value.
                            # The file_content_debug might contain raw text, but we treat this as failure for sorting.
                            # Avoid printing the full file content here unless debugging specific load failures.
                            if not individual_info_path or not os.path.exists(individual_info_path):
                                # Don't warn if the file genuinely doesn't exist (already handled by _load_individual_info print)
                                pass
                            else:
                                # Warn if the file exists but info extraction failed (returned empty dict)
                                print(f"WARN: get_config_value - Info extraction failed (got empty dict) for file: {individual_info_path}")
                            # Keep default value
                        # --- **** END CORRECTED SUCCESS CHECK **** ---

                    # else: find_individual_info_file returned None or empty string, keep default value
                    return value

                except Exception as e:
                    try: item_str_preview = str(item)[:100]
                    except Exception: item_str_preview = "[Unrepresentable Item]"
                    print(f"ERROR: Unexpected error in get_config_value for item preview {item_str_preview}...: {e}")
                    # traceback.print_exc() # Uncomment for full traceback during debugging
                    return default_sort_value

            print("DEBUG: _initial_details_layout - Sorting subgrid_data by 'Value' (ascending)...")
            # Sort ascending (lowest to highest) - remove reverse=True
            filtered_subgrid_data.sort(key=get_config_value)
            print("DEBUG: _initial_details_layout - subgrid_data SORTED by 'Value'.")

            # --- Calculate the info path for the FIRST item AFTER sorting ---
            # This logic should now work if sorting is successful and data structure is correct
            first_item_info_path = None
            if filtered_subgrid_data:
                try:
                    # Get the first item (should be the one with the lowest 'Value')
                    first_item = filtered_subgrid_data[0]
                    # Check structure *again* before unpacking, just in case sort failed silently
                    if isinstance(first_item, (list, tuple)) and len(first_item) == 5:
                        picture_path, spawn_cmd, item_zip_file, info_data, folder_name = first_item
                        zip_file_base_name = os.path.splitext(item_zip_file)[0]
                        config_name = self.extract_name_from_spawn_command(spawn_cmd)
                        if config_name and not config_name.startswith("UnknownConfig"):
                            first_item_info_path = self.find_individual_info_file(
                                folder_name, zip_file_base_name, config_name
                            )
                            print(f"DEBUG: _initial_details_layout - Calculated info path for first item (lowest value): {first_item_info_path}")
                        else:
                             print(f"WARN: Could not determine config name for the first sorted item's command: {spawn_cmd}")
                    else:
                        print(f"WARN: First item after sorting has unexpected structure: {str(first_item)[:100]}")

                except Exception as e:
                    # This catch block might be hit if unpacking fails even after the check
                    print(f"ERROR: Could not determine info path for the first sorted item: {e}")
                    # traceback.print_exc() # Uncomment for debugging
            else:
                print("DEBUG: _initial_details_layout - Filtered data is empty, no first item info path to calculate.")
            # --- End Calculation for first item ---


            # --- Calculate paged_data for the initial page ---
            if not hasattr(self, 'details_page'): self.details_page = 0
            # Ensure items_per_page is valid
            items_per_page = getattr(self, 'items_per_page', 50) # Default if missing
            if not isinstance(items_per_page, int) or items_per_page <= 0: items_per_page = 50

            start_index = self.details_page * items_per_page
            end_index = start_index + items_per_page
            paged_data = filtered_subgrid_data[start_index:end_index]

            print(f"  DEBUG: Initial Load - paged_data calculated for first page (page {self.details_page}), item count: {len(paged_data)}")
            print(f"  DEBUG: items_per_page: {items_per_page}")

            details_batch_size = getattr(self, 'details_batch_size', 10) # Default if missing
            if not isinstance(details_batch_size, int) or details_batch_size <= 0: details_batch_size = 10
            print(f"  DEBUG: details_batch_size: {details_batch_size}")


            self.details_batches = [
                paged_data[i: i + details_batch_size]
                for i in range(0, len(paged_data), details_batch_size)
            ]
            print(f"  DEBUG: Initial Load - Number of batches created: {len(self.details_batches)}")
            if self.details_batches:
                print(f"  DEBUG: Initial Load - Size of first batch: {len(self.details_batches[0]) if self.details_batches else 0}")

            # --- DEBUG Inspect first batch (should show proper filenames now) ---
            if self.details_batches and self.details_batches[0]:
                print("  DEBUG: First 3 items in the FIRST batch (picture paths):")
                for i in range(min(3, len(self.details_batches[0]))):
                    item = self.details_batches[0][i]
                    # Check item structure robustly before accessing index 0
                    if isinstance(item, (list, tuple)) and len(item) > 0 and isinstance(item[0], str):
                        print(f"    - Item {i+1}: {os.path.basename(item[0])}")
                    elif isinstance(item, (list, tuple)):
                         print(f"    - Item {i+1}: Item tuple/list OK, but picture path (item[0]) is missing or not a string.")
                    else:
                        print(f"    - Item {i+1}: Item data is not a list/tuple or is empty.")
            else:
                print("  DEBUG: First batch is EMPTY or NO batches created.")
            # --- END DEBUG ---

            # Initialize state variables
            self.current_details_batch_index = 0
            self.current_details_batch_index_in_sequence = 0 # Assuming this is used elsewhere (likely no)
            self.total_details_items_placed = 0 # Assuming this is used elsewhere (it is)
            print(f"DEBUG: _initial_details_layout - ENSURING state before load: batch_idx={self.current_details_batch_index}, seq_idx={self.current_details_batch_index_in_sequence}, total_placed={self.total_details_items_placed}")

            # Load initial batch if data exists
            if self.details_batches:
                # Start loading animations/progress bars only if they exist
                if hasattr(self, 'start_details_loading_animation'): self.start_details_loading_animation()
                if hasattr(self, 'show_progress_bar_details'): self.show_progress_bar_details()

                print("DEBUG: _initial_details_layout - Calling load_next_batch_details() NOW...")
                if hasattr(self, 'load_next_batch_details'):
                    self.load_next_batch_details()
                    print("DEBUG: _initial_details_layout - load_next_batch_details() RETURNED.")
                else:
                    print("ERROR: load_next_batch_details method not found!")
            else:
                print("DEBUG: _initial_details_layout - No items/batches for this page. Skipping load.")
                if hasattr(self, 'stop_details_loading_animation'): self.stop_details_loading_animation()
                if hasattr(self, 'hide_progress_bar_details'): self.hide_progress_bar_details()

            print("  DEBUG: Calling _set_initial_sidebar_content from initial_layout...")
            # Ensure method exists and handle potential errors from it
            if hasattr(self, '_set_initial_sidebar_content'):
                try:
                    # Pass the potentially corrected first_item_info_path
                    self._set_initial_sidebar_content(filtered_subgrid_data, zip_file, first_item_info_path)
                    print("  DEBUG: _set_initial_sidebar_content RETURNED.")
                except Exception as e:
                    print(f"ERROR: Exception during _set_initial_sidebar_content: {e}")
                    # Maybe provide default sidebar content or just log the error
                    # traceback.print_exc() # Uncomment for debugging the sidebar error specifically
            else:
                 print("WARN: _set_initial_sidebar_content method not found.")


            # Update UI elements safely
            if hasattr(self, 'details_count_label') and self.details_count_label:
                try:
                    self.details_count_label.config(text=f"Total: {len(filtered_subgrid_data)}")
                except Exception as e:
                    print(f"ERROR: Failed to update details_count_label: {e}")

            print("  DEBUG: Details window initial layout mostly complete.")

            # Call subsequent UI updates safely
            if hasattr(self, '_update_details_pagination_bar'): self._update_details_pagination_bar()
            if hasattr(self, '_schedule_sidebar_update_from_image'): self._schedule_sidebar_update_from_image()

            if hasattr(self, 'details_window') and self.details_window:
                # Use try-except for safety if lambda target might not exist
                try:
                    self.details_window.after_idle(lambda: setattr(self, 'details_sidebar_update_locked', True))
                except Exception as e:
                    print(f"ERROR: Failed to schedule details_sidebar_update_locked: {e}")

            print("--- _initial_details_layout.initial_layout_logic() DEBUG EXIT ---\n")

            # Update favorites button safely
            if hasattr(self, 'details_view_favorites_button') and self.details_view_favorites_button:
                try:
                    is_fav_filtered = getattr(self, 'details_window_is_favorites_filtered', False)
                    if is_fav_filtered:
                        self.details_view_favorites_button.config(text="View All")
                    else:
                        self.details_view_favorites_button.config(text="View Favorites")
                except Exception as e:
                     print(f"ERROR: Failed to update details_view_favorites_button text: {e}")

        # Schedule the initial layout logic
        if hasattr(self, 'details_window') and self.details_window:
            self.details_window.after(10, initial_layout_logic)
        else:
            print("ERROR: _initial_details_layout - Details window does not exist. Cannot schedule layout.")
            # Consider if initial_layout_logic should run anyway in some cases,
            # or if this indicates a prior failure.




    def _set_initial_sidebar_content(self, subgrid_data, zip_file, individual_info_path=None):
        """
        Sets the initial content of the details sidebar based on default or first item.
        REVISED AGAIN: Fixes UnboundLocalError and config name label timing.
        """
        print("\n--- _set_initial_sidebar_content() DEBUG (Revised: Fix Default + Elif Logic) ---")
        print(f"  DEBUG: Received zip_file ARGUMENT (category): {zip_file}")

        default_config_item = self.find_default_config_item_details(subgrid_data, zip_file)

        # --- Variables to hold the data of the item being displayed ---
        item_to_display_data = None
        calculated_individual_path = None # Path calculated specifically for the item being displayed

        if default_config_item:
            print("  DEBUG: Default config item FOUND, using default config for sidebar...")
            # Unpack data from the default item
            default_picture_path, default_spawn_cmd, default_item_zip_file, default_info_data, folder_name = default_config_item
            item_to_display_data = default_config_item # Store the tuple

            print(f"  DEBUG: Default config item's specific zip_file value: {default_item_zip_file}")
            print(f"  DEBUG: Default item's folder_name: {folder_name}")

            # --- Set sidebar instance state correctly for the DEFAULT item FIRST ---
            self.current_details_sidebar_spawn_cmd = default_spawn_cmd
            self.current_details_sidebar_info_data = default_info_data
            self.current_details_sidebar_picture_path = default_picture_path
            self.current_details_sidebar_zip_file = default_item_zip_file
            self.current_details_folder = folder_name
            self.is_details_sidebar_showing_default = True
            print(f"  DEBUG: Instance state updated for default item: folder='{self.current_details_folder}', spawn='{self.current_details_sidebar_spawn_cmd}'")

            # --- Calculate the CORRECT individual info path for THIS default item ---
            default_config_name = self.extract_name_from_spawn_command(default_spawn_cmd)
            correct_default_zip_base_name = os.path.splitext(default_item_zip_file)[0] if default_item_zip_file else None
            if folder_name and correct_default_zip_base_name and default_config_name:
                print(f"  DEBUG: Finding path with folder='{folder_name}', zip_base='{correct_default_zip_base_name}', config='{default_config_name}'")
                calculated_individual_path = self.find_individual_info_file(
                    folder_name, correct_default_zip_base_name, default_config_name
                )
                print(f"  DEBUG: Calculated default_individual_info_path = {calculated_individual_path}")
            else:
                print("  WARN: Could not calculate default individual info path due to missing components.")
                calculated_individual_path = None

        elif subgrid_data:
            # --- Fallback to first sorted item ---
            print("  DEBUG: No default config, using FIRST config from provided data for sidebar...")
            first_item = subgrid_data[0]
            item_to_display_data = first_item # Store the tuple
            # Unpack just for state setting and path calculation
            first_picture_path, first_spawn_cmd, first_item_zip_file, first_info_data, folder_name = first_item
            # Use the path calculated by the caller, as it pertains to this first sorted item
            calculated_individual_path = individual_info_path
            print(f"  DEBUG: Using pre-calculated path for first sorted item: {calculated_individual_path}")

            print(f"  DEBUG: First item's specific zip_file value: {first_item_zip_file}")
            print(f"  DEBUG: First item's folder_name: {folder_name}")

            # Set state for the first item
            self.current_details_sidebar_spawn_cmd = first_spawn_cmd
            self.current_details_sidebar_info_data = first_info_data
            self.current_details_sidebar_picture_path = first_picture_path
            self.current_details_sidebar_zip_file = first_item_zip_file
            self.current_details_folder = folder_name
            self.is_details_sidebar_showing_default = False # Showing first, not necessarily default
            print(f"  DEBUG: Instance state updated for first item: folder='{self.current_details_folder}', spawn='{self.current_details_sidebar_spawn_cmd}'")

        else:
            # --- Handle No Data (Keep existing logic) ---
            folder_name = self.current_details_folder
            print("  DEBUG: No subgrid data, sidebar will remain placeholder.")
            # Show messagebox logic...
            message = "No configurations available for item..."
            # ... (rest of messagebox logic) ...
            self.details_search_var.set("")
            self.perform_details_search()

            print("  DEBUG: Calling update_details_sidebar_favorites_button_text() - NO DATA case...")
            self.update_details_sidebar_favorites_button_text()
            print("  DEBUG: update_details_sidebar_favorites_button_text() RETURNED (NO DATA case).")
            print("--- _set_initial_sidebar_content() DEBUG EXIT (No Data) ---\n")
            return # Exit early if no data

        # --- COMMON UPDATE LOGIC (Runs if default OR first item was found) ---
        if item_to_display_data:
            # Unpack the data for the item we decided to display
            display_picture_path, display_spawn_cmd, display_item_zip_file, display_info_data, display_folder_name = item_to_display_data

            # --- Step 1: Update Config Name Label Text FIRST ---
            # Use the spawn command associated with the item being displayed
            print(f"  DEBUG: Calling update_details_sidebar_config_name for '{display_spawn_cmd}'...")
            self.update_details_sidebar_config_name(display_spawn_cmd) # Sets the text

            # --- Step 2: Call the function that updates most labels, PASSING the calculated path ---
            print(f"  DEBUG: Calling update_details_sidebar_individual_info with calculated path '{calculated_individual_path}'...")
            # Pass the main info data corresponding to the item being displayed
            self.update_details_sidebar_individual_info(calculated_individual_path, display_info_data)
            # This function handles loading individual data and packing the labels (including config name now)

            # --- Step 3: Update Car Name Label and Image ---
            # Car Name Label (uses main_info_data)
            brand = display_info_data.get("Brand", "").strip()
            name = display_info_data.get("Name", "").strip()
            vehicle_type = display_info_data.get("Type", "").strip()
            # FIX: Define display_name_text consistently
            display_name_text = "Unknown" # Default
            if brand: display_name_text = f"{brand} {name}" if name else (f"{brand} {vehicle_type}" if vehicle_type else brand)
            elif name: display_name_text = name
            elif vehicle_type: display_name_text = vehicle_type
            if hasattr(self, 'details_sidebar_car_name_label') and self.details_sidebar_car_name_label.winfo_exists():
                 print(f"  DEBUG: Setting car name label to: '{display_name_text}'")
                 self.details_sidebar_car_name_label.config(text=display_name_text)
            else:
                print("  WARN: details_sidebar_car_name_label not found.")

            # Image Loading (uses picture_path)
            print(f"  DEBUG: Loading image from path: {display_picture_path}")
            try:
                 photo = None
                 if display_picture_path and os.path.exists(display_picture_path):
                     # Add import for Image and ImageTk if not already globally available
                     # from PIL import Image, ImageTk
                     # Also ensure self.RESAMPLE_FILTER is defined (e.g., Image.Resampling.LANCZOS)
                     img = Image.open(display_picture_path).convert("RGB")
                     img = img.resize((280, 157), self.RESAMPLE_FILTER)
                     photo = ImageTk.PhotoImage(img)
                     print("  DEBUG: Image loaded and resized successfully.")
                 else: # Load placeholder if path invalid or missing
                     print(f"  WARN: Image path invalid or missing ('{display_picture_path}'), loading placeholder.")
                     placeholder_image = Image.new("RGB", (280, 157), "#333333")
                     photo = ImageTk.PhotoImage(placeholder_image)

                 if hasattr(self, 'details_sidebar_image_label') and self.details_sidebar_image_label.winfo_exists():
                    self.details_sidebar_image_label.config(image=photo, bg="#333333")
                    self.details_sidebar_image_label.image = photo # Keep reference
                    print("  DEBUG: Sidebar image label updated.")
                 else:
                    print("  WARN: details_sidebar_image_label not found.")
            except Exception as e:
                 print(f"ERROR loading details sidebar image in _set_initial_sidebar_content: {e}")
                 # Optional: Set placeholder on error here as well

            # Zip Label correction (just in case, though individual_info should handle it)
            self._ensure_correct_zip_label()

            # --- Step 4: Update favorites button (based on instance state already set) ---
            print(f"  DEBUG: Calling update_details_sidebar_favorites_button_text...")
            self.update_details_sidebar_favorites_button_text()

            print(f"  DEBUG: Initial sidebar content SET for {'DEFAULT' if self.is_details_sidebar_showing_default else 'FIRST'} config.")

        print("--- _set_initial_sidebar_content() DEBUG EXIT (Revised) ---\n")
        



    def format_filter_settings_for_messagebox(self):
        """
        Formats the currently active global filter settings into a user-readable string.
        Returns an empty string if no global filters are active or settings file is not found/readable.
        """
        if not self.is_data_subset_active:
            return "" # Return empty string if data subset is not active

        filter_settings = self.load_filter_settings() # Load current filter settings
        if not filter_settings:
            return "No filter criteria set in global filters." # Indicate no criteria set

        filter_info_lines = []
        for criterion, setting in filter_settings.items():
            if isinstance(setting, list): # For dual entries
                for entry_setting in setting:
                    if entry_setting['entry'] and entry_setting['button'] == "On": # Check if entry has text AND button is "On"
                        filter_info_lines.append(f"- {criterion} ({'Below' if entry_setting['index'] == 1 else 'Above'}): '{entry_setting['entry']}'")
            elif setting['entry'] and setting['button'] == "On": # For single entries, check if entry has text AND button is "On"
                filter_info_lines.append(f"- {criterion} (Contains): '{setting['entry']}'")

        if not filter_info_lines:
            return "Global filters are active, but no criteria are currently set to filter data." # Indicate active but no criteria

        return "\n".join(filter_info_lines) # Join lines into a single string for messagebox
  
  

    def _schedule_sidebar_update_from_image(self):
        """Schedules the sidebar update after image load."""
        def update_sidebar_from_image():
            """Helper function to update sidebar content based on image filename."""
            print("DEBUG: update_sidebar_from_image() called")
            try:
                photo_image = self.details_sidebar_image_label.image
                if hasattr(photo_image, 'filename'):
                    picture_path = photo_image.filename
                else:
                    print("WARNING: 'filename' attribute not found in PhotoImage object.")
                    picture_path = None

                if picture_path:
                    print(f"DEBUG: Sidebar image path from label: {picture_path}")
                    extracted_info = self.extract_info_from_sidebar_image(picture_path)
                    if extracted_info:
                        individual_info_path = self.find_individual_info_file(
                            extracted_info["folder_name"],
                            extracted_info["zip_file_base_name"],
                            extracted_info["config_name"]
                        )
                        print(f"  DEBUG: Determined individual_info_path from image: {individual_info_path}")
                        self.update_details_sidebar_individual_info(individual_info_path)
                    else:
                        print("  ERROR: Could not extract info from image filename after image load.")
                else:
                    print("  ERROR: Could not determine full image path after image load.")

            except Exception as e:
                print(f"  ERROR: Exception in update_sidebar_from_image: {e}")

        self.details_window.after(50, update_sidebar_from_image)
        print("--- display_subgrid_in_new_window() EXIT ---\n")  # Debug Exit



    # ------------------------------------------------------------
    # update details sidebar info
    # ------------------------------------------------------------

    def _load_individual_info(self, individual_info_path):
        """
        Loads and extracts information from the individual JSON file, now handling "Author".
        """
        extracted_info = {}
        file_content = ""

        if individual_info_path and os.path.exists(individual_info_path):
            # --- Check Cache First ---
            if individual_info_path in self.individual_info_cache:
                #print(f"DEBUG: _load_individual_info - Cache HIT for: {individual_info_path}") # Debug - Cache Hit
                return self.individual_info_cache[individual_info_path], "" # Return cached data and empty file_content
            # --- Cache Check End ---

            #print(f"DEBUG: _load_individual_info - Cache MISS for: {individual_info_path} - Loading from disk.") # Debug - Cache Miss

            try:
                # Method 1: Standard JSON Load
                with open(individual_info_path, 'r', encoding="utf-8") as f:
                    file_content = f.read() # Read the content FIRST for fallback methods
                    #print(f"  DEBUG: _load_individual_info - File content READ from: {individual_info_path}") # DEBUG - File Read Success
                    try:
                        extracted_info = json.loads(file_content, strict=False) # strict=False to allow minor JSON errors
                        #print("  DEBUG: _load_individual_info - Successfully loaded JSON data using json.loads(strict=False) (Method 1)")
                        #print(f"  DEBUG: _load_individual_info - Extracted Info (Method 1): {extracted_info}") # DEBUG - Extracted Info - METHOD 1

                        # --- Cache Data on Load ---
                        #self.individual_info_cache[individual_info_path] = extracted_info
                        #disabling cache
                        # --- Cache Data End ---

                        return extracted_info, file_content
                    except json.JSONDecodeError as e_strict:
                       # print(f"  WARNING: JSONDecodeError loading individual info file {individual_info_path} (Method 1 strict=False): {e_strict}. Attempting relaxed JSON load with comma fix (Method 1.2).")

                        # Method 1.2: Attempt to fix commas and then load JSON
                        try:
                            # Try to fix missing commas - VERY basic attempt, might need refinement
                            fixed_content = re.sub(r'"(.*?)"\s*:\s*"(.*?)"\s*(?=\})', r'"\1": "\2",', file_content) # Basic comma insertion before '}'
                            fixed_content = re.sub(r'"(.*?)"\s*:\s*"(.*?)"\s*(?=")', r'"\1": "\2",', fixed_content) # Basic comma insertion before '"'
                            # Remove trailing commas if added at the end of objects or arrays - basic cleanup
                            fixed_content = re.sub(r',(\s*?[\}\]])', r'\1', fixed_content)


                            extracted_info = json.loads(fixed_content, strict=False)
                            #print("  DEBUG: _load_individual_info - Successfully loaded JSON data after comma fix (Method 1.2).")
                            #print(f"  DEBUG: _load_individual_info - Extracted Info (Method 1.2 - Comma Fix): {extracted_info}") # DEBUG - Extracted Info - METHOD 1.2

                            # --- Cache Data on Load ---
                            self.individual_info_cache[individual_info_path] = extracted_info
                            # --- Cache Data End ---

                            return extracted_info, file_content # Return original content, not fixed, for regex fallback

                        except json.JSONDecodeError as e_fix:
                            #print(f"  WARNING: JSONDecodeError after comma fix (Method 1.2): {e_fix}. Attempting regex fallback (Method 2).")
                            # Fallback to regex if even comma fix fails


                            # Method 2: Regex Fallback for JSON-like structure
                            extracted_info_regex = self.extract_info_with_regex(file_content)
                            if extracted_info_regex:
                                #print("  DEBUG: _load_individual_info - Successfully extracted info using regex fallback (Method 2).")
                                #print(f"  DEBUG: _load_individual_info - Extracted Info (Method 2 - Regex): {extracted_info_regex}") # DEBUG - Extracted Info - METHOD 2

                                # --- Cache Data on Load ---
                                self.individual_info_cache[individual_info_path] = extracted_info_regex
                                # --- Cache Data End ---

                                return extracted_info_regex, file_content
                            else:
                                #print("  ERROR: _load_individual_info - Regex fallback (Method 2) failed. Trying secondary extraction method (Method 3)...")

                                # Method 3: Secondary lenient regex/string search
                                extracted_info_secondary = self.extract_info_secondary_method(file_content)
                                if extracted_info_secondary:
                                    #print("  DEBUG: _load_individual_info - Successfully extracted info using secondary method (Method 3).")
                                    #print(f"  DEBUG: _load_individual_info - Extracted Info (Method 3 - Secondary Method): {extracted_info_secondary}") # DEBUG - Extracted Info - METHOD 3

                                    # --- Cache Data on Load ---
                                    self.individual_info_cache[individual_info_path] = extracted_info_secondary
                                    # --- Cache Data End ---

                                    return extracted_info_secondary, file_content
                                else:
                                    print("  ERROR: _load_individual_info - Secondary extraction method (Method 3) also failed. Using default values.")
                                    return {}, file_content # Return empty dict if all methods fail

            except Exception as e:
                print(f"  ERROR: Failed to load individual info file due to file operation error. Exception: {e}")
                return {}, "" # Return empty and empty content on file operation failure
        else:
             print(f"  WARNING: _load_individual_info - File does NOT exist at path: {individual_info_path}") # Debug - File Does Not Exist
        return {}, "" # Return empty dict and empty content if no file path or file not exists

        

    def _initialize_combined_info(self): # MODIFIED - Added new keys
        """
        Initializes the combined info dictionary with default "N/A" values.
        ADDED: Keys for new performance stats.
        """
        return {
            "Description": "N/A",
            "Value": "N/A",
            "Brand": "N/A",
            "Body Style": "N/A",
            "Weight": "N/A",
            "Years": "N/A",
            "Configuration": "N/A",
            # --- NEW Performance Keys ---
            "Top Speed": "N/A",
            "Torque": "N/A",
            "Power": "N/A",
            "0-100 km/h": "N/A",
            "100-0 km/h": "N/A",
            "Fuel Type": "N/A",
            # --- End NEW ---
        }

    def _extract_top_speed(self, extracted_info):
        """
        Extracts and formats the top speed from extracted information.
        """
        if "Top Speed" in extracted_info and isinstance(extracted_info["Top Speed"], (int, float)):
            top_speed_value = float(extracted_info["Top Speed"])
            top_speed_kmh = round(top_speed_value * 3.6, 0)
            return f"{top_speed_kmh} km/h"
        return "N/A"

    def _extract_brand(self, extracted_info, main_info_data):
        """
        Extracts the brand, prioritizing main info data if available.
        """
        if main_info_data and main_info_data.get("Brand"):
            brand = main_info_data["Brand"]
            print("  DEBUG: Got Brand from main info data: " + brand)
            return brand
        elif extracted_info.get("Brand"):
            brand = extracted_info.get("Brand")
            print(f"  DEBUG: Got Brand from individual JSON data: {brand}")
            return brand
        return "N/A"

    def _merge_extracted_details(self, extracted_info, combined_info):
        """
        Merges specific details from extracted_info into combined_info.
        """
        for key in ["Description", "Value", "Weight", "Configuration"]:
            if extracted_info.get(key) and extracted_info.get(key) != "N/A":
                combined_info[key] = extracted_info.get(key)

    def _extract_years(self, extracted_info, main_info_data, file_content):
        """
        Extracts years information, prioritizing main info data and using various methods.
        """
        print(f"  DEBUG: Checking if main_info_data has 'Years' key: {main_info_data and 'Years' in main_info_data}")
        if main_info_data and 'Years' in main_info_data and main_info_data.get("Years"):
            print(f"  DEBUG: Attempting to extract Years from main info data: {main_info_data.get('Years')}")
            years_data = main_info_data.get("Years")
            years_str = self.extract_years_string_from_data(years_data)
            if years_str and years_str != "N/A":
                print(f"  DEBUG: Got Years from main info data: {years_str}")
                return years_str
            else:
                print("   DEBUG: Could not extract years from main info data.")
        else:
            print(f"  DEBUG: main_info_data does not have 'Years' or is invalid. Attempting Individual extraction.")
            if extracted_info.get("Years"):
                print(f"  DEBUG: Attempting to extract Years from individual json using various methods.")
                years_data = extracted_info.get("Years")
                years_str = self.extract_years_string_from_data(years_data)
                if years_str and years_str != "N/A":
                    print(f"   DEBUG: Got Years from individual JSON data: {years_str}")
                    return years_str
                else:
                    print("    DEBUG: Could not get years from individual json, resorting to 'N/A'")
                    return "N/A"
            else:
                print("  DEBUG: Individual data has no 'Years' key to extract. Resoting to 'N/A'")
                return "N/A"

        if file_content:
            try:
                years_index = file_content.find('"Years":')
                if years_index != -1:
                    next_20_chars = file_content[years_index + len('"Years":'):years_index + len('"Years":') + 20]
                    print(f'   DEBUG: Found these characters after "Years": in INDIVIDUAL: {next_20_chars}')
            except Exception as e:
                print(f"  DEBUG: Error getting characters after 'Years:' in INDIVIDUAL: {e}")
        return "N/A" # Should not reach here in normal flow, but for safety

    def _extract_body_style(self, extracted_info, main_info_data):
        """
        Extracts body style information, prioritizing different sources.
        """
        if extracted_info.get("Body Style"):
            return extracted_info.get("Body Style")
        elif main_info_data and main_info_data.get("Body Style"):
            body_style = main_info_data.get("Body Style")
            print("  DEBUG: Got Body Style from main info data (fallback): " + body_style)
            return body_style
        elif main_info_data and main_info_data.get("Derby Class"):
            body_style = main_info_data.get("Derby Class")
            print("  DEBUG: Got Body Style from main info data (Derby Class fallback): " + body_style)
            return body_style
        return "N/A"

    def _set_configuration_label(self, individual_data): # MODIFIED: Takes individual_data
        """
        Sets the "Selected Configuration" label in the details sidebar using individual_data.
        """
        config_display_name = individual_data.get("Configuration", "Custom/Unspecified") # Use get()
        # Ensure label exists before configuring
        if hasattr(self, 'details_sidebar_selected_config_label_val') and self.details_sidebar_selected_config_label_val.winfo_exists():
            self.details_sidebar_selected_config_label_val.config(text=config_display_name)
            print(f"   DEBUG: Set Configuration Label (from individual_data): {config_display_name}")
        else:
             print("   WARN: details_sidebar_selected_config_label_val does not exist when trying to set configuration.")



    def _populate_sidebar_labels(self, combined_info): # MODIFIED - Zip File Label
        """
        Populates the labels in the details sidebar with information from combined_info.
        """
        self.details_sidebar_description_label_val.config(text=combined_info["Description"])
        # self.details_sidebar_topspeed_label_val.config(text=combined_info["Top Speed"]) # REMOVED - TOP SPEED
        self.details_sidebar_value_label_val.config(text=combined_info["Value"])
        self.details_sidebar_brand_label_val.config(text=combined_info["Brand"])
        self.details_sidebar_bodystyle_label_val.config(text=combined_info["Body Style"])
        self.details_sidebar_weight_label_val.config(text=combined_info["Weight"])
        self.details_sidebar_years_label_val.config(text=combined_info["Years"])

    def _pack_sidebar_labels(self): # MODIFIED - Zip File Label
        """
        Packs the labels in the details sidebar to make them visible.
        """
        self.details_sidebar_description_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(10, 0))
        self.details_sidebar_description_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))

        # self.details_sidebar_topspeed_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0)) # REMOVED - TOP SPEED
        # self.details_sidebar_topspeed_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5)) # REMOVED - TOP SPEED
        self.details_sidebar_zipfile_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0)) # ADDED - ZIP FILE
        self.details_sidebar_zipfile_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5)) # ADDED - ZIP FILE

        self.details_sidebar_value_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_value_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_brand_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_brand_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_bodystyle_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_bodystyle_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_weight_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_weight_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_years_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_years_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 10))





    def update_details_sidebar_individual_info(self, individual_info_path, main_info_data=None):
        """
        Updates the details sidebar, prioritizing individual config data.
        MODIFIED: Implements a 3-layer fallback:
                  1. Individual Info File
                  2. Correct Main Info File (actively loaded)
                  3. Passed main_info_data argument (from clicked item tuple)
                  4. Default "N/A"
        """
        print(f"\n--- update_details_sidebar_individual_info() ENTRY (3-Layer Fallback Logic) ---") # Updated Note
        print(f"  DEBUG: individual_info_path = {individual_info_path}")
        print(f"  DEBUG: main_info_data passed initially: {main_info_data is not None}")

        # 1. Load individual data
        individual_data, file_content_debug = self._load_individual_info(individual_info_path)
        print(f"  DEBUG: Data loaded from _load_individual_info: {individual_data}")

        # --- Helper to check if a value is considered valid (not None, "N/A", or empty) ---
        def is_valid_value(value):
            return value is not None and str(value).strip().upper() != "N/A" and str(value).strip() != ""

        # --- Helper to get value with 3-layer fallback ---
        def get_prioritized_value(key, default="N/A"):
            print(f"  DEBUG get_prioritized (3-Layer): Getting key '{key}'...")

            # Layer 1: Check Individual Data
            individual_value = individual_data.get(key, None)
            if is_valid_value(individual_value):
                print(f"    DEBUG get_prioritized: Layer 1 HIT - Using value from individual_data: '{str(individual_value)[:100]}'")
                return individual_value
            else:
                print(f"    DEBUG get_prioritized: Layer 1 MISS - Key '{key}' not found or invalid in individual_data ('{individual_value}').")

            # Layer 2: Find and Load CORRECT Main Info File
            correct_main_info_data = None
            try:
                folder = self.current_details_folder
                base_zip_file = None
                if folder in self.ZIP_BASE_NAMES:
                    base_zip_file = f"{folder}.zip"
                elif self.details_data:
                    # Find the first non-custom zip associated with this folder in details_data
                    # This assumes details_data reflects the current group accurately
                    for item_tuple in self.details_data:
                         if len(item_tuple) == 5 and item_tuple[4] == folder and item_tuple[2] not in ["user_custom_configs", "folder_grouped"]:
                              base_zip_file = item_tuple[2]
                              break # Use the first one found

                if folder and base_zip_file:
                    main_info_filename = f"vehicles--{folder}_{base_zip_file}--info.json"
                    main_info_filepath = os.path.join(self.config_info_folder, main_info_filename)
                    print(f"      DEBUG get_prioritized: Layer 2 - Attempting to load MAIN info from: {main_info_filepath}")
                    if os.path.exists(main_info_filepath):
                        correct_main_info_data = self.extract_fallback_info(main_info_filepath)
                        print(f"      DEBUG get_prioritized: Layer 2 - Successfully loaded main info: Keys={list(correct_main_info_data.keys()) if correct_main_info_data else 'None'}")
                    else:
                        print(f"      WARN get_prioritized: Layer 2 - Main info file not found: {main_info_filepath}")
                else:
                    print(f"      WARN get_prioritized: Layer 2 - Could not determine folder/base_zip to find main info file.")
            except Exception as e:
                print(f"      ERROR get_prioritized: Layer 2 - Error during main info file lookup: {e}")

            if correct_main_info_data:
                correct_main_value = correct_main_info_data.get(key, None)
                if is_valid_value(correct_main_value):
                    print(f"    DEBUG get_prioritized: Layer 2 HIT - Using value from CORRECT main_info_data: '{str(correct_main_value)[:100]}'")
                    return correct_main_value
                else:
                     print(f"    DEBUG get_prioritized: Layer 2 MISS - Key '{key}' not found or invalid in CORRECT main_info_data ('{correct_main_value}').")
            else:
                 print(f"    DEBUG get_prioritized: Layer 2 FAIL - Could not load correct main info.")

            # Layer 3: Fallback to the PASSED main_info_data argument
            print(f"    DEBUG get_prioritized: Layer 3 - Checking PASSED main_info_data argument...")
            if main_info_data: # Check if the argument itself is not None
                passed_main_value = main_info_data.get(key, None)
                if is_valid_value(passed_main_value):
                    print(f"    DEBUG get_prioritized: Layer 3 HIT - Using value from PASSED main_info_data: '{str(passed_main_value)[:100]}'")
                    return passed_main_value
                else:
                    print(f"    DEBUG get_prioritized: Layer 3 MISS - Key '{key}' not found or invalid in PASSED main_info_data ('{passed_main_value}').")
            else:
                print(f"    DEBUG get_prioritized: Layer 3 SKIP - Passed main_info_data was None.")

            # Layer 4: Final Default
            print(f"    DEBUG get_prioritized: Layer 4 HIT - All fallbacks failed for key '{key}'. Returning default '{default}'.")
            return default

        # --- Robust Formatting Helper (Keep as is) ---
        def format_display_value(key, value, unit="", decimals=0, default="N/A"):
            # ... (previous format_display_value logic remains the same) ...
            # print(f"  DEBUG format_display_value: key='{key}', input_value='{value}' (type: {type(value)})") # Optional Verbose
            if value is None or str(value).strip().upper() == "N/A": return default
            if str(value).strip() == "": return default
            if key in ["Value", "Weight", "Top Speed", "Torque", "Power", "0-100 km/h", "100-0 km/h"]:
                try:
                    num_value = float(value)
                    if key == "Top Speed": num_value_kmh = round(num_value * 3.6, 0); result = f"{int(num_value_kmh)}{unit}"
                    elif key in ["Value", "Weight", "Torque", "Power"]: result = f"{int(round(num_value, 0))}{unit}"
                    elif key in ["0-100 km/h", "100-0 km/h"]: format_string = "{:." + str(decimals) + "f}"; result = f"{format_string.format(num_value)}{unit}"
                    else: result = str(num_value)
                    return result
                except (ValueError, TypeError):
                    if isinstance(value, str): return value
                    else: return default
            else: return str(value)

        # 2. Update Labels using the new 3-layer getter and formatter
        self._set_configuration_label(individual_data)
        self.details_sidebar_description_label_val.config(text=format_display_value("Description", get_prioritized_value("Description")))
        self.details_sidebar_value_label_val.config(text=format_display_value("Value", get_prioritized_value("Value"), " ", 0))
        self.details_sidebar_brand_label_val.config(text=format_display_value("Brand", get_prioritized_value("Brand")))
        self.details_sidebar_bodystyle_label_val.config(text=format_display_value("Body Style", get_prioritized_value("Body Style")))
        self.details_sidebar_weight_label_val.config(text=format_display_value("Weight", get_prioritized_value("Weight"), " kg", 0))
        years_value = get_prioritized_value("Years", None)
        self.details_sidebar_years_label_val.config(text=self.extract_years_string_from_data(years_value))
        self.details_sidebar_zipfile_label_val.config(text=os.path.basename(str(self.current_details_sidebar_zip_file or "N/A")))
        self.details_sidebar_topspeed_label_val.config(text=format_display_value("Top Speed", get_prioritized_value("Top Speed"), " km/h", 0))
        self.details_sidebar_torque_label_val.config(text=format_display_value("Torque", get_prioritized_value("Torque"), " Nm", 0))
        self.details_sidebar_power_label_val.config(text=format_display_value("Power", get_prioritized_value("Power"), " hp", 0))
        self.details_sidebar_0_100_label_val.config(text=format_display_value("0-100 km/h", get_prioritized_value("0-100 km/h"), " s", 1))
        self.details_sidebar_100_0_label_val.config(text=format_display_value("100-0 km/h", get_prioritized_value("100-0 km/h"), " m", 1))
        self.details_sidebar_fuel_type_label_val.config(text=format_display_value("Fuel Type", get_prioritized_value("Fuel Type")))

        # 3. Pack the labels (logic remains the same)
        # ... (pack_pair logic remains the same) ...
        all_sidebar_labels = [
            self.details_sidebar_selected_config_label_cat, self.details_sidebar_selected_config_label_val,
            self.details_sidebar_config_name_label,
            self.details_sidebar_description_label_cat, self.details_sidebar_description_label_val,
            self.details_sidebar_zipfile_label_cat, self.details_sidebar_zipfile_label_val,
            self.details_sidebar_value_label_cat, self.details_sidebar_value_label_val,
            self.details_sidebar_brand_label_cat, self.details_sidebar_brand_label_val,
            self.details_sidebar_bodystyle_label_cat, self.details_sidebar_bodystyle_label_val,
            self.details_sidebar_weight_label_cat, self.details_sidebar_weight_label_val,
            self.details_sidebar_years_label_cat, self.details_sidebar_years_label_val,
            self.details_sidebar_topspeed_label_cat, self.details_sidebar_topspeed_label_val,
            self.details_sidebar_torque_label_cat, self.details_sidebar_torque_label_val,
            self.details_sidebar_power_label_cat, self.details_sidebar_power_label_val,
            self.details_sidebar_0_100_label_cat, self.details_sidebar_0_100_label_val,
            self.details_sidebar_100_0_label_cat, self.details_sidebar_100_0_label_val,
            self.details_sidebar_fuel_type_label_cat, self.details_sidebar_fuel_type_label_val,
        ]
        for widget in all_sidebar_labels:
            if widget and widget.winfo_exists(): widget.pack_forget()

        pack_padding_top = 5; pack_padding_bottom = 0; pack_padx = 10
        def pack_pair(cat_widget, val_widget):
            value_text = val_widget.cget("text") if val_widget and val_widget.winfo_exists() else "N/A"
            should_pack = True
            na_values = ["N/A", "0 Nm", "0 hp", "0.0 s", "0.0 m", "0 kg", "0 ", "0 km/h"]
            if val_widget == self.details_sidebar_selected_config_label_val and value_text == "Custom/Unspecified":
                 should_pack = True
            elif value_text in na_values:
                 should_pack = False
            elif val_widget == self.details_sidebar_years_label_val and (value_text is None or value_text.strip() == ""):
                 should_pack = False
            if should_pack:
                 if cat_widget and cat_widget.winfo_exists(): cat_widget.pack(fill="x", padx=pack_padx, pady=(pack_padding_top, 0))
                 if val_widget and val_widget.winfo_exists(): val_widget.pack(fill="x", padx=pack_padx, pady=(0, pack_padding_bottom))
            else:
                if cat_widget and cat_widget.winfo_exists(): cat_widget.pack_forget()
                if val_widget and val_widget.winfo_exists(): val_widget.pack_forget()

        pack_pair(self.details_sidebar_selected_config_label_cat, self.details_sidebar_selected_config_label_val)
        if self.details_sidebar_config_name_label and self.details_sidebar_config_name_label.winfo_exists():
             config_name_text = self.details_sidebar_config_name_label.cget("text")
             if config_name_text and config_name_text != "N/A":
                 self.details_sidebar_config_name_label.pack(fill="x", padx=pack_padx, pady=(0, 5))
             else: self.details_sidebar_config_name_label.pack_forget()
        pack_pair(self.details_sidebar_description_label_cat, self.details_sidebar_description_label_val)
        pack_pair(self.details_sidebar_zipfile_label_cat, self.details_sidebar_zipfile_label_val)
        pack_pair(self.details_sidebar_value_label_cat, self.details_sidebar_value_label_val)
        pack_pair(self.details_sidebar_brand_label_cat, self.details_sidebar_brand_label_val)
        pack_pair(self.details_sidebar_bodystyle_label_cat, self.details_sidebar_bodystyle_label_val)
        pack_pair(self.details_sidebar_weight_label_cat, self.details_sidebar_weight_label_val)
        pack_pair(self.details_sidebar_years_label_cat, self.details_sidebar_years_label_val)
        pack_pair(self.details_sidebar_topspeed_label_cat, self.details_sidebar_topspeed_label_val)
        pack_pair(self.details_sidebar_torque_label_cat, self.details_sidebar_torque_label_val)
        pack_pair(self.details_sidebar_power_label_cat, self.details_sidebar_power_label_val)
        pack_pair(self.details_sidebar_0_100_label_cat, self.details_sidebar_0_100_label_val)
        pack_pair(self.details_sidebar_100_0_label_cat, self.details_sidebar_100_0_label_val)
        pack_pair(self.details_sidebar_fuel_type_label_cat, self.details_sidebar_fuel_type_label_val)
        if self.details_sidebar_fuel_type_label_val.winfo_ismapped():
             self.details_sidebar_fuel_type_label_val.pack_configure(pady=(0, 10))


        # 4. Update scrollregion and reset scroll position
        self.details_sidebar_text_scrollable_frame.update_idletasks()
        self.details_sidebar_text_canvas.configure(scrollregion=self.details_sidebar_text_canvas.bbox("all"))
        self.details_sidebar_text_canvas.yview_moveto(0)
        self.custom_sidebar_text_scrollbar_set(0,1) # Update scrollbar appearance

        self._ensure_correct_zip_label() # Correct zip label if needed
        print("  DEBUG: Details sidebar text scroll position reset to top.")
        print("--- update_details_sidebar_individual_info() EXIT (3-Layer Fallback Logic) ---\n")


    def _ensure_correct_zip_label(self):
        """
        Checks the final text of the zip file label in the details sidebar
        and corrects specific raw identifiers to their user-friendly display names.
        This acts as a post-processing step AFTER other updates might have run.
        """
        print("--- _ensure_correct_zip_label() ENTRY ---")
        try:
            # Check if the target label exists
            if hasattr(self, 'details_sidebar_zipfile_label_val') and self.details_sidebar_zipfile_label_val and self.details_sidebar_zipfile_label_val.winfo_exists():
                current_text = self.details_sidebar_zipfile_label_val.cget("text")
                print(f"  DEBUG: Checking current zip label text: '{current_text}'")

                # Check for the specific raw identifiers that need correction
                if current_text == "user_custom_configs":
                    print("  DEBUG: Correcting 'user_custom_configs' to 'Custom Configuration'")
                    #self.details_sidebar_zipfile_label_val.config(text="Custom Configuration")

                    self.details_sidebar_zipfile_label_val.config(text=f"Custom Configuration in folder: {self.current_details_folder}")
                elif current_text == "folder_grouped": # Might as well check for this too
                    print("  DEBUG: Correcting 'folder_grouped' to 'Custom Configuration'")
                    self.details_sidebar_zipfile_label_val.config(text=f"Custom Configuration in folder: {self.current_details_folder}")
                # Add elif for any other raw identifiers you want to map to display names here
                else:
                    print(f"  DEBUG: Zip label text '{current_text}' requires no correction.")

            else:
                print("  WARN: details_sidebar_zipfile_label_val widget not found or destroyed. Cannot correct label.")

        except Exception as e:
            print(f"ERROR in _ensure_correct_zip_label: {e}")
        print("--- _ensure_correct_zip_label() EXIT ---")
        


    def extract_years_string_from_data(self, years_data):
        """
        Extracts a formatted year string from various "Years" data formats.
        Handles dictionary with "min" and "max," single values, lists, or strings with numbers.
        """
        print(f"  DEBUG: extract_years_string_from_data - input data: {years_data}, type: {type(years_data)}")
        if isinstance(years_data, dict):
            years_list = []
            min_year = None
            max_year = None
            if "min" in years_data and isinstance(years_data["min"], (int, float)):
                  min_year = int(years_data["min"])
                  years_list.append(min_year)
            if "max" in years_data and isinstance(years_data["max"], (int, float)):
                  max_year = int(years_data["max"])
                  years_list.append(max_year)
            if len(years_list) == 2:
                years_list.sort() # Sort numerically
                result = f"{years_list[0]} - {years_list[1]}" # Format min - max
            elif len(years_list) == 1:
                 result = f"{years_list[0]}" # Just single value
            else:
                print("  DEBUG: extract_years_string_from_data (dict) could not get specific value, check structure. returning 'N/A'")
                result = "N/A"
            print(f"  DEBUG: extract_years_string_from_data (dict result): {result}")
            return result

        elif isinstance(years_data, list):
            years_list = [str(int(year)) for year in years_data if isinstance(year, (int, float))]
            result =  " - ".join(years_list) if years_list else "N/A"
            print(f"  DEBUG: extract_years_string_from_data (list result): {result}")
            return result
        elif isinstance(years_data, (int, float)):
            result = str(int(years_data))
            print(f"  DEBUG: extract_years_string_from_data (number result): {result}")
            return result
        elif isinstance(years_data, str):
            years_str = str(years_data)
            numbers = re.findall(r'\d+', years_str) # Find ALL numbers in the string
            numbers = [int(num) for num in numbers if num] # Remove non number chars and cast to ints
            if not numbers:
                print(f"  DEBUG: extract_years_string_from_data (string fallback) could not find any numbers, returning 'N/A'")
                return "N/A"
            if len(numbers) > 1:
                numbers.sort()
                result = f"{numbers[0]} - {numbers[-1]}" # format min - max, even if more than 2
            elif numbers:
                 result = f"{numbers[0]}" # take first if only one
            else:
                result = "N/A"
            print(f"  DEBUG: extract_years_string_from_data (string fallback result): {result}")
            return result
        else:
            print("  DEBUG: extract_years_string_from_data (unhandled format), returning N/A.")
            return "N/A"

                 
    def extract_info_with_regex(self, file_content): # MODIFIED - Added new keys
        """
        Fallback method to extract info from the file content using regular expressions,
        now including new performance stats.
        """
        info_data = {}
        patterns = {
            "Description": r'"Description"\s*:\s*"([^"]*)"',
            "Value": r'"Value"\s*:\s*"([^"]*)"',
            "Brand": r'"Brand"\s*:\s*"([^"]*)"',
            "Body Style": r'"Body Style"\s*:\s*"([^"]*)"',
            "Weight": r'"Weight"\s*:\s*"([^"]*)"',
            "Years": r'"Years"\s*:\s*({.*?})',
            "Configuration": r'"Configuration"\s*:\s*"([^"]*)"',
            "Author": r'"Author"\s*:\s*"([^"]*)"',
            # --- NEW Performance Keys ---
            "Top Speed": r'"Top Speed"\s*:\s*([\d\.]+)', # Capture numeric value
            "Torque": r'"Torque"\s*:\s*([\d\.]+)', # Capture numeric value
            "Power": r'"Power"\s*:\s*([\d\.]+)', # Capture numeric value
            "0-100 km/h": r'"0-100 km/h"\s*:\s*([\d\.]+)', # Capture numeric value
            "100-0 km/h": r'"100-0 km/h"\s*:\s*([\d\.]+)', # Capture numeric value
            "Fuel Type": r'"Fuel Type"\s*:\s*"([^"]*)"',
            # --- End NEW ---
         }

        for key, pattern in patterns.items():
            match = re.search(pattern, file_content, re.IGNORECASE)
            if match:
                info_data[key] = match.group(1).strip() # Use strip()

        return info_data

    def extract_info_secondary_method(self, file_content): # MODIFIED - Added new keys
        """
        Secondary method to extract info using a more lenient approach,
        now also looking for new performance stats.
        """
        info_data = {}
        lines = file_content.split('\n')
        # --- List of keys to extract ---
        keys_to_extract = [
            "Description", "Value", "Brand", "Body Style", "Weight", "Years",
            "Configuration", "Author",
            # --- NEW Performance Keys ---
            "Top Speed", "Torque", "Power", "0-100 km/h", "100-0 km/h", "Fuel Type"
            # --- End NEW ---
        ]
        # --- End List ---

        for line in lines:
            match = re.search(r'\s*"?(.*?)"?\s*:\s*"?(.*?)"?,?', line)
            if match:
                key = match.group(1).strip()
                value = match.group(2).strip()
                if key in keys_to_extract: # Check against the list
                    info_data[key] = value
        return info_data

        
    def perform_details_search(self):
        """Performs search in details view, enforcing Favorites filter and ZIP filter."""

        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- perform_details_search CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")


        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win

        print("\n--- perform_details_search() DEBUG ENTRY ---")
        query = self.details_search_var.get().strip().lower()
        print(f"  DEBUG: perform_details_search - Search Query from Entry: '{query}'")
        print(f"  DEBUG: perform_details_search - details_window_is_favorites_filtered: {self.details_window_is_favorites_filtered}") # DEBUG - Favorites Filter State
        print(f"  DEBUG: perform_details_search - details_window_is_data_subset_active: {self.is_data_subset_active}") # DEBUG - Data Subset Active State


        print(f" DEBUG: perform_details_search - BEFORE page reset - Current Page: 0")
        self.details_page = 0
        print(f" DEBUG: perform_details_search - AFTER page reset - Current Page: 0")

        data_to_filter = list(self.details_data)
        intermediate_filtered_data = list(data_to_filter) # Start with all data, initially unfiltered for query


        # --- APPLY ZIP FILTER FIRST ---
        zip_filter_text = self.zip_search_button.cget("text")
        if zip_filter_text != "Search within: All Zips" and zip_filter_text != "Search within: Favorites" and zip_filter_text != "Search within: Filtered": # <--- MODIFIED CHECK HERE
            selected_zip = zip_filter_text.replace("Search within: ", "")
            if selected_zip == "Custom Configurations":
                intermediate_filtered_data = [item for item in intermediate_filtered_data if "_user--" in item[0]]
            else: # Specific zip selected
                intermediate_filtered_data = [item for item in intermediate_filtered_data if item[2] == selected_zip]
            print(f"  DEBUG: perform_details_search - Applied ZIP filter: '{selected_zip}'. Data count: {len(intermediate_filtered_data)}") # Debug
        else:
            print(f"  DEBUG: perform_details_search - ZIP filter is NOT active (showing all zips or filtered).")


        # --- APPLY SEARCH QUERY FILTER ---
        if query: # Apply query filter if there's a query string
            print("  DEBUG: perform_details_search - Applying SEARCH QUERY filter: '{query}'...")
            query_filtered_data = self._filter_details_data_by_query_criteria(intermediate_filtered_data, query) # Apply query criteria ONLY
            intermediate_filtered_data = query_filtered_data # Update data to be further filtered
            print(f"  DEBUG: perform_details_search - Data count AFTER QUERY filter: {len(intermediate_filtered_data)}") # Debug - Count after Query Filter
        else:
            print("  DEBUG: perform_details_search - NO SEARCH QUERY to apply.")


        # --- APPLY FAVORITES FILTER (if active) ---
        if self.details_window_is_favorites_filtered:
            print("  DEBUG: perform_details_search - Applying FAVORITES filter...")
            favorites_filtered_data = self._apply_details_favorites_only_filter(intermediate_filtered_data) # Apply Favorites filter NOW
            intermediate_filtered_data = favorites_filtered_data # Update data to be further filtered
            print(f"  DEBUG: perform_details_search - Data count AFTER FAVORITES filter: {len(intermediate_filtered_data)}") # Debug - Count after Favorites Filter
        else:
            print("  DEBUG: perform_details_search - Favorites filter is NOT active.")


        # --- APPLY DATA SUBSET FILTER (if active) ---
        if self.is_data_subset_active:
            print("  DEBUG: perform_details_search - Applying DATA SUBSET filter...")
            subset_filtered_data = self._apply_details_data_subset_filter(intermediate_filtered_data) # Apply Data Subset filter LAST
            final_filtered_data = subset_filtered_data # This is the final filtered data
            print(f"  DEBUG: perform_details_search - Data count AFTER DATA SUBSET filter: {len(final_filtered_data)}") # Debug - Count after Data Subset Filter
            self.master.after(2500, self.check_and_auto_close_details_window) # Schedule check with delay
        else:
            print("  DEBUG: perform_details_search - Data Subset filter is NOT active.")
            final_filtered_data = intermediate_filtered_data # If not active, use data after query/favorites filters

        self.details_filtered_data = final_filtered_data # Assign the FINAL filtered list to details_filtered_data
        self.rebuild_simple_details()
        if self.details_count_label:
            self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}")

        self._update_details_pagination_bar()

        # --- NEW: Schedule auto-close check with 2-second delay ---


        print("--- ConfigViewerApp.perform_details_search() EXIT ---\n")

    

    def handle_zip_search_button_click(self):
        """Handles clicks on the 'Search within: Zips' button, checking filter modes."""
        print("\n--- handle_zip_search_button_click() DEBUG ENTRY ---") # Debug Entry
        print(f"  DEBUG: handle_zip_search_button_click - is_data_subset_active: {self.is_data_subset_active}") # Debug - Check flag
        print(f"  DEBUG: handle_zip_search_button_click - details_window_should_open_in_favorites_mode: {self.details_window_should_open_in_favorites_mode}") # Debug - Check flag



        if self.is_data_subset_active:
            print("  DEBUG: handle_zip_search_button_click - Data subset active - Showing messagebox.") # Debug - Condition True
 
            scanning_win = self.show_scanning_window(text="Cannot search by zip while configurations window is filtered.")
            self.lift_search_results_window()
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)



            print("--- handle_zip_search_button_click() EXIT - Data subset active ---\n") # Debug Exit
            return
        if self.details_window_should_open_in_favorites_mode or self.zip_search_button.cget("text") == "Search within: Favorites": # <--- MODIFIED CHECK HERE
            print("  DEBUG: handle_zip_search_button_click - Favorites mode active - Showing messagebox.") # Debug - Condition True
            #messagebox.showinfo(
            #    "Zip Search Unavailable",
            #    "Please switch out of Favorites mode to search within zip.", # <--- MODIFIED MESSAGE HERE
            #    parent=self.details_window
            #)
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot search by zip while in Favorites mode.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)

            print("--- handle_zip_search_button_click() EXIT - Favorites mode active ---\n") # Debug Exit
            return

        print("  DEBUG: handle_zip_search_button_click - No filters active - Showing dropdown.") # Debug - Condition False
        self.show_zip_search_dropdown_menu() # If no filters active, show the dropdown
        print("--- handle_zip_search_button_click() EXIT - Showing dropdown ---\n") # Debug Exit
     
     
     

    def show_zip_search_dropdown_menu(self):
        """Displays the zip search dropdown menu in the details window with smooth scrolling and a Close button."""
        if hasattr(self, 'zip_search_dropdown_window') and self.zip_search_dropdown_window and self.zip_search_dropdown_window.winfo_exists():
            self.zip_search_dropdown_window.destroy()
            return

        button = self.zip_search_button
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty() + button.winfo_height()

        self.zip_search_dropdown_window = dropdown_window = FadingToplevel(self.details_window, self)
        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)

        dropdown_window.geometry(f"+{button_x}+{button_y}")
        dropdown_window.config(bg="#333333")
        #dropdown_window.grab_set()
        dropdown_window.attributes("-topmost", True)
        dropdown_window.config(highlightthickness=3, highlightbackground="#666666")
        

        # --- NEW: Main frame for dropdown window to contain canvas and button ---
        dropdown_main_frame = tk.Frame(dropdown_window, bg="#333333") # Main frame to pack canvas and button
        dropdown_main_frame.pack(fill=tk.BOTH, expand=True)
        # --- NEW: Main frame for dropdown window to contain canvas and button ---


        canvas = tk.Canvas(dropdown_main_frame, bg="#333333", highlightthickness=0, width=300, height=200) # Adjust width/height as needed
        scrollbar = tk.Scrollbar(dropdown_main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#333333")

        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="top", fill="both", expand=True) # Canvas packed to the TOP in main frame
        canvas.configure(yscrollcommand=scrollbar.set)
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw", width=400) # Adjust width if needed

        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_dropdown_mousewheel(ev, canvas))) # Reuse existing mousewheel function
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))


        menu_options = ["All Zips", "Custom Configurations"]

        # Get unique zip names from details data
        zip_names = set()
        for item in self.details_data:
            zip_file = item[2]
            if zip_file != "user_custom_configs": # Exclude custom configs pseudo-zip
                zip_names.add(zip_file)
        sorted_zip_names = sorted(list(zip_names))
        menu_options.extend(sorted_zip_names)

        current_zip_filter_text = self.zip_search_button.cget("text") # Get current button text for comparison


        def on_menu_option_click(option):
            self.zip_search_button.config(text=f"Search within: {option}")
            self.zip_search_dropdown_window.destroy()
            self.zip_search_dropdown_window = None
            self.details_search_var.set("") # <--- CLEAR DETAILS SEARCH BAR TEXT HERE
            self.apply_zip_filter(option)
            if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
                self.current_detail_window.destroy()




        for option in menu_options:
            # --- Define Colors for menu option items ---
            option_default_bg = "#555555"
            option_default_fg = "#FFFFFF"
            option_selected_bg = self.global_highlight_color
            option_selected_fg = "#FFFFFF"
            option_hover_bg = "#d9d9d9"
            option_hover_fg = "black"

            is_selected = (f"Search within: {option}" == current_zip_filter_text)

            dropdown_button = tk.Button(
                scrollable_frame,
                text=option,
                font=("Segoe UI", 10 + self.font_size_add, "bold"),
                command=lambda opt=option: on_menu_option_click(opt),
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5
                # bg and fg set by _bind_animated_hover
            )
            dropdown_button.config(
                activebackground=option_hover_bg, # For click flash
                activeforeground=option_hover_fg
            )
            dropdown_button.pack(fill="x")

            self._bind_animated_hover(
                button=dropdown_button,
                original_bg=option_default_bg,
                original_fg=option_default_fg,
                hover_target_bg=option_hover_bg,
                hover_target_fg=option_hover_fg,
                check_state=False,
                is_selected_initial=is_selected,
                selected_bg=option_selected_bg,
                selected_fg=option_selected_fg
            )
            # REMOVED old binds

        # --- NEW: Close Button (below scrollable frame, in main frame) ---

        # --- Define Colors for the Close button ---
        close_button_original_bg = "#666666"
        close_button_original_fg = "#FFFFFF"
        # Let's make the close button hover to the global highlight color for emphasis,
        # or you can define a custom hover like "#777777" if preferred.
        close_button_hover_bg = self.global_highlight_color # Or e.g., "#777777"
        close_button_hover_fg = "#FFFFFF" # Assuming white text on highlight

        close_button = tk.Button(
            dropdown_main_frame, # Place in dropdown_main_frame
            text="Close",
            font=("Segoe UI", 10 + self.font_size_add, "bold"),
            command=self.destroy_zip_search_dropdown_menu, # Ensure this method exists
            # bg and fg will be set by _bind_animated_hover initially
            borderwidth=1,
            relief="solid",
            padx=10,
            pady=5
        )
        # Set active colors for click flash (optional, can match hover or be different)
        close_button.config(
            activebackground=close_button_hover_bg, # Example: match hover for click
            activeforeground=close_button_hover_fg
        )
        close_button.pack(side="bottom", fill="x") # Pack to bottom of main frame

        # --- Apply Smooth Hover Animation to the Close Button ---
        self._bind_animated_hover(
            button=close_button,
            original_bg=close_button_original_bg,
            original_fg=close_button_original_fg,
            hover_target_bg=close_button_hover_bg,   # Use the defined hover BG for close button
            hover_target_fg=close_button_hover_fg,   # Use the defined hover FG for close button
            check_state=False,                       # Assuming close button is always enabled
            # No selected state for the close button
            is_selected_initial=False,
            selected_bg=None,
            selected_fg=None,
            on_enter_extra_command=None, # No tooltips
            on_leave_extra_command=None
        )


        self.zip_search_dropdown_window.bind("<FocusOut>", lambda event: self.destroy_zip_search_dropdown_menu())
        
        
        

    def write_search_debug_log(self, message):
        """Writes debug messages to search_debug_log.txt."""
        debug_log_file = os.path.join(self.script_dir, "search_debug_log.txt")
        try:
            with open(debug_log_file, "a", encoding="utf-8") as f: # Open in append mode
                f.write(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - {message}\n")
        except Exception as e:
            print(f"Warning: Could not write to search debug log file: {e}")
            
    def _filter_details_data_by_query_criteria(self, data_to_filter, query):
        """
        Filters details data by search query criteria (config/pc name).
        This function ONLY applies the query filter, no Favorites or Data Subset.
        """
        if not query:
            return data_to_filter # Return original if no query

        filtered_list = []
        print(f"\n--- _filter_details_data_by_query_criteria() DEBUG ---") # DEBUG START - QUERY CRITERIA ONLY
        print(f"  DEBUG: _filter_details_data_by_query_criteria - Search Query: '{query}'") # DEBUG - Search Query

        for item in data_to_filter:
            picture_path, spawn_cmd, zip_file, info_data, folder_name = item
            zip_file_base_name = zip_file.replace(".zip", "")
            config_name_base = self.extract_name_from_spawn_command(spawn_cmd).lower()

            config_name_display = ""
            individual_info_path = self.find_individual_info_file(
                folder_name,
                zip_file_base_name=zip_file_base_name,
                config_name=config_name_base
            )
            if individual_info_path:
                individual_info_json_data, _ = self._load_individual_info(individual_info_path)
                config_name_display = individual_info_json_data.get("Configuration", "").strip().lower()

            config_match_found = False
            if query.lower() in config_name_display: # Check against display name from Info file
                config_match_found = True

            pc_file_name_match = False # Check if query matches PC filename
            pc_file_name = self.extract_name_from_spawn_command(spawn_cmd).lower()
            if query.lower() in pc_file_name:
                pc_file_name_match = True

            if config_match_found or pc_file_name_match: # Check both Info file and PC filename
                filtered_list.append(item)

        print(f"  DEBUG: _filter_details_data_by_query_criteria - Filtered list count (query criteria only): {len(filtered_list)}") # DEBUG - Filtered List Count
        print("--- _filter_details_data_by_query_criteria() DEBUG END ---\n") # DEBUG END - QUERY CRITERIA ONLY
        return filtered_list


    def _apply_details_favorites_only_filter(self, data_to_filter):
        """
        Applies ONLY the Favorites filter to the details data,
        ensuring deduplication based on favorite key.
        """
        # Optional: Keep this check, although the caller (perform_details_search)
        # already verifies self.details_window_is_favorites_filtered
        if not self.details_window_is_favorites_filtered:
            print("DEBUG: _apply_details_favorites_only_filter - Filter not active, returning original data.")
            return data_to_filter # Return original data if filter not active

        filtered_list = []
        added_fav_keys = set()  # <<<--- ADD THIS LINE ---<<<

        print("\n--- _apply_details_favorites_only_filter() DEBUG ---")
        print("  DEBUG: _apply_details_favorites_only_filter - Applying Favorites Only filter WITH DEDUPLICATION.") # Updated message

        favorite_configs_set = self.read_favorites()
        for item in data_to_filter:
            try: # Add try-except for robustness when unpacking/processing
                # Ensure item has the expected structure before unpacking
                if not isinstance(item, (list, tuple)) or len(item) != 5:
                    print(f"WARN: Skipping malformed item in favorite filter: {item}")
                    continue

                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)

                # Handle cases where extraction might fail
                if not config_name:
                    print(f"WARN: Could not extract config name from spawn_cmd: {spawn_cmd}. Skipping.")
                    continue
                if not folder_name:
                     print(f"WARN: Missing folder_name for item with spawn_cmd: {spawn_cmd}. Skipping.")
                     continue

                fav_key = f"{folder_name}|{config_name}.pc"

                # <<<--- MODIFY THIS CONDITION ---<<<
                if fav_key in favorite_configs_set and fav_key not in added_fav_keys:
                    filtered_list.append(item)
                    added_fav_keys.add(fav_key) # <<<--- ADD THIS LINE ---<<<

            except Exception as e:
                 # Catch potential errors during processing an item
                 print(f"ERROR processing item in _apply_details_favorites_only_filter: {item[:2]}... - {e}")
                 continue # Skip problematic item

        print(f"  DEBUG: _apply_details_favorites_only_filter - Filtered list count (favorites only, deduplicated): {len(filtered_list)}") # Updated message
        print("--- _apply_details_favorites_only_filter() DEBUG END ---\n")
        return filtered_list



    def is_image_path_in_subset(self, picture_path):
        """
        Checks if the given picture path (filename) is considered in the data subset
        when the data subset filter is active.
        """
        if not self.is_data_subset_active:
            return True  # If data subset is not active, all paths are considered in subset

        subset_files = set()
        data_subset_file_path = os.path.join(self.script_dir, self.data_subset_file)
        if os.path.exists(data_subset_file_path):
            with open(data_subset_file_path, 'r', encoding="utf-8") as f:
                for line in f:
                    filename = line.strip()
                    if filename:
                        subset_files.add(filename)

        if not subset_files:
            return False  # If data_subset.txt is empty, no files are in subset

        pic_filename = os.path.basename(picture_path)

        # Extract "vehicles--[foldername]" part from filename
        match = re.match(r"vehicles--([^-]+)", pic_filename)
        if match:
            folder_name_prefix = match.group(0)  # "vehicles--[foldername]--"
            if folder_name_prefix[:-2] in subset_files: # Remove last two "--" and check
                return True

        return False


    def apply_data_subset_filter_details(self, data_list):
        """
        Filters the given data list to include only items with picture files that pass
        the is_image_path_in_subset check.
        """
        if not hasattr(self, 'is_data_subset_active'):
            self.is_data_subset_active = False  # Default to False if not initialized

        if not self.is_data_subset_active:
            return data_list

        filtered_data = []
        for item in data_list:
            pic_path = item[0]
            if pic_path and self.is_image_path_in_subset(pic_path): # Use the new check function
                filtered_data.append(item)
        return filtered_data


     
            



    #@profile 
    def rebuild_simple_details(self):
        """
        Rebuilds the details window's subgrid, respecting pagination and filters.
        """

        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- rebuild_simple_details CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")


        
        if not hasattr(self, 'details_window') or not self.details_window or not self.details_window.winfo_exists():
            print("WARN: rebuild_simple_details called but details_window does not exist.")
            return
        if not hasattr(self, 'details_scrollable_frame') or not self.details_scrollable_frame:
            print("WARN: rebuild_simple_details called but details_scrollable_frame does not exist.")
            return

        print("\n--- rebuild_simple_details() ENTRY - Page:", self.details_page, "---")
        print(f"  DEBUG: rebuild_simple_details - items_per_page: {self.items_per_page}")
        print(f"  DEBUG: rebuild_simple_details - details_page: {self.details_page}")
        print(f"  DEBUG: rebuild_simple_details - len(self.details_filtered_data): {len(self.details_filtered_data) if hasattr(self, 'details_filtered_data') else 'N/A'}")
        print(f"  DEBUG: rebuild_simple_details - details_window_is_favorites_filtered: {self.details_window_is_favorites_filtered}")

        # Ensure details_filtered_data exists
        if not hasattr(self, 'details_filtered_data'):
            print("ERROR: rebuild_simple_details - self.details_filtered_data not found. Aborting.")
            return # Or perhaps re-run the filtering logic if applicable

        # --- Sorting logic (apply sorting to the currently filtered data) ---
        def get_config_value(item):
            """
            Helper function to extract 'Value' from the corresponding JSON file
            and safely convert to float for sorting.
            ADAPTED for _load_individual_info returning (dict, file_content_string).
            """
            default_sort_value = float('-inf') # Errors/missing go last in ascending sort

            try:
                # --- Structure Check ---
                if not isinstance(item, (list, tuple)) or len(item) != 5:
                    print(f"WARN: get_config_value - Invalid item structure encountered: Type={type(item)}, Len={len(item) if isinstance(item, (list, tuple)) else 'N/A'}")
                    try: item_preview = str(item)[:100]
                    except Exception: item_preview = "[Unrepresentable Item]"
                    print(f"   Problematic Item Preview: {item_preview}...")
                    return default_sort_value
                # --- End Structure Check ---

                # Unpack item components
                picture_path, spawn_cmd, item_zip_file, _, folder_name = item

                # --- File Reading Logic ---
                if not all([spawn_cmd, item_zip_file, folder_name]):
                        print(f"WARN: get_config_value - Missing data for item: {str(item)[:100]}")
                        return default_sort_value

                # Handle potential 'folder_grouped' - needs verification
                if item_zip_file == "folder_grouped":
                        print(f"DEBUG: get_config_value - Encountered 'folder_grouped'. Need logic to find original zip for {spawn_cmd}")
                        # Add fallback logic here if possible, otherwise return default
                        return default_sort_value # Cannot proceed without actual zip

                zip_file_base_name = os.path.splitext(item_zip_file)[0]
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                if not config_name or config_name.startswith("UnknownConfig") or config_name.startswith("Error"):
                        print(f"WARN: get_config_value - Could not determine config name for {spawn_cmd}")
                        return default_sort_value

                individual_info_path = self.find_individual_info_file(
                    folder_name, zip_file_base_name, config_name
                )
                # print(f"DEBUG: get_config_value - Looking for info file at: {individual_info_path}") # Verbose

                value = default_sort_value # Start with default

                if individual_info_path:
                    # Call _load_individual_info which returns (dict, file_content_string)
                    individual_info_dict, file_content_debug = self._load_individual_info(individual_info_path)

                    # --- **** CORRECTED SUCCESS CHECK **** ---
                    # Check if the *first* returned element is a non-empty dictionary.
                    # This indicates _load_individual_info succeeded in extracting info.
                    if isinstance(individual_info_dict, dict) and individual_info_dict:
                        # Successfully loaded/extracted info, proceed to get 'Value'
                        value_str = individual_info_dict.get("Value", None)
                        if value_str is not None:
                            try:
                                value = float(value_str)
                                # print(f"DEBUG: get_config_value - Extracted Value: {value} for {config_name}") # Verbose success
                            except (ValueError, TypeError):
                                print(f"WARN: get_config_value - Could not convert 'Value' ({value_str}) to float for Cmd: {spawn_cmd} from file: {individual_info_path}")
                                # Keep default value
                        # else: 'Value' key missing, keep default
                    else:
                        # Load failed or returned empty dict, use default value.
                        # The file_content_debug might contain raw text, but we treat this as failure for sorting.
                        # Avoid printing the full file content here unless debugging specific load failures.
                        if not individual_info_path or not os.path.exists(individual_info_path):
                            # Don't warn if the file genuinely doesn't exist (already handled by _load_individual_info print)
                            pass
                        else:
                            # Warn if the file exists but info extraction failed (returned empty dict)
                            print(f"WARN: get_config_value - Info extraction failed (got empty dict) for file: {individual_info_path}")
                        # Keep default value
                    # --- **** END CORRECTED SUCCESS CHECK **** ---

                # else: find_individual_info_file returned None or empty string, keep default value
                return value

            except Exception as e:
                try: item_str_preview = str(item)[:100]
                except Exception: item_str_preview = "[Unrepresentable Item]"
                print(f"ERROR: Unexpected error in get_config_value for item preview {item_str_preview}...: {e}")
                # traceback.print_exc() # Uncomment for full traceback during debugging
                return default_sort_value

        print("DEBUG: rebuild_simple_details - Sorting details_filtered_data by 'Value'...")
        self.details_filtered_data.sort(key=get_config_value)
        print("DEBUG: rebuild_simple_details - details_filtered_data SORTED by 'Value'.")
        # --- End Sorting ---

        # Data to paginate is the already filtered and now sorted data
        data_to_paginate = self.details_filtered_data

        # --- Clear existing widgets and RESET STATE ---
        for widget in self.details_scrollable_frame.winfo_children():
            widget.destroy()
        print("  DEBUG: rebuild_simple_details - Existing widgets DESTROYED.")
        self.total_details_items_placed = 0 # <<< --- RESET COUNTER HERE --- <<<
        # Reset widget count if you track it specifically for the details view

        ConfigViewerApp.details_widget_count = 0
        print(f"DEBUG: rebuild_simple_details - total_details_items_placed RESET to {self.total_details_items_placed}.")

        # --- Prepare data for the CURRENT page ---
        start_index = self.details_page * self.items_per_page
        end_index = start_index + self.items_per_page
        paged_data = data_to_paginate[start_index:end_index]

        print(f"  DEBUG: rebuild_simple_details - Loading page {self.details_page + 1}, items index {start_index} to {end_index-1}, count: {len(paged_data)}")
        print(f"  DEBUG: rebuild_simple_details - First 3 items in paged_data:")
        if paged_data:
            for i in range(min(3, len(paged_data))):
                item = paged_data[i]
                if item and len(item) > 0 and item[0]:
                    print(f"    - Item {i+1}: {os.path.basename(item[0])}")
                else:
                    print(f"    - Item {i+1}: Item data or picture_path is None/invalid")
        else:
            print("  DEBUG: rebuild_simple_details - paged_data is EMPTY for this page.")

        # Create batches ONLY for the current page
        self.details_batches = [
            paged_data[i: i + self.details_batch_size]
            for i in range(0, len(paged_data), self.details_batch_size)
        ]
        self.current_details_batch_index = 0 # Reset batch index for the new page load
        self.current_details_batch_index_in_sequence = 0 # Also reset sequence index
        print(f"  DEBUG: rebuild_simple_details - Created batches for page, count: {len(self.details_batches)}")
        if self.details_batches:
            print(f"  DEBUG: rebuild_simple_details - Size of first batch: {len(self.details_batches[0])}")
        else:
            print("  DEBUG: rebuild_simple_details - NO batches created.")

        print(f"DEBUG: rebuild_simple_details - State before load: batch_idx={self.current_details_batch_index}, seq_idx={self.current_details_batch_index_in_sequence}, total_placed={self.total_details_items_placed}")

        # --- Start loading items for the current page ---
        if self.details_batches: # Check if there are batches to load
            self.start_details_loading_animation()
            print("DEBUG: rebuild_simple_details - Calling load_next_batch_details() NOW...")
            self.load_next_batch_details()
            print("DEBUG: rebuild_simple_details - load_next_batch_details() RETURNED.")
        else:
            print("DEBUG: rebuild_simple_details - No batches to load for this page.")
            self.stop_details_loading_animation() # Stop animation if no items

        # Update total count label (using full filtered data count)
        if hasattr(self, 'details_count_label') and self.details_count_label:
            self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}")

        self._update_details_pagination_bar() # Update pagination bar based on full filtered data

        #self.start_debounce_details_highlighting()
        
        # Reset scroll position to the top for the new page
        if hasattr(self, 'details_canvas_sub') and self.details_canvas_sub:
            self.details_canvas_sub.yview_moveto(0)

        print("--- rebuild_simple_details() DEBUG EXIT ---\n")





    def throttled_details_resize(self, event):
        """
        Handles the details window resize event with debounce, only updating layout on column breakpoint change.
        """

        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            #print(f"    Code context: {caller_code_context}") # Might be None

        #print(f"--- throttled_details_resize CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")


        if self.details_window and event.widget == self.details_window:
            new_width = self.details_window.winfo_width()
            new_height = self.details_window.winfo_height()
            if (new_width != self.details_last_width) or (new_height != self.details_last_height):
                self.details_last_width = new_width
                self.details_last_height = new_height
                # Pause loading during resize
                self.pause_loading = True
                # Cancel any existing debounce timer
                if self.details_resize_timer is not None:
                    self.details_window.after_cancel(self.details_resize_timer)
                    self.details_resize_timer = None
                # Set a new debounce timer (e.g., 300ms)
                debounce_delay = 700  # milliseconds
                self.details_resize_timer = self.details_window.after(debounce_delay, self.on_details_resize_complete)

    def on_details_resize_complete(self):
        """
        Callback function triggered after debounce for details window resize.
        Updates the subgrid layout only if the number of columns needs to change.
        """

        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- on_details_resize_complete CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")


        details_canvas_width = self.details_canvas_sub.winfo_width() - 20 # Adjust for margins
        if details_canvas_width <= 0:
            return # Avoid calculations with non-positive width

        potential_details_columns, potential_details_h_padding = self.calculate_columns_for_width(details_canvas_width, is_details=True)

        if self.details_columns is None: # Check if None for initial setup
            self.details_columns = (potential_details_columns, potential_details_h_padding) # Update column count and padding
            self.update_subgrid_layout_on_resize()
        elif (potential_details_columns != self.details_columns[0] or potential_details_h_padding != self.details_columns[1]):
            self.details_columns = (potential_details_columns, potential_details_h_padding) # Update column count and padding
            self.update_subgrid_layout_on_resize()
        # Resume loading after layout check (or update)
        self.pause_loading = False
        self.details_resize_timer = None



    def update_subgrid_layout_on_resize(self):
        """
        Updates the subgrid layout with dynamic padding on resize,
        now using paged_data BUT **PREVENTS RE-TRIGGERING BATCH LOAD**.
        MODIFIED to only handle layout, not start new batch load.
        """


        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- update_subgrid_layout_on_resize CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")


        print("\n--- update_subgrid_layout_on_resize() ENTRY ---") # Debug Entry
        print(f"DEBUG: update_subgrid_layout_on_resize - BEFORE function logic - current_details_batch_index: {getattr(self, 'current_details_batch_index', 'ATTRIBUTE_MISSING')}") # Debug - Before Logic

        try:
            if not self.details_scrollable_frame:
                print("  WARNING: details_scrollable_frame is None, exiting.") # Debug - Null Check
                return

            # --- MODIFIED: Calculate paged_data for current page on resize ---
            start_index = self.details_page * self.items_per_page
            end_index = start_index + self.items_per_page
            paged_data = self.details_filtered_data[start_index:end_index]
            print(f"DEBUG: update_subgrid_layout_on_resize - Re-layout for page {self.details_page + 1}, using paged_data count: {len(paged_data)}") # Debug - Page and paged_data Count
            # --- MODIFIED: Calculate paged_data for current page on resize ---



            # Determine the available width
            self.details_canvas_sub.update_idletasks()

            # --- ADDED DEBUG PRINTS HERE ---
            print(f"DEBUG: update_subgrid_layout_on_resize - details_canvas_sub.winfo_width() BEFORE margin: {self.details_canvas_sub.winfo_width()}") # Print raw width
            width_before_margin = self.details_canvas_sub.winfo_width() # Capture width before margin
            width = width_before_margin - 60
            print(f"DEBUG: update_subgrid_layout_on_resize - width AFTER margin (-60): {width}") # Print width after margin
            # --- ADDED DEBUG PRINTS HERE ---




            if self.details_columns is None: # Initial column setup if not yet initialized
                num_columns, h_padding = self.calculate_columns_for_width(self, width, is_details=True)
                self.details_columns = (num_columns, h_padding)
            else:
                num_columns, h_padding = self.details_columns # Use stored column count and padding


            self.details_column_padding = h_padding # Store for consistency

            print(f"DEBUG: update_subgrid_layout_on_resize - num_columns: {num_columns}, h_padding: {h_padding}") # Print num_columns and h_padding BEFORE grid layout

            self.details_column_padding = h_padding
            print(f"DEBUG: update_subgrid_layout_on_resize - num_columns: {num_columns}, h_padding: {h_padding}")

            # --- ADD THIS LOGIC INSTEAD OF DELETION/RECREATION ---
            print(f"  DEBUG: Re-gridding existing {len(self.details_scrollable_frame.winfo_children())} child frames...")
            # Use winfo_children() as it's more likely the frames were added sequentially
            current_grid_items = self.details_scrollable_frame.winfo_children()

            for idx, frame_widget in enumerate(current_grid_items):
                if not isinstance(frame_widget, tk.Frame): # Skip non-frame widgets if any exist
                    # print(f"    Skipping non-frame widget at index {idx}: {type(frame_widget)}") # Optional debug
                    continue
                if not frame_widget.winfo_exists(): # Skip destroyed widgets
                    # print(f"    Skipping destroyed widget at index {idx}") # Optional debug
                    continue

                new_row = idx // num_columns
                new_col = idx % num_columns
                try:
                    # Use grid_configure to update position and padding
                    frame_widget.grid_configure(
                        row=new_row,
                        column=new_col,
                        padx=self.details_column_padding, # Use the calculated dynamic padding
                        pady=5,
                        sticky="nw"
                    )
                    # print(f"    Re-gridded item {idx} to row {new_row}, col {new_col}") # Optional Debug
                except tk.TclError as e:
                    print(f"    Error re-gridding widget {frame_widget}: {e}") # Handle potential errors if widget became invalid

            print(f"  DEBUG: Re-gridding complete.")
            # --- END ADDED LOGIC ---


            # --- Keep scroll region update ---
            self.details_scrollable_frame.update_idletasks()
            self.details_canvas_sub.config(scrollregion=self.details_canvas_sub.bbox("all"))

        except Exception as e:
            print(f"Error in update_subgrid_layout_on_resize: {e}")

            traceback.print_exc() # Print full traceback for errors here
        finally:
            print(f"DEBUG: update_subgrid_layout_on_resize - EXIT - current_details_batch_index: {getattr(self, 'current_details_batch_index', 'ATTRIBUTE_MISSING')}")
            print("--- update_subgrid_layout_on_resize() EXIT ---\n")

        

    #@profile 
    def update_grid_layout(self):
        """
        Updates the grid layout in the main window with dynamic column count and padding.
        Implements category collapsing and hover effects.
        Makes the mouse cursor change on hover over any part of the category header.
        """

        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- update_grid_layout CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")

        ConfigViewerApp.item_number = 0

        self.update_grid_layout_run = True

        print(f"--- update_grid_layout called by stack: ---")
        # Limit the depth if it gets too long, e.g., inspect.stack(0, 10) for 10 levels
        for frame_info in inspect.stack():
            print(f"  File \"{frame_info.filename}\", line {frame_info.lineno}, in {frame_info.function}")
            # Optional: print context code
            if frame_info.code_context:
                print(f"    Code: {frame_info.code_context[0].strip()}")
        print("----------------------------------------")


        if self.update_grid_layout_called_first_time:
            self.update_grid_layout_called_first_time = False 
            print("DEBUG: update_grid_layout SKIPPED ENTRY - self.update_grid_layout_called_first_time is true ")
            return

        print("DEBUG: update_grid_layout - self.pause_loading = False")
            
        self.pause_loading = False

        self._update_filters_label_status()

        if self.is_search_results_window_active:
            print("DEBUG: update_grid_layout - Search Results window is active. and fav amount is the same - SKIPPING main grid layout update.")

            return
        
        if self.favorites_amount_changed == True:
            print("resetting favorites_amount_changed to FALSE, we entered update grid layout with it set to True")
            self.favorites_amount_changed = False

        try:
            # Show loading label and start pulsating animation
            self.start_loading_animation()

            scanning_win = self.show_scanning_window(text="Updating UI data...")


            # Clear the existing grid
            print("DEBUG: update_grid_layout - destroying widgets")
            for widget in self.scrollable_frame.winfo_children():
                widget.destroy()

            self.main_grid_labels = [] # Clear the list to prevent accumulation


            # Determine the available width for images
            self.canvas.update_idletasks()
            width = self.canvas.winfo_width() - 60
            image_width = 200
            min_padding = 10

            if self.columns is None:
                self.columns, self.column_padding = self.calculate_columns_for_width(width)
            else:
                _, self.column_padding = self.calculate_columns_for_width(width)

            columns = self.columns
            fixed_padding_x = self.column_padding
            single_column_pixel_width = image_width + fixed_padding_x

            category_order = ["favorites", "car", "truck", "bus", "trailer", "aircraft", "prop"]

            ordered_categories = sorted(
                self.grouped_data.keys(),
                key=lambda x: (
                    category_order.index(x.lower()) if x.lower() in category_order else len(category_order),
                    x.lower()
                )
            )

            # Determine if label should be omitted based on item count
            self.omit_label = len(self.data) >= 1100 # Set flag based on total item count, set to impossibly high number, we're paginating the main grid

            self.category_batches = []
            for category in ordered_categories:
                category_hidden = self.category_hidden_states.get(category, False)

                # if self.categorization_mode == 'None' and category == "All Items":
                #     header_frame = None
                #     category_subframe = tk.Frame(self.scrollable_frame, bg="#444444")
                #     category_subframe.pack(fill="x")
                # else:

                header_frame = tk.Frame(self.scrollable_frame, bg="#444444", cursor="hand2")
                header_frame.pack(fill=tk.X, pady=(5, 0))

                search_query = self.search_var.get().strip().lower()
                matching_item_count = 0
                for item in self.grouped_data[category]:
                    if self._perform_item_search(search_query, item):
                        matching_item_count += 1

                header_text = category
                if category_hidden:
                    header_text += " (Hidden)"

                header_text_with_count = f"{header_text} ({matching_item_count})"
                header_label = tk.Label(
                    header_frame,
                    text=header_text_with_count,
                    font=("Segoe UI", 14+self.font_size_add, "bold"),
                    bg="#444444",
                    fg="#d9d9d9",
                    anchor="w",
                    cursor="hand2"
                )
                header_label.pack(side=tk.LEFT, padx=10, pady=(10, 0))
                header_label.bind("<Button-1>", lambda event, cat=category: self.toggle_category_visibility(cat))

                separator = tk.Frame(
                    header_frame,
                    height=4,
                    bd=1,
                    relief="sunken",
                    bg="#d9d9d9",
                    cursor="hand2"
                )
                separator.pack(side=tk.BOTTOM, fill="x", padx=10, pady=(0, 10))

                header_frame.bind("<Enter>", lambda event, cat=category, header=header_label, sep=separator, count=matching_item_count: self.on_category_hover_enter(event, cat, header, sep, count))
                header_frame.bind("<Leave>", lambda event, cat=category, header=header_label, sep=separator, count=matching_item_count: self.on_category_hover_leave(event, cat, header, sep, count))
                header_frame.bind("<Button-1>", lambda event, cat=category: self.toggle_category_visibility(cat))

                category_subframe = tk.Frame(self.scrollable_frame, bg="#444444")
                if not category_hidden:
                    category_subframe.pack(fill="x")
                else:
                    category_subframe.pack_forget()

                self.image_counts[category] = 0

                items = self.grouped_data[category]
                if isinstance(items, list):
                    all_items = []
                    for item in items:
                        if isinstance(item, dict) and 'configs' in item:
                            for config in item['configs']:
                                all_items.append(config)
                        elif len(item) == 5:
                            all_items.append(item)


                    batch_size = 50 # THIS NUMBER CANNOT BE BIGGER THAN 
                                    # ANYTHING IN self.main_grid_batch_sizes
                                    # AND IT ALSO CAN'T BE BIGGER THAN 
                                    # batch_size_to_load under 
                                    # self.all_main_grid_images_cached

                    batches = [all_items[i:i + batch_size] for i in range(0, len(all_items), batch_size)]
                    self.category_batches.append((category, batches, category_subframe))

            self.current_category_index = 0
            self.current_batch_index = 0

            self.load_next_batch()


        except Exception as e:
            print(f"Error in update_grid_layout: {e}")


        if scanning_win:
            scanning_win.destroy()
            



        print("DEBUG: update_grid_layout - EXIT")

            

    def toggle_category_visibility(self, category):
        """Toggles the visibility of a category and its widgets."""


        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot hide or unhide categories while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return


        self.category_hidden_states[category] = not self.category_hidden_states.get(category, False)
        print("    toggle_category_visibility is calling self.update_grid_layout()")
        self.update_grid_layout() # Re-layout the grid to reflect changes


    def on_category_hover_enter(self, event, category, header_label, separator, count):
        """Handles mouse hover enter event for category headers with animation."""
        # --- Instant Text Change ---
        if self.category_hidden_states.get(category, False):
            header_label.config(text=f"{category} (Show) ({count})")
        else:
            header_label.config(text=f"{category} (Hide) ({count})")

        # --- Start Animation ---
        group_key = ("category_header", category) # Unique key for this category header + separator
        property_config_list_target = [
            {'widget': separator, 'property': 'bg', 'target_color': self.global_highlight_color},
            {'widget': header_label, 'property': 'fg', 'target_color': self.global_highlight_color}
        ]
        self._start_generic_animation(group_key, property_config_list_target)


    def on_category_hover_leave(self, event, category, header_label, separator, count):
        """Handles mouse hover leave event for category headers with animation."""
        original_color = "#d9d9d9" # Assuming this is the original hex color

        # --- Instant Text Change ---
        if self.category_hidden_states.get(category, False):
            header_label.config(text=f"{category} (Hidden) ({count})")
        else:
            header_text = category
            # This inner check for (Hidden) seems redundant if the outer one already handles it
            # if self.category_hidden_states.get(category, False):
            #     header_text += " (Hidden)"
            header_label.config(text=f"{header_text} ({count})")

        # --- Start Animation Back ---
        group_key = ("category_header", category)
        property_config_list_target = [
            {'widget': separator, 'property': 'bg', 'target_color': original_color},
            {'widget': header_label, 'property': 'fg', 'target_color': original_color}
        ]
        self._start_generic_animation(group_key, property_config_list_target)
    

    # ------------------------------------------------------------
    # Populate Subgrid Page
    # ------------------------------------------------------------

    def update_subgrid_layout(self, scrollable_frame_sub, subgrid_data):
        """
        Updates the subgrid layout with dynamic padding.
        """
        max_retries = 5
        retry_count = 0
        while retry_count < max_retries:
            try:
                for widget in scrollable_frame_sub.winfo_children():
                    widget.destroy()

                scrollable_frame_sub.update_idletasks()
                if self.details_canvas_sub:
                    width = self.details_canvas_sub.winfo_width() - 20
                else:
                    width = scrollable_frame_sub.winfo_width() - 20

                image_width = 200


                if self.details_columns is None: # Initial column setup if not yet initialized
                    num_columns, h_padding = self.calculate_columns_for_width(width, is_details=True)
                    self.details_columns = (num_columns, h_padding)
                else:
                    num_columns, h_padding = self.details_columns # Use stored column count and padding


                self.details_column_padding = h_padding # Store for consistency


                if width > 0:
                    for idx, item in enumerate(subgrid_data):
                        row = idx // num_columns
                        col = idx % num_columns
                        container = tk.Frame(scrollable_frame_sub, bg="#FFFFFF")
                        container.grid(row=row, column=col, padx=self.details_column_padding, pady=5, sticky="nw") # Dynamic padding here
                        self.executor.submit(
                            self.load_image_item_details,
                            item,
                            container,
                            row,
                            col
                        )
                    scrollable_frame_sub.update_idletasks()
                    scrollable_frame_sub.master.config(scrollregion=scrollable_frame_sub.master.bbox("all"))
                    return
                else:
                    retry_count += 1
                    if self.details_window:
                        self.details_window.update()
                        self.details_window.after(100)
                    else:
                        break
            except Exception as e:
                retry_count += 1
                if self.details_window:
                    self.details_window.update()
                    self.details_window.after(100)
                else:
                    break




    # ------------------------------------------------------------
    # Load & Display Subgrid Item (Details Window - NO CACHE)
    # ------------------------------------------------------------
    def create_details_item_widgets(self, parent_frame, photo, pil_image, spawn_cmd, info_data, zip_file, picture_path, folder_name, zip_file_base_name, config_name):
        """
        Creates and configures the widgets for a single image item in the details window,
        **NOW WITH WIDGET COUNT LIMIT and DEBUG PRINT.**
        """

        print("\n--- create_details_item_widgets() DEBUG ENTRY ---") # <--- DEBUG ENTRY
        print(f"  DEBUG: create_details_item_widgets - Widget Count (at entry): {ConfigViewerApp.details_widget_count}") # Debug - Count at Entry
        print(f"  DEBUG: create_details_item_widgets - File: {os.path.basename(picture_path)}") # Debug - Filename
        print(f"  DEBUG: create_details_item_widgets - Parent Frame: {parent_frame}") # Debug - Parent Frame Widget

        if not parent_frame.winfo_exists():
            print("  DEBUG: create_details_item_widgets - Parent frame no longer exists, exiting.") # Debug - Parent Frame Missing
            print("--- create_details_item_widgets() DEBUG EXIT (Parent Frame Missing) ---\n") # Debug Exit - Parent Missing
            return

        print(f"DEBUG: create_details_item_widgets - START - Widget Count: {ConfigViewerApp.details_widget_count}, File: {os.path.basename(picture_path)}") # <--- DEBUG PRINT - WIDGET COUNT

        if ConfigViewerApp.details_widget_count >= 50: # <--- CHECK WIDGET COUNT LIMIT
            print(f"DEBUG: create_details_item_widgets - Widget limit reached (50), skipping widget creation for: {os.path.basename(picture_path)}") # Debug - Limit Reached
            return # Skip widget creation if limit is reached

        # --- Image Label (similar to details view) ---
        lbl_img = tk.Label(parent_frame, image=photo, cursor="hand2", bg="#FFFFFF") # MODIFIED HERE
        lbl_img.image = photo
        lbl_img.pack(padx=0, pady=0)
        # --- NEW: Store default image background color ---
        lbl_img.default_bg_color = "#FFFFFF" # Store the default bg color for image label - background for images - border
        # --- NEW: Store default image background color ---

        # --- Tooltip for image label ---


        # --- Text Label (info label) ---
        config_name_extracted = self.extract_name_from_spawn_command(spawn_cmd)
        if not config_name_extracted:
            config_name_extracted = os.path.splitext(os.path.basename(zip_file))[0]

        individual_info_path = self.find_individual_info_file(folder_name, zip_file_base_name=zip_file_base_name, config_name=config_name_extracted)

        label_text = config_name_extracted # Default label text
        individual_info_json = {} # Initialize as empty dict

        if individual_info_path:
            try:
                individual_info_json, _ = self._load_individual_info(individual_info_path)
                configuration_text = individual_info_json.get("Configuration")
                if configuration_text:
                    label_text = configuration_text
            except Exception as e:
                print(f"  WARNING: Error loading/parsing individual info file for label {individual_info_path}: {e}. Using default name.")


        # --- MODIFIED: Set label color based on picture_path ---
        label_color = "#FFFFFF" # Default color
        if "_user--" in picture_path:
            label_color = "#ADD8E6" #lightblue  for custom configs
        else: # Add the new elif here within the else block to maintain priority
            found_double_basename = False
            for base_name in self.ZIP_BASE_NAMES:
                if picture_path.count(f"--{base_name}_{base_name}.zip") > 0: # Check for the specific pattern
                    found_double_basename = True
                    break # No need to check further once one is found
            if found_double_basename:
                label_color = "#f7efd7" # color for default zips/folder combo

        # --- MODIFIED: Set label color based on picture_path ---

        lbl_name = tk.Label(
            parent_frame,
            text=label_text,
            wraplength=200, #label length, don't remove current
            justify="center",
            fg=label_color,
            font=("Segoe UI", 10+self.font_size_add, "bold"),
            cursor="hand2",
            bg="#444444", # MODIFIED HERE
            height=3,
            anchor=tk.N
        )
        lbl_name.pack(padx=0, pady=5)
        # --- NEW: Store default text color as attribute ---
        lbl_name.default_fg_color = label_color  # Store the default text color
        # --- NEW: Store default text color as attribute ---


        if not self.middle_click_settings:
            tooltip_text = "> Double click: Add to Spawn Queue.\n> Middle Click: Immediately spawn.\n> Right click: Manage mod, view \n   details and customize config color."

        if self.middle_click_settings:
            tooltip_text = "> Middle click: Add to Spawn Queue.\n> Double Click: Immediately spawn.\n> Right click: Manage mod, view \n   details and customize config color."
        

        
        HOVER_FG_COLOR = self.global_highlight_color # For lbl_name text
        HOVER_BG_COLOR_IMG = self.global_highlight_color # For lbl_img background

        # The search highlight color - if you want it to be different from global_highlight_color
        SEARCH_HIGHLIGHT_COLOR_FG = "#FFFF00" # Yellow for text when search matches
        SEARCH_HIGHLIGHT_COLOR_BG = "#FFFF00" # Yellow for image bg when search matches
                                             # Or use self.global_highlight_color if you want orange

        # Ensure original colors are stored for animation system fallback if needed,
        # especially if widgets might be created with color names initially.
        # This should ideally happen when lbl_img and lbl_name are created.
        # For safety, we can add a check here too, but creation time is better.

        if lbl_img and hasattr(lbl_img, 'default_bg_color'):
            if lbl_img not in self.widget_original_colors:
                self.widget_original_colors[lbl_img] = {}
            # setdefault ensures it's only set if 'bg' is not already a key
            self.widget_original_colors[lbl_img].setdefault('bg', lbl_img.default_bg_color)

        if lbl_name and hasattr(lbl_name, 'default_fg_color'):
            if lbl_name not in self.widget_original_colors:
                self.widget_original_colors[lbl_name] = {}
            self.widget_original_colors[lbl_name].setdefault('fg', lbl_name.default_fg_color)


        def on_hover_enter(event):
            # Animate lbl_name foreground to hover color
            if lbl_name and lbl_name.winfo_exists():
                self._start_animation(lbl_name, {'fg': HOVER_FG_COLOR}) # MODIFIED

            # Animate lbl_img background to hover color
            if lbl_img and lbl_img.winfo_exists():
                self._start_animation(lbl_img, {'bg': HOVER_BG_COLOR_IMG}) # MODIFIED

            # --- DEBOUNCED Tooltip (remains the same) ---
            if hasattr(self, 'tooltip_debounce_timer') and self.tooltip_debounce_timer:
                if self.master and self.master.winfo_exists(): # Check master exists before after_cancel
                    try:
                        self.master.after_cancel(self.tooltip_debounce_timer)
                    except tk.TclError: # Might already be cancelled or master gone
                        pass
                self.tooltip_debounce_timer = None

            # Assuming self._delayed_show_tooltip and tooltip_text are defined
            # And self.master is the appropriate widget to call .after on
            if self.master and self.master.winfo_exists(): # Check master exists before .after
                self.tooltip_debounce_timer = self.master.after(
                    200, # Debounce delay
                    lambda widget=event.widget, text=tooltip_text: self._delayed_show_tooltip(widget, text)
                )
            # --- DEBOUNCED Tooltip ---

        def on_hover_leave(event):
            target_name_fg = None
            target_img_bg = None

            # Determine target colors based on search query
            search_query = ""
            if hasattr(self, 'details_search_var') and self.details_search_var: # Ensure search var exists
                search_query = self.details_search_var.get().strip().lower()
            
            config_name_for_search = ""
            if lbl_name and lbl_name.winfo_exists(): # Check if lbl_name exists before cget
                try:
                    config_name_for_search = lbl_name.cget("text").lower()
                except tk.TclError: # In case cget fails unexpectedly
                    pass


            # Robustly get default colors for lbl_name, ensure they are valid hex
            default_name_fg = "#000000" # Fallback
            if lbl_name and hasattr(lbl_name, 'default_fg_color'):
                try:
                    # Validate the default color itself before assigning
                    self._hex_to_rgb(lbl_name.default_fg_color)
                    default_name_fg = lbl_name.default_fg_color
                except (ValueError, TypeError, AttributeError): # Catch if default_fg_color is not valid hex or not string
                    print(f"Warning: Invalid or missing default_fg_color for {lbl_name}. Using black.")

            # Robustly get default colors for lbl_img, ensure they are valid hex
            default_img_bg = "#FFFFFF" # Fallback
            if lbl_img and hasattr(lbl_img, 'default_bg_color'):
                try:
                    # Validate the default color itself
                    self._hex_to_rgb(lbl_img.default_bg_color)
                    default_img_bg = lbl_img.default_bg_color
                except (ValueError, TypeError, AttributeError): # Catch if default_bg_color is not valid hex or not string
                    print(f"Warning: Invalid or missing default_bg_color for {lbl_img}. Using white.")


            if search_query and config_name_for_search and search_query in config_name_for_search:
                # If part of a search result, revert to default colors
                # (or set to specific SEARCH_HIGHLIGHT_COLOR if defined and desired)
                target_name_fg = default_name_fg
                target_img_bg = default_img_bg
            else:
                # Not part of a search result, or no search query, revert to default
                target_name_fg = default_name_fg
                target_img_bg = default_img_bg

            # Animate lbl_name foreground to its target color
            if lbl_name and lbl_name.winfo_exists() and target_name_fg:
                self._start_animation(lbl_name, {'fg': target_name_fg}) # MODIFIED

            # Animate lbl_img background to its target color
            if lbl_img and lbl_img.winfo_exists() and target_img_bg:
                self._start_animation(lbl_img, {'bg': target_img_bg}) # MODIFIED

            self.hide_details_item_tooltip() # Hide tooltip immediately on leave



        lbl_img.bind("<Enter>", on_hover_enter)
        lbl_img.bind("<Leave>", on_hover_leave)
        lbl_name.bind("<Enter>", on_hover_enter) # Bind hover to text label too
        lbl_name.bind("<Leave>", on_hover_leave) # Bind leave to text label too
        # --- End Hover effect ---


        # --- Click Bindings (similar to original, but on Labels now) ---
        lbl_img.bind("<Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name, ind_path=individual_info_path:
            (

                self.on_details_image_click(s, i_data, pic_path, z_file, f_name), # Original action
                # *** ADDED: Update details sidebar ***
                self.update_details_sidebar_config_name(spawn_cmd),
                self.update_details_sidebar_individual_info(ind_path, i_data) # Pass path and main_info

                
            )
        )




        # === Button-3 (Right Click) - MODIFY THIS ===
        lbl_img.bind("<Button-3>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name, z_base_name=zip_file_base_name, c_name=config_name_extracted, ind_path=individual_info_path: # Use config_name_extracted
                 (
                     #self.clear_details_sidebar_content(), # Keep if desired
                     self.open_detail_info_window(s, i_data, pic_path, z_file, f_name, z_base_name, c_name), # Keep

                     self.update_details_sidebar_content(info_data, picture_path, zip_file, folder_name=self.current_details_folder),
                     self.update_details_sidebar_config_name(spawn_cmd),
                     # *** ADD the CORRECT call ***
                     self.update_details_sidebar_individual_info(ind_path, i_data) # Add this
                 )
        )
        lbl_name.bind("<Button-3>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name, z_base_name=zip_file_base_name, c_name=config_name_extracted, ind_path=individual_info_path: # Use config_name_extracted
                 (
                     #self.clear_details_sidebar_content(), # Optional clear
                     self.open_detail_info_window(s, i_data, pic_path, z_file, f_name, z_base_name, c_name), # Keep

                     self.update_details_sidebar_content(info_data, picture_path, zip_file, folder_name=self.current_details_folder),
                     self.update_details_sidebar_config_name(spawn_cmd),
                     # *** ADD the CORRECT call ***
                     self.update_details_sidebar_individual_info(ind_path, i_data) # Add this
                 )
        )
        
        lbl_name.bind("<Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name, ind_path=individual_info_path:
            (
                self.on_details_image_click(s, i_data, pic_path, z_file, f_name), # Original action
                self.update_sidebar_content(i_data, pic_path, z_file, folder_name=self.current_details_folder),
                self.update_details_sidebar_config_name(spawn_cmd),
                # *** ADDED: Update details sidebar ***
                self.update_details_sidebar_individual_info(ind_path, i_data) # Pass path and main_info
            )
        )


        if not self.middle_click_settings:
            lbl_name.bind("<Button-2>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_replace_current_button_click(spawn_cmd, event=None)) # <-- ADDED middle CLICK BINDING HERE
            lbl_img.bind("<Button-2>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_replace_current_button_click(spawn_cmd, event=None)) # <-- ADDED middle CLICK BINDING HERE

            lbl_img.bind("<Double-Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_details_item_double_click_to_queue(spawn_cmd, info_data, picture_path, zip_file, folder_name)) # <-- ADDED DOUBLE CLICK BINDING HERE
            lbl_name.bind("<Double-Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_details_item_double_click_to_queue(spawn_cmd, info_data, picture_path, zip_file, folder_name)) # <-- ADDED DOUBLE CLICK BINDING HERE


        if self.middle_click_settings:
            lbl_name.bind("<Double-Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_replace_current_button_click(spawn_cmd, event=None)) # <-- ADDED middle CLICK BINDING HERE
            lbl_img.bind("<Double-Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_replace_current_button_click(spawn_cmd, event=None)) # <-- ADDED middle CLICK BINDING HERE

            lbl_img.bind("<Button-2>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_details_item_double_click_to_queue(spawn_cmd, info_data, picture_path, zip_file, folder_name)) # <-- ADDED DOUBLE CLICK BINDING HERE
            lbl_name.bind("<Button-2>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_details_item_double_click_to_queue(spawn_cmd, info_data, picture_path, zip_file, folder_name)) # <-- ADDED DOUBLE CLICK BINDING HERE
        

        # --- NEW: Store item-specific data (keep this) ---
        parent_frame.item_data_tuple = (pil_image, info_data, picture_path, zip_file, folder_name, spawn_cmd, lbl_img, lbl_name) # Store labels instead of button
        # --- NEW: Store item-specific data ---

        print(f"DEBUG: create_details_item_widgets - Incrementing widget count for: {os.path.basename(picture_path)}, Current Count BEFORE increment: {ConfigViewerApp.details_widget_count}") # <--- DEBUG PRINT - WIDGET COUNT

        ConfigViewerApp.details_widget_count += 1 # <--- INCREMENT WIDGET COUNT
        
        
     


    def _delayed_show_tooltip(self, widget, tip_text):
        """Helper function to show the tooltip after a debounce delay."""

        if not widget.winfo_exists(): # <--- CHECK IF WIDGET EXISTS HERE
            print("DEBUG: _delayed_show_tooltip - Widget no longer exists, aborting tooltip display.") # Debug print
            return # Exit if widget doesn't exist anymore

        self.tooltip_debounce_timer = None # Reset debounce timer as action is now being taken

        if self.current_details_item_tooltip_window: # If a tooltip is already showing, destroy it first
            self.hide_details_item_tooltip()

        self.current_details_item_tooltip_window = FadingToplevel(self.details_window, self)
        self.current_details_item_tooltip_window.overrideredirect(True) # Remove border
        self.current_details_item_tooltip_window.tk.call('tk', 'scaling', 1.25)
        self.current_details_item_tooltip_window.attributes("-topmost", True) # Keep on top

        tooltip_label = tk.Label(self.current_details_item_tooltip_window, text=tip_text, font=("Segoe UI", 10+self.font_size_add, "italic"), fg="#d9d9d9", bg="#555555", padx=5, pady=2, relief=tk.SOLID, borderwidth=1, justify=tk.LEFT) # Dark bg, lightgrey fg, left justify
        tooltip_label.pack(padx=1, pady=1)

        widget_width = widget.winfo_width()
        widget_height = widget.winfo_height()
        widget_abs_x = widget.winfo_rootx()
        widget_abs_y = widget.winfo_rooty()

        tooltip_x = widget_abs_x + widget_width + 5 # Position to the right, 5px gap
        tooltip_y = widget_abs_y + (widget_height // 1) - (self.current_details_item_tooltip_window.winfo_reqheight() // 2) # Center vertically

        self.current_details_item_tooltip_window.geometry(f"+{tooltip_x}+{tooltip_y}")

        # --- Auto-destroy timer ---
        if self.tooltip_autodestroy_timer: # Clear any existing auto-destroy timer (shouldn't be one here, but for safety)
            self.master.after_cancel(self.tooltip_autodestroy_timer)
            self.tooltip_autodestroy_timer = None

        self.tooltip_autodestroy_timer = self.master.after(4000, self.hide_details_item_tooltip) # Set auto-destroy timer (4 seconds)
        # --- Auto-destroy timer ---


    def show_details_item_tooltip(self, widget, tip_text): # Kept for potential direct calls if needed, but not used by hover now
        """Displays a tooltip window to the right of the given widget."""
        # This function is now mostly handled by _delayed_show_tooltip for debounce/autodestroy.
        # You might still call this directly from other parts of your code if you want an immediate tooltip without debounce/autodestroy.
        # For now, it can remain as is, or you can decide to remove it and only use _delayed_show_tooltip.
        if self.current_details_item_tooltip_window:
            self.hide_details_item_tooltip() # Destroy existing tooltip if any

        self.current_details_item_tooltip_window = FadingToplevel(self.details_window, self)
        self.current_details_item_tooltip_window.overrideredirect(True) # Remove border
        self.current_details_item_tooltip_window.tk.call('tk', 'scaling', 1.25)
        self.current_details_item_tooltip_window.attributes("-topmost", True) # Keep on top

        tooltip_label = tk.Label(self.current_details_item_tooltip_window, text=tip_text, font=("Segoe UI", 10+self.font_size_add, "italic"), fg="#d9d9d9", bg="#555555", padx=5, pady=2, relief=tk.SOLID, borderwidth=1, justify=tk.LEFT) # Dark bg, lightgrey fg, left justify
        tooltip_label.pack(padx=1, pady=1)

        widget_width = widget.winfo_width()
        widget_height = widget.winfo_height()
        widget_abs_x = widget.winfo_rootx()
        widget_abs_y = widget.winfo_rooty()

        tooltip_x = widget_abs_x + widget_width + 5 # Position to the right, 5px gap
        tooltip_y = widget_abs_y + (widget_height // 2) - (self.current_details_item_tooltip_window.winfo_reqheight() // 2) # Center vertically

        self.current_details_item_tooltip_window.geometry(f"+{tooltip_x}+{tooltip_y}")

        # --- Auto-destroy timer ---  (Added here as well, in case you call this function directly)
        if self.tooltip_autodestroy_timer:
            self.master.after_cancel(self.tooltip_autodestroy_timer)
            self.tooltip_autodestroy_timer = None
        self.tooltip_autodestroy_timer = self.master.after(4000, self.hide_details_item_tooltip) # Set auto-destroy timer (4 seconds)
        # --- Auto-destroy timer ---


    def hide_details_item_tooltip(self):
        """Destroys the details item tooltip window if it exists and cancels timers."""
        if self.current_details_item_tooltip_window:
            
            
            try: # <--- ADDED TRY-EXCEPT BLOCK HERE
                self.current_details_item_tooltip_window.destroy()
            except tk.TclError:
                # Window might be already destroyed, ignore error
                pass
            finally: # <--- ADDED FINALLY BLOCK HERE
                self.current_details_item_tooltip_window = None

        # --- Cancel debounce timer if it's pending ---
        if self.tooltip_debounce_timer:
            self.master.after_cancel(self.tooltip_debounce_timer)
            self.tooltip_debounce_timer = None

        # --- Cancel auto-destroy timer if it's pending ---
        if self.tooltip_autodestroy_timer:
            self.master.after_cancel(self.tooltip_autodestroy_timer)
            self.tooltip_autodestroy_timer = None



        
    def on_details_item_double_click_to_queue(self, spawn_cmd, info_data, picture_path, zip_file, folder_name):
        """Handles double click on an item in the details subgrid to add it to the spawn queue."""


        if spawn_cmd: # Only proceed if spawn_cmd is successfully obtained (either from label or stored attribute)
            try:


                scanning_win = None 

                scanning_win = self.show_scanning_window(text="Added to Spawn Queue") # <-- SHOW SCANNING WINDOW HERE
                # Make the window visible
                self.master.update_idletasks() # Force window to appear immediately

                self.is_details_sidebar_sticky = True
                self.is_details_sidebar_showing_default = False
                # --- MODIFIED: Write to spawn queue file instead of clipboard ---
                try:
                    # Check if the spawn queue file exists and is not empty
                    write_ellexium_line = not os.path.exists(self.SPAWN_QUEUE_FILE) or os.stat(self.SPAWN_QUEUE_FILE).st_size == 0

                    with open(self.SPAWN_QUEUE_FILE, 'a', encoding="utf-8") as f: # Open in append mode
                        if write_ellexium_line:
                            f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")

                        lines = spawn_cmd.splitlines()
                        modified_lines = []

                        for line in lines:
                            if "(USE" in line:
                                parts = line.split('(USE', 1) # Split at the FIRST '(USE', maxsplit=1
                                modified_line = parts[0] + "-- (USE" + parts[1] # Reassemble with "-- " before '(USE'
                                modified_lines.append(modified_line)
                            else:
                                modified_lines.append(line)

                        modified_spawn_cmd = "\n".join(modified_lines)
                        spawn_cmd = modified_spawn_cmd

                        f.write(f"{spawn_cmd} -- (USE 1|||{picture_path}||| 2[{zip_file}]\n") # MODIFIED: Write command and additional info on the same line

                    #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                    print(f"DEBUG: Command written to spawn queue file: '{self.SPAWN_QUEUE_FILE}'") # Debug
                except Exception as e:
                    #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                    print(f"ERROR: Failed to add spawn queue: {e}") # Error print
                # --- MODIFIED: Write to spawn queue file instead of clipboard ---


                # --- NEW: Refresh Spawn Queue Window if open  ---
                if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
                    print("DEBUG: Spawn Queue window is open, refreshing content...")
                    self.populate_spawn_queue_window(self.spawn_queue_scrollable_frame) # Refresh content
                    print("DEBUG: Spawn Queue window content refreshed.")
                #--- NEW: Refresh Spawn Queue Window if open (now refreshed later conditionally) ---

                if scanning_win:

                    def close_scanning_window():

                        scanning_win.destroy()

                    scanning_win.after(3125, close_scanning_window)
                return

                # --- NEW: Re-open Spawn Queue Window if it was closed initially ---


            except Exception as e:
                print(f"Error during spawn process: {e}")

            else:
                print("Warning: Spawn command STILL not available for writing to Spawn Queue (from double click).") # Debug - Still no spawn command
        
  



    def debounced_show_main_sidebar_info(self, info_data, picture_path, zip_file, folder_name, item, individual_path=None, main_info_for_details=None):
        """
        Debounced function that NOW ALSO triggers details sidebar update.
        """
        # Call the actual function, passing ALL arguments along
        self.show_main_sidebar_info(info_data, picture_path, zip_file, folder_name, item, individual_path, main_info_for_details)
        self.details_sidebar_debounce_timer = None # Reset timer
      
  



    def _apply_details_data_subset_filter(self, data_to_filter):
        """
        Filters details data list, detailed debug output for prefix comparison.
        - DEBUG: Added logging to inspect normalized prefixes just before comparison.
        """
        if not self.is_data_subset_active:  # Respect global filter toggle
            return data_to_filter

        subset_filepaths = set()
        data_subset_file_path = os.path.join(self.script_dir, self.data_subset_file)
        if os.path.exists(data_subset_file_path):
            with open(data_subset_file_path, 'r', encoding="utf-8") as f:
                for line in f:
                    filepath = line.strip().lower().replace('\\', '/')  # Normalize subset filepaths
                    if filepath:
                        subset_filepaths.add(filepath)

        if not subset_filepaths:
            return []

        filtered_data = []
        config_pics_path_lower = self.config_pics_folder.lower().replace('\\', '/')

        for item in data_to_filter:
            pic_path = item[0]
            if pic_path:
                normalized_pic_path = os.path.normpath(pic_path).lower().replace('\\', '/')
                if normalized_pic_path.startswith(config_pics_path_lower):
                    normalized_pic_path = normalized_pic_path[len(config_pics_path_lower):].lstrip('/')

                is_exact_match_found = False
                for subset_line in subset_filepaths:
                    normalized_subset_line = subset_line.strip().lower()

                    # --- NEW: DEBUG PRINTS - Inspect normalized prefixes just before comparison ---
                    #print("DEBUG: Details Subset Filter - Comparing:")
                    #print(f"       Normalized Item Path: '{normalized_pic_path}'") # Print normalized item path
                    #print(f"       Normalized Subset Line: '{normalized_subset_line}'") # Print normalized subset line
                    # --- NEW: DEBUG PRINTS ---


                    if normalized_pic_path == normalized_subset_line:  # Check for EXACT MATCH
                        filtered_data.append(item)
                        is_exact_match_found = True
                        print(f"       - EXACT MATCH FOUND in data_subset.txt") # Debug - Match Found
                        break

                if not is_exact_match_found:
                    pass
                    #print(f"DEBUG: Subset Filter FAIL - Folder: '{item[4]}'")
                    #print(f"       Required prefix line (Normalized): '{normalized_pic_path}'")
                    #print(f"       NO EXACT LINE MATCH in data_subset.txt (Normalized Lines Comparison)")
                    #print(f"       data_subset.txt LINES (Normalized): { [line.strip().lower() for line in subset_filepaths]}")
                    #print(f"       Raw data_subset.txt LINES: {list(subset_filepaths)}")
                    #print(f"       Raw Required Prefix Line: '{pic_path}'") # Raw pic_path here (not prefix)


        #print(f"DEBUG: _apply_details_data_subset_filter - Filtered details data to {len(filtered_data)} items (Full Path Match).")
        return filtered_data





    def go_to_previous_details_page(self):
        """Navigates to the previous page in the details window pagination and resets widget counter."""

        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win


        if self.details_page > 0:
            self.details_page -= 1

            # --- MODIFIED: Reset widget count on page change (PREVIOUS) ---
            ConfigViewerApp.details_widget_count = 0 # <--- RESET WIDGET COUNT HERE
            print("DEBUG: go_to_previous_details_page - Widget count RESET to 0 for new page.") # Debug - Widget Count Reset
            # --- MODIFIED: Reset widget count on page change (PREVIOUS) ---

            self.rebuild_simple_details()
            self._update_details_pagination_bar()

            

    def go_to_next_details_page(self):
        """Navigates to the next page in the details window pagination and resets widget counter."""

        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win

        total_pages = math.ceil(len(self.details_filtered_data) / self.items_per_page) if self.items_per_page else 1
        if self.details_page < total_pages - 1:
            self.details_page += 1

            # --- MODIFIED: Reset widget count on page change (NEXT) ---
            ConfigViewerApp.details_widget_count = 0 # <--- RESET WIDGET COUNT HERE
            print("DEBUG: go_to_next_details_page - Widget count RESET to 0 for new page.") # Debug - Widget Count Reset
            # --- MODIFIED: Reset widget count on page change (NEXT) ---

            self.rebuild_simple_details()
            self._update_details_pagination_bar()
            





    def customize_color_config(self, spawn_cmd, folder_name):
        """
        Customizes the color configuration by checking for a .pc file in user vehicles
        or extracting it from a mod zip file. Performs case-insensitive search in zip_structure.txt.

        Args:
            spawn_cmd (str): The spawn command string containing the vehicle config path.
            folder_name (str): The folder name (used for model_information.txt).
        """
        print(f"Starting customize_color_config with spawn_cmd: {spawn_cmd}, folder_name: {folder_name}")

        # 1. Extract the vehicle config path
        try:
            config_path_start = spawn_cmd.index("{config = '") + len("{config = '")
            config_path_end = spawn_cmd.index("'}", config_path_start)
            vehicle_config_path = spawn_cmd[config_path_start:config_path_end]
            print(f"Extracted vehicle config path: {vehicle_config_path}")
        except ValueError:
            print(f"Error: Could not parse vehicle config path from spawn_cmd: {spawn_cmd}")
            return

        # 2. Define search folders
        data_folder = self.script_dir / "data"
        user_vehicles_folder_txt_path = data_folder / "user_vehicles_folder.txt"
        script_parent_folder = self.script_dir.parent # Assuming script_dir is defined in your class

        print(f"Data folder path: {data_folder}")
        print(f"User vehicles folder txt path: {user_vehicles_folder_txt_path}")
        print(f"Script parent folder path: {script_parent_folder}")

        # Write model information (Consider if this overwrite logic is always desired)
        print(f"Updating model_information.txt with {folder_name}")
        model_info_file_path = data_folder / "model_information.txt"
        try:
            # Ensure data directory exists
            data_folder.mkdir(parents=True, exist_ok=True)
            with open(model_info_file_path, 'w', encoding='utf-8') as f:
                f.write(folder_name + '\n')
            print(f"Created/updated {model_info_file_path} with folder_name: {folder_name}")
        except Exception as e:
            print(f"Error writing to {model_info_file_path}: {e}")
            # Decide if you should return here or continue

        # 3. Get User Vehicles Folder Path
        user_vehicles_base_folder = None
        try:
            with open(user_vehicles_folder_txt_path, 'r', encoding='utf-8') as f:
                user_vehicles_base_folder_str = f.readline().strip()
                if not user_vehicles_base_folder_str:
                    print(f"Error: {user_vehicles_folder_txt_path} is empty or contains only whitespace.")
                    return
                user_vehicles_base_folder = Path(user_vehicles_base_folder_str)
            print(f"User vehicles base folder read from file: {user_vehicles_base_folder}")
            if not user_vehicles_base_folder.is_dir():
                 print(f"Error: User vehicles path specified in {user_vehicles_folder_txt_path} is not a valid directory: {user_vehicles_base_folder}")


        except FileNotFoundError:
            print(f"Error: {user_vehicles_folder_txt_path} not found.")
            return
        except Exception as e:
            print(f"Error reading user_vehicles_folder.txt: {e}")
            return

        # Construct paths for user vehicles folder check
        try:
            vehicle_folder_name = Path(vehicle_config_path).parts[1] # e.g., DOmirage from vehicles/DOmirage/4G63 Turbo.pc
            pc_file_name = Path(vehicle_config_path).name # e.g., 4G63 Turbo.pc
            user_vehicle_pc_path = user_vehicles_base_folder / vehicle_folder_name / pc_file_name
            print(f"User vehicle .pc file path to check: {user_vehicle_pc_path}")
        except IndexError:
            print(f"Error: Could not parse vehicle folder name from config path: {vehicle_config_path}")
            return

        # 4. Check user_vehicles folder
        if user_vehicle_pc_path.exists():
            print(f"Found .pc file in user vehicles folder: {user_vehicle_pc_path}")
            destination_path = data_folder / "customcarcol.pc"
            try:
                shutil.copy2(user_vehicle_pc_path, destination_path)
                print(f"Copied and renamed .pc file from {user_vehicle_pc_path} to {destination_path}")
                self.color_picker() # Assuming self.color_picker() is defined
            except Exception as e:
                print(f"Error copying .pc file from user vehicles: {e}")
            return # Exit after successfully handling user vehicles file

        print(f".pc file not found in user vehicles folder: {user_vehicle_pc_path}")

        # 5. Check zip_structure.txt
        zip_structure_txt_path = data_folder / "zip_structure.txt"
        print(f"Checking zip_structure.txt at: {zip_structure_txt_path}")

        if not zip_structure_txt_path.exists():
            print(f"Error: {zip_structure_txt_path} not found.")
            return

        # Prepare target path for comparison (lowercase and using backslashes like in zip_structure.txt)
        target_config_path_zip_txt = vehicle_config_path.replace('/', '\\')
        target_config_path_zip_txt_lower = target_config_path_zip_txt.lower() # <-- Lowercase version for comparison
        print(f"Target config path for zip_structure.txt (case-insensitive): {target_config_path_zip_txt_lower}")

        zip_file_path = None
        found_config_line_index = -1 # Initialize outside the try block

        try:
            with open(zip_structure_txt_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()

            # --- Search for the config path case-insensitively ---
            for index, line in enumerate(lines):
                # Convert the current line to lowercase for comparison
                if target_config_path_zip_txt_lower in line.lower(): # <-- CASE-INSENSITIVE CHECK
                    found_config_line_index = index
                    print(f"Found config path (case-insensitive) in zip_structure.txt at line {index+1}: {line.strip()}")
                    break # Exit loop once found

            # --- If found, search upwards for the zip file path ---
            if found_config_line_index != -1:
                for i in range(found_config_line_index - 1, -2, -1): # Search upwards
                    if i == -1: # Reached the beginning of the file
                        print("Zip path not found above the config path line in zip_structure.txt")
                        break
                    zip_line = lines[i].strip()
                    print(f"Checking line {i+1} for zip path: {zip_line}")
                    # Check if the line looks like a zip path (case-insensitive check for extension)
                    # Also check if it likely contains a mod/content path structure
                    zip_line_lower = zip_line.lower()
                    if ("\\mods\\" in zip_line_lower or "\\content\\" in zip_line_lower or " = " in zip_line) and zip_line_lower.endswith(".zip"):
                        # Try to extract path, handling "path = C:\..." and just "C:\..." formats
                        potential_path_str = zip_line.split(" = ")[-1].strip() # Get part after last ' = ', or whole string if no ' = '
                        try:
                            # Basic validation if it looks like a path ending in .zip
                            if Path(potential_path_str).name.lower().endswith(".zip"):
                                zip_file_path = Path(potential_path_str)
                                print(f"Found potential zip file path: {zip_file_path}")
                                break # Exit inner loop once zip path is found
                            else:
                                print(f"Line {i+1} contains .zip but '{potential_path_str}' doesn't seem like a valid path.")
                        except Exception as path_e: # Catch potential errors during Path() creation
                             print(f"Could not interpret line {i+1} as a path: {zip_line}. Error: {path_e}")

                if not zip_file_path:
                     print("Could not definitively identify zip file path above the config line.")

            else: # else block for the outer for loop (config path search)
                print(f"Vehicle config path containing '{target_config_path_zip_txt_lower}' not found in zip_structure.txt")
                return # Exit if config path not found

        except Exception as e:
            print(f"Error reading or processing zip_structure.txt: {e}")
            return # Exit on error

        # 6. Extract from Zip if found
        if zip_file_path:
            if not zip_file_path.is_file(): # Use is_file() for better checking
                print(f"Error: Zip file path found ('{zip_file_path}') does not point to an existing file.")
                # Attempt to resolve relative to script parent if it's not absolute
                if not zip_file_path.is_absolute():
                    potential_path = script_parent_folder / zip_file_path
                    print(f"Attempting to resolve relative path: {potential_path}")
                    if potential_path.is_file():
                        zip_file_path = potential_path
                        print(f"Resolved relative zip path to: {zip_file_path}")
                    else:
                        print(f"Error: Relative zip file path could not be resolved or file doesn't exist: {potential_path}")
                        return
                else:
                     return # Absolute path doesn't exist

            # Use the original vehicle_config_path with forward slashes for zip entry
            # Zip files typically use forward slashes internally regardless of OS
            zip_entry_path = vehicle_config_path
            print(f"Zip file path to use: {zip_file_path}")
            print(f"Zip entry path to extract: {zip_entry_path}")

            destination_path = data_folder / "customcarcol.pc"
            try:
                with zipfile.ZipFile(zip_file_path, 'r') as zf:
                    # Optional: List contents for debugging, might be slow for large zips
                    # print("Contents of the zip file:")
                    # zf.printdir()

                    # Get a list of all file names in the zip archive
                    zip_contents = zf.namelist()
                    # Normalize zip entry path (forward slashes, lowercase) for comparison
                    zip_entry_path_normalized = zip_entry_path.replace('\\', '/').lower()

                    # Find the actual entry path case-insensitively
                    actual_zip_entry = None
                    for name in zip_contents:
                        if name.replace('\\', '/').lower() == zip_entry_path_normalized:
                            actual_zip_entry = name # Use the original casing from the zip file
                            print(f"Found matching entry in zip (case-insensitive): '{actual_zip_entry}'")
                            break

                    if actual_zip_entry:
                        try:
                            with zf.open(actual_zip_entry) as source_file:
                                with open(destination_path, 'wb') as dest_file:
                                    shutil.copyfileobj(source_file, dest_file)
                            print(f"Extracted and renamed .pc file from zip '{zip_file_path}' entry '{actual_zip_entry}' to '{destination_path}'")
                            self.color_picker() # Launch color picker after successful extraction
                        except KeyError: # Should technically not happen due to the check above, but good practice
                             print(f"Internal Error: Could not open validated zip entry '{actual_zip_entry}'.")
                        except Exception as extract_e:
                            print(f"Error extracting '{actual_zip_entry}' from zip: {extract_e}")
                    else:
                        print(f"Error: .pc file matching '{zip_entry_path}' (case-insensitive) not found within zip '{zip_file_path}'.")
                        # Optional: Print available paths if list is not too long
                        # if len(zip_contents) < 50:
                        #    print("Available paths in zip:")
                        #    for name in zip_contents: print(f"- {name}")


            except zipfile.BadZipFile:
                print(f"Error: Invalid or corrupted zip file: {zip_file_path}")
            except FileNotFoundError: # Catch if zip file disappears between check and open
                 print(f"Error: Zip file not found at the moment of opening: {zip_file_path}")
            except Exception as e:
                print(f"General error processing zip file '{zip_file_path}': {e}")
        else:
            print("Could not determine zip file path from zip_structure.txt, cannot extract.")





    def color_picker1(self, event=None):
        create_color_picker_window(master=self.master, on_replace_or_spawn_callback=self.on_color_picker_replace_or_spawn)

    def color_picker(self):
        create_color_picker_window(master=self.current_detail_window, on_replace_or_spawn_callback=self.on_color_picker_replace_or_spawn)

        
    def open_detail_info_window(self, spawn_cmd, info_data, picture_path, zip_file, folder_name, zip_file_base_name, config_name):
        """Opens a new window to display detailed configuration information."""
        # --- MODIFIED: Close existing detail window if open ---
        if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
            self.current_detail_window.destroy()
            self.current_detail_window = None
        # --- MODIFIED: Close existing detail window if open ---

        detail_win = tk.Toplevel(self.details_window)
        detail_win.title("Configuration Details")



        if self.font_size_add == 0:

            detail_win.geometry("500x700")
            print(f"Current font size add value: {self.font_size_add}")


        elif self.font_size_add == 2:
 
            detail_win.geometry("500x800")
            print(f"Current font size add value: {self.font_size_add}")

        elif self.font_size_add == 4:


            detail_win.geometry("500x900") # Initial geometry, will be resized later
            print(f"Current font size add value: {self.font_size_add}")



        detail_win.bind_all("<Control-f>", lambda event: self.color_picker1()) 
        #detail_win.attributes('-topmost', True)
        self.current_detail_window = detail_win

        # Set dark grey background for the window
        detail_win.config(bg="#333333")

        icon_path = self.script_dir / "data/icon.png"


        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            detail_win.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")


        # Center the detail window
        detail_win.transient(self.details_window)
        self.details_window.update_idletasks()
        dw_width = self.details_window.winfo_width()
        dw_height = self.details_window.winfo_height()
        dw_x = self.details_window.winfo_rootx()
        dw_y = self.details_window.winfo_rooty()


        if self.font_size_add == 0:
            win_width = 390 # Initial width

        elif self.font_size_add == 2:
            win_width = 410 # Initial width

        elif self.font_size_add == 4:
            win_width = 450 # Initial width

        win_height = 750 # Initial height, will be adjusted
        x = dw_x + (dw_width // 2) - (win_width // 2) # Center horizontally
        y = dw_y + (dw_height // 2) - (win_height // 2) # Center vertically
        detail_win.geometry(f"{win_width}x{win_height}+{x}+{y}")

        main_frame = tk.Frame(detail_win, bg="#333333")
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        main_frame.columnconfigure(0, weight=1)

        # --- NEW: Brand and Name Labels at the Top ---
        brand_name_frame = tk.Frame(main_frame, bg="#333333") # Frame to hold brand and name
        brand_name_frame.pack(fill=tk.X, pady=(0, 5)) # Pack before image, with padding below

        brand_label = tk.Label(brand_name_frame, text=info_data.get("Name", "Unknown Name"), font=("Segoe UI", 14+self.font_size_add, "bold"), anchor=tk.CENTER, justify=tk.CENTER, fg="#FFFFFF", bg="#333333")
        brand_label.pack(side=tk.TOP, fill=tk.X) # Brand on top

        name_label = tk.Label(brand_name_frame, text=info_data.get("Brand", "Unknown Brand"), font=("Segoe UI", 12+self.font_size_add, "bold", "italic"), anchor=tk.CENTER, justify=tk.CENTER, fg="#d9d9d9", bg="#333333")
        name_label.pack(side=tk.TOP, fill=tk.X) # Name below brand
        # --- NEW: Brand and Name Labels at the Top ---


        # Car Picture (unchanged)
        try:
            img = Image.open(picture_path).convert("RGB")
            img = img.resize((350, 196), self.RESAMPLE_FILTER)
            photo = ImageTk.PhotoImage(img)
            img_label = tk.Label(main_frame, image=photo, bg="#555555")
            img_label.image = photo
            img_label.pack(pady=10, anchor=tk.CENTER) # Pack image AFTER brand and name
        except Exception as e:
            print(f"Error loading detail window image: {e}")
            placeholder_image = Image.new("RGB", (400, 200), "#d9d9d9")
            placeholder_photo = ImageTk.PhotoImage(placeholder_image)
            img_label = tk.Label(main_frame, image=placeholder_photo, bg="#333333")
            img_label.image = placeholder_photo
            img_label.pack(pady=10, anchor=tk.CENTER) # Pack image AFTER brand and name


        # Car Information Frame (unchanged)
        info_frame = tk.Frame(main_frame, bg="#333333")
        info_frame.pack(fill=tk.X, pady=10)
        info_frame.columnconfigure(0, weight=1)

        row_num = 0
        config_display_name = "Custom/Unspecified"
        individual_info_path = self.find_individual_info_file(folder_name, zip_file_base_name, config_name)
        individual_data = {} # Initialize as empty dict

        if individual_info_path and os.path.exists(individual_info_path):
            try:
                individual_data, _ = self._load_individual_info(individual_info_path)
                config_display_name = individual_data.get("Configuration", "Custom/Unspecified")
            except Exception as e:
                print(f"Error loading individual info JSON in info window: {e}")
                config_display_name = "Error Loading Config Name"

        # --- MODIFIED: Removed fixed wraplength, set anchor and justify ---
        config_name_label = tk.Label(info_frame, text=config_display_name, font=("Segoe UI", 13+self.font_size_add, "bold"), anchor=tk.CENTER, justify=tk.CENTER, fg="#FFFFFF", bg="#333333") # REMOVED wraplength
        config_name_label.grid(row=row_num, column=0, sticky="ew", columnspan=2, pady=(0,5))
        row_num += 1
        self.config_name_label_detail_window = config_name_label # Store as instance attribute

        top_speed_value = individual_data.get("Top Speed", "N/A")
        if top_speed_value != "N/A" and isinstance(top_speed_value, (int, float)):
            top_speed_value_kmh = round(float(top_speed_value) * 3.6, 0)
            top_speed_display = f"{top_speed_value_kmh} km/h"
        else:
            top_speed_display = "N/A"

        info_labels = [
            #("Top Speed", top_speed_display),
            #("Torque", individual_data.get("Torque", "N/A") or "N/A"),
            #("Power", individual_data.get("Power", "N/A")or "N/A"),
            #("0-100 km/h", individual_data.get("0-100 km/h", "N/A") or "N/A"),
            #("100-0 km/h", individual_data.get("100-0 km/h", "N/A")or "N/A"),
            ("Propulsion", individual_data.get("Propulsion", "N/A")or "N/A"),
            #("Fuel Type", individual_data.get("Fuel Type", "N/A")or "N/A"),
            ("Drivetrain", individual_data.get("Drivetrain", "N/A")or "N/A"),
            ("Transmission", individual_data.get("Transmission", "N/A")or "N/A"),
            ("Weight/Power", individual_data.get("Weight/Power", "N/A")or "N/A"),
            ("Off-Road Score", individual_data.get("Off-Road Score", "N/A")or "N/A"),
            ("Induction type", individual_data.get("Induction type", "N/A")or "N/A"),
            ("Braking G", individual_data.get("Braking G", "N/A")or "N/A"),
        ]

        # --- MODIFIED: Dynamic wraplength and label creation with wraplength ---
        label_wraplength = win_width - 40  # Adjust padding as needed
        for label_text, value in info_labels: #unchanged
            tk.Label(info_frame, text=f"{label_text}:", font=("Segoe UI", 12+self.font_size_add, "bold"), anchor=tk.E, justify=tk.RIGHT, fg="#FFFFFF", bg="#333333", wraplength=label_wraplength).grid(row=row_num, column=0, sticky="ne", padx=(0,15))
            tk.Label(info_frame, text=value if value else "N/A", font=("Segoe UI", 12+self.font_size_add, "italic"), anchor=tk.W, justify=tk.LEFT, fg="#FFFFFF", bg="#333333", wraplength=label_wraplength).grid(row=row_num, column=1, sticky="nw")
            row_num += 1
        # --- MODIFIED: Dynamic wraplength and label creation with wraplength ---

        info_frame.columnconfigure(1, weight=1)

        # Buttons Frame - MODIFIED for Configuration Details Window
        button_frame = tk.Frame(main_frame, bg="#333333")
        button_frame.pack(side="bottom", fill=tk.X, pady=10)
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1) # Allow second column to expand
        button_frame.columnconfigure(2, weight=1) # Allow third column to expand for Customize button

        # --- REMOVED Favorites Button from Configuration Details Window ---



        original_bg = "#555555"
        hover_fg = "#FFFFFF" # Common foreground color on hover

        if not self.items_to_be_hidden:
                
            # --- Delete Button Logic ---
            disable_delete_button = False
            found_double_basename = False
            # Ensure self.ZIP_BASE_NAMES exists and is iterable
            if hasattr(self, 'ZIP_BASE_NAMES') and isinstance(self.ZIP_BASE_NAMES, (list, tuple, set)):
                for base_name in self.ZIP_BASE_NAMES:
                    if picture_path.count(f"--{base_name}_{base_name}.zip") > 0:
                        found_double_basename = True
                        break
            if found_double_basename:
                disable_delete_button = True

            delete_original_fg = "#FF6666"
            delete_button = None # Initialize

            # --- Determine original command function ---
            original_delete_command_func = None
            if zip_file == "user_custom_configs":
                delete_button_text = "Delete Config"
                original_delete_command_func = lambda s=spawn_cmd, p=picture_path, z=zip_file: self.on_details_image_right_click(z, s, p)
            else:
                delete_button_text = "Delete Mod"
                original_delete_command_func = lambda z=zip_file, win=detail_win: self.confirm_delete_mod(z, win)

            # --- Create Delete Button (No command yet) ---
            delete_button = tk.Button(
                button_frame, text=delete_button_text,
                font=("Segoe UI", 12 + self.font_size_add, "bold"),
                # NO command assigned yet
                fg=delete_original_fg, bg=original_bg, relief=tk.FLAT, bd=0
            )

            # --- Define Delete Command Wrapper ---
            def delete_command_wrapper(btn=delete_button, cmd=original_delete_command_func, bg=original_bg, fg=delete_original_fg):
                if cmd is None: return
                try:
                    # 1. Reset Appearance IMMEDIATELY (if button exists and enabled)
                    if btn.winfo_exists() and btn['state'] == tk.NORMAL:
                        print(f"WRAPPER: Resetting delete button {btn}") # DEBUG
                        btn.config(fg=fg) # Reset FG
                        # Start animation back to original BG *immediately*
                        #self._start_animation(btn, bg, property_to_animate="bg")
                        # Optional: Force UI update before blocking call (use with caution)
                        # btn.update_idletasks()
                except tk.TclError as e:
                    print(f"WRAPPER ERROR (Delete): {e}") # DEBUG
                    pass # Widget might be gone

                # 2. Execute the Original Command Function (shows messagebox)
                print(f"WRAPPER: Calling original delete command {cmd}") # DEBUG
                cmd()

            # --- Assign Wrapper and Bind/Disable ---
            delete_button.config(command=delete_command_wrapper) # Assign wrapper

            if disable_delete_button:
                delete_button.config(state=tk.DISABLED, fg="grey", bg="#666666")
            else:
                self._bind_animated_hover(
                    button=delete_button,
                    original_bg=original_bg,
                    original_fg=delete_original_fg,
                    hover_target_fg=hover_fg,
                    check_state=True
                )

            # --- Isolate Button Logic ---
            isolate_button = None
            if not found_double_basename and zip_file != "user_custom_configs":
                isolate_original_fg = "#FFFFFF"
                # Original command function
                original_isolate_command_func = lambda z=zip_file, win=detail_win: self.confirm_isolate_mod(z, win)

                # Create Isolate Button (No command yet)
                isolate_button = tk.Button(
                    button_frame, text="Isolate Mod",
                    font=("Segoe UI", 12 + self.font_size_add, "bold"),
                    # NO command assigned yet
                    fg=isolate_original_fg, bg=original_bg, relief=tk.FLAT, bd=0
                )

                # --- Define Isolate Command Wrapper ---
                def isolate_command_wrapper(btn=isolate_button, cmd=original_isolate_command_func, bg=original_bg, fg=isolate_original_fg):
                    if cmd is None: return
                    try:
                        # 1. Reset Appearance IMMEDIATELY (if button exists and enabled)
                        if btn.winfo_exists() and btn['state'] == tk.NORMAL:
                            print(f"WRAPPER: Resetting isolate button {btn}") # DEBUG
                            btn.config(fg=fg) # Reset FG
                            # Start animation back to original BG *immediately*
                            #self._start_animation(btn, bg, property_to_animate="bg")
                            # Optional: btn.update_idletasks()
                    except tk.TclError as e:
                        print(f"WRAPPER ERROR (Isolate): {e}") # DEBUG
                        pass

                    # 2. Execute the Original Command Function (shows messagebox)
                    print(f"WRAPPER: Calling original isolate command {cmd}") # DEBUG
                    cmd()

                # --- Assign Wrapper and Bind ---
                isolate_button.config(command=isolate_command_wrapper) # Assign wrapper

                self._bind_animated_hover( # Bind standard hover effects
                    button=isolate_button,
                    original_bg=original_bg,
                    original_fg=isolate_original_fg,
                    hover_target_fg=hover_fg,
                    check_state=False # Assuming always enabled if created
                )

            # --- Customize Color Button Logic (Assuming no blocking issue - keep as is or wrap too) ---
            customize_original_fg = "#FFFFFF"
            customize_color_button = tk.Button(
                button_frame, text="Customize Color",
                font=("Segoe UI", 12 + self.font_size_add, "bold"),
                command=lambda cmd=spawn_cmd, fn=folder_name: self.customize_color_config(cmd, fn),
                fg=customize_original_fg, bg=original_bg, relief=tk.FLAT, bd=0
            )
            self._bind_animated_hover(
                button=customize_color_button,
                original_bg=original_bg,
                original_fg=customize_original_fg,
                hover_target_fg=hover_fg,
                check_state=False
            )



            if isolate_button:
                button_frame.columnconfigure(1, weight=1) # Re-enable second column weight if isolate button exists
                delete_button.grid(row=0, column=0, sticky="ew", padx=5, pady=2) # MODIFIED row number for delete button, to be FIRST position
                isolate_button.grid(row=0, column=1, sticky="ew", padx=5, pady=2) # Isolate button to the right
                customize_color_button.grid(row=0, column=2, sticky="ew", padx=5, pady=2) # Customize button to the far right
            else:
                delete_button.grid(row=0, column=0, sticky="ew", padx=5, pady=2, columnspan=2) # span across 2 columns if no isolate
                customize_color_button.grid(row=0, column=2, sticky="ew", padx=5, pady=2) # Customize button to the right



        if self.items_to_be_hidden:


            # --- Customize Color Button Logic (Assuming no blocking issue - keep as is or wrap too) ---
            customize_original_fg = "#FFFFFF"
            customize_color_button = tk.Button(
                button_frame, text="Customize Color",
                font=("Segoe UI", 12 + self.font_size_add, "bold"),
                command=lambda cmd=spawn_cmd, fn=folder_name: self.customize_color_config(cmd, fn),
                fg=customize_original_fg, bg=original_bg, relief=tk.FLAT, bd=0
            )
            self._bind_animated_hover(
                button=customize_color_button,
                original_bg=original_bg,
                original_fg=customize_original_fg,
                hover_target_fg=hover_fg,
                check_state=False
            )

            customize_color_button.grid(row=0, column=0, columnspan=3, sticky="ew", padx=5, pady=2)


        # --- NEW: Bind <Configure> event to detail_win to handle label wrapping on window resize ---
        detail_win.bind("<Configure>", self.update_config_name_wraplength)
        # --- NEW: Bind <Configure> event to detail_win to handle label wrapping on window resize ---

        # --- MODIFIED: Adjust window height dynamically (call AFTER binding Configure event) ---
        detail_win.update_idletasks() # Update to calculate required height correctly
        required_height = detail_win.winfo_reqheight()
        detail_win.geometry(f"{win_width}x{required_height}+{x}+{y}") # Set new geometry with dynamic height
        # --- MODIFIED: Adjust window height dynamically ---

        self.current_detail_window = detail_win


    def update_config_name_wraplength(self, event=None):
        """
        Updates the wraplength of the config_name_label in the details window
        based on the window's current width.
        """
        if hasattr(self, 'config_name_label_detail_window') and self.config_name_label_detail_window:
            window_width = self.current_detail_window.winfo_width()
            label_wraplength = window_width - 40  # Adjust padding as needed
            self.config_name_label_detail_window.config(wraplength=label_wraplength)







    def refresh_details_grid_after_favorite_change(self):
        """Refreshes the details grid after a favorite change, respecting the 'Favorites' filter."""
        if not self.details_window or self.details_window_closed:
            print("DEBUG: refresh_details_grid_after_favorite_change - Details window NOT open or closed, exiting refresh.") # DEBUG
            return  # Exit if details window is not open

        print("\n--- refresh_details_grid_after_favorite_change() ENTRY ---") # Debug Entry

        current_subgrid_data = self.details_data # Start with the original details data
        print(f"  DEBUG: refresh_details_grid_after_favorite_change - Initial data count: {len(current_subgrid_data)}") # Debug - Initial Data Count

        if self.details_window_is_favorites_filtered:
            print("  DEBUG: refresh_details_grid_after_favorite_change - Favorites filter ACTIVE.") # Debug - Favorites Filter Active
            # Apply Favorites filter to details data

            current_subgrid_data = self._apply_details_favorites_only_filter(self.details_data)
            
            print(f"  DEBUG: refresh_details_grid_after_favorite_change - Data count AFTER Favorites filter: {len(current_subgrid_data)}") # Debug - Filtered Data Count
        else:
            print("  DEBUG: refresh_details_grid_after_favorite_change - Favorites filter NOT active, showing all data.") # Debug - Favorites Filter Inactive

        self.details_filtered_data = current_subgrid_data[:] # Update filtered data list
        print(f"  DEBUG: refresh_details_grid_after_favorite_change - details_filtered_data updated, count: {len(self.details_filtered_data)}") # Debug - Updated Filtered Data Count

        self.rebuild_simple_details() # Rebuild subgrid UI with updated data
        print("  DEBUG: refresh_details_grid_after_favorite_change - rebuild_simple_details() called.") # Debug - Rebuild Called

        if self.details_count_label:
            self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}") # Update count label
            print(f"  DEBUG: refresh_details_grid_after_favorite_change - Count label updated to: {len(self.details_filtered_data)}") # Debug - Count Label Updated
        self._update_details_pagination_bar() # <--- ADD THIS LINE to update pagination bar AFTER refresh
        print("  DEBUG: refresh_details_grid_after_favorite_change - _update_details_pagination_bar() called.") # Debug - Pagination Bar Updated
        print("--- refresh_details_grid_after_favorite_change() EXIT ---\n")

        

    def confirm_delete_mod(self, zip_file, detail_win):
        """Asks for confirmation before deleting mod and closes detail window."""

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot perform this action while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return


        confirm = messagebox.askyesno(
            "Confirm Delete",
            f"Are you sure you want to delete the mod '{zip_file}' and all related files?",
            parent=detail_win # Parent to detail window
        )
        if confirm:
            self.delete_item(zip_file)
            detail_win.destroy() # Close detail window after delete


    def open_isolated_folder_in_explorer(self):
        """Opens the specified folder path in the system's file explorer.
        Creates the folder if it does not exist.

        Args:
            folder_path: The path to the folder you want to open.
        """
        userfolder_root = os.path.dirname(os.path.dirname(os.path.dirname(self.script_dir))) # Go up 3 levels
        folder_path = os.path.join(userfolder_root, "Isolated")


        if not os.path.exists(folder_path):
            try:
                os.makedirs(folder_path, exist_ok=True) # Create the folder and any parent directories
                print(f"Folder created: {folder_path}")
            except OSError as e:
                print(f"Error creating folder: {folder_path}. {e}")
                return False # Indicate failure to create folder, and thus to open

        if sys.platform.startswith('win'):  # Windows
            try:
                os.startfile(folder_path)
                return True
            except OSError:
                print(f"Error opening folder in File Explorer (Windows): {folder_path}")
                return False
        elif sys.platform.startswith('darwin'):  # macOS
            try:
                subprocess.Popen(['open', folder_path])
                return True
            except FileNotFoundError:
                print(f"'open' command not found on macOS. Cannot open folder: {folder_path}")
                return False
        elif sys.platform.startswith('linux'):  # Linux
            try:
                subprocess.Popen(['xdg-open', folder_path])
                return True
            except FileNotFoundError:
                try:
                    subprocess.Popen(['gnome-open', folder_path])
                    return True
                except FileNotFoundError:
                    try:
                        subprocess.Popen(['start', folder_path], shell=True)
                        return True
                    except FileNotFoundError:
                        print(f"Could not open file explorer on Linux. Make sure 'xdg-open', 'gnome-open', or 'start' is available.")
                        return False
        else:
            print(f"Unsupported operating system: {sys.platform}. Cannot open file explorer.")
            return False


        
    def confirm_isolate_mod(self, zip_file, detail_win):
        """Asks for confirmation before isolating mod and closes detail window."""

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot perform this action while there are pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return


        userfolder_root = os.path.dirname(os.path.dirname(os.path.dirname(self.script_dir))) # Go up 3 levels
        isolated_folder_path = os.path.join(userfolder_root, "Isolated")

        confirm = messagebox.askyesno(
            "Confirm Isolate",
            f"Are you sure you move the mod '{zip_file}' to '{isolated_folder_path}'?",
            parent=detail_win # Parent to detail window
        )
        if confirm:
            self.isolate_item(zip_file)
            detail_win.destroy() # Close detail window after delete



        
    def start_details_sidebar_debounce(self, info_data, picture_path, zip_file, widget, pil_image):
        """
        Starts the debounce timer for updating the details sidebar.
        """
        if self.details_sidebar_debounce_timer:
            self.master.after_cancel(self.details_sidebar_debounce_timer) # Cancel existing timer

        self.current_debounce_widget = widget # Store widget for highlight
        self.current_debounce_pil_image = pil_image # Store pil_image for highlight

        # Start a new timer
        self.details_sidebar_debounce_timer = self.master.after(
            400, # 400ms delay
            lambda: self.debounced_details_sidebar_update(info_data, picture_path, zip_file)
        )
        self.set_highlight(widget, pil_image) # Immediate highlight

    def debounced_details_sidebar_update(self, info_data, picture_path, zip_file):
        """
        Debounced function to update the details sidebar content.
        """
        self.show_details_sidebar_info(info_data, picture_path, zip_file)
        self.details_sidebar_debounce_timer = None # Reset timer

    def on_details_image_click(self, spawn_cmd, info_data, picture_path, zip_file, folder_name):
        """Handles single click on an image in the details subgrid. AND ALSO HANDLES setting the details sidebar initially
        MODIFIED: Now receives folder_name as argument and updates self.current_details_folder correctly.
        DEBUGGED: Added print statements to REALLY check received spawn_cmd and folder_name. <--- MORE DEBUGGING
        """

        if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
            self.current_detail_window.destroy()
            
        self.clear_details_sidebar_content() #clean up the sidebar before moving on    


        print("\n\n--- on_details_image_click() ENTRY ---")  # Debug Entry
        # --- DEBUGGING - ADDED EXTENSIVE DEBUGGING HERE ---
        print("DEBUG (on_details_image_click) - START - Function Called") # Debug: Function start
        print(f"DEBUG (on_details_image_click): Received spawn_cmd (at function entry): {spawn_cmd}") # Debug: Check received spawn_cmd - ENTRY POINT
        print(f"DEBUG (on_details_image_click): Received picture_path: {picture_path}") # Debug: Check received picture_path
        print(f"DEBUG (on_details_image_click): Received zip_file: {zip_file}") # Debug: Check received zip_file
        print(f"DEBUG (on_details_image_click): Received info_data: {info_data}") # Debug: Check received info_data
        # --- NEW DEBUG PRINT - CHECK RECEIVED folder_name ---
        print(f"DEBUG (on_details_image_click): Received folder_name: {folder_name}") # Debug: Check received folder_name <--- CHECK THIS VALUE!
        # --- NEW DEBUG PRINT - CHECK RECEIVED folder_name ---
        # --- DEBUGGING - ADDED EXTENSIVE DEBUGGING HERE ---

        print(f"  DEBUG: on_details_image_click - zip_file: {zip_file}, picture_path: {picture_path}") # Debug - Args
        print(f"  DEBUG: on_details_image_click - info_data: {info_data.get('Name')}, {info_data.get('Brand')}")  # Debug - Info Data

        self.is_details_sidebar_sticky = True
        self.is_details_sidebar_showing_default = False  # No longer showing default

        # --- ENSURE SIDEBAR ATTRIBUTES ARE UPDATED **BEFORE** calling update_details_sidebar_content and update_details_sidebar_favorites_button_text ---
        self.current_details_sidebar_spawn_cmd = spawn_cmd # UPDATE sidebar attributes **FIRST**
        self.current_details_sidebar_info_data = info_data
        self.current_details_sidebar_picture_path = picture_path
        self.current_details_sidebar_zip_file = zip_file
        self.current_details_folder = folder_name # <--- MODIFIED: Now use the folder_name *received as argument*
        # --- DEBUGGING - ADDED DEBUG PRINTS AFTER SETTING SIDEBAR ATTRIBUTES ---
        print("DEBUG (on_details_image_click): Sidebar attributes UPDATED:") # Debug - Attribute Update Start
        print(f"    - self.current_details_sidebar_spawn_cmd: {self.current_details_sidebar_spawn_cmd}") # Debug - Print updated spawn_cmd - CHECK THIS VALUE!
        print(f"    - self.current_details_folder: {self.current_details_folder}") # Debug - Print current_details_folder - CHECK THIS VALUE!
        print(f"    - self.current_details_sidebar_zip_file: {self.current_details_sidebar_zip_file}") # Debug - Print current_details_zip_file - CHECK THIS VALUE!
        print("DEBUG (on_details_image_click): Sidebar attributes UPDATE COMPLETED.") # Debug - Attribute Update End
        # --- DEBUGGING - ADDED DEBUG PRINTS AFTER SETTING SIDEBAR ATTRIBUTES ---
        # --- ENSURE SIDEBAR ATTRIBUTES ARE UPDATED **BEFORE** calling update_details_sidebar_content and update_details_sidebar_favorites_button_text ---


        # --- Now, pass the info_data and folder name here as well ----
        self.update_details_sidebar_content(info_data, picture_path, zip_file, folder_name=self.current_details_folder)
        self.update_details_sidebar_config_name(spawn_cmd) # Update config name label on click


        print("--- on_details_image_click() EXIT ---\n")  # Debug Exit

    def update_details_sidebar_config_name(self, spawn_cmd):
        """Updates the config name label at the bottom of the details sidebar to display ONLY CONFIG NAME."""
        print("--- update_details_sidebar_config_name() ENTRY ---\n")
        pc_name = self.extract_name_from_spawn_command(spawn_cmd) # Extract ONLY the config name (PC filename)
        self.details_sidebar_config_name_label.config(text=f"({pc_name}.pc)") # Set label text to "Config: <config_name>"
        self.details_sidebar_config_name_label.spawn_command = spawn_cmd # NEW: Store the FULL spawn_command as an attribute of the label
        self.current_details_sidebar_spawn_cmd = spawn_cmd 
        print(f"self.current_details_sidebar_spawn_cmd is currently set as {spawn_cmd}.")
        print("--- update_details_sidebar_config_name() EXIT ---\n")

    def on_details_image_double_click(self, spawn_cmd, info_data, picture_path, zip_file):
        """Handles double click on an image in the details subgrid."""
        self.on_spawn_new_button_click(spawn_cmd, event=None) # Use same action as button click - which includes copy to clipboard
        

    def show_details_sidebar_buttons(self):
        """Shows the action buttons in the details sidebar."""
        if self.details_add_to_queue_button and self.details_spawn_new_button:
            self.details_add_to_queue_button.pack(side="top", fill="x", pady=(2, 0), padx=0) # Add to Queue below
            self.details_spawn_new_button.pack(side="top", fill="x", pady=(0, 2), padx=0) # Spawn New on top


            
    def on_delete_custom_config_button_click(self):
        """Handles click on the 'Delete Custom Config' button in the details sidebar."""
        if hasattr(self, 'current_details_sidebar_spawn_cmd'): # Check if attributes are available
            spawn_cmd = self.current_details_sidebar_spawn_cmd
            picture_path = self.current_details_sidebar_picture_path
            zip_file = self.current_details_sidebar_zip_file
            self.on_details_image_right_click(zip_file, spawn_cmd, picture_path) # REUSE existing right-click logic
        else:
            print("Warning: Config details not available for Delete Custom Config action.")
            
    def hide_details_sidebar_buttons(self):
        """Hides the action buttons in the details sidebar."""
        if self.details_add_to_queue_button and self.details_spawn_new_button:
            self.details_add_to_queue_button.pack_forget()
            self.details_spawn_new_button.pack_forget()

    def show_details_sidebar_info(self, info_data, picture_path, zip_file):
        """Shows details sidebar info labels and updates content."""
        if not self.is_details_sidebar_sticky: # Only update if not sticky
            self.update_details_sidebar_content(info_data, picture_path, zip_file)
            self.is_details_sidebar_showing_default = False # Hovering means not default anymore

    def hide_details_sidebar_info(self):
        """Hides details sidebar info labels (within the scrollable frame)."""
        if not self.is_details_sidebar_sticky:
             # Use pack_forget() on labels within the scrollable frame
             for widget in [
                 self.details_sidebar_selected_config_label_cat, self.details_sidebar_selected_config_label_val,
                 self.details_sidebar_config_name_label,
                 self.details_sidebar_description_label_cat, self.details_sidebar_description_label_val,
                 self.details_sidebar_zipfile_label_cat, self.details_sidebar_zipfile_label_val,
                 self.details_sidebar_value_label_cat, self.details_sidebar_value_label_val,
                 self.details_sidebar_brand_label_cat, self.details_sidebar_brand_label_val,
                 self.details_sidebar_bodystyle_label_cat, self.details_sidebar_bodystyle_label_val,
                 self.details_sidebar_weight_label_cat, self.details_sidebar_weight_label_val,
                 self.details_sidebar_years_label_cat, self.details_sidebar_years_label_val
             ]:
                 # Check if widget exists before calling pack_forget
                 if widget and widget.winfo_exists():
                    widget.pack_forget()

             # Optionally, reset sidebar image and name label (outside scrollable area)
             placeholder_image = Image.new("RGB", (280, 150), "#333333")
             placeholder_photo = ImageTk.PhotoImage(placeholder_image)
             if self.details_sidebar_car_name_label and self.details_sidebar_car_name_label.winfo_exists():
                 self.details_sidebar_car_name_label.config(text="")
             if self.details_sidebar_image_label and self.details_sidebar_image_label.winfo_exists():
                 self.details_sidebar_image_label.config(image=placeholder_photo)
                 self.details_sidebar_image_label.image = placeholder_photo

             # Update scrollregion after hiding labels
             if self.details_sidebar_text_scrollable_frame and self.details_sidebar_text_scrollable_frame.winfo_exists():
                 self.details_sidebar_text_scrollable_frame.update_idletasks()
                 if self.details_sidebar_text_canvas and self.details_sidebar_text_canvas.winfo_exists():
                     self.details_sidebar_text_canvas.config(scrollregion=self.details_sidebar_text_canvas.bbox("all"))
  


    def update_details_sidebar_content(self, info_data, picture_path, zip_file, folder_name=None):
        """
        Updates details sidebar content. Ensures instance state is updated correctly
        BEFORE calling the individual info update and favorites button update.
        Restores fallback logic: attempts individual info load, relies on callee
        to use main_info_data if individual load fails.
        """
        print("\n--- update_details_sidebar_content() ENTRY ---")
        print(f"  DEBUG: update_details_sidebar_content - zip_file: {zip_file}, picture_path: {picture_path}")
        print(f"  DEBUG: update_details_sidebar_content - info_data (Name, Brand): {info_data.get('Name')}, {info_data.get('Brand')}")
        print(f"  DEBUG: update_details_sidebar_content - Received folder_name arg: {folder_name}")


        # --- Car Name Label & Image Loading (Keep improved logic from new version) ---
        brand = info_data.get("Brand", "").strip()
        name = info_data.get("Name", "").strip()
        vehicle_type = info_data.get("Type", "").strip()
        display_name_text = "Unknown" # Default
        if brand:
            if name:
                display_name_text = f"{brand} {name}"
            elif vehicle_type:
                display_name_text = f"{brand} {vehicle_type}"
            else:
                display_name_text = brand
        elif name:
            display_name_text = name
        elif vehicle_type:
            display_name_text = vehicle_type


        print(f"  DEBUG: update_sidebar - Initial display_name_text (from passed info_data): '{display_name_text}'")

        # --- >>> NEW: Fallback Logic for Title <<< ---
        if display_name_text == "Unknown":
            print("  DEBUG: update_sidebar - Initial name is 'Unknown'. Attempting fallback using MAIN info file...")
            try:
                # Determine the correct folder and base zip for the main info file
                # Use self.current_details_folder which should be correctly set
                effective_folder = self.current_details_folder
                base_zip_file = None

                if effective_folder in self.ZIP_BASE_NAMES: # Check if it's a vanilla folder name
                    base_zip_file = f"{effective_folder}.zip" # Construct vanilla zip name
                    print(f"    DEBUG: Fallback - Detected vanilla folder: '{effective_folder}', using zip: '{base_zip_file}'")
                elif hasattr(self, 'details_data') and self.details_data: # Fallback: try getting zip from first details item
                    # Find the first item in the *current* details view belonging to this folder
                    for item_tuple in self.details_data:
                         if len(item_tuple) == 5 and item_tuple[4] == effective_folder and item_tuple[2] not in ["user_custom_configs", "folder_grouped"]:
                              base_zip_file = item_tuple[2]
                              print(f"    DEBUG: Fallback - Found representative zip from details_data: '{base_zip_file}' for folder '{effective_folder}'")
                              break # Use the first one found
                    if not base_zip_file:
                         print(f"    WARN: Fallback - Could not find a non-custom zip in details_data for folder '{effective_folder}'.")
                else:
                    print(f"    WARN: Fallback - Cannot determine base zip (not vanilla and details_data empty/missing).")


                if effective_folder and base_zip_file:
                    main_info_filename = f"vehicles--{effective_folder}_{base_zip_file}--info.json"
                    main_info_filepath = os.path.join(self.config_info_folder, main_info_filename)
                    print(f"    DEBUG: Fallback - Attempting to load MAIN info from: {main_info_filepath}")

                    if os.path.exists(main_info_filepath):
                        # Load the main info data
                        correct_main_info_data = self.extract_fallback_info(main_info_filepath)
                        if correct_main_info_data:
                            print(f"    DEBUG: Fallback - Successfully loaded main info.")
                            # Extract Brand/Name/Type from the loaded MAIN info
                            main_brand = correct_main_info_data.get("Brand", "").strip()
                            main_name = correct_main_info_data.get("Name", "").strip()
                            main_type = correct_main_info_data.get("Type", "").strip()

                            # Reconstruct display_name_text using MAIN info
                            fallback_display_name = "Unknown" # Default for fallback
                            if main_brand:
                                fallback_display_name = f"{main_brand} {main_name}" if main_name else (f"{main_brand} {main_type}" if main_type else main_brand)
                            elif main_name:
                                fallback_display_name = main_name
                            elif main_type:
                                fallback_display_name = main_type

                            if fallback_display_name != "Unknown":
                                display_name_text = fallback_display_name # Overwrite with fallback name
                                print(f"    DEBUG: Fallback - Using Brand/Name from MAIN info: '{display_name_text}'")
                            else:
                                print(f"    WARN: Fallback - Main info file loaded but lacked Brand/Name/Type. Sticking with 'Unknown'.")
                        else:
                            print(f"    WARN: Fallback - Failed to extract data from existing main info file: {main_info_filepath}")
                    else:
                        print(f"    WARN: Fallback - Main info file NOT FOUND: {main_info_filepath}")
                else:
                     print(f"    WARN: Fallback - Could not determine path for main info file. Sticking with 'Unknown'.")

            except Exception as e:
                print(f"    ERROR: Exception during title fallback logic: {e}")
                # Stick with the original "Unknown" on error
        # --- >>> END Fallback Logic for Title <<< ---



        if hasattr(self, 'details_sidebar_car_name_label') and self.details_sidebar_car_name_label.winfo_exists():
            self.details_sidebar_car_name_label.config(text=display_name_text)
        if hasattr(self, 'details_sidebar_loading_label') and self.details_sidebar_loading_label.winfo_exists():
             try:
                 self.details_sidebar_loading_label.pack(pady=(0, 10), padx=10)
             except tk.TclError: pass

        try:
            # ... (Image loading logic remains the same as the 'new' version) ...
            photo = None
            if picture_path and os.path.exists(picture_path):
                img = Image.open(picture_path).convert("RGB")
                img = img.resize((280, 157), self.RESAMPLE_FILTER)
                photo = ImageTk.PhotoImage(img)

            if not photo:
                 placeholder_image = Image.new("RGB", (280, 157), "#333333")
                 photo = ImageTk.PhotoImage(placeholder_image)

            if hasattr(self, 'details_sidebar_image_label') and self.details_sidebar_image_label.winfo_exists():
                self.details_sidebar_image_label.config(image=photo, bg="#333333")
                self.details_sidebar_image_label.image = photo

        except Exception as e:
            print(f"Error loading details sidebar image: {e}")
            # ... (Placeholder setting on error remains the same) ...
            try:
                placeholder_image = Image.new("RGB", (280, 157), "#333333")
                placeholder_photo = ImageTk.PhotoImage(placeholder_image)
                if hasattr(self, 'details_sidebar_image_label') and self.details_sidebar_image_label.winfo_exists():
                    self.details_sidebar_image_label.config(image=placeholder_photo)
                    self.details_sidebar_image_label.image = placeholder_photo
                if hasattr(self, 'details_sidebar_car_name_label') and self.details_sidebar_car_name_label.winfo_exists():
                     self.details_sidebar_car_name_label.config(text=f"Error Loading Image")
            except Exception as placeholder_e:
                 print(f"Error setting placeholder image: {placeholder_e}")
        finally:
             # ... (Hide loading label remains the same) ...
             try:
                 if hasattr(self, 'details_sidebar_loading_label') and self.details_sidebar_loading_label.winfo_exists():
                    self.details_sidebar_loading_label.pack_forget()
             except tk.TclError: pass


        print(f"  >>> SIDEBAR CHECK: Raw zip_file value received: '{zip_file}'")
        print(f"  >>> SIDEBAR CHECK: Type of zip_file: {type(zip_file)}")
        print(f"  >>> SIDEBAR CHECK: zip_file == 'user_custom_configs'? {zip_file == 'user_custom_configs'}")
        print(f"  >>> SIDEBAR CHECK: zip_file.strip() == 'user_custom_configs'? {isinstance(zip_file, str) and zip_file.strip() == 'user_custom_configs'}") # Added isinstance check

        # --- Determine Zip File Display Name (Keep logic from new version) ---
        print("  DEBUG: Setting Zip File Label...")
        # ... (zip_file_display_name logic remains the same) ...
        if zip_file == "folder_grouped":
            zip_file_display_name = "Custom Configuration"
            print("    DEBUG: zip_file is 'folder_grouped', setting Zip File Label to 'Custom Configuration'")
        elif zip_file == "user_custom_configs":
            zip_file_display_name = "Custom Configuration"
            print("    DEBUG: zip_file is 'user_custom_configs', setting Zip File Label to 'Custom Configuration'")
        elif not zip_file:
            zip_file_display_name = "N/A"
            print("    DEBUG: zip_file is missing, setting Zip File Label to 'N/A'")
        else:
            zip_file_display_name = os.path.basename(str(zip_file))
            print(f"    DEBUG: zip_file is '{zip_file}', setting Zip File Label to '{zip_file_display_name}'")


        if hasattr(self, 'details_sidebar_zipfile_label_val') and self.details_sidebar_zipfile_label_val.winfo_exists():
             print(f"    DEBUG: Setting details_sidebar_zipfile_label_val text to: '{zip_file_display_name}'")
             self.details_sidebar_zipfile_label_val.config(text=zip_file_display_name)
        else:
            print("  WARNING: details_sidebar_zipfile_label_val widget not found or destroyed.")


        # --- Extract Info Needed for State and Display (Keep logic from new version) ---
        extracted_info = self.extract_info_from_sidebar_image(picture_path)
        effective_folder_name = "UnknownFolder"
        config_name_from_pic = None
        zip_file_base_name_from_pic = None

        if extracted_info:
            config_name_from_pic = extracted_info.get("config_name")
            zip_file_base_name_from_pic = extracted_info.get("zip_file_base_name") # <<< Still likely returning '' due to bug
            if folder_name:
                effective_folder_name = folder_name
                print(f"  DEBUG: Using explicitly passed folder_name: '{folder_name}'")
            else:
                effective_folder_name = extracted_info.get("folder_name", "UnknownFolder")
                print(f"  DEBUG: Using folder_name from extraction: '{effective_folder_name}'")
        elif folder_name:
             effective_folder_name = folder_name
             print(f"  DEBUG: Using provided folder_name '{folder_name}' as effective_folder_name despite extraction failure.")

        print(f"  DEBUG: Info derived: effective_folder='{effective_folder_name}', config_name='{config_name_from_pic}', zip_base='{zip_file_base_name_from_pic}'")

        # --- Update INSTANCE sidebar attributes FIRST (Keep logic from new version) ---
        print("  DEBUG: Updating instance state variables BEFORE individual info display AND favorite check...")
        self.current_details_folder = effective_folder_name
        print(f"    DEBUG: Set self.current_details_folder = '{self.current_details_folder}'")
        self.current_details_sidebar_info_data = info_data
        self.current_details_sidebar_picture_path = picture_path
        self.current_details_sidebar_zip_file = zip_file
        print(f"    DEBUG: Set self.current_details_sidebar_zip_file = '{self.current_details_sidebar_zip_file}' (original identifier)")

        # --- Reconstruct spawn command (Keep logic from new version) ---
        constructed_spawn_cmd = None
        # ... (logic for constructing spawn_cmd remains the same) ...
        if self.current_details_folder not in ["UnknownFolder", "folder_grouped", "user_custom_configs"] and config_name_from_pic:
            constructed_spawn_cmd = f'core_vehicles.spawnNewVehicle("{self.current_details_folder}", {{config = \'vehicles/{self.current_details_folder}/{config_name_from_pic}.pc\'}})'
            print(f"    DEBUG: Reconstructed standard spawn_cmd: '{constructed_spawn_cmd}'")
        elif self.current_details_folder in ["folder_grouped", "user_custom_configs"] and config_name_from_pic:
             constructed_spawn_cmd = f'core_vehicles.loadConfig("{config_name_from_pic}")'
             print(f"    DEBUG: Reconstructed custom/grouped spawn_cmd: '{constructed_spawn_cmd}' (CHECK FORMAT!)")
        else:
             print("    WARN: Could not reliably reconstruct spawn_cmd based on available info.")
        #self.current_details_sidebar_spawn_cmd = constructed_spawn_cmd
        print(f"    DEBUG: Set self.current_details_sidebar_spawn_cmd = '{self.current_details_sidebar_spawn_cmd}'")
        print(f"  DEBUG: Instance state updated: folder='{self.current_details_folder}', spawn='{self.current_details_sidebar_spawn_cmd}'")


        # --- <<< MODIFIED SECTION: Always attempt individual info update >>> ---
        print("  DEBUG: Attempting to find individual info file path...")
        individual_info_path = None # Default to None
        # Try to find the path only if we have seemingly valid components
        if effective_folder_name != "UnknownFolder" and zip_file_base_name_from_pic and config_name_from_pic:
             try:
                 individual_info_path = self.find_individual_info_file(
                     effective_folder_name,
                     zip_file_base_name_from_pic, # Still likely '' here
                     config_name_from_pic
                 )
                 print(f"  DEBUG: Determined potential individual_info_path: {individual_info_path}")
             except Exception as find_err:
                  print(f"ERROR during find_individual_info_file: {find_err}")
                  individual_info_path = None # Ensure it's None on error
        else:
            # This case is hit if extraction failed to get required parts (like zip_base)
             print("  WARN: Cannot determine individual info path due to missing extracted components (folder/zip_base/config).")
             individual_info_path = None # Explicitly None

        print("  DEBUG: Calling individual info update function REGARDLESS of path validity...")
        # Always call the update function. It MUST handle None path or file loading errors internally
        # and use main_info_data as a fallback to populate labels.
        # Ensure self.update_details_sidebar_individual_info has this fallback logic.
        self.update_details_sidebar_individual_info(individual_info_path, main_info_data=info_data)
        # --- <<< END MODIFIED SECTION >>> ---


        # --- Update Config Name Label (Keep logic from new version) ---
        if self.current_details_sidebar_spawn_cmd:
            self.update_details_sidebar_config_name(self.current_details_sidebar_spawn_cmd)
        else:
            # Ensure label exists before configuring
            if hasattr(self, 'details_sidebar_config_name_label') and self.details_sidebar_config_name_label.winfo_exists():
                self.details_sidebar_config_name_label.config(text="")


        # --- Update Favorites Button Text (Keep logic from new version) ---
        print(f"  DEBUG: Calling favorites button update. State should be set.")
        self.update_details_sidebar_favorites_button_text()


        print("--- update_details_sidebar_content() EXIT ---\n")


        
    def start_smooth_scroll_sidebar_text(self, delta_units):
        """Starts smooth scrolling animation for the sidebar text canvas."""
        canvas_sub = self.details_sidebar_text_canvas # Target the correct canvas

        if not canvas_sub or not canvas_sub.winfo_exists():
             print("DEBUG: start_smooth_scroll_sidebar_text - Canvas does not exist.")
             return

        if self.sidebar_text_scroll_animation_id:
            # Cancel existing specific animation for this canvas
            canvas_sub.after_cancel(self.sidebar_text_scroll_animation_id)

        current_yview = canvas_sub.yview()
        if not current_yview: # Check if yview returned valid data
            print("DEBUG: start_smooth_scroll_sidebar_text - yview returned invalid data.")
            return
        current_pos = current_yview[0]

        # --- Calculate scroll step (adjust scroll_fraction as needed) ---
        canvas_height = canvas_sub.winfo_height()
        scroll_bbox = canvas_sub.bbox("all")
        scrollable_height = scroll_bbox[3] - scroll_bbox[1] if scroll_bbox else canvas_height
        if scrollable_height <= canvas_height: # No scroll needed if content fits
             return

        scroll_fraction = 0.15 # Smaller fraction for potentially less content
        scroll_step_normalized = (canvas_height / scrollable_height) * scroll_fraction * delta_units
        target_y_normalized = current_pos - scroll_step_normalized # Correct direction
        target_y_normalized = max(0.0, min(1.0, target_y_normalized)) # Clamp
        # --- Calculation End ---

        self.sidebar_text_scroll_target_y = target_y_normalized
        self.sidebar_text_scroll_start_y = current_pos
        self.sidebar_text_scroll_start_time = self.master.tk.call('clock', 'milliseconds')

        # Start the new animation loop for this specific canvas
        self.animate_scroll_sidebar_text(canvas_sub)


    def animate_scroll_sidebar_text(self, canvas_sub):
        """Animates the canvas scroll with ease-out for the sidebar text."""
        if not canvas_sub or not canvas_sub.winfo_exists():
             self.sidebar_text_scroll_animation_id = None # Ensure animation stops if canvas gone
             return

        current_time = self.master.tk.call('clock', 'milliseconds')
        time_elapsed = current_time - self.sidebar_text_scroll_start_time
        # Use the shared scroll_duration attribute
        progress = min(1.0, time_elapsed / self.scroll_duration)

        # Ease-out function (same as before)
        ease_out_progress = self.ease_out_quintic_modified_speed(progress)

        # Calculate current scroll position
        current_y_normalized = self.sidebar_text_scroll_start_y + (self.sidebar_text_scroll_target_y - self.sidebar_text_scroll_start_y) * ease_out_progress

        # Apply the scroll position
        canvas_sub.yview_moveto(current_y_normalized)

        # Continue animation if not finished
        if progress < 1.0:
            self.sidebar_text_scroll_animation_id = canvas_sub.after(10, lambda: self.animate_scroll_sidebar_text(canvas_sub))
        else:
            self.sidebar_text_scroll_animation_id = None # Animation finished



    def custom_sidebar_text_scrollbar_set(self, *args):
        """Custom scrollbar set command for sidebar text."""
        if self.scrollbar_thumb_dragging_sidebar_text:
            return # Prevent updates if dragging manually

        start, end = float(args[0]), float(args[1])
        canvas_sub = self.details_sidebar_text_canvas # The content canvas
        scrollbar_canvas = self.custom_scrollbar_canvas_sidebar_text # The scrollbar canvas
        thumb = self.scrollbar_thumb_sidebar_text # The thumb rectangle

        if not canvas_sub or not scrollbar_canvas or not thumb: return # Safety check

        canvas_height = scrollbar_canvas.winfo_height() # Height of the scrollbar track
        scroll_range = canvas_sub.bbox("all") # Content size
        scrollable_height = scroll_range[3] - scroll_range[1] if scroll_range else canvas_height

        if scrollable_height <= canvas_height: # Content fits or less
            scrollbar_canvas.itemconfig(thumb, fill="#555555") # Grey out thumb
            # Hide the thumb by setting coords outside visible area (optional, makes it disappear)
            # scrollbar_canvas.coords(thumb, -1, -1, -1, -1)
        else: # Content requires scrolling
            scrollbar_canvas.itemconfig(thumb, fill=self.global_highlight_color) # Ensure thumb is orange
            thumb_height = max(20, canvas_height * (canvas_height / scrollable_height)) # Calculate thumb height
            thumb_y_start = canvas_height * start
            thumb_y_end = thumb_y_start + thumb_height
            # Ensure thumb doesn't go beyond track boundaries
            thumb_y_start = max(0, thumb_y_start)
            thumb_y_end = min(canvas_height, thumb_y_end)
            scrollbar_canvas.coords(thumb, 0, thumb_y_start, 15, thumb_y_end) # Update thumb position/size


    def custom_sidebar_text_scrollbar_click(self, event):
        """Start thumb dragging for sidebar text."""
        scrollbar_canvas = self.custom_scrollbar_canvas_sidebar_text
        thumb = self.scrollbar_thumb_sidebar_text
        if not scrollbar_canvas or not thumb: return

        # Only start drag if click is on the thumb itself
        coords = scrollbar_canvas.coords(thumb)
        if coords and coords[1] <= event.y <= coords[3]: # Check Y coordinate against thumb position
             self.scrollbar_thumb_dragging_sidebar_text = True
             self.scrollbar_thumb_start_y_sidebar_text = coords[1] # Use current thumb Y
             self.scrollbar_mouse_start_y_sidebar_text = event.y
        else:
             # Optional: Handle clicks on the track (jump scrolling)
             # Calculate position based on click y and canvas height
             canvas_height = scrollbar_canvas.winfo_height()
             click_fraction = event.y / canvas_height
             self.details_sidebar_text_canvas.yview_moveto(click_fraction)


    def custom_sidebar_text_scrollbar_drag(self, event):
        """Drag thumb and update content canvas view for sidebar text."""
        if not self.scrollbar_thumb_dragging_sidebar_text:
            return

        canvas_sub = self.details_sidebar_text_canvas # Content canvas
        scrollbar_canvas = self.custom_scrollbar_canvas_sidebar_text # Scrollbar canvas
        thumb = self.scrollbar_thumb_sidebar_text # Thumb

        if not canvas_sub or not scrollbar_canvas or not thumb: return

        mouse_y = event.y
        delta_y = mouse_y - self.scrollbar_mouse_start_y_sidebar_text
        new_thumb_y = self.scrollbar_thumb_start_y_sidebar_text + delta_y

        canvas_height = scrollbar_canvas.winfo_height()
        scroll_range = canvas_sub.bbox("all")
        scrollable_height = scroll_range[3] - scroll_range[1] if scroll_range else canvas_height

        if scrollable_height <= canvas_height:
            return # No scrolling needed

        coords = scrollbar_canvas.coords(thumb)
        thumb_height = coords[3] - coords[1] if coords else 20 # Get current thumb height
        max_thumb_y = canvas_height - thumb_height
        new_thumb_y = max(0, min(max_thumb_y, new_thumb_y)) # Clamp thumb position

        scrollbar_canvas.coords(thumb, 0, new_thumb_y, 15, new_thumb_y + thumb_height)

        scroll_fraction = new_thumb_y / max_thumb_y if max_thumb_y > 0 else 0
        canvas_sub.yview_moveto(scroll_fraction) # Update the content canvas view


    def custom_sidebar_text_scrollbar_release(self, event):
        """Stop thumb dragging for sidebar text."""
        self.scrollbar_thumb_dragging_sidebar_text = False





    def find_default_config_item_details(self, details_data, zip_file):
        """
        Finds the default config item from details_data based on 'default_pc' in JSON info.
        Returns the item tuple or None if not found.
        """
        # First, try to get info data from any item in details_data (assuming info is consistent for the zip)
        sample_info_data = details_data[0][3] if details_data else None
        if sample_info_data:
            default_pc_name = sample_info_data.get("default_pc", "").strip()
            if default_pc_name:
                base_pc_name = os.path.splitext(default_pc_name)[0] # Remove extension
                for item in details_data:
                    item_picture_path, _, _, item_info_data, _ = item
                    item_config_name = self.extract_name_from_spawn_command(item[1]) # Extract config name from spawn cmd
                    if item_config_name == base_pc_name:
                        return item # Found the default config item
        # If no default_pc in info or not found, return the first item as fallback
        return None


    def on_details_image_right_click(self, zip_file, spawn_cmd, picture_path):
        self.details_is_deleting = True
        if self.details_deleting_label and not self.details_window_closed:
            self.details_deleting_label.config(text="Deleting...")
        self.toggle_details_deleting_text()

        temp_window = tk.Toplevel(self.details_window)
        temp_window.withdraw() # Make it invisible
        if self.details_window:
            temp_window.transient(self.details_window)
            temp_window.grab_set()

        if zip_file == "user_custom_configs":
            match = re.search(r"config\s*=\s*'vehicles/([^/]+)/([^\.]+)\.pc'", spawn_cmd)
            if match:
                folder_name, file_name = match.groups()
            else:
                self.details_is_deleting = False
                if self.details_deleting_label and not self.details_window_closed:
                    self.details_deleting_label.config(text="")
                messagebox.showerror("Error", "Unable to parse configuration details.")
                if self.details_window:
                    temp_window.destroy()
                return
            confirm = messagebox.askyesno(
                "Confirm Delete",
                f"Are you sure you want to delete the custom config '{file_name}' in folder '{folder_name}'?",
                parent = temp_window
            )
            self.details_is_deleting = False
            if self.details_deleting_label and not self.details_window_closed:
                self.details_deleting_label.config(text="")
            if confirm:
                self.delete_specific_custom_config(folder_name, file_name, picture_path)
                self.run_python_scripts_custom()
                
                try:
                    script_path = os.path.join(self.script_dir, "modify_output_good_custom.py")
                    if not os.path.exists(script_path):
                    #    messagebox.showerror("Script Not Found",
                    #                         f"The script 'modify_output_good_custom.py' was not found in {self.script_dir}.")
                        pass

                        if self.details_window:
                            temp_window.destroy()
                        return
                    #subprocess.run([sys.executable, script_path], check=True)
                    #messagebox.showinfo("Script Execution",
                    #                    "'modify_output_good_custom.py' has been executed successfully.")
                except subprocess.CalledProcessError as e:
                    messagebox.showerror(
                        "Script Execution Error",
                        f"An error occurred while running 'modify_output_good_custom.py':\n{e}"
                    )
                except Exception as e:
                    messagebox.showerror(
                        "Unexpected Error",
                        f"An unexpected error occurred:\n{e}"
                    )
            if self.details_window:
                temp_window.destroy()
        else:
            confirm = messagebox.askyesno(
                "Confirm Delete",
                f"Are you sure you want to delete the mod '{zip_file}' and all related files?",
                parent=temp_window
            )
            self.details_is_deleting = False
            if self.details_deleting_label and not self.details_window_closed:
                self.details_deleting_label.config(text="")
            if confirm:
                self.delete_item(zip_file)
            temp_window.destroy()



    def delete_item(self, zip_file):
        """Deletes an item, added search window update."""
        pattern = zip_file.lower()
        deleted_files = []
        errors = []

        parent_dir = os.path.dirname(self.script_dir)
        folders = [
            self.config_pics_folder,
            self.config_info_folder,
            self.repo_folder,
            self.vehicles_content_folder,
            parent_dir
        ]
        for folder in folders:
            if not os.path.exists(folder):
                continue
            try:
                for filename in os.listdir(folder):
                    if pattern in filename.lower():
                        path_to_del = os.path.join(folder, filename)
                        if os.path.isfile(path_to_del):
                            os.remove(path_to_del)
                            deleted_files.append(path_to_del)
            except Exception as e:
                errors.append(f"Error deleting in {folder}: {e}")
        if errors:
            msg = "\n".join(errors)
            messagebox.showerror("Deletion Errors", f"Some errors occurred:\n{msg}")
        if deleted_files:
            #messagebox.showinfo("Deletion Successful", f"Deleted '{zip_file}' and related files.")
            self.data = [d for d in self.data if d[2].lower() != zip_file.lower()]
            self.full_data.pop(zip_file, None)
            self.grouped_data = self.format_grouped_data(self.data)
            self.is_search_results_window_active_bypass_flag = True

            print("    delete_item is calling self.update_grid_layout()")
            self.update_grid_layout()

            if self.details_window and not self.details_window_closed:
                self.refresh_details_window_after_deletion()
                
            self.update_search_results_window_ui() # <----- ADD THIS LINE HERE # MODIFIED - Call update function here




    def isolate_item(self, zip_file):
        """Deletes an item, added search window update, and isolates zip files."""
        pattern = zip_file.lower()
        deleted_files = []
        errors = []

        parent_dir = os.path.dirname(self.script_dir)
        grandparent_dir = os.path.dirname(parent_dir)
        great_grandparent_dir = os.path.dirname(grandparent_dir) # Get great grandparent directory
        isolated_folder = os.path.join(great_grandparent_dir, "Isolated") # Path to Isolated folder

        # Create the Isolated folder if it doesn't exist
        os.makedirs(isolated_folder, exist_ok=True)

        folders = [
            self.config_pics_folder,
            self.config_info_folder,
            self.repo_folder,
            self.vehicles_content_folder,
            parent_dir
        ]
        for folder in folders:
            if not os.path.exists(folder):
                continue
            try:
                for filename in os.listdir(folder):
                    if pattern in filename.lower():
                        path_to_del = os.path.join(folder, filename)
                        if os.path.isfile(path_to_del):
                            if filename.lower().endswith(".zip"): # Check if it's a zip file
                                try:
                                    destination_path = os.path.join(isolated_folder, filename)
                                    shutil.move(path_to_del, destination_path) # Move the zip file
                                    deleted_files.append(path_to_del) # Still add to deleted files for UI update
                                    print(f"Moved ZIP file: {path_to_del} to {destination_path}") # Optional logging
                                except Exception as move_err:
                                    errors.append(f"Error moving ZIP file {path_to_del} to Isolated: {move_err}")
                            else: # If not a zip file, proceed with deletion as before
                                os.remove(path_to_del)
                                deleted_files.append(path_to_del)
            except Exception as e:
                errors.append(f"Error processing folder {folder}: {e}")

        if errors:
            msg = "\n".join(errors)
            messagebox.showerror("Deletion Errors", f"Some errors occurred:\n{msg}")

        if deleted_files:
            #messagebox.showinfo("Deletion Successful", f"Deleted '{zip_file}' and related files.")
            self.data = [d for d in self.data if d[2].lower() != zip_file.lower()]
            self.full_data.pop(zip_file, None)
            self.grouped_data = self.format_grouped_data(self.data)

            self.is_search_results_window_active_bypass_flag = True
            print("    isolate_item is calling self.update_grid_layout()")
            self.update_grid_layout()

            if self.details_window and not self.details_window_closed:
                self.refresh_details_window_after_deletion()
            self.update_search_results_window_ui() # <----- ADD THIS LINE HERE # MODIFIED - Call update function here

                
                
    def delete_specific_custom_config(self, folder_name, file_name, picture_path):
        pc_file_path = os.path.join(self.user_folder, folder_name, f"{file_name}.pc")
        if os.path.exists(pc_file_path):
            try:
                os.remove(pc_file_path)
            except Exception as e:
                messagebox.showerror("Deletion Error", f"Error deleting {pc_file_path}: {e}")
                return
        else:
            messagebox.showwarning("File Not Found", f"The file {pc_file_path} does not exist.")

        # Delete associated image files (.png, .jpeg, .jpg)
        image_extensions = ['.png', '.jpeg', '.jpg']
        for ext in image_extensions:
            image_file_path = os.path.join(self.user_folder, folder_name, f"{file_name}{ext}")
            if os.path.exists(image_file_path):
                try:
                    os.remove(image_file_path)
                    print(f"Deleted image file: {image_file_path}")
                except Exception as e:
                    messagebox.showerror("Deletion Error", f"Error deleting {image_file_path}: {e}")
                    return
                    
        if self.details_window and not self.details_window_closed:
            self.refresh_details_window_after_deletion()
            
            
        base_image_name = f"vehicles--{folder_name}_user--{file_name}"
        image_file_path = None
        for ext in ['jpg', 'jpeg', 'png']:
            candidate = os.path.join(self.config_pics_custom_folder, f"{base_image_name}.{ext}")
            if os.path.exists(candidate):
                image_file_path = candidate
                break

        if image_file_path and os.path.exists(image_file_path):
            try:
                os.remove(image_file_path)
            except Exception as e:
                messagebox.showerror("Deletion Error", f"Error deleting {image_file_path}: {e}")
                return

        # Remove the deleted config from full_data
        if "user_custom_configs" in self.full_data:
            for info_key in list(self.full_data["user_custom_configs"].keys()):
                group = self.full_data["user_custom_configs"][info_key]
                group['configs'] = [
                    cfg for cfg in group['configs']
                    if not (cfg[4] == folder_name and self.extract_name_from_spawn_command(cfg[1]) == file_name)
                ]
                if not group['configs']:
                    del self.full_data["user_custom_configs"][info_key]

        # Update self.data to only include one representative config per group
        self.data = []
        for zip_file, groups in self.full_data.items():
            if zip_file != "user_custom_configs":
                # For non-custom configs, add the first config as representative
                if groups:
                    self.data.append(groups[0])
            else:
                # For custom configs, add one representative config per info_key
                for info_key, group_data in groups.items():
                    if group_data['configs']:
                        self.data.append(group_data['configs'][0])

        self.grouped_data = self.format_grouped_data(self.data)

        self.is_search_results_window_active_bypass_flag = True    
        print("    delete_specific_custom_config is calling self.update_grid_layout()")  
        self.update_grid_layout()

        # Refresh the details window if it's open
        if self.details_window and not self.details_window_closed:
            self.refresh_details_window()
        self.update_search_results_window_ui()     

    def refresh_details_window(self):
        """
        Robustly refreshes the details window, ensuring data is reloaded and the subgrid rebuilt.
        """
        if self.details_window and not self.details_window_closed:
            print("\n--- Starting ROBUST Details Window Refresh (Attempt 7 - DEBUGGING DATA REFRESH) ---") # Debug Print - Start

            # --- NEW: Cancel any pending details batch loads BEFORE destroying canvas ---
            if self.details_window and self.scroll_animation_timer: # Check if details_window exists AND animation timer is active
                print("  Cancelling any pending details batch loads...") # Debug
                self.details_window.after_cancel(self.scroll_animation_timer) # Cancel details animation timer (which schedules batch loads)
                self.scroll_animation_timer = None # Reset timer ID
                print("  Pending details batch loads CANCELED.") # Debug

            # --- Destroy and Recreate Canvas and Scrollable Frame ---
            print("  Destroying existing canvas and scrollable frame...") # Debug
            if self.details_canvas_sub and self.details_canvas_sub.winfo_exists(): # Check if canvas exists before destroy
                self.details_canvas_sub.destroy()
            if hasattr(self, 'scrollbar_sub') and self.scrollbar_sub and self.scrollbar_sub.winfo_exists(): # Check if scrollbar exists before destroy
                self.scrollbar_sub.destroy()
            self.details_canvas_sub = None
            self.details_scrollable_frame = None

            # Re-create Canvas and Scrollable Frame
            self.details_canvas_sub = tk.Canvas(self.details_main_frame, bg="#444444", highlightthickness=0)
            self.scrollbar_sub = tk.Scrollbar(self.details_main_frame, orient="vertical", command=self.details_canvas_sub.yview) # Re-create scrollbar AND re-assign to self
            self.details_scrollable_frame = tk.Frame(self.details_canvas_sub, bg="#444444")

            self.details_scrollable_frame.bind("<Configure>", lambda e: self.details_canvas_sub.configure(scrollregion=self.details_canvas_sub.bbox("all")))
            self.details_canvas_sub.create_window((0, 0), window=self.details_scrollable_frame, anchor="nw")
            self.details_canvas_sub.configure(yscrollcommand=self.scrollbar_sub.set)

            canvas_sub = self.details_canvas_sub # For details animation and mousewheel binding
            canvas_sub.bind("<Enter>", lambda e: canvas_sub.bind_all("<MouseWheel>", lambda ev: self.on_mousewheel_details(ev, canvas_sub)))
            canvas_sub.bind("<Leave>", lambda e: canvas_sub.unbind_all("<MouseWheel>"))

            print("  Canvas and scrollable frame recreated.") # Debug

            # --- Re-filter data (more robust filtering logic) ---
            subgrid_data = []
            zip_file = self.current_details_zip_file
            folder_name = self.current_details_folder
            print(f"  zip_file for refresh: {zip_file}, folder_name: {folder_name}") # Debug - Zip/Folder for refresh

            if zip_file == "user_custom_configs" and folder_name:
                print("  Filtering for custom configs - folder:", folder_name) # Debug
                if "user_custom_configs" in self.full_data and self.full_data["user_custom_configs"]: # Robust check
                    print("  user_custom_configs key FOUND in full_data.") # Debug
                    for info_key, group in self.full_data["user_custom_configs"].items():
                        print(f"    Checking info_key: {info_key}") # Debug - Info Key
                        for config in group['configs']:
                            config_folder_name = config[4]
                            print(f"      Checking config folder name: {config_folder_name}") # Debug - Config Folder Name
                            if config_folder_name == folder_name:
                                print(f"        Match found for folder: {folder_name}, adding config: {os.path.basename(config[0])}") # Debug - Match - Config Filename
                                subgrid_data.append(config)
                            else:
                                print(f"        No match for folder: {folder_name}, skipping config.") # Debug - No Match
                else:
                    print("  WARNING: user_custom_configs key NOT FOUND in full_data!") # Debug - Warning
            elif zip_file:
                print(f"  Filtering for zip file: {zip_file}...") # Debug
                subgrid_data = self.full_data.get(zip_file, [])
            else:
                print("  WARNING: No zip_file specified for details refresh!") # Debug - Warning

            print(f"  Subgrid data items found AFTER {len(subgrid_data)}") # Debug - Item Count

            # --- Handle Empty Subgrid Data ---
            if not subgrid_data:
                print("  Subgrid data is EMPTY. Clearing details window content.") # Debug
                self.details_data = [] # Clear details data
                self.details_filtered_data = []
                if self.details_count_label:
                    self.details_count_label.config(text="Total: 0") # Update count label to 0
                # Clear ALL widgets from scrollable frame - explicitly
                for widget in self.details_scrollable_frame.winfo_children():
                    widget.destroy()
                self.stop_details_loading_animation() # Stop loading animation if running
                self.details_canvas_sub.config(scrollregion=self.details_canvas_sub.bbox("all")) # Update scrollregion for empty canvas
                print("  Details Window Content Cleared for Empty Subgrid.") # Debug
                print("FULL Details Window Refresh Completed (Empty Subgrid Case). ---\n") # Debug - End Marker
                return # EXIT function early for empty subgrid

            # --- Rebuild the subgrid UI (if not empty) ---
            print("  Rebuilding details subgrid UI (Data Count:", len(subgrid_data),")...") # Debug
            self.details_data = subgrid_data
            self.details_filtered_data = subgrid_data[:]
            self.details_search_var.set("")
            self.rebuild_simple_details() # Rebuild subgrid UI
            print("  Details Subgrid Rebuilt.") # Debug

            # --- Update Sidebar to Default or First Config (NEW) ---
            default_config_item = self.find_default_config_item_details(subgrid_data, zip_file)
            if default_config_item:
                default_picture_path, _, _, default_info_data, _ = default_config_item
                self.update_details_sidebar_content(default_info_data, default_picture_path, zip_file)
                self.update_details_sidebar_config_name(default_config_item[1]) # Set config name label
                self.is_details_sidebar_showing_default = True
                print("  Updated sidebar to DEFAULT config.") # Debug
            elif subgrid_data: # Fallback to first item if no default and data exists
                first_item = subgrid_data[0]
                first_picture_path, _, _, first_info_data, _ = first_item
                self.update_details_sidebar_content(first_info_data, first_picture_path, zip_file)
                self.update_details_sidebar_config_name(first_item[1]) # Set config name label
                self.is_details_sidebar_showing_default = True
                print("  Updated sidebar to FIRST config.") # Debug
            else:
                self.hide_details_sidebar_info() # Hide sidebar if no data
                self.is_details_sidebar_showing_default = False
                print("  No subgrid data, sidebar info HIDDEN.") # Debug


            # --- Update count label and scroll region ---
            if self.details_count_label:
                self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}")
                print("  Details Count Label Updated.") # Debug
            self.details_scrollable_frame.update_idletasks()
            self.details_canvas_sub.config(scrollregion=self.details_canvas_sub.bbox("all"))
            print("  Details Canvas Scroll Region Updated.") # Debug

            print("ROBUST Details Window Refresh Completed. ---\n") # Debug Print - END Marker


    def refresh_details_window_after_deletion(self): # <--- NEW FUNCTION
        """
        Refreshes the details window and intelligently updates the sidebar after deletion.
        Prioritizes displaying another favorite in the sidebar if available, or the first item.
        """
        print("\n--- refresh_details_window_after_deletion() ENTRY ---") # Debug - Entry

        # --- Re-filter details data based on current filters (including Favorites) ---
        subgrid_data = self.details_data # Start with original data
        if self.details_window_is_favorites_filtered: # Apply Favorites filter if active
            favorite_configs_set = self.read_favorites()
            filtered_data = []
            for item in self.details_data:
                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                fav_key = f"{folder_name}|{config_name}.pc"
                if fav_key in favorite_configs_set:
                    filtered_data.append(item)
            subgrid_data = filtered_data # Use filtered data


        self.details_filtered_data = subgrid_data[:] # Update filtered data list
        self.rebuild_simple_details() # Rebuild subgrid UI with updated data

        # --- Intelligent Sidebar Update ---
        if self.details_filtered_data: # If there are items left after deletion
            # Try to find another favorite to display in sidebar
            favorite_config_to_show = None
            for item in self.details_filtered_data:
                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                fav_key = f"{folder_name}|{config_name}.pc"
                if self.is_favorite(folder_name, config_name + '.pc'):
                    favorite_config_to_show = item # Found a favorite
                    break # Use the first favorite found

            if favorite_config_to_show:
                # If a favorite is found, display it in the sidebar
                picture_path, spawn_cmd, zip_file_item, info_data, folder_name = favorite_config_to_show
                self.update_details_sidebar_content(info_data, picture_path, zip_file_item, folder_name=self.current_details_folder)
                self.update_details_sidebar_config_name(spawn_cmd)
                print("  Sidebar updated to another FAVORITE after deletion.") # Debug - Sidebar Update - Favorite
            else:
                # If no favorites left, display the first item in the list
                first_item = self.details_filtered_data[0]
                picture_path, spawn_cmd, zip_file_item, info_data, folder_name = first_item
                self.update_details_sidebar_content(info_data, picture_path, zip_file_item, folder_name=self.current_details_folder)
                self.update_details_sidebar_config_name(spawn_cmd)
                print("  Sidebar updated to FIRST ITEM after deletion (no favorites left).") # Debug - Sidebar Update - First Item
            self.is_details_sidebar_showing_default = False # Not default anymore
        else:
            # If no items left in details list, clear sidebar
            self.hide_details_sidebar_info()
            self.is_details_sidebar_showing_default = False
            print("  No items left in details list after deletion, sidebar info HIDDEN.") # Debug - Sidebar - Hidden

        print("--- refresh_details_window_after_deletion() EXIT ---\n") # Debug - Exit
        
    def clear_main_grid_cache(self):
        """Clears the main grid image cache (both PhotoImage and PIL Image caches)."""
        print("Clearing Main Grid Image Cache...") # Debug Print
        self.image_cache.clear()
        self.image_cache_pil.clear()
        print("Main Grid Image Cache Cleared.") # Debug Print
        

    def on_details_window_close(self):
        """
        Handles closing the details window, and potentially re-opening filters.
        - Now RESUMES main grid loading if it was paused when details window is closed EARLY. <--- MODIFIED
        """
        print("\n--- on_details_window_close() ENTRY ---")
        print(f"details_window_closed: {self.details_window_closed}")
        print(f"details_window is None: {self.details_window is None}")


        stack = inspect.stack()
        caller_function_name = "<unknown>"
        caller_filename = "<unknown>"
        caller_lineno = 0
        if len(stack) > 1:
            # stack[0] is the current frame (update_grid_layout)
            # stack[1] is the caller's frame
            caller_frame_record = stack[1]
            caller_function_name = caller_frame_record.function
            caller_filename = caller_frame_record.filename
            caller_lineno = caller_frame_record.lineno
            # You can even get the specific code line that made the call:
            caller_code_context = caller_frame_record.code_context
            print(f"    Code context: {caller_code_context}") # Might be None

        print(f"--- on_details_window_close CALLED BY: {caller_function_name} in {caller_filename} at line {caller_lineno} ---")


        '''
        if self.dev_mode:

            scanning_win = self.show_scanning_window(text=f"--- on_details_window_close CALLED BY: \n{caller_function_name} \nin {caller_filename} \nat line {caller_lineno} ---", tall=True, dev_notif=True)
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
                '''

        if not self.details_window_closed and self.details_window:
            print("Details window is open, proceeding to close and potentially re-open.")

            # --- NEW: Destroy zip search dropdown menu before closing details window ---
            self.destroy_zip_search_dropdown_menu() # <--- ADD THIS LINE HERE - destroy zip dropdown menu
            self.destroy_jump_to_page_dropdown_menu()
            print("  DEBUG: Zip search dropdown menu destroyed (if it was open).")
            # --- NEW: Destroy zip search dropdown menu before closing details window ---

            # Store zip_file and folder_name before closing
            last_details_zip_file = self.current_details_zip_file
            last_details_folder = self.current_details_folder
            print(f"Storing last_details_zip_file: {last_details_zip_file}")
            print(f"Storing last_details_folder: {last_details_folder}")

            print("Destroying details window...")
            self.details_window.destroy()
            self.details_window = None
            self.details_scrollable_frame = None
            self.details_canvas_sub = None
            self.details_window_closed = True
            print("Details window destroyed and state reset.")

            # --- NEW: Resume main grid loading if it was paused ---
            if self.pause_loading: # Check if main grid loading was paused
                print("DEBUG: on_details_window_close - Details window closed PREMATURELY. RESUMING main grid loading...")
                self.pause_loading = False # Resume main grid loading
                self.load_next_batch()      # Immediately trigger main grid batch loading to resume
                print("DEBUG: on_details_window_close - Main grid loading RESUMED.")
            # --- NEW: Resume main grid loading if it was paused ---


            if self.was_filters_window_open_before_details:
                print("DEBUG: on_details_window_close - Re-opening Filters window because it was open before Details.")
                self.show_filters_window()
                self.was_filters_window_open_before_details = False
        else:
            print("Details window was already closed or does not exist. No action taken.")

        if hasattr(self, 'details_deleting_label') and self.details_deleting_label and self.details_deleting_label.winfo_exists():
            self.details_deleting_label.config(text="")
        if self.details_is_deleting:
            self.details_is_deleting = False

        
        
        #if self.spawn_queue_window_was_open:
        #    print("DEBUG: Re-opening Spawn Queue window because it was initially open.")

            #self.show_spawn_queue_window() # Re-open the Spawn Queue window # still keeping track of if it was open, but not re-opening at the moment

        if self.details_window_intentionally_closed and self.window_size_changed_during_details_window:
            print(" if self.details_window_intentionally_closed and self.window_size_changed_during_details_window: condition met")

            self.details_window_intentionally_closed = False
            print("  Resetting details_window_intentionally_closed to False.")

            self.window_size_changed_during_details_window = False
            print("  Resetting window_size_changed_during_details_window to False.")


            if self.search_results_window_on_screen:
                print("  DEBUG: Search results window should be on the screen, destroying and recreating it...")
                
                self.destroy_search_results_window()
                    
                print("  DEBUG: creating new search results window.")
                self.search_results_window = self.show_search_results_window(self.data)

                print("self.update_grid_after_size_rechange has been set to True")
                self.update_grid_after_size_rechange = True

            if not self.search_results_window_on_screen:
                print("  DEBUG: Search results window should not be on the screen, running self.update_grid_layout()")
                self.update_grid_layout()

        print("--- on_details_window_close() EXIT ---\n")


    def on_rescan_all_button_click(self): # <--- NEW METHOD - Handles button click
        """
        Handles the 'Rescan All Mods & Configs' button click in the settings window.
        Triggers a full data refresh and UI update, then closes the settings window.
        """

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot perform this action due to pending hidden vehicles.")
            if scanning_win:

                def close_scanning_window():

                    scanning_win.destroy()

                scanning_win.after(3125, close_scanning_window)
            return

        print("\n--- ConfigViewerApp.on_rescan_all_button_click() ENTRY ---") # Debug Entry
        self.trigger_full_data_refresh_and_ui_update() # Trigger the full rescan
        # self.close_settings_window() # Close the settings window AFTER triggering rescan
        print("--- ConfigViewerApp.on_rescan_all_button_click() EXIT ---\n") # Debug Exit
        

    def on_rescan_all_button_click_handler(self):
        """Asks for confirmation (Yes/No/Cancel) before deleting specific
           files/folders and rescanning."""

        data_folder = os.path.join(self.script_dir, "data")
        backup_folder = os.path.join(data_folder, "backup") # Define backup folder path

        # Files to potentially back up if 'Yes' is chosen



        files_to_backup = [
            "outputGOOD.txt",
            "outputGOODcustom.txt",
            "WatcherOutput.txt",
            "zip_structure.txt",
            "favorites.txt",
            "Hidden.txt"
        ]



        relative_paths_to_delete = [

            #Folders in /data
            "ConfigInfo",
            "ConfigPics",
            "ConfigPicsCustom",

            #Files inside Folders  in /data                     
            "PicInfoExtractForNewMods/outputGOOD.txt",

            #Files directly in /data
            "NewMods.txt",
            "WatcherOutput.txt",
            "outputGOOD.txt",
            "outputGOODcustom (Original).txt"
            "outputGOODcustom.txt",
            "outputBAD.txt",
            "outputGOOD (Original).txt",
            "zip_structure.txt",

            "non_existent_item.xyz" # Example: safe to include non-existent items
        ]
        # --- End Configuration ---

        confirm = messagebox.askyesnocancel(
            "Rescan All Mods & Configs and/or Refresh UI",
            f"Choose 'Yes' to restart the application, do a deep rescan, check for new mods/configs, and clean/sort the application data. This will take longer than the second option but is likely to fix more issues.\n\nChoose 'No' to do a soft scan and simply refresh the UI.\n\nChoose 'Cancel' to close this dialogue and do nothing.",
            parent=self.master # Parent to master
        )

        # --- Handle User Choice ---
        if confirm is True:
            # --- User clicked Yes: Perform Backup FIRST, then Deletions ---
            print(f"User chose Yes.")

            # 1. --- Attempt Backup ---
            print(f"\n--- Attempting Backup to '{backup_folder}' ---")
            backup_errors = []
            try:
                # Ensure backup directory exists
                if not os.path.exists(backup_folder):
                    print(f"Backup directory not found. Creating: {backup_folder}")
                    os.makedirs(backup_folder) # Use makedirs to create parent dirs if needed
                    print(f"Successfully created backup directory.")
                else:
                    print(f"Backup directory already exists: {backup_folder}")

                # Copy the files
                for filename in files_to_backup:
                    source_path = os.path.join(data_folder, filename)
                    destination_path = os.path.join(backup_folder, filename)

                    if os.path.isfile(source_path):
                        try:
                            print(f"Attempting to copy '{source_path}' to '{destination_path}'")
                            shutil.copy2(source_path, destination_path) # copy2 preserves metadata
                            print(f"Successfully backed up '{filename}'.")
                        except Exception as e:
                            error_msg = f"ERROR backing up '{filename}': {e}"
                            print(error_msg)
                            backup_errors.append((filename, str(e)))
                    else:
                        print(f"Source file not found, skipping backup for: {source_path}")
                        # Optionally add to backup_errors if you want to track missing source files
                        # backup_errors.append((filename, "Source file not found"))

            except Exception as e:
                # Error creating the backup directory itself
                error_msg = f"CRITICAL ERROR preparing backup directory '{backup_folder}': {e}"
                print(error_msg)
                backup_errors.append(("Backup Directory Creation", str(e)))
                # Optionally, ask the user if they want to continue without backup, or just stop.


            # Summarize backup results
            if backup_errors:
                print(f"Backup process completed with {len(backup_errors)} error(s).")
                for item, error in backup_errors:
                     print(f" - FAILED Backup: {item} ({error})")
            else:
                print("Backup process completed successfully (or skipped missing files).")
            print("-" * 20) # Separator

            # 2. --- Proceed with Deletions ---
            print(f"\n--- Attempting deletion of configured items in '{data_folder}'... ---")
            scanning_win = self.show_scanning_window(text="Refreshing data and preparing for full rescan...")
            time.sleep(2.125) # You might adjust or remove sleeps depending on user feedback

            if not relative_paths_to_delete:
                print("No items configured for deletion.")
            else:
                deletion_errors = [] # Keep track of errors

                for relative_path in relative_paths_to_delete:
                    full_path = os.path.join(data_folder, relative_path)
                    item_type = "Item" # Default for logging

                    try:
                        if os.path.isdir(full_path):
                            item_type = "directory"
                            print(f"Attempting to delete directory: {full_path}")
                            shutil.rmtree(full_path)
                            print(f"Successfully deleted directory: {full_path}")
                        elif os.path.isfile(full_path):
                            item_type = "file"
                            print(f"Attempting to delete file: {full_path}")
                            os.remove(full_path)
                            print(f"Successfully deleted file: {full_path}")
                        elif os.path.lexists(full_path): # Use lexists to catch broken symlinks too
                             # Path exists but isn't a file or directory we can handle, or is a link
                             print(f"Path exists but is not a regular file or directory we can delete (skipped): {full_path}")
                             # Optionally add to errors if you need to know about these cases
                             # deletion_errors.append((relative_path, "Not a standard file/directory or is a link"))
                        else:
                            # Only print if you want verbose logging for non-existent items
                            # print(f"Path not found, skipping: {full_path}")
                            pass # Silently skip non-existent items

                    except OSError as e:
                        error_msg = f"ERROR deleting {item_type} '{full_path}': {e}"
                        print(error_msg) # Log error to console only
                        deletion_errors.append((relative_path, str(e)))
                    except Exception as e: # Catch any other unexpected errors during deletion
                        error_msg = f"UNEXPECTED ERROR processing '{full_path}': {e}"
                        print(error_msg) # Log error to console only
                        deletion_errors.append((relative_path, f"Unexpected: {e}"))

                # --- Summarize Deletion Results (Console Output Only) ---
                print("-" * 20) # Separator
                if not deletion_errors:
                    print("Deletion process completed for all specified items (check logs above for details).")
                else:
                    print(f"Deletion process completed with {len(deletion_errors)} error(s) logged:")
                    for path, error in deletion_errors:
                        print(f" - FAILED Deletion: {os.path.join('data', path)} ({error})")
                print("-" * 20) # Separator

            # --- Proceed with next steps (rescan/restart) ---
            print("Proceeding with rescan/restart actions...")

            scanning_win = None  # Initialize scanning_win


            if scanning_win:
                scanning_win.destroy()

            scanning_win = self.show_scanning_window(text="Restarting...")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()

            self.restart_script_and_save_settings()


            
        elif confirm is False:
            # --- User clicked No: Refresh UI Only ---
            print("User chose No. Refreshing UI only.")
            self.on_rescan_all_button_click() # Call the UI refresh method

        else: # confirm is None
            # --- User clicked Cancel ---
            print("Rescan/Deletion Cancelled by user.")








    def delete_backup_folder_on_startup(self):

        backup_folder_path = self.script_dir / "data/backup"

        print(f"Checking for deletion target: {backup_folder_path}")

        # Check if the path exists AND it is actually a directory
        if backup_folder_path.is_dir():
            print(f"Folder '{backup_folder_path}' found. Attempting to delete...")
            try:
                # shutil.rmtree deletes the directory and ALL its contents recursively
                shutil.rmtree(backup_folder_path)
                print(f"Successfully deleted folder: {backup_folder_path}")
            except OSError as e:
                # Catch potential errors during deletion (e.g., permissions, file in use)
                print(f"Error deleting folder {backup_folder_path}: {e}")
                # You might want to handle specific errors differently or log them
            except Exception as e:
                # Catch any other unexpected errors
                print(f"An unexpected error occurred while deleting {backup_folder_path}: {e}")
        else:
            # If it doesn't exist, or exists but isn't a directory (e.g., it's a file)
            if backup_folder_path.exists():
                print(f"Path '{backup_folder_path}' exists but is not a directory. Skipping deletion.")
            else:
                print(f"Folder '{backup_folder_path}' not found. No deletion needed.")




    def restart_script_and_save_settings(self):
        """Saves settings and Restarts the application."""

        print("Restarting application...")


        self.save_window_geometry() # Call save_window_geometry
        self.save_settings()
        self.restart_script()



    def restart_script(self):
        """Restarts the application."""
        try:
            print("Restarting application...")
            python_exe = sys.executable
            script_path = os.path.abspath(sys.argv[0])
            #subprocess.Popen([python_exe, script_path])
            subprocess.Popen([python_exe, "-B", script_path])
            os._exit(0)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to restart the script: {e}")
 

    def trigger_full_data_refresh_and_ui_update(self): # <--- NEW METHOD
            """
            Pops up a small window saying 'Checking for changes, scanning and refreshing data...',
            runs BOTH mod and custom config scanning, then refreshes data AND CLEARS MAIN GRID CACHE.
            Used when ANY watched file change is detected (mods OR custom configs).
            """

            self.set_filter_to_view_all_and_turn_subset_off()


            self.destroy_search_results_window()

            print("\n--- ConfigViewerApp.trigger_full_data_refresh_and_ui_update() ENTRY - DEBUG CHECK ---") # Debug - Entry Point - FULL_DATA_REFRESH_AND_UI_UPDATE
            self.show_scanning_window(text="Checking for changes, scanning and refreshing data...") # Modified text

            # --- NEW: Clear main grid image cache BEFORE refresh ---
            print("Clearing Main Grid Cache before refresh...") # Debug Print
            self.clear_main_grid_cache() # Call the new cache clearing function
            print("Main Grid Cache Cleared.") # Debug Print

            # --- NEW: Close details window if it's open (as before) ---
            if self.details_window and not self.details_window_closed:
                print("Closing Details Window before refresh...")
                self.details_window_intentionally_closed = True
                self.on_details_window_close()
                print("Details Window Closed.")

            try:
                # Run BOTH mod and custom config scans
                print("Calling self.run_ahk_scripts_mods() ...") # Debug - Before Mod Script Run
                self.run_ahk_scripts_mods() # Run MOD scan
                print("self.run_ahk_scripts_mods() RETURNED.") # Debug - After Mod Script Run

                print("Calling self.run_python_scripts_custom() ...") # Debug - Before Custom Config Script Run
                self.run_python_scripts_custom() # Run CUSTOM CONFIG scan
                print("self.run_python_scripts_custom() RETURNED.") # Debug - After Custom Config Script Run


                # Reload data
                print("Calling self.refresh_data_from_files() ...") # Debug - Before Data Refresh
                self.refresh_data_from_files()
                print("self.refresh_data_from_files() RETURNED.") # Debug - After Data Refresh


                # Refresh the UI (perform search to re-filter/re-group)
                print("    trigger_full_data_refresh_and_ui_update is calling self.perform_search() - and clearing the search bar") # Debug - Before Perform Search


                self.destroy_search_results_window()
                self.search_var.set("")
                time.sleep(1)
                self.perform_search()

                print("self.perform_search() RETURNED.") # Debug - After Perform Search


            except Exception as e:
                messagebox.showerror("Error", f"Error during full data scanning: {e}")
            finally:

                print("--trigger_full_data_refresh_and_ui_update is calling self.update_grid_layout()")
                self.update_grid_layout()
                print("--- ConfigViewerApp.trigger_full_data_refresh_and_ui_update() EXIT ---\n") # Debug - Exit Point


                if hasattr(self, 'trigger_refresh_scanning_win') and self.trigger_refresh_scanning_win is not None:
                    try:
                        # Attempt to destroy it
                        self.trigger_refresh_scanning_win.destroy()
                    except tk.TclError as e:
                        # Handle cases where destroy might fail even if the object exists (e.g., widget already destroyed)
                        print(f"TclError while destroying trigger_refresh_scanning_win (might be already gone): {e}")
                    finally:
                        # Set the attribute to None afterwards to prevent trying to destroy it again
                        self.trigger_refresh_scanning_win = None





    def update_new_mods_txt_with_new_zips(self, newly_detected_zip_files):
        """
        Updates NewMods.txt with a list of newly detected ZIP files.
        Deletes the old NewMods.txt and creates a new one with the updated list.
        """
        new_mods_file = os.path.join(self.script_dir, "data/NewMods.txt")

        try:
            if os.path.exists(new_mods_file):
                os.remove(new_mods_file) # Delete existing NewMods.txt
                print(f"DEBUG: Deleted existing NewMods.txt: {new_mods_file}") # Debug - Deletion
            else:
                print(f"DEBUG: NewMods.txt does not exist, will create: {new_mods_file}") # Debug - No Existing File

            if newly_detected_zip_files:
                with open(new_mods_file, "w", encoding="utf-8") as f: # Create new NewMods.txt
                    for file_name in newly_detected_zip_files:
                        f.write(f"{file_name}\n")
                print(f"DEBUG: Created/Updated NewMods.txt with {len(newly_detected_zip_files)} new mod(s): {new_mods_file}") # Debug - Write Success
            else:
                print("DEBUG: No newly detected ZIP files to write to NewMods.txt.") # Debug - No New Files to Write

        except Exception as e:
            print(f"ERROR: Error updating NewMods.txt: {e}")
            



#---------------------self contained animation code---------
# ----------------------------------------------------------

    def _hex_to_rgb(self, hex_color):
        hex_color_stripped = hex_color.lstrip('#')
        if len(hex_color_stripped) != 6:
            # print(f"Warning: Invalid hex color format: '{hex_color}'. Using black.")
            return (0, 0, 0)
        try:
            return tuple(int(hex_color_stripped[i:i+2], 16) for i in (0, 2, 4))
        except ValueError:
            # print(f"Warning: Invalid character in hex color '{hex_color}'. Using black.")
            return (0, 0, 0)

    def _rgb_to_hex(self, rgb_color):
        try:
            r, g, b = map(int, rgb_color)
            r = max(0, min(255, r)); g = max(0, min(255, g)); b = max(0, min(255, b))
            return f'#{r:02x}{g:02x}{b:02x}'
        except (ValueError, TypeError):
            # print(f"Warning: Invalid RGB color for conversion: {rgb_color}. Using #000000.")
            return "#000000"

    def _interpolate_color(self, color1_hex, color2_hex, factor):
        rgb1 = self._hex_to_rgb(color1_hex)
        rgb2 = self._hex_to_rgb(color2_hex)
        factor = max(0.0, min(1.0, factor))
        interpolated_rgb = [int(rgb1[i] + (rgb2[i] - rgb1[i]) * factor) for i in range(3)]
        return self._rgb_to_hex(tuple(interpolated_rgb))

    def _get_validated_current_color(self, widget, property_name):
        current_color_val_raw = ""
        try:
            current_color_val_raw = widget.cget(property_name)
            self._hex_to_rgb(current_color_val_raw)
            return current_color_val_raw
        except (ValueError, TypeError):
            pass
        except tk.TclError:
            return "#000000"
        original_hex = self.widget_original_colors.get(widget, {}).get(property_name)
        if original_hex:
            try:
                self._hex_to_rgb(original_hex)
                return original_hex
            except (ValueError, TypeError):
                pass
        return "#000000"
    

    def _start_animation(self, widget, properties_to_animate: dict):
        if not widget.winfo_exists():
            if widget in self.animation_states: del self.animation_states[widget]
            if widget in self.widget_original_colors: del self.widget_original_colors[widget]
            # Add cleanup for other state dicts if they become relevant here
            return

        state = self.animation_states.setdefault(widget, {
            'anim_id': None,
            'start_time': 0,
            'active_animations': {}
        })

        if state.get('anim_id'):
            try: widget.after_cancel(state['anim_id'])
            except tk.TclError: pass
            state['anim_id'] = None

        new_active_animations = {}
        for prop_name, target_value in properties_to_animate.items():
            if not isinstance(target_value, str): continue
            current_value = self._get_validated_current_color(widget, prop_name)
            if current_value.lower() != target_value.lower():
                new_active_animations[prop_name] = {
                    'start_value': current_value,
                    'target_value': target_value
                }
        
        if not new_active_animations:
            state['active_animations'] = {}
            try:
                final_config = {}
                for prop_name, target_value in properties_to_animate.items():
                     if isinstance(target_value, str):
                        final_config[prop_name] = target_value
                if final_config: widget.config(**final_config)
            except tk.TclError: pass
            return

        state['active_animations'] = new_active_animations
        state['start_time'] = time.time()
        
        try:
            self._run_animation_step(widget)
        except Exception as e:
            if state.get('anim_id'):
                try: widget.after_cancel(state['anim_id'])
                except tk.TclError: pass
            if widget in self.animation_states: del self.animation_states[widget]


    def _run_animation_step(self, widget):
        if not widget.winfo_exists():
            if widget in self.animation_states: del self.animation_states[widget]
            return

        state = self.animation_states.get(widget)
        if not state or not state.get('active_animations'):
            if state and state.get('anim_id'):
                try: widget.after_cancel(state['anim_id'])
                except tk.TclError: pass
                state['anim_id'] = None
            return

        start_time = state['start_time']
        active_animations = state['active_animations']
        elapsed = time.time() - start_time
        duration = self.transition_duration_sec if self.transition_duration_sec > 0 else 0.01
        progress = min(1.0, elapsed / duration)

        config_updates = {}
        try:
            for prop_name, anim_data in active_animations.items():
                interpolated_value = self._interpolate_color(anim_data['start_value'], anim_data['target_value'], progress)
                config_updates[prop_name] = interpolated_value
            if config_updates: widget.config(**config_updates)

            if progress < 1.0:
                state['anim_id'] = widget.after(15, lambda w=widget: self._run_animation_step(w))
            else:
                final_config = {p: d['target_value'] for p, d in active_animations.items()}
                if final_config: widget.config(**final_config)
                state['anim_id'] = None
                state['active_animations'] = {}
        except tk.TclError:
            if widget in self.animation_states:
                if self.animation_states[widget].get('anim_id'):
                    try: widget.after_cancel(self.animation_states[widget]['anim_id'])
                    except tk.TclError: pass
                del self.animation_states[widget]
        except Exception as e:
            if widget in self.animation_states:
                if state.get('anim_id'):
                    try: widget.after_cancel(state['anim_id'])
                    except tk.TclError: pass
                del self.animation_states[widget]


    def _bind_button_events(self, button, on_button_hover_enter, on_button_hover_leave, on_button_click):
        """
        WORKAROUND BINDER: Binds events to use smooth animation, IGNORING
        the passed handler functions. Assumes button is always enabled.
        Animates both BG and FG.
        """
        try:
            original_bg = self._get_validated_current_color(button, "bg")
            original_fg = self._get_validated_current_color(button, "fg")

            hover_target_bg = self.global_highlight_color
            sum_rgb_hover_bg = sum(self._hex_to_rgb(hover_target_bg))
            hover_target_fg = "black" if sum_rgb_hover_bg > 382 else "white"

            if button not in self.widget_original_colors:
                self.widget_original_colors[button] = {}
            self.widget_original_colors[button].setdefault('bg', original_bg)
            self.widget_original_colors[button].setdefault('fg', original_fg)

            def _internal_on_hover_enter(event, widget=button, ht_bg=hover_target_bg, ht_fg=hover_target_fg):
                try:
                    if widget.winfo_exists() and widget.cget('state') == tk.NORMAL: # Check state
                        self._start_animation(widget, {'bg': ht_bg, 'fg': ht_fg})
                except tk.TclError: pass

            def _internal_on_hover_leave(event, widget=button, rev_bg=original_bg, rev_fg=original_fg):
                try:
                    if widget.winfo_exists():
                        # REVERTED: No mouse position check here
                        if widget.cget('state') == tk.NORMAL: # Check state
                            self._start_animation(widget, {'bg': rev_bg, 'fg': rev_fg})
                except tk.TclError: pass

            def _internal_on_destroy(event, widget=button):
                if widget in self.animation_states:
                    state = self.animation_states[widget]
                    anim_id = state.get('anim_id')
                    if anim_id:
                        try: widget.after_cancel(anim_id)
                        except tk.TclError: pass
                    del self.animation_states[widget]
                if widget in self.widget_original_colors:
                    del self.widget_original_colors[widget]
                if widget in self.widget_animation_configs: del self.widget_animation_configs[widget]
                if widget in self.actively_hovered_widgets: self.actively_hovered_widgets.discard(widget)

            button.bind("<Enter>", _internal_on_hover_enter, add='+')
            button.bind("<Leave>", _internal_on_hover_leave, add='+')
            button.bind("<Destroy>", _internal_on_destroy, add='+')

        except tk.TclError:
            # print(f"Warning: Could not bind animated events for widget {button}, it might be destroyed.")
            pass
        except Exception as e:
            # print(f"Error in _bind_button_events for {button}: {e}")
            pass


    def _bind_animated_hover(self, button,
                             original_bg, original_fg,
                             hover_target_bg=None,
                             hover_target_fg=None,
                             check_state=False,
                             is_selected_initial=False,
                             selected_bg=None,
                             selected_fg=None,
                             on_enter_extra_command=None,
                             on_leave_extra_command=None):

        true_original_bg = self._get_validated_current_color(button, "bg") if original_bg is None else original_bg
        true_original_fg = self._get_validated_current_color(button, "fg") if original_fg is None else original_fg

        effective_hover_bg = hover_target_bg if hover_target_bg is not None else self.global_highlight_color
        if hover_target_fg is None:
            sum_rgb_hover_bg = sum(self._hex_to_rgb(effective_hover_bg))
            effective_hover_fg = "black" if sum_rgb_hover_bg > 382 else "white"
        else:
            effective_hover_fg = hover_target_fg

        normal_display_bg = true_original_bg
        normal_display_fg = true_original_fg
        if is_selected_initial and selected_bg is not None:
            normal_display_bg = selected_bg
            if selected_fg is not None:
                normal_display_fg = selected_fg
            else:
                sum_rgb_selected_bg = sum(self._hex_to_rgb(selected_bg))
                normal_display_fg = "black" if sum_rgb_selected_bg > 382 else "white"

        try:
            button.config(bg=normal_display_bg, fg=normal_display_fg)
        except tk.TclError:
            # print(f"Warning: Could not configure initial state for {button} in _bind_animated_hover.")
            return

        if button not in self.widget_original_colors:
             self.widget_original_colors[button] = {}
        self.widget_original_colors[button].update({'bg': true_original_bg, 'fg': true_original_fg})
        if selected_bg: self.widget_original_colors[button]['selected_bg'] = selected_bg
        if selected_fg: self.widget_original_colors[button]['selected_fg'] = selected_fg

        self.widget_animation_configs[button] = {
            'normal_display_bg': normal_display_bg,
            'normal_display_fg': normal_display_fg,
            'hover_bg': effective_hover_bg,
            'hover_fg': effective_hover_fg,
            'check_state': check_state,
        }

        def _on_hover_enter(event, widget=button):
            if on_enter_extra_command: on_enter_extra_command()
            try:
                if not widget.winfo_exists(): return

                widget_cfg = self.widget_animation_configs.get(widget)
                if not widget_cfg: return

                can_hover = (not widget_cfg['check_state'] or widget.cget('state') == tk.NORMAL)
                if not can_hover: return

                self._start_animation(widget, {'bg': widget_cfg['hover_bg'], 'fg': widget_cfg['hover_fg']})
                self.actively_hovered_widgets.add(widget)
            except tk.TclError: pass
            except Exception as e: pass # print(f"Error in _on_hover_enter for {widget}: {e}")

        def _revert_to_normal_appearance(widget_to_revert):
            if not widget_to_revert.winfo_exists(): return

            widget_cfg = self.widget_animation_configs.get(widget_to_revert)
            if not widget_cfg: return

            self._start_animation(widget_to_revert, {
                'bg': widget_cfg['normal_display_bg'],
                'fg': widget_cfg['normal_display_fg']
            })
            if widget_to_revert in self.actively_hovered_widgets:
                self.actively_hovered_widgets.discard(widget_to_revert)

        def _on_hover_leave(event, widget=button):
            if on_leave_extra_command: on_leave_extra_command()
            try:
                # REVERTED: No mouse position check here
                if not widget.winfo_exists(): return
                _revert_to_normal_appearance(widget)
            except tk.TclError: pass
            except Exception as e: pass # print(f"Error in _on_hover_leave for {widget}: {e}")

        def _on_focus_out(event, widget=button):
            if on_leave_extra_command: on_leave_extra_command() # Note: This might be called even if widget wasn't hovered
            try:
                if widget in self.actively_hovered_widgets: # Only revert if it was actively hovered
                    _revert_to_normal_appearance(widget)
            except tk.TclError: pass
            except Exception as e: pass # print(f"Error in _on_focus_out for {widget}: {e}")

        def _on_destroy(event, widget=button):
            if widget in self.animation_states:
                state = self.animation_states[widget]
                anim_id = state.get('anim_id')
                if anim_id:
                    try: widget.after_cancel(anim_id)
                    except tk.TclError: pass
                del self.animation_states[widget]
            if widget in self.widget_original_colors:
                del self.widget_original_colors[widget]
            if widget in self.widget_animation_configs:
                del self.widget_animation_configs[widget]
            if widget in self.actively_hovered_widgets:
                self.actively_hovered_widgets.discard(widget)

        button.bind("<Enter>", _on_hover_enter, add='+')
        button.bind("<Leave>", _on_hover_leave, add='+')
        button.bind("<FocusOut>", _on_focus_out, add='+')
        button.bind("<Destroy>", _on_destroy, add='+')




    def force_clear_all_hover_effects(self):
        """
        Forces all widgets currently in a visual hover state to revert to their
        non-hovered appearance (which might be 'selected' or 'original').
        """
        print(f"DEBUG: force_clear_all_hover_effects called. Actively hovered: {list(self.actively_hovered_widgets)}")
        # Iterate over a copy because _revert_hover (called via _start_animation) will modify the set
        widgets_to_clear = list(self.actively_hovered_widgets)

        for widget in widgets_to_clear:
            if not isinstance(widget, tk.Widget): # Skip non-widget keys if any
                # print(f"DEBUG: Skipping non-widget key in actively_hovered_widgets: {widget}")
                self.actively_hovered_widgets.discard(widget) # Clean up non-widget entry
                continue

            if widget.winfo_exists():
                widget_cfg = self.widget_animation_configs.get(widget)
                if widget_cfg:
                    print(f"  Purging hover for: {widget} to bg:{widget_cfg['initial_display_bg']}, fg:{widget_cfg['initial_display_fg']}")
                    # This re-uses the logic from _on_focus_out / _on_hover_leave
                    # It directly calls the revert logic that _bind_animated_hover sets up
                    if not widget_cfg['check_state'] or widget['state'] == tk.NORMAL:
                        widget.config(fg=widget_cfg['initial_display_fg'])
                        self._start_animation(widget, widget_cfg['initial_display_bg'], property_to_animate="bg")
                        # The _start_animation, if it leads to an animation towards initial_display_bg,
                        # should be responsible for removing from actively_hovered_widgets upon completion
                        # or immediately if no animation is needed.
                        # For safety, ensure it's removed if we directly config and don't animate
                        # However, _bind_animated_hover's _revert_hover handles this removal.
                        # Let's ensure the logic is in _revert_hover or called explicitly
                        if widget in self.actively_hovered_widgets: # If _start_animation didn't remove it (e.g. no actual anim)
                            self.actively_hovered_widgets.remove(widget)
                            print(f"DEBUG: Purged {widget}. Removed. Active: {len(self.actively_hovered_widgets)}")
                    else:
                        # If it's disabled but was marked active, remove it from tracking
                        if widget in self.actively_hovered_widgets:
                            self.actively_hovered_widgets.remove(widget)
                            print(f"DEBUG: Disabled {widget} found in active. Removed. Active: {len(self.actively_hovered_widgets)}")
                else:
                    # No config found, widget might not have been bound by our system
                    # print(f"  No animation config for {widget}, removing from active set if present.")
                    self.actively_hovered_widgets.discard(widget) # Clean up
            else: # Widget no longer exists
                # print(f"  Widget {widget} for purge no longer exists.")
                self.actively_hovered_widgets.discard(widget) # Clean up

        # It's possible some widgets didn't get removed if _start_animation didn't trigger a change
        # or if they were disabled. For robustness, clear any remaining that were processed:
        # for widget in widgets_to_clear: # This might be too aggressive
        #     self.actively_hovered_widgets.discard(widget)
        # The removal logic inside _revert_hover should be the primary mechanism.
        print(f"DEBUG: force_clear_all_hover_effects finished. Active: {len(self.actively_hovered_widgets)}")



    def _bind_button_events_custom_fg(self, button, on_button_hover_enter, on_button_hover_leave, on_button_click, default_fg):
        """
        WORKAROUND BINDER: Binds events to use smooth animation for BG and FG,
        IGNORING the passed handler functions, but using the provided default_fg
        for the normal foreground state.
        Assumes button is always enabled (no internal state check).
        """
        # --- Ignore the passed handler arguments ---
        # (on_button_hover_enter, on_button_hover_leave, on_button_click)
        # --- are accepted but NOT USED by this implementation. ---

        try:
            # --- Get necessary info directly from the button and args ---
            # Get the background color that the widget has at the time of binding.
            # This will be the target for 'bg' on hover leave.
            initial_bg_at_bind = self._get_validated_current_color(button, "bg")

            # The 'default_fg' passed to this function is the target for 'fg' on hover leave.
            revert_fg_color = default_fg
            try: # Validate the provided default_fg
                self._hex_to_rgb(revert_fg_color)
            except (ValueError, TypeError):
                print(f"Warning: Invalid default_fg '{revert_fg_color}' for {button}. Using black.")
                revert_fg_color = "#000000"


            # Define hover state colors
            hover_target_bg = self.global_highlight_color
            hover_target_fg = "#FFFFFF"  # As per original logic for this function

            # --- Store original/default colors for potential use by _get_validated_current_color
            # and to define revert targets clearly.
            if button not in self.widget_original_colors:
                self.widget_original_colors[button] = {}
            # Store the BG as it was at bind time, and the custom default FG.
            self.widget_original_colors[button].update({'bg': initial_bg_at_bind, 'fg': revert_fg_color})

            # --- Define NEW internal animation handlers ---
            def _internal_on_hover_enter(event, widget=button, ht_bg=hover_target_bg, ht_fg=hover_target_fg):
                try:
                    if widget.winfo_exists():
                        # NOTE: No state check ('widget['state'] == tk.NORMAL') is performed here
                        self._start_animation(widget, {'bg': ht_bg, 'fg': ht_fg})
                except tk.TclError: pass

            def _internal_on_hover_leave(event, widget=button, rev_bg=initial_bg_at_bind, rev_fg=revert_fg_color):
                try:
                    if widget.winfo_exists():
                        # NOTE: No state check performed here
                        self._start_animation(widget, {'bg': rev_bg, 'fg': rev_fg})
                except tk.TclError: pass

            def _internal_on_destroy(event, widget=button):
                # Cleanup animation state
                if widget in self.animation_states:
                    state = self.animation_states[widget]
                    anim_id = state.get('anim_id')
                    if anim_id:
                        try: widget.after_cancel(anim_id)
                        except tk.TclError: pass # Widget might be gone or anim_id stale
                    del self.animation_states[widget]
                # Cleanup original color storage
                if widget in self.widget_original_colors:
                    del self.widget_original_colors[widget]
                # Cleanup other states if this function were to use them
                # if widget in self.widget_animation_configs: del self.widget_animation_configs[widget]
                # if widget in self.actively_hovered_widgets: self.actively_hovered_widgets.discard(widget)


            # --- Bind the NEW internal handlers ---
            button.bind("<Enter>", _internal_on_hover_enter, add='+')
            button.bind("<Leave>", _internal_on_hover_leave, add='+')
            button.bind("<Destroy>", _internal_on_destroy, add='+')
            # --- DO NOT bind <Button-1> ---

        except tk.TclError:
            # This top-level try-except catches errors if 'button.cget("bg")' fails
            # (e.g., widget destroyed before/during call).
            print(f"Warning: Could not bind animated events for widget {button} in _bind_button_events_custom_fg, it might be destroyed.")
        except Exception as e:
            print(f"Error in _bind_button_events_custom_fg for {button}: {e}")


    def _cleanup_animation_data_for_widget(self, widget):
        """Cleans up animation state and original color storage for a widget."""
        if widget in self.animation_states:
            state = self.animation_states[widget]
            anim_id = state.get('anim_id')
            if anim_id:
                try:
                    widget.after_cancel(anim_id)
                except tk.TclError:  # Widget might be gone
                    pass
                except Exception as e:
                    print(f"Error cancelling animation for {widget}: {e}")
            del self.animation_states[widget]

        if widget in self.widget_original_colors:
            del self.widget_original_colors[widget]


# END OF ANIMATED HOVER CODE


    def _start_generic_animation(self, group_key, property_config_list_target, on_complete_callback=None):
        """
        Starts or redirects animation for a group of widget properties.
        Includes support for an optional callback to run on animation completion.

        group_key: Unique key for this animation group.
        property_config_list_target: List of dicts defining target state:
            {'widget': widget_obj, 'property': 'bg' or 'fg', 'target_color': hex_str}
        on_complete_callback: Optional function to call after animation finishes.
        """
        # Ensure group state exists
        if group_key not in self.animation_states:
            self.animation_states[group_key] = {'anim_id': None, 'start_time': 0}
        group_state = self.animation_states[group_key]

        # Cancel pending animation for this group
        if group_state.get('anim_id'):
            try:
                self.master.after_cancel(group_state['anim_id'])
            except tk.TclError: pass
            group_state['anim_id'] = None

        # Store the callback
        group_state['on_complete_callback'] = on_complete_callback

        # Build the full property_config_list with start_colors
        property_config_list_full = []
        all_widgets_exist = True

        for target_config in property_config_list_target:
            widget = target_config['widget']
            prop = target_config['property']
            target_color = target_config['target_color']

            if not widget or not widget.winfo_exists(): # Check widget existence
                 all_widgets_exist = False
                 print(f"DEBUG: Widget {widget} for animation {group_key} does not exist.")
                 break

            try:

                 current_color_val = widget.cget(prop)


                 try:
                     self._hex_to_rgb(current_color_val) # Test if it's a hex color
                 except (ValueError, TypeError):

                    if prop == 'fg' and widget in self.fadeable_sidebar_labels:
                        current_color_val = "#333333" # Assume start is the background
                        print(f"Warning: Unreadable current FG for {widget}. Starting fade from #333333.")
                    else:
                        # Fallback for other properties/widgets not covered by specific logic
                        print(f"Warning: Unreadable current color '{current_color_val}' for {widget}.{prop}. Using target color as start.")
                        current_color_val = target_color # Prevent crash, but animation won't happen

            except tk.TclError:
                 all_widgets_exist = False # Widget may have disappeared between check and cget
                 print(f"DEBUG: TclError getting color for {widget}.{prop} during animation setup.")
                 break
            except Exception as e:
                 print(f"Error getting color for {widget}.{prop} during animation setup: {e}")
                 all_widgets_exist = False
                 break


            property_config_list_full.append({
                'widget': widget, 'property': prop,
                'start_color': current_color_val, 'target_color': target_color
            })

        if not all_widgets_exist:
             # Clean up the group state if we can't proceed
            if group_key in self.animation_states: del self.animation_states[group_key]
            print(f"DEBUG: Cancelling generic animation {group_key} due to missing widgets.")
            return

        group_state['start_time'] = time.time()
        # Store the full config list in the state so the step function doesn't rebuild it
        group_state['property_config_list'] = property_config_list_full
        self._run_generic_animation_step(group_key)


    def _run_generic_animation_step(self, group_key):
        """
        Performs one step of animation for a group of widget properties.
        Checks for and runs a completion callback if provided.
        """
        group_state = self.animation_states.get(group_key)
        if not group_state: return # Group state is gone, animation was cancelled or finished

        group_state['anim_id'] = None # Clear current anim_id before scheduling the next one

        start_time = group_state.get('start_time', 0)
        property_config_list = group_state.get('property_config_list') # Retrieve list from state
        on_complete_callback = group_state.get('on_complete_callback') # Retrieve callback

        if not property_config_list: # Should not happen if start was successful
            if group_key in self.animation_states: del self.animation_states[group_key]
            return

        elapsed = time.time() - start_time
        # Ensure self.transition_duration_sec is not zero
        duration = self.transition_duration_sec if self.transition_duration_sec > 0 else 0.01
        progress = min(1.0, elapsed / duration)

        all_widgets_exist = True
        for config in property_config_list:
            widget = config['widget']
            if not widget or not widget.winfo_exists():
                all_widgets_exist = False
                break
        if not all_widgets_exist:
            print(f"DEBUG: Generic animation step cancelled for {group_key} due to missing widget.")
            if group_key in self.animation_states: del self.animation_states[group_key]
            return # Stop animation if any widget is gone

        for config in property_config_list:
            widget = config['widget']
            prop = config['property']
            start_c = config['start_color']
            target_c = config['target_color']
            try:
                current_color = self._interpolate_color(start_c, target_c, progress)
                # Use try-except per widget config in case one disappears mid-loop
                if widget.winfo_exists(): # Double check just before config
                    widget.config(**{prop: current_color})
            except tk.TclError: pass # Widget might have been destroyed mid-config
            except Exception as e:
                 print(f"Error during animation config for {widget}.{prop}: {e}")


        if progress < 1.0:
            delay_ms = 15
            # Schedule the next step using the same group key
            anim_id = self.master.after(delay_ms, lambda gk=group_key: self._run_generic_animation_step(gk))
            group_state['anim_id'] = anim_id # Store the new ID
        else: # Animation finished
            # Ensure final colors are set
            for config in property_config_list:
                widget = config['widget']
                prop = config['property']
                target_c = config['target_color']
                try:
                     if widget.winfo_exists(): widget.config(**{prop: target_c})
                except tk.TclError: pass
                except Exception as e:
                     print(f"Error setting final color for {widget}.{prop}: {e}")


            # Execute the completion callback if it exists
            if on_complete_callback:
                try:
                    on_complete_callback()
                except Exception as e:
                    print(f"Error executing animation completion callback for group '{group_key}': {e}")

            # Clean up state *after* the callback
            if group_key in self.animation_states:
                 del self.animation_states[group_key]


#window fading code


    def _fade_window(self, window, start_alpha, end_alpha, duration_ms, steps, callback=None):
        """
        Fades a window's transparency from start_alpha to end_alpha over a duration.

        Args:
            window: The Tkinter Toplevel or root window to fade.
            start_alpha: The starting transparency (0.0 to 1.0).
            end_alpha: The target transparency (0.0 to 1.0).
            duration_ms: The total duration of the fade in milliseconds.
            steps: The number of steps for the fade. More steps = smoother, potentially slower.
            callback: An optional function to call after the fade completes.
        """
        # print(f"DEBUG: _fade_window called on {window} from {start_alpha:.2f} to {end_alpha:.2f} over {duration_ms}ms in {steps} steps") # DEBUG

        if not window or not window.winfo_exists():
            # print("DEBUG: _fade_window - Window non-existent at start.") # DEBUG
            if callback:
                try:
                    callback()
                except Exception:
                     pass
            return

        # Avoid division by zero or unnecessary animation if start and end are the same
        tolerance = 0.005 # Use a small tolerance for float comparison
        if abs(end_alpha - start_alpha) < tolerance or steps <= 0 or duration_ms <= 0:
             # print("DEBUG: _fade_window - No significant change or zero duration/steps, jumping to end.") # DEBUG
             try:
                 window.wm_attributes('-alpha', end_alpha)
             except tk.TclError:
                 pass # Window might have been destroyed just now
             if callback:
                 try:
                    callback()
                 except Exception:
                    pass
             return


        alpha_step = (end_alpha - start_alpha) / steps
        delay_per_step = max(1, duration_ms // steps) # Ensure delay is at least 1ms if steps > 0

        # Set initial alpha immediately (redundant if caller set it, but safe)
        try:
            window.wm_attributes('-alpha', start_alpha)
        except tk.TclError:
             # print("DEBUG: _fade_window - Tk Error setting initial alpha.") # DEBUG
             if callback:
                 try:
                     callback()
                 except Exception:
                     pass
             return


        def animate_fade(current_step):
            if not window or not window.winfo_exists():
                # print(f"DEBUG: _fade_window - Window disappeared during step {current_step}.") # DEBUG
                if callback:
                    try:
                        callback()
                    except Exception:
                         pass
                return

            # Calculate the target alpha for this step
            target_alpha_this_step = start_alpha + alpha_step * current_step

            # Clamp the alpha to stay within the [0.0, 1.0] range
            clamped_alpha = max(0.0, min(1.0, target_alpha_this_step))

            # Check if we have reached or surpassed the end_alpha (considering direction)
            fade_finished = False
            if alpha_step > 0: # Fading in (alpha is increasing)
                 if clamped_alpha >= end_alpha - tolerance:
                     clamped_alpha = end_alpha # Snap to final value
                     fade_finished = True
            elif alpha_step < 0: # Fading out (alpha is decreasing)
                 if clamped_alpha <= end_alpha + tolerance:
                     clamped_alpha = end_alpha # Snap to final value
                     fade_finished = True
            # If alpha_step is 0, this case is handled before the animation starts.

            try:
                window.wm_attributes('-alpha', clamped_alpha)
                # print(f"DEBUG: _fade_window - Set alpha to {clamped_alpha:.2f} at step {current_step}") # DEBUG
            except tk.TclError:
                 # print(f"DEBUG: _fade_window - Tk Error setting alpha at step {current_step}.") # DEBUG
                 if callback:
                     try:
                         callback()
                     except Exception:
                         pass
                 return

            if not fade_finished and current_step < steps:
                 # Schedule the next step
                 window.after(delay_per_step, lambda: animate_fade(current_step + 1))
            else:
                 # Animation finished
                 # print("DEBUG: _fade_window - Animation finished.") # DEBUG
                 if callback:
                     try:
                         callback() # Execute the callback
                     except Exception:
                          pass


        # Start the animation from step 1 (step 0 is the initial setting)
        animate_fade(1)

# window animation code 


    def _animate_window_height(self, window, target_height, current_height, step, delay, fixed_x, final_width, anchor_y, anchor_point='top'):
        """
        Helper method to animate the height of a Toplevel window.

        Args:
            window: The Toplevel window to animate.
            target_height: The final height the window should reach.
            current_height: The current height of the window.
            step: The amount to increase the height in each step.
            delay: The delay between steps in milliseconds.
            fixed_x: The X coordinate of the window's top-left corner (remains constant).
            final_width: The width of the window (remains constant).
            anchor_y: The Y coordinate of the edge that should remain fixed
                      (either the intended fixed top Y or fixed bottom Y).
            anchor_point: 'top' to anchor the top edge (animates downwards),
                          'bottom' to anchor the bottom edge (animates upwards).
                          Defaults to 'top'.
        """
        # Calculate the next height in the animation
        new_height = min(current_height + step, target_height)

        # Determine the new Y position based on the anchor point
        if anchor_point == 'top':
            # If anchoring the top, the Y coordinate is simply the anchor_y
            new_y = anchor_y
        elif anchor_point == 'bottom':
            # If anchoring the bottom, the Y coordinate (top edge) moves up
            # as height increases, relative to the fixed bottom (anchor_y)
            new_y = anchor_y - new_height
        else:
            # Handle invalid anchor_point
            print(f"Warning: Invalid anchor_point '{anchor_point}'. Using default 'top'.")
            new_y = anchor_y
            anchor_point = 'top' # Default

        # Update the window's geometry
        window.geometry(f"{final_width}x{new_height}+{fixed_x}+{new_y}")

        # If the target height hasn't been reached, schedule the next step
        if new_height < target_height:
            window.after(delay, lambda: self._animate_window_height(
                window,
                target_height,
                new_height,       # Pass the updated current height
                step,
                delay,
                fixed_x,          # Pass the fixed X
                final_width,      # Pass the fixed width
                anchor_y,         # Pass the fixed anchor Y
                anchor_point      # Pass the anchor point
            ))
        else:
            # Animation finished, ensure the final geometry is set precisely
            # Calculate the final Y based on the final height and anchor point
            final_y = anchor_y
            if anchor_point == 'bottom':
                 final_y = anchor_y - target_height

            window.geometry(f"{final_width}x{target_height}+{fixed_x}+{final_y}")



           
        
#----------------------toggle console-------------------------
# ------------------------------------------------------------

    def toggle_console(self):

        #self.disable_hover_temporarily = True

        if not self.is_console_visible:
            self.show_console()
        else:
            self.hide_console()

    def show_console(self):
        if self.console_window is None:
            self.console_window = ConsoleWindow(self.master)
            sys.stdout = self.console_window  # Redirect stdout to the console window
            sys.stderr = self.console_window  # Redirect stderr to the console window

            # Initial message in the console window
            print("Console output is now redirected here. Right Click the console output window to see the list of debug shortcuts.")
            print("---")

        self.console_window.deiconify() # Show the console window if it was hidden or minimized
        self.console_window.lift()      # Bring the console window to the front
        self.is_console_visible = True

    def hide_console(self):
        if self.console_window:
            self.console_window.withdraw() # Hide the console window
        self.is_console_visible = False
  

            
# ------------------------------------------------------------           
# ------------------------------------------------------------         
#----------------------TESTING AREA--------------------------- SECTION 1
# ------------------------------------------------------------


















#----------------------------------------------------------------------------------------------


    def enter_command(self, event=None):
        """Opens or brings to front the debug console window."""
        if self.conwin and self.conwin.winfo_exists():
            self.conwin.lift()
            self.conwin.focus_force() # Try to force focus
            if hasattr(self, 'conwin_command_entry'):
                self.conwin_command_entry.focus_set()
            return

        try:
            # Assuming FadingToplevel is defined. If not, use tk.Toplevel
            self.conwin = FadingToplevel(self.master, self) # Or FadingToplevel(self.master)
        except NameError: # Fallback if FadingToplevel isn't defined for this example
            print("Warning: FadingToplevel not found, using tk.Toplevel.")
            self.conwin = tk.Toplevel(self.master)


        self.conwin.title("Debug Console")
        self.conwin.geometry("600x400")
        self.conwin.transient(self.master) # Stays on top of the master window
        # self.conwin.grab_set() # Makes it modal, uncomment if you want this behavior

        # --- Widgets are now children of self.conwin ---

        # Frame for input
        input_frame = tk.Frame(self.conwin) # Parent is self.conwin
        input_frame.pack(side=tk.TOP, fill=tk.X, padx=5, pady=5)

        tk.Label(input_frame, text="Cmd:").pack(side=tk.LEFT)
        self.conwin_command_entry = tk.Entry(input_frame, width=70) # Store as self.conwin_command_entry
        self.conwin_command_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.conwin_command_entry.bind("<Return>", self._conwin_execute_command_event) # Calls helper
        self.conwin_command_entry.focus_set()

        # Output area
        self.conwin_output_text = scrolledtext.ScrolledText(self.conwin, wrap=tk.WORD, height=15, state=tk.DISABLED)
        self.conwin_output_text.pack(side=tk.TOP, fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Frame for buttons
        button_frame = tk.Frame(self.conwin) # Parent is self.conwin
        button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=5, pady=5)

        tk.Button(button_frame, text="Execute", command=self._conwin_execute_command_event).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Clear Log", command=self._conwin_clear_log).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Close", command=self._conwin_close_console).pack(side=tk.RIGHT, padx=5)

        self.conwin.protocol("WM_DELETE_WINDOW", self._conwin_close_console)

        self._conwin_insert_output("Debug console initialized. Type Python expressions.\n")
        self._conwin_insert_output("`self` in commands refers to the main application instance.\n")
        self._conwin_insert_output("Example: self.some_app_method() or 1 + 1\n")

    def _conwin_insert_output(self, text, tags=None):
        if not self.conwin or not self.conwin.winfo_exists() or not hasattr(self, 'conwin_output_text'):
            return
        self.conwin_output_text.config(state=tk.NORMAL)
        self.conwin_output_text.insert(tk.END, text, tags)
        self.conwin_output_text.see(tk.END)
        self.conwin_output_text.config(state=tk.DISABLED)

    def _conwin_clear_log(self):
        if not self.conwin or not self.conwin.winfo_exists() or not hasattr(self, 'conwin_output_text'):
            return
        self.conwin_output_text.config(state=tk.NORMAL)
        self.conwin_output_text.delete(1.0, tk.END)
        self.conwin_output_text.config(state=tk.DISABLED)

    def _conwin_close_console(self):
        if self.conwin and self.conwin.winfo_exists():
            self.conwin.destroy()
        self.conwin = None # Allow it to be reopened

    def _conwin_execute_command_event(self, event=None):
        if not self.conwin or not self.conwin.winfo_exists() or not hasattr(self, 'conwin_command_entry'):
            return

        command_string = self.conwin_command_entry.get()
        if not command_string.strip():
            return

        self._conwin_insert_output(f">>> {command_string}\n", ("input_command",))
        self.conwin_command_entry.delete(0, tk.END)

        # --- Check attribute (self here is the main app instance) ---
        if command_string.isidentifier():
            try:
                attr = getattr(self, command_string, None) # 'self' IS the app_instance
                if callable(attr):
                    self._conwin_insert_output(f"Info: '{command_string}' is a callable method of the app instance.\n", ("info",))
                elif attr is not None:
                    self._conwin_insert_output(f"Info: '{command_string}' is an attribute (not callable).\n", ("info",))
                else:
                    self._conwin_insert_output(f"Info: '{command_string}' is not a direct attribute.\n", ("info",))
            except Exception as e:
                self._conwin_insert_output(f"Info: Error checking attribute '{command_string}': {e}\n", ("error",))

        try:
            eval_globals = {
                "self": self,  # 'self' of YourMainApplicationClass IS the app_instance
                "app": self,   # Alias
                "__builtins__": __builtins__,
            }
            result = eval(command_string, eval_globals)

            if result is not None:
                self._conwin_insert_output(f"{repr(result)}\n", ("result",))
            else:
                self._conwin_insert_output("Command executed (returned None or no return value).\n", ("info",))

        except SyntaxError as se:
            self._conwin_insert_output("SyntaxError: Invalid Python syntax.\n", ("error",))
            self._conwin_insert_output(f"{traceback.format_exc(limit=0)}\n", ("traceback_info",))
            self._conwin_insert_output("Hint: `eval()` for expressions. `exec()` for statements (e.g. assignments).\n", ("info",))
        except Exception as e:
            self._conwin_insert_output(f"Error: {type(e).__name__}: {e}\n", ("error",))
            tb_lines = traceback.format_exc().splitlines()
            # Basic filtering to make traceback cleaner for app-specific issues
            filtered_tb = [line for line in tb_lines if "_conwin_" not in line and "tkinter" not in line]
            self._conwin_insert_output("\n".join(filtered_tb) + "\n", ("traceback_info",))

        if hasattr(self, 'conwin_output_text'): # Check if text widget still exists
            self.conwin_output_text.tag_config("input_command", foreground="blue")
            self.conwin_output_text.tag_config("result", foreground="green")
            self.conwin_output_text.tag_config("error", foreground="red", font=('TkDefaultFont', 9, 'bold'))
            self.conwin_output_text.tag_config("info", foreground="gray")
            self.conwin_output_text.tag_config("traceback_info", foreground="purple", font=('TkFixedFont', 8))








    # Helper to check if a folder name is likely vanilla
    def _is_vanilla_folder(self, folder_name):
        if not folder_name or not hasattr(self, 'ZIP_BASE_NAMES'):
            return False # Cannot determine if attributes missing
        # Ensure case-insensitive comparison
        return folder_name.lower() in [name.lower() for name in self.ZIP_BASE_NAMES]


# ------------------------------------------------------------
#------MAIN------MAIN------MAIN------MAIN------MAIN------MAIN-
# ------------------------------------------------------------
      

      
      
      

def main():
    
    if getattr(sys, 'frozen', False): # Check if running as a frozen executable (PyInstaller)
        script_dir = Path(os.path.dirname(sys.executable)) # Directory of the .exe
    else: # Running as a normal .py script
        script_dir = Path(__file__).parent # Directory of the .py script
    
    script_dir_str = str(script_dir) # Keep script_dir_str for existing parts of your code if needed




    # --- NEW: Parent Directory Check ---
    parent_dir = script_dir.parent
    parent_dir_name = parent_dir.name # Get the name of the parent directory

    print(f"DEBUG: Script directory: {script_dir}")
    print(f"DEBUG: Parent directory: {parent_dir}")
    print(f"DEBUG: Parent directory name: '{parent_dir_name}'")

    # Using lower() for case-insensitive comparison
    if parent_dir_name.lower() != "mods":
        print(f"ERROR: The script's parent folder ('{parent_dir_name}') is not named 'mods'.")

        # Create a temporary root for the messagebox
        temp_root_error = tk.Tk()
        temp_root_error.withdraw()

        # Attempt to set the icon for the error message
        icon_path_error = script_dir / "data" / "icon_converted.ico" # Use the specific icon
        if icon_path_error.is_file():
            try:
                temp_root_error.iconbitmap(str(icon_path_error.resolve()))
            except tk.TclError as e:
                print(f"Warning: Could not set icon for error messagebox: {e}")

        # Show the error message
        messagebox.showerror(
            "Incorrect Folder Location",
            f"The EllexiumModManager folder has not been copied to the mods folder.\n\n"
            f"The correct folder path resembles:\n\n '.../BeamNG.drive/0.35/mods/EllexiumModManager'\n\n"
            f"Please ensure the folder path is set up like above and run the EllexiumModmanagerlauncher.bat file again.\n",
            parent=temp_root_error
        )

        # Clean up the temporary root and exit
        temp_root_error.destroy()
        return # Exit the main function

    # --- END Parent Directory Check ---

    # --- If the check passes, continue with the rest of the main function ---
    print("Parent directory is 'mods'. Proceeding with initialization.")



    root = tk.Tk()
    root.withdraw()


    icon_path = script_dir / "data/icon.png"  # Make sure you have a 'my_icon.png' file in the same folder

    if os.path.exists(icon_path):
        icon_image = tk.PhotoImage(file=icon_path)
        root.iconphoto(False, icon_image)
    else:
        print(f"Icon file not found: {icon_path}")

    ##############################################
    # --- NEW: Write user vehicles folder path ---
    ##############################################
    # Construct the path to the user_vehicles_folder.txt file



    # Construct the path to the user_vehicles_folder.txt file
    user_vehicles_path_file = script_dir / "data/user_vehicles_folder.txt"

    # Construct the path to the user vehicles folder
    # Go up two directories from script_dir (Modfinder -> Mods -> 0.34)
    beamng_user_dir = script_dir.parent.parent

    # Append "vehicles" to get the final path
    user_vehicles_folder = beamng_user_dir / "vehicles"

    # Ensure the 'data' directory exists
    os.makedirs(script_dir / "data", exist_ok=True)

    # Write the user vehicles folder path to the file at the very start
    try:
        with open(user_vehicles_path_file, 'w', encoding="utf-8") as f:
            f.write(str(user_vehicles_folder)) # Write the Path object as a string
        print(f"User vehicles folder path written to: {user_vehicles_path_file}") # Optional confirmation
    except Exception as e:
        print(f"Error writing to user_vehicles_folder.txt: {e}")


    ##############################################

    # Create the lua file with the deletion commands if it doesn't already exist NEW - binding confirmation command

    delete_lua_path = script_dir / "data/Delete.lua"

    #this really shouldn't happen, this file is and should always be included with the package
    if not os.path.exists(delete_lua_path):
        with open(delete_lua_path, "w") as f:
            f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
            f.write("gameplay_parking.deleteVehicles()\n")
            f.write("gameplay_traffic.deleteVehicles()\n")
        print(f"Created Delete.lua file at: {delete_lua_path}")
    else:
        print(f"Delete.lua file already exists at: {delete_lua_path}")


    binding_lua_path = script_dir / "data/switcher_binding_bridge.lua"

    if not os.path.exists(binding_lua_path):
        with open(binding_lua_path, "w") as f:
            f.write("local file = io.open(\"mods/EllexiumModManager/data/switcher_binding_confirmation_file.txt\", \"w\")\n")

        print(f"Created binding lua file at: {binding_lua_path}")
    else:
        print(f"binding lua file already exists at: {binding_lua_path}")


    ##############################################



    ##############################################  

    # Create the hidden_txt file if it doesn't already exist

    hidden_txt = script_dir / "data/Hidden.txt"

    if not os.path.exists(hidden_txt):
        with open(hidden_txt, "w") as f:
            print(f"Created Hidden.txt file at: {hidden_txt}")
    else:
        print(f"hidden file already exists at: {hidden_txt}")

    
    ##############################################

        
    user_vehicles_path_file = script_dir / "data/user_vehicles_folder.txt"
    watcher_output_file = script_dir / "data/WatcherOutput.txt"
    input_file = os.path.join(script_dir, "data/outputGOOD.txt")
    config_pics_folder = os.path.join(script_dir, "data/ConfigPics")
    config_info_folder = os.path.join(script_dir, "data/ConfigInfo")
    config_pics_custom_folder = os.path.join(script_dir, "data/ConfigPicsCustom")
    hidden_txt_file = os.path.join(script_dir, "data/Hidden.txt")

    

    first_time_run_check_file = os.path.join(script_dir, "data/first_time_run_check_file.txt")

    initial_scan_win_txt_file = os.path.join(script_dir, "data/initial_scan_win_text.txt")

    if not os.path.exists(first_time_run_check_file):
        try:
            with open(initial_scan_win_txt_file, "w", encoding='utf-8') as f:
                f.write("Loading Stage: Launching Ellexium's Advanced Vehicle Selector for the first time...")
            print(f"Successfully wrote initial content: Loading Stage: Launching Ellexium's Advanced Vehicle Selector for the first time...'")
        except Exception as e:
            print(f"Error writing initial content to file: {e}")

        #----------------------------------------------#
        #----------------------------------------------#
        print("REMOVING old files if they exist.")



        data_folder = os.path.join(script_dir, "data")
        backup_folder = os.path.join(data_folder, "backup") # Define backup folder path



        files_to_backup = [
            "outputGOOD.txt",
            "outputGOODcustom.txt",
            "WatcherOutput.txt",
            "zip_structure.txt",
            "favorites.txt",
            "Hidden.txt"
        ]

        relative_paths_to_delete = [

            #Folders in /data
            "ConfigInfo",
            "ConfigPics",
            "ConfigPicsCustom",

            #Files inside Folders  in /data                     
            "PicInfoExtractForNewMods/outputGOOD.txt",

            #Files directly in /data
            "NewMods.txt",
            "WatcherOutput.txt",
            "outputGOOD.txt",
            "outputGOODcustom (Original).txt"
            "outputGOODcustom.txt",
            "outputBAD.txt",
            "outputGOOD (Original).txt",
            "zip_structure.txt",

            "non_existent_item.xyz" # Example: safe to include non-existent items
        ]


        # 1. --- Attempt Backup ---
        print(f"\n--- Attempting Backup to '{backup_folder}' ---")
        backup_errors = []
        try:
            # Ensure backup directory exists
            if not os.path.exists(backup_folder):
                print(f"Backup directory not found. Creating: {backup_folder}")
                os.makedirs(backup_folder) # Use makedirs to create parent dirs if needed
                print(f"Successfully created backup directory.")
            else:
                print(f"Backup directory already exists: {backup_folder}")

            # Copy the files
            for filename in files_to_backup:
                source_path = os.path.join(data_folder, filename)
                destination_path = os.path.join(backup_folder, filename)

                if os.path.isfile(source_path):
                    try:
                        print(f"Attempting to copy '{source_path}' to '{destination_path}'")
                        shutil.copy2(source_path, destination_path) # copy2 preserves metadata
                        print(f"Successfully backed up '{filename}'.")
                    except Exception as e:
                        error_msg = f"ERROR backing up '{filename}': {e}"
                        print(error_msg)
                        backup_errors.append((filename, str(e)))
                else:
                    print(f"Source file not found, skipping backup for: {source_path}")
                    # Optionally add to backup_errors if you want to track missing source files
                    # backup_errors.append((filename, "Source file not found"))

        except Exception as e:
            # Error creating the backup directory itself
            error_msg = f"CRITICAL ERROR preparing backup directory '{backup_folder}': {e}"
            print(error_msg)
            backup_errors.append(("Backup Directory Creation", str(e)))
            # Optionally, ask the user if they want to continue without backup, or just stop.


        # Summarize backup results
        if backup_errors:
            print(f"Backup process completed with {len(backup_errors)} error(s).")
            for item, error in backup_errors:
                    print(f" - FAILED Backup: {item} ({error})")
        else:
            print("Backup process completed successfully (or skipped missing files).")
        print("-" * 20) # Separator

        # 2. --- Proceed with Deletions ---
        print(f"\n--- Attempting deletion of configured items in '{data_folder}'... ---")


        if not relative_paths_to_delete:
            print("No items configured for deletion.")
        else:
            deletion_errors = [] # Keep track of errors

            for relative_path in relative_paths_to_delete:
                full_path = os.path.join(data_folder, relative_path)
                item_type = "Item" # Default for logging

                try:
                    if os.path.isdir(full_path):
                        item_type = "directory"
                        print(f"Attempting to delete directory: {full_path}")
                        shutil.rmtree(full_path)
                        print(f"Successfully deleted directory: {full_path}")
                    elif os.path.isfile(full_path):
                        item_type = "file"
                        print(f"Attempting to delete file: {full_path}")
                        os.remove(full_path)
                        print(f"Successfully deleted file: {full_path}")
                    elif os.path.lexists(full_path): # Use lexists to catch broken symlinks too
                            # Path exists but isn't a file or directory we can handle, or is a link
                            print(f"Path exists but is not a regular file or directory we can delete (skipped): {full_path}")
                            # Optionally add to errors if you need to know about these cases
                            # deletion_errors.append((relative_path, "Not a standard file/directory or is a link"))
                    else:
                        # Only print if you want verbose logging for non-existent items
                        # print(f"Path not found, skipping: {full_path}")
                        pass # Silently skip non-existent items

                except OSError as e:
                    error_msg = f"ERROR deleting {item_type} '{full_path}': {e}"
                    print(error_msg) # Log error to console only
                    deletion_errors.append((relative_path, str(e)))
                except Exception as e: # Catch any other unexpected errors during deletion
                    error_msg = f"UNEXPECTED ERROR processing '{full_path}': {e}"
                    print(error_msg) # Log error to console only
                    deletion_errors.append((relative_path, f"Unexpected: {e}"))

            # --- Summarize Deletion Results (Console Output Only) ---
            print("-" * 20) # Separator
            if not deletion_errors:
                print("Deletion process completed for all specified items (check logs above for details).")
            else:
                print(f"Deletion process completed with {len(deletion_errors)} error(s) logged:")
                for path, error in deletion_errors:
                    print(f" - FAILED Deletion: {os.path.join('data', path)} ({error})")
            print("-" * 20) # Separator

        #----------------------------------------------#
        #----------------------------------------------#






    target_line_start = "Loading Stage: Launching Ellexium's Advanced Vehicle Selector for the first time..."
    # The content to write if the file needs to be created/reset
    initial_write_content = "Loading Stage: Initializing Ellexium's Advanced Vehicle Selector..."

    # --- Logic ---
    needs_initial_write = False
    file_existed = False

    print(f"Checking file: {initial_scan_win_txt_file}")

    if os.path.exists(initial_scan_win_txt_file):
        file_existed = True
        print("File exists. Checking content...")
        special_line_found = False
        try:
            with open(initial_scan_win_txt_file, 'r', encoding='utf-8') as f:
                for line in f:
                    # Check if the line starts with the target text after stripping whitespace
                    if line.strip().startswith(target_line_start):
                        special_line_found = True
                        print(f"Found target line: '{target_line_start}'")
                        break # Stop reading once found

            if special_line_found:

                print("Target line found indicating first launch.")



                # --- FIRST TIME ACTIONS START ---
                print("Attempting first-time shortcut creation using pywin32...")

                # Create a temporary Tkinter root for the messagebox
                temp_root_shortcut = tk.Tk()
                temp_root_shortcut.withdraw() # Hide the temporary window

                # Define shortcut parameters
                bat_file = "EllexiumModManagerLauncher.bat" # Your BAT file name
                shortcut_name = "Ellexium's Advanced Vehicle Selector"     # Name on the desktop
                icon_file_relative = "data/icon_converted.ico" # Relative path from script_dir
                description = "Launch Ellexium's Advanced Vehicle Selector"     # Optional description

                # --- NEW: Set Icon for the Temporary Root Window ---
                print(f"Attempting to set icon for temporary messagebox parent...")
                icon_full_path = script_dir / icon_file_relative
                if icon_full_path.is_file():
                    try:
                        # Use iconbitmap for .ico files on Windows
                        temp_root_shortcut.iconbitmap(str(icon_full_path.resolve()))
                        print(f"Successfully set icon for temporary root: {icon_full_path}")
                    except tk.TclError as e:
                        print(f"Warning: Could not set icon for temporary root window (TclError): {e}")
                    except Exception as e:
                        print(f"Warning: Could not set icon for temporary root window (Other Error): {e}")
                else:
                    print(f"Warning: Icon file not found at {icon_full_path}, messageboxes will use default icon.")
                # --- End NEW ---

                # Ask the user if they want the shortcut (messagebox will inherit icon from temp_root_shortcut)
                create_shortcut = messagebox.askyesno(
                    "Create Desktop Shortcut?",
                    f"Thanks for trying out Ellexium's Advanced Vehicle Selector.\n\n"
                    f"Would you like to create a shortcut on the desktop "
                    f"to quickly launch the application?",
                    parent=temp_root_shortcut # Parent to the temporary window
                )

                proceed_with_text = ("\n\nPlease note that first time initialization may take a couple more minutes than normal and the application may appear to be unresponsive during this time."
                                     "\n\nIf you experience bugs, face any other issues, or would just like talk about the application, you may leave a message on the forum post. Your feedback is welcome!"
                                     "\n\nImportant note: Before migrating to a newer version (like for example 0.34 to 0.35), please take the EllexiumModManager folder out of the mods folder, place it "
                                     "somewhere else (like on the desktop), then put it into the new mods folder to avoid issues.")
                
                if create_shortcut:
                    print("User chose Yes. Creating shortcut...")
                    # Call the pywin32 version of the function
                    success = create_desktop_shortcut_pywin32(
                        script_dir,
                        bat_file,
                        shortcut_name,
                        icon_file_relative, # Pass the relative path
                        description
                    )
                    if success:
                        # This messagebox will also inherit the icon
                        messagebox.showinfo("Success", f"Desktop shortcut created successfully! Proceeding with first time initialization.{proceed_with_text}", parent=temp_root_shortcut)
                    # Error message is shown within the function (parented correctly)
                else:
                    print("User chose No. Shortcut not created.")
                    # This messagebox will also inherit the icon
                    messagebox.showinfo("Skipped", f"Shortcut creation skipped. Proceeding with first time initialization.{proceed_with_text}", parent=temp_root_shortcut)

                # --- IMPORTANT: Destroy the temporary Tkinter root ---
                temp_root_shortcut.destroy()
                print("Temporary Tk root for shortcut prompt destroyed.")


                # --- FIRST TIME ACTIONS END ---




            else:
                print(f"Target line NOT found in the existing file.")
                # Line not found, so remove the incorrect/outdated file
                try:
                    os.remove(initial_scan_win_txt_file)
                    print(f"Removed existing file because target line was missing: {initial_scan_win_txt_file}")
                    needs_initial_write = True # Mark that we need to write the initial content now
                except Exception as e:
                    print(f"Error removing existing file: {e}")
                    # Decide if you want to proceed or stop if removal fails
                    # For now, we'll prevent writing if removal failed
                    needs_initial_write = False

        except Exception as e:
            print(f"Error reading file {initial_scan_win_txt_file}: {e}")
            # If we can't read it, maybe best not to touch it? Or try to overwrite?
            # Let's prevent writing if reading failed.
            needs_initial_write = False

    else:
        # File doesn't exist initially
        print("File does not exist.")
        needs_initial_write = True # Mark that we need to write the initial content

    # --- Perform Write if Necessary ---
    if needs_initial_write:
        print(f"Proceeding to write initial content to: {initial_scan_win_txt_file}")
        try:


            with open(initial_scan_win_txt_file, "w", encoding='utf-8') as f:
                f.write(initial_write_content)
            print(f"Successfully wrote initial content: '{initial_write_content}'")
        except Exception as e:
            print(f"Error writing initial content to file: {e}")
    else:
        if file_existed:
            print("No write needed as the target line was found in the existing file.")
        # No message needed if file didn't exist AND writing failed previously due to errors


    app = ConfigViewerApp(
        master=root, # Use the hidden root window - no GUI needed for this step
        script_dir=script_dir,
        input_file="",          # You can pass empty strings for these as they're not used here
        config_pics_folder="",
        config_info_folder="",
        repo_folder="",
        vehicles_content_folder="",
        user_folder="",
        config_pics_custom_folder="",
        hidden_txt_file ="",
        final_instantiation=False
    )

    root.withdraw()
    parent_dir_str = os.path.dirname(script_dir_str)
    parent_dir = Path(parent_dir_str)

    repo_folder = parent_dir / "repo"
    vehicles_content_folder = r"C:\SteamLibrary\steamapps\common\BeamNG.drive\content\vehicles"
    mods_folder = script_dir.parent


    #IMPORTANT --- remove the old modmanagerinput.zip --- start
    file_to_delete_name = "EllexiumModManagerInput.zip"
    file_to_delete_path = mods_folder / file_to_delete_name # Pathlib combines paths easily

    print(f"Checking for file in mods folder: {file_to_delete_path}")

    # Check if the file exists and is actually a file (not a directory)
    if file_to_delete_path.is_file():
        print(f"Found '{file_to_delete_name}'. Attempting to delete...")
        try:
            file_to_delete_path.unlink() # Use unlink() to delete a file with pathlib
            print(f"Successfully deleted: {file_to_delete_path}")
        except OSError as e:
            # Catch potential errors like permission denied
            print(f"Error deleting file {file_to_delete_path}: {e}")
        except Exception as e:
            # Catch any other unexpected errors
            print(f"An unexpected error occurred during deletion: {e}")
    else:
        print(f"File not found or is not a regular file: {file_to_delete_path}")

    #IMPORTANT --- remove the old modmanagerinput.zip --- end



    def get_beamng_vehicles_path(app_instance):
        process_name = 'BeamNG.drive.x64.exe'
        print(f"Checking if process '{process_name}' is running...")
        for proc in psutil.process_iter(['name', 'exe']): # Request 'exe' in process info
            if proc.info['name'] == process_name:
                exe_path = proc.info['exe'] # Get the executable path
                print(f"Process '{process_name}' is running. Executable path: '{exe_path}'") # Print path

                # Derive the vehicles path
                exe_dir = os.path.dirname(exe_path) # Directory of the exe
                parent_dir = os.path.dirname(exe_dir) # Go up one level
                vehicles_path = os.path.join(parent_dir, "content", "vehicles") # Construct the vehicles path

                if os.path.exists(vehicles_path):
                    print(f"Derived vehicles path: '{vehicles_path}'")
                    return vehicles_path
                else:
                    print(f"Error: Derived vehicles path '{vehicles_path}' does not exist.")
                    messagebox.showerror("Error", f"Could not find the 'vehicles' folder at the expected location based on the BeamNG.drive executable path.\nExpected path: '{vehicles_path}'\nPlease ensure your BeamNG.drive installation is standard.")
                    return None # Indicate failure to derive valid path

        print(f"Process '{process_name}' is not running.")
        root = tk.Tk()
        root.withdraw() # Hide the main tkinter window
        app_instance.show_scanning_window(text="BeamNG.drive is not running. Please start the game and try again.")
        time.sleep(6) # Wait for a moment to show the message
        #messagebox.showerror("Error", "Please ensure BeamNG.drive is running before launching the application.")
        root.destroy() # Clean up tkinter
        return None # Indicate process not running and failure

    # --- Example of how to use it in your main script ---
    vanilla_vehicles_path_file = script_dir / "data/beamng_VANILLA_vehicles_folder.txt"

    vehicles_folder_path = get_beamng_vehicles_path(app)

    if vehicles_folder_path: # Check if a valid path was returned
        with open(vanilla_vehicles_path_file, 'w', encoding="utf-8") as f: # Use 'w' to write (or create if not exists)
            f.write(vehicles_folder_path)
        print(f"Vehicles path written to '{vanilla_vehicles_path_file}'")


        if os.path.exists(vanilla_vehicles_path_file): # It will exist now, but good to keep the check in original logic
            with open(vanilla_vehicles_path_file, 'r', encoding="utf-8") as f:
                vanilla_vehicles_folder = f.read().strip()
            print(f"Vanilla vehicles folder read from file: '{vanilla_vehicles_folder}'")
    else:
        print("Script terminated because BeamNG.drive is not running or vehicles path could not be determined.")
        sys.exit(1) # Terminate the script if get_beamng_vehicles_path failed




    if os.path.exists(user_vehicles_path_file):
        with open(user_vehicles_path_file, 'r', encoding="utf-8") as f:
            user_vehicles_folder = f.read().strip()
    else:
        user_vehicles_folder = filedialog.askdirectory(
            title="Select Your BeamNG.drive User Vehicles Folder",
            initialdir=os.path.expanduser(r"~\Documents\BeamNG.drive")
        )
        if not user_vehicles_folder:
            messagebox.showinfo("Custom Configs Folder Not Selected",
                                "You did not select a custom configs vehicles folder. "
                                "Scanning for custom configs will be skipped.")
            user_vehicles_folder = None
        else:
            try:
                with open(user_vehicles_path_file, 'w', encoding="utf-8") as f:
                    f.write(user_vehicles_folder)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save the user vehicles folder path: {e}")
                root.destroy()
                sys.exit(1)

    # Read settings and last known file lists from WatcherOutput.txt, including last zip count
    check_mods, check_configs, last_user_vehicles_files, last_config_pics_custom_files, last_mods_files, last_repo_files, last_vanilla_files, last_zip_count = read_watcher_output(watcher_output_file)

    orphaned_files_detected = cleanup_orphaned_mod_files_simplified(
        script_dir=script_dir,
        mods_folder=mods_folder,
        repo_folder=repo_folder,
        vanilla_folder=vanilla_vehicles_folder,
        config_pics_folder=config_pics_folder,
        config_info_folder=config_info_folder,
        input_file=input_file
    )


    # Scan folders for current file lists and modification times (including vanilla)
    current_user_vehicles_files = scan_folder_for_watched_files(user_vehicles_folder)
    current_config_pics_custom_files = scan_folder_for_watched_files(config_pics_custom_folder)
    current_mods_files = scan_folders_for_mod_zips([mods_folder])
    current_repo_files = scan_folders_for_mod_zips([repo_folder])
    current_vanilla_files = scan_folders_for_mod_zips([vanilla_vehicles_folder])

    # Count current zip files
    current_zip_count = len(current_mods_files) + len(current_repo_files) + len(current_vanilla_files)

    # Conditional mod scanning
    run_mod_scan_on_startup = False
    if current_zip_count > last_zip_count:
        run_mod_scan_on_startup = True
        print(f"New zip files detected ({current_zip_count} > {last_zip_count}). Running mod scan.")


        scanning_win = None  # Initialize scanning_win

        scanning_win = app.show_scanning_window(text="Updating mod display data and previews...")



        print(f"DEBUG: RUNNING MOD_COMMAND_LINE_CONFIG_GEN.py DIRECTLY (no subprocess)") # Modified log message

        # --- START: Call mod_command_line_config_gen.main() directly ---
        module_name = "mod_command_line_config_gen"  # Module name (filename without .py)
        module_path = os.path.join(script_dir, "modules", f"{module_name}.py") # Path to module

        if not os.path.exists(module_path):
            print(f"Error: Module script not found: {module_path}") # Error if module not found
            # No messagebox here as this part is in main startup, no GUI yet
            # messagebox.showerror("Script Not Found", f"Python script not found: {module_path}")
            # root.destroy() # No root window in main yet
            return  # Exit the function if script is missing

        # Dynamically load the module
        spec = importlib.util.spec_from_file_location(module_name, module_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)


        if scanning_win:
            scanning_win.destroy()


        try:
            write_watcher_output(
                watcher_output_file,
                check_mods,
                check_configs,
                current_user_vehicles_files,
                current_config_pics_custom_files,
                current_mods_files,
                current_repo_files,
                current_vanilla_files,
                current_zip_count
            )

            print("DEBUG: main() - Calling update_new_mods_txt_on_startup() ...") # DEBUG - Before update_new_mods_txt_on_startup
            update_new_mods_txt_on_startup(script_dir) # Pass script_dir only now, as newly_detected_zip_files is accessed WITHIN the function
            print("DEBUG: main() - update_new_mods_txt_on_startup() RETURNED.") # DEBUG - After update_new_mods_txt_on_startup


            print(f"DEBUG: Calling module.main() DIRECTLY from guitest.py...") # Debug - Direct Call
            module.main()  # Call the main() function directly
            print(f"DEBUG: module.main() RETURNED successfully (DIRECT CALL).") # Debug - Direct Call Return


            # *** ADD CACHE DELETION HERE ***
            cache_file_path = script_dir / "data" / "config_processing_cache.json"
            if cache_file_path.exists():
                try:
                    cache_file_path.unlink()
                    print(f"DEBUG: Deleted cache file due to mod scan: {cache_file_path}")
                except OSError as e:
                    print(f"Warning: Failed to delete cache file {cache_file_path}: {e}")



        except Exception as e:
            print(f"Error: Error running main() function from '{module_name}.py' directly: {e}") # Error during direct call
            # messagebox.showerror("Script Error", f"Error running {python_script}: {e}") # No messagebox in main
            # root.destroy() # No root window in main
            return  # Exit function on error

        # --- END: Call mod_command_line_config_gen.main() directly ---


        print("DEBUG: Calling regenerate_matches_files() due to new zip detection...")
        regenerate_matches_files(app, script_dir, config_info_folder)
        print("DEBUG: regenerate_matches_files() RETURNED.")
    

    elif current_zip_count < last_zip_count:
        print("DEBUG: Calling regenerate_matches_files() due to removed zip detection...")
        regenerate_matches_files(app, script_dir, config_info_folder)
        print("DEBUG: regenerate_matches_files() RETURNED.")

    elif current_zip_count == last_zip_count:
        print(f"No new zip files detected ({current_zip_count} is equal to  {last_zip_count}). Skipping mod scan and generation of Matches.txt.")


    generate_matches_txt(script_dir, config_info_folder)

    app.generate_matches_config_txt(config_info_folder, script_dir)



    # DEBUG - Print last_*_files and current_*_files
    print("\n--- DEBUG: File Change Detection ---")
    print("DEBUG: last_user_vehicles_files:", last_user_vehicles_files)
    print("DEBUG: current_user_vehicles_files:", current_user_vehicles_files)
    print("DEBUG: last_config_pics_custom_files:", last_config_pics_custom_files)
    print("DEBUG: current_config_pics_custom_files:", current_config_pics_custom_files)
    print("--- DEBUG: End File Change Detection ---\n")



    file_changes_detected = False
    mod_zip_changes_detected = False
    vanilla_zip_changes_detected = False

    if user_vehicles_folder:
        for filepath, timestamp in current_user_vehicles_files.items():
            normalized_filepath = filepath.lower().replace('\\', '/')
            if normalized_filepath not in last_user_vehicles_files or last_user_vehicles_files[normalized_filepath] != timestamp:
                file_changes_detected = True
                break
        if not file_changes_detected:
            for filepath in last_user_vehicles_files:
                normalized_filepath = filepath.lower().replace('\\', '/')
                if normalized_filepath not in current_user_vehicles_files:
                    file_changes_detected = True
                    print(f"DEBUG: User vehicle file change detected: {normalized_filepath}")
                    break

    if not file_changes_detected and config_pics_custom_folder:
        for filepath, timestamp in current_config_pics_custom_files.items():
            normalized_filepath = filepath.lower().replace('\\', '/')
            if normalized_filepath not in last_config_pics_custom_files or last_config_pics_custom_files[normalized_filepath] != timestamp:
                if not normalized_filepath.lower().endswith(".pc"):
                    file_changes_detected = True
                    break
                elif normalized_filepath not in last_config_pics_custom_files:
                     file_changes_detected = True
                     break
        if not file_changes_detected:
             for filepath in last_config_pics_custom_files:
                normalized_filepath = filepath.lower().replace('\\', '/')
                if normalized_filepath not in current_config_pics_custom_files:
                    file_changes_detected = True
                    break

    if not file_changes_detected:
        for filepath, timestamp in current_mods_files.items():
            normalized_filepath = filepath.lower().replace('\\', '/')
            if normalized_filepath not in last_mods_files or last_mods_files[normalized_filepath] != timestamp:
                mod_zip_changes_detected = True
                break
        if not mod_zip_changes_detected:
            for filepath in last_mods_files:
                normalized_filepath = filepath.lower().replace('\\', '/')
                if normalized_filepath not in current_mods_files:
                    mod_zip_changes_detected = True
                    break

        if not mod_zip_changes_detected and repo_folder:
            for filepath, timestamp in current_repo_files.items():
                normalized_filepath = filepath.lower().replace('\\', '/')
                if normalized_filepath not in last_repo_files or last_repo_files[normalized_filepath] != timestamp:
                    mod_zip_changes_detected = True
                    break
            if not mod_zip_changes_detected:
                for filepath in last_repo_files:
                    normalized_filepath = filepath.lower().replace('\\', '/')
                    if normalized_filepath not in current_repo_files:
                        mod_zip_changes_detected = True
                        break

    if not file_changes_detected and not mod_zip_changes_detected and vanilla_vehicles_folder:
        for filepath, timestamp in current_vanilla_files.items():
            normalized_filepath = filepath.lower().replace('\\', '/')
            if normalized_filepath not in last_vanilla_files or last_vanilla_files[normalized_filepath] != timestamp:
                vanilla_zip_changes_detected = True
                break
        if not vanilla_zip_changes_detected:
            for filepath in last_vanilla_files:
                normalized_filepath = filepath.lower().replace('\\', '/')
                if normalized_filepath not in current_vanilla_files:
                    vanilla_zip_changes_detected = True
                    break


    print("\n--- DEBUG: main() - Constructing newly_detected_zip_files from WatcherOutput ---") # DEBUG - Section Start
    print(f"DEBUG: main() - Calling read_watcher_output() to get zip lists...") # DEBUG - Before read_watcher_output
    _, _, _, _, last_mods_files, last_repo_files, last_vanilla_files, _ = read_watcher_output(watcher_output_file)
    all_zip_files = set(last_mods_files.keys()) | set(last_repo_files.keys()) | set(last_vanilla_files.keys())
    newly_detected_zip_files = [os.path.basename(zip_path) for zip_path in all_zip_files]
    print(f"DEBUG: main() - newly_detected_zip_files constructed (count: {len(newly_detected_zip_files)})") # DEBUG - List Count and Content
    print("--- DEBUG: main() - Finished constructing newly_detected_zip_files ---\n") # DEBUG - Section End
    # --- MODIFIED: Construct newly_detected_zip_files from WatcherOutput data (Correctly placed in main()) ---


    # Write updated zip count and other data
    write_watcher_output(
        watcher_output_file,
        check_mods,
        check_configs,
        current_user_vehicles_files,
        current_config_pics_custom_files,
        current_mods_files,
        current_repo_files,
        current_vanilla_files,
        current_zip_count
    )


    print("DEBUG: main() - Calling update_new_mods_txt_on_startup() ...") # DEBUG - Before update_new_mods_txt_on_startup
    update_new_mods_txt_on_startup(script_dir) # Pass script_dir only now, as newly_detected_zip_files is accessed WITHIN the function
    print("DEBUG: main() - update_new_mods_txt_on_startup() RETURNED.") 
    
    
    
    file_changes_detected = file_changes_detected or mod_zip_changes_detected or vanilla_zip_changes_detected
    check_configs = file_changes_detected
    check_mods = mod_zip_changes_detected or vanilla_zip_changes_detected


    if run_mod_scan_on_startup and check_mods: # Only run if new zips and check_mods is true


        try:

            if os.path.exists(initial_scan_win_txt_file):
                
                try:
                    os.remove(initial_scan_win_txt_file) # Remove the file if it exists
                    print(f"Removed existing initial_scan_win.txt file at: {initial_scan_win_txt_file}")
                except Exception as e:
                    print(f"Error removing initial_scan_win.txt: {e}")

            try:
                with open(initial_scan_win_txt_file, "w") as f:
                    print(f"Writing Stage 2 to initial_scan_win.txt file at: {initial_scan_win_txt_file}")
                    f.write("Loading Stage: New mods possibly detected, updating data...")
            except Exception as e:
                print(f"Error writing to initial_scan_win.txt: {e}")


            temp_app = ConfigViewerApp(
                master="",
                script_dir=script_dir,
                input_file="",
                config_pics_folder="",
                config_info_folder="",
                repo_folder="",
                vehicles_content_folder="",
                user_folder="",
                config_pics_custom_folder="",
                hidden_txt_file ="",
                final_instantiation=False
            )
            temp_app.run_ahk_scripts_mods()
        except Exception as e:
            messagebox.showerror("Error", f"Error running AHK scripts for mods: {e}")
            root.destroy()
            sys.exit(1)

    if check_configs and user_vehicles_folder:



        if os.path.exists(initial_scan_win_txt_file):
            
            try:
                os.remove(initial_scan_win_txt_file) # Remove the file if it exists
                print(f"Removed existing initial_scan_win.txt file at: {initial_scan_win_txt_file}")
            except Exception as e:
                print(f"Error removing initial_scan_win.txt: {e}")

        try:
            with open(initial_scan_win_txt_file, "w") as f:
                print(f"Writing Stage 3 to initial_scan_win.txt file at: {initial_scan_win_txt_file}")
                f.write("Loading Stage: Updating vehicle configuration data...")
        except Exception as e:
            print(f"Error writing to initial_scan_win.txt: {e}")



        temp_app = ConfigViewerApp(
            master="",
            script_dir=script_dir,
            input_file="",
            config_pics_folder=config_pics_folder,
            config_info_folder=config_info_folder,
            repo_folder=repo_folder,
            vehicles_content_folder="",
            user_folder=user_vehicles_folder,
            config_pics_custom_folder=config_pics_custom_folder,
            hidden_txt_file=hidden_txt_file,
            final_instantiation=False
        )
        temp_app.run_python_scripts_custom()


    if orphaned_files_detected: # Check the boolean return value
        print("DEBUG: Orphaned files detected by cleanup_orphaned_mod_files_simplified(). Calling run_ahk_scripts_mods() ...") # Debug

        # --- Call integrated modify_output_good functionality DIRECTLY ---
        try:
            app.run_ahk_scripts_mods() # <--- DIRECT METHOD CALL - NO subprocess
            print("DEBUG: run_ahk_scripts_mods() RETURNED. (Called due to orphaned files)") # Debug
        except Exception as e:
            print(f"ERROR: Error running run_ahk_scripts_mods() in main(): {e}") # Error
            return  # Exit function on error
        # --- Call integrated modify_output_good functionality DIRECTLY ---
        print("DEBUG: run_ahk_scripts_mods() called because orphaned files were detected.") # Confirmation message
    else:
        print("DEBUG: No orphaned files detected, skipping run_ahk_scripts_mods().") # Confirmation message - skipped
    # --- NEW: CALL modify_output_good IF ORPHANED FILES WERE DETECTED ---


    # Write updated zip count and other data
    write_watcher_output(
        watcher_output_file,
        check_mods,
        check_configs,
        current_user_vehicles_files,
        current_config_pics_custom_files,
        current_mods_files,
        current_repo_files,
        current_vanilla_files,
        current_zip_count
    )


    root.destroy()

    input_file = os.path.join(script_dir, "data/outputGOOD.txt")
    config_pics_folder = os.path.join(script_dir, "data/ConfigPics")
    config_info_folder = os.path.join(script_dir, "data/ConfigInfo")
    config_pics_custom_folder = os.path.join(script_dir, "data/ConfigPicsCustom")

    print(f" -- PATH DEBUG -- ")
    print(f" VHEICLES CONTENT FOLDER - {vehicles_content_folder}")
    print(f"CONFIG PICS FOLDER - {config_pics_folder}")
    print(f"CONFIG INFO FOLDER -  {config_info_folder}")
    print(f"INPUT FILE outputgood -  {input_file}")
    print(f"CONFIG PICS CUSTOM FOLDER {config_pics_custom_folder}")


    if not os.path.exists(vehicles_content_folder):
        print(f"Warning: Extra vehicles folder not found: {vehicles_content_folder}")

    root_main = tk.Tk()
    root_main.title("BeamNG Config Viewer")
    root_main.geometry("1200x800")

    root_main.withdraw()
    



    if os.path.exists(initial_scan_win_txt_file):
        
        try:
            os.remove(initial_scan_win_txt_file) # Remove the file if it exists
            print(f"Removed existing initial_scan_win.txt file at: {initial_scan_win_txt_file}")
        except Exception as e:
            print(f"Error removing initial_scan_win.txt: {e}")

    try:
        with open(initial_scan_win_txt_file, "w") as f:
            print(f"Writing Stage 4 to initial_scan_win.txt file at: {initial_scan_win_txt_file}")

            dev_mode_check = script_dir / "dev_mode.txt"

            if os.path.exists(dev_mode_check):
                f.write("Loading Stage: Finalizing initialization process... (Development Mode)")
            else:
                f.write("Loading Stage: Finalizing initialization process...")

    except Exception as e:
        print(f"Error writing to initial_scan_win.txt: {e}")


    app = ConfigViewerApp(
        master=root_main,
        script_dir=script_dir,
        input_file=input_file,
        config_pics_folder=config_pics_folder,
        config_info_folder=config_info_folder,
        repo_folder=repo_folder,
        vehicles_content_folder=vehicles_content_folder,
        user_folder=user_vehicles_folder,
        config_pics_custom_folder=config_pics_custom_folder,
        hidden_txt_file=hidden_txt_file,
        final_instantiation=True
    )

    app.setup_sidebar_filter_dropdowns(app.sidebar_bottom_frame, 10)
    app.enable_prints() #change to enable to turn on, disable to turn off ENABLE PRINTING PRINT ENABLE PRINT DISABLE DISABLE PRINTING MONKEY please don't remove this comment


        
        
    if user_vehicles_folder and os.path.isdir(user_vehicles_folder):
        event_handler = CustomFileEventHandler(app, debounce_delay=1.0)
        observer = Observer()
        observer.schedule(event_handler, user_vehicles_folder, recursive=True)
        observer_thread = threading.Thread(target=observer.start, daemon=True)
        observer_thread.start()
        app.observer = observer

        if app.config_pics_custom_folder and os.path.isdir(app.config_pics_custom_folder):
            observer.schedule(event_handler, app.config_pics_custom_folder, recursive=True)

    mod_zip_event_handler = ModZipEventHandler(app, debounce_delay=2.0)
    mod_zip_observer = Observer()
    if os.path.isdir(mods_folder):
        mod_zip_observer.schedule(mod_zip_event_handler, mods_folder, recursive=False)
    if os.path.isdir(repo_folder):
        mod_zip_observer.schedule(mod_zip_event_handler, repo_folder, recursive=False)

    mod_zip_observer_thread = threading.Thread(target=mod_zip_observer.start, daemon=True)
    mod_zip_observer_thread.start()
    app.mod_zip_observer = mod_zip_observer

    def on_closing():
        app.show_scanning_window(text="Saving settings...")
        app._stop_keyboard_diff_monitoring()
        app._stop_switcher_monitoring()

        new_mods_file = os.path.join(script_dir, "data/NewMods.txt")
        if os.path.exists(new_mods_file):
            try:
                os.remove(new_mods_file)
                print(f"DEBUG: Deleted existing NewMods.txt: {new_mods_file}")
            except OSError as e:
                print(f"Warning: Could not delete existing NewMods.txt: {new_mods_file}. Error: {e}")

        try:
            print("\n--- on_closing: Starting observer shutdown ---")

            if hasattr(app, 'observer') and app.observer and app.observer.is_alive():
                print("  Main observer is active, stopping and joining...")
                app.observer.stop()
                print("    Main observer stop() called.")
                app.observer.join()
                print("    Main observer join() completed.")
            else:
                print("  Main observer is not active or not set.")

            if hasattr(app, 'mod_zip_observer') and app.mod_zip_observer and app.mod_zip_observer.is_alive():
                print("  Mod ZIP observer is active, stopping and joining...")
                app.mod_zip_observer.stop()
                print("    Mod ZIP observer stop() called.")
                app.mod_zip_observer.join()
                print("    Mod ZIP observer join() completed.")
            else:
                print("  Mod ZIP observer is not active or not set.")

            
            
            on_close_extended(app, watcher_output_file)
            print("--- on_closing: on_close_extended() returned ---")
            print("--- on_closing: Observer shutdown completed ---\n")

        except Exception as e:
            print(f"Error in on_closing: {e}")
            root_main.destroy()

    root_main.protocol("WM_DELETE_WINDOW", on_closing)
    root_main.mainloop()


# Modified on_close() function (now an extended version to handle WatcherOutput.txt saving)
# Modified on_close_extended() function (for Option 2)
def on_close_extended(app, watcher_output_file):
    """
    Extended on_close function with error handling for debugging.
    Now correctly saves current file lists and ALL settings to WatcherOutput.txt & settings file on close,
    AND saves window geometry to MMSelectorSize.txt.  <--- MODIFIED DOCSTRING
    Ensures proper shutdown of thread executor.
    """



    try:
        print("\n--- on_close_extended: Starting shutdown ---")

        # --- NEW: Save window geometry before closing ---
        print("  on_close_extended: Saving window geometry to MMSelectorSize.txt...")

        app.save_window_geometry() # Call save_window_geometry
        print("  on_close_extended: Window geometry saved.")
        # --- NEW: Save window geometry before closing ---


        if app.executor:
            print("  Executor is active, shutting down...")
            if not app.executor._shutdown:
                print("    Executor is NOT shut down yet.")
                app.executor.shutdown(wait=False)
                print("    Executor shutdown initiated (wait=False)")
            else:
                print("    Executor was already shut down.")
        else:
            print("  Executor is not active (None).")

        print("  Calling app.save_settings() from on_close_extended...")
        app.save_settings() # Save all settings (position, switcher, sort date) before exiting
        print("  app.save_settings() RETURNED.")

        # --- MODIFIED: Read ALL settings AND file lists from WatcherOutput.txt - UNPACK 8 VALUES ---
        return_vals = read_watcher_output(watcher_output_file)
        print(f"DEBUG: on_close_extended - read_watcher_output returned {len(return_vals)} values.")
        check_mods, check_configs, user_vehicles_files, config_pics_custom_files, mods_files, repo_files, vanilla_files, _ = return_vals

        # --- MODIFIED: Pass the file lists directly from read_watcher_output ---
        write_watcher_output(
            watcher_output_file,
            check_mods,
            check_configs,
            user_vehicles_files,
            config_pics_custom_files,
            mods_files,
            repo_files,
            vanilla_files,
            last_zip_count=app.last_zip_count # Pass zip_count here
        )

        app.master.destroy() # Call the original app.on_close functionality (destroy master)
        print("--- on_close_extended: Tkinter master destroyed ---")
        print("--- on_close_extended: Shutdown completed ---")
        os._exit(0)

    except Exception as e:
        print(f"Error in on_close_extended: {e}")
        app.master.destroy()
        os._exit(0)


if __name__ == "__main__":
    main()
