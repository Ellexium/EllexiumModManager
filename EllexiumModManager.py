# -----------------------------------------------------------------------------------
# Version: 0.1.7.3 (Public Experimental Snapshot - 13th Release | March 18, 2025)
# -----------------------------------------------------------------------------------

import builtins

import os
import re
import tkinter as tk
from tkinter import ttk
from tkinter import font
from tkinter import messagebox, filedialog
from PIL import Image, ImageTk
import concurrent.futures
import threading
import math
import subprocess
import sys
import glob
import time
import shutil
import psutil
import itertools
import json
from pathlib import Path
from datetime import datetime
import importlib.util
import functools
import zipfile
import gc
#from memory_profiler import profile  

from collections import OrderedDict


import pydirectinput
import win32gui
import ctypes
import pywintypes

from watchdog.observers import Observer

from modules.config_processors import (
    run_configpicextractor_custom_integrated,
    run_mod_command_line_config_gen_custom_integrated,
    run_modify_output_good_integrated,
    process_lines
)

from modules.event_handlers import (
    ModZipEventHandler,
    CustomFileEventHandler
)

from modules.ui_helpers import (
    on_floating_window_unmapped,
    destroy_floating_button_window,
    hide_floating_window,
    show_floating_window,
    focus_config_viewer_from_floating_button,
    remember_floating_window_position,
    load_floating_window_position,
    save_floating_window_position,
    create_floating_button_window,
    on_floating_window_mapped,
    toggle_floating_window_visibility
)

from modules.resize_and_scroll import (
    throttled_resize,
    on_resize_complete,
    on_mousewheel_main,
    on_mousewheel_details,
    ease_out_quintic_modified_speed,
    start_scroll_debounce_timer_main_grid,
    on_scroll_debounce_complete_main_grid,
    is_descendant_of,
    start_smooth_scroll_main,
    start_smooth_scroll_details,
    animate_scroll_main,
    animate_scroll_details,
    calculate_columns_for_width,
    animate_scroll_search_results
)


from modules.colorchange import (
    create_color_picker_window,
)
# ------------------------------------------------------------
# List of zip base names for fallback info extraction
# ------------------------------------------------------------





# NEW Helper function to scan for mod zip files
def scan_folders_for_mod_zips(folders_list):
    """
    Scans a list of folders for .zip files and returns a dictionary of {filepath: modification_timestamp}.
    """
    all_zip_files = {}
    extensions = ['.zip']
    for folder_path in folders_list: # Iterate through list of folders
        if not folder_path or not os.path.isdir(folder_path):
            continue # Skip invalid folders, but continue checking others
        for root, _, files in os.walk(folder_path):
            for file in files:
                if any(file.lower().endswith(ext) for ext in extensions):
                    filepath = os.path.join(root, file)
                    normalized_filepath = os.path.normpath(filepath).lower().replace('\\', '/') # Normalize path
                    try:
                        all_zip_files[normalized_filepath] = os.path.getmtime(filepath)
                        #print(f"DEBUG: scan_folders_for_mod_zips - Found ZIP: {filepath}, Timestamp: {all_zip_files[normalized_filepath]}") # DEBUG
                    except OSError: # Handle cases where file might be inaccessible
                        print(f"Warning: Could not get modification time for {filepath}. Skipping.")
    return all_zip_files



def scan_folder_for_watched_files(folder_path):
    """
    Recursively scans a folder, normalizes file paths to lowercase and forward slashes,
    and returns a dictionary of {normalized_filepath: modification_timestamp}.
    """
    file_list = {}
    if not folder_path or not os.path.isdir(folder_path):
        return file_list # Return empty dict for invalid folder

    extensions = ['.pc', '.png', '.jpg', '.jpeg']
    for root, _, files in os.walk(folder_path):
        for file in files:
            if any(file.lower().endswith(ext) for ext in extensions):
                filepath = os.path.join(root, file)
                normalized_filepath = os.path.normpath(filepath).lower().replace('\\', '/') # Normalize path
                try:
                    file_list[normalized_filepath] = os.path.getmtime(filepath)
                except OSError: # Handle cases where file might be inaccessible
                    print(f"Warning: Could not get modification time for {filepath}. Skipping.")
    return file_list


def regenerate_matches_files(app_instance, script_dir, config_info_folder):
    """
    Deletes matches.txt and matches_config.txt and regenerates them.

    Args:
        app_instance: An instance of the ConfigViewerApp class.  <--- NEW ARGUMENT
        script_dir: Path to the script's directory where matches.txt and matches_config.txt are located.
        config_info_folder: Path to the ConfigInfo folder containing JSON files, needed for regeneration.
    """
    matches_file_path = os.path.join(script_dir, "data/Matches.txt")
    matches_config_file_path = os.path.join(script_dir, "data/matches_config.txt")

    # Delete matches.txt if it exists
    if os.path.exists(matches_file_path):
        try:
            os.remove(matches_file_path)
            print(f"Deleted: {matches_file_path}")
        except Exception as e:
            print(f"Error deleting {matches_file_path}: {e}")
    else:
        print(f"{matches_file_path} does not exist, skipping deletion.")

    # Delete matches_config.txt if it exists
    if os.path.exists(matches_config_file_path):
        try:
            os.remove(matches_config_file_path)
            print(f"Deleted: {matches_config_file_path}")
        except Exception as e:
            print(f"Error deleting {matches_config_file_path}: {e}")
    else:
        print(f"{matches_config_file_path} does not exist, skipping deletion.")



# 1.  read_watcher_output function definition -  <-- PLACE THIS FIRST
# Modified read_watcher_output function (for Option 2)
# Modified read_watcher_output function (FULLY MANUAL parsing - NO configparser)
# Modified read_watcher_output function (for MOD ZIP FILES)
# ------------------------------------------------------------
# Modified read_watcher_output function (to include VanillaFiles)
# ------------------------------------------------------------
def read_watcher_output(file_path):
    """
    Reads WatcherOutput.txt, now also getting lists of mod zip files, vanilla zip files,
    and the last zip count.
    """
    check_mods, check_configs = False, False
    user_vehicles_files, config_pics_custom_files = {}, {}
    mods_files, repo_files, vanilla_files = {}, {}, {}
    last_zip_count = 0 # Initialize last zip count

    try:
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding="utf-8") as f:
                lines = f.readlines()

            settings_section_started, user_vehicles_section_started = False, False
            config_pics_custom_section_started, mods_files_section_started = False, False
            repo_files_section_started, vanilla_files_section_started = False, False
            zip_count_section_started = False # NEW: zip count section

            for line in lines:
                line = line.strip()

                if line.startswith("CheckMods:"):
                    check_mods = (line.split(":", 1)[1].strip().lower() == "true")
                elif line.startswith("CheckConfigs:"):
                    check_configs = (line.split(":", 1)[1].strip().lower() == "true")
                elif line == "[Settings]":
                    settings_section_started = True; user_vehicles_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False
                elif line == "[UserVehiclesFiles]":
                    user_vehicles_section_started = True; settings_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False
                elif line == "[ConfigPicsCustomFiles]":
                    config_pics_custom_section_started = True; settings_section_started = False; user_vehicles_section_started = False; mods_files_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False
                elif line == "[ModsFiles]":
                    mods_files_section_started = True; settings_section_started = False; user_vehicles_section_started = False; config_pics_custom_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False
                elif line == "[RepoFiles]":
                    repo_files_section_started = True; settings_section_started = False; user_vehicles_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False
                elif line == "[VanillaFiles]":
                    vanilla_files_section_started = True; settings_section_started = False; user_vehicles_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; repo_files_section_started = False; zip_count_section_started = False
                elif line == "[ZipCount]": # NEW: ZipCount Section Header
                    zip_count_section_started = True; settings_section_started = False; user_vehicles_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False
                elif line.startswith("["):
                    settings_section_started = False; user_vehicles_section_started = False; config_pics_custom_section_started = False; mods_files_section_started = False; repo_files_section_started = False; vanilla_files_section_started = False; zip_count_section_started = False


                if user_vehicles_section_started:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        filepath, timestamp_str = parts[0].strip(), parts[1].strip()
                        try: user_vehicles_files[filepath] = float(timestamp_str)
                        except ValueError: print(f"Warning: Invalid timestamp format in UserVehiclesFiles line: {line}")
                elif config_pics_custom_section_started:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        filepath, timestamp_str = parts[0].strip(), parts[1].strip()
                        try: config_pics_custom_files[filepath] = float(timestamp_str)
                        except ValueError: print(f"Warning: Invalid timestamp format in ConfigPicsCustomFiles line: {line}")
                elif mods_files_section_started:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        filepath, timestamp_str = parts[0].strip(), parts[1].strip()
                        try: mods_files[filepath] = float(timestamp_str)
                        except ValueError: print(f"Warning: Invalid timestamp format in ModsFiles line: {line}")
                elif repo_files_section_started:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        filepath, timestamp_str = parts[0].strip(), parts[1].strip()
                        try: repo_files[filepath] = float(timestamp_str)
                        except ValueError: print(f"Warning: Invalid timestamp format in RepoFiles line: {line}")
                elif vanilla_files_section_started:
                    parts = line.split("=", 1)
                    if len(parts) == 2:
                        filepath, timestamp_str = parts[0].strip(), parts[1].strip()
                        try: vanilla_files[filepath] = float(timestamp_str)
                        except ValueError: print(f"Warning: Invalid timestamp format in VanillaFiles line: {line}")
                elif zip_count_section_started: # NEW: ZipCount Section Parsing
                    try:
                        last_zip_count = int(line)
                    except ValueError:
                        print(f"Warning: Invalid zip count format in ZipCount line: {line}")

    except Exception as e:
        print(f"Error reading {file_path}: {e}. Using default settings and empty file lists.")

    return check_mods, check_configs, user_vehicles_files, config_pics_custom_files, mods_files, repo_files, vanilla_files, last_zip_count # Return last_zip_count


def write_watcher_output(file_path, check_mods, check_configs, user_vehicles_files, config_pics_custom_files, mods_files, repo_files, vanilla_files, zip_count):
    """
    Writes settings and file lists to WatcherOutput.txt, including vanilla zip file lists and zip count.
    """
    try:
        with open(file_path, "w", encoding="utf-8") as f:
            f.write("[Settings]\n")
            f.write(f"CheckMods = {str(check_mods).lower()}\n")
            f.write(f"CheckConfigs = {str(check_configs).lower()}\n")

            f.write("\n[UserVehiclesFiles]\n")
            sorted_user_vehicles_files = sorted(user_vehicles_files.items())
            for filepath, timestamp in sorted_user_vehicles_files:
                f.write(f"{filepath} = {timestamp}\n")

            f.write("\n[ConfigPicsCustomFiles]\n")
            sorted_config_pics_custom_files = sorted(config_pics_custom_files.items())
            for filepath, timestamp in sorted_config_pics_custom_files:
                f.write(f"{filepath} = {timestamp}\n")

            f.write("\n[ModsFiles]\n")
            sorted_mods_files = sorted(mods_files.items())
            for filepath, timestamp in sorted_mods_files:
                f.write(f"{filepath} = {timestamp}\n")

            f.write("\n[RepoFiles]\n")
            sorted_repo_files = sorted(repo_files.items())
            for filepath, timestamp in sorted_repo_files:
                f.write(f"{filepath} = {timestamp}\n")

            f.write("\n[VanillaFiles]\n")
            sorted_vanilla_files = sorted(vanilla_files.items())
            for filepath, timestamp in sorted_vanilla_files:
                f.write(f"{filepath} = {timestamp}\n")

            f.write("\n[ZipCount]\n") # NEW: ZipCount section
            f.write(str(zip_count) + "\n") # Write zip count


        print(f"Successfully wrote settings and file lists to {file_path} (including vanilla zip files and zip count)")
    except Exception as e:
        print(f"Error writing to {file_path}: {e}")




def cleanup_orphaned_mod_files_simplified(script_dir, mods_folder, repo_folder, vanilla_folder, config_pics_folder, config_info_folder, input_file):
    """
    Simplified function to identify and log orphaned AND non-orphaned files,
    including folder and file lists in the deletion log.

    Args:
        script_dir: Path to the script's directory.
        mods_folder: Path to the mods folder.
        repo_folder: Path to the repo folder.
        vanilla_folder: Path to the vanilla vehicles folder.
        config_pics_folder: Path to the ConfigPics folder.
        config_info_folder: Path to the ConfigInfo folder.
        input_file: Path to the outputGOOD.txt file.
    """

    print("\n--- STARTING SIMPLIFIED STARTUP CLEANUP FOR ORPHANED MOD FILES (VERBOSE LOG) ---")

    # 1. Get list of existing zip files from Mods, Repo, and Vanilla folders
    existing_zip_files = set()
    folders_to_check = {"Mods Folder": mods_folder, "Repo Folder": repo_folder, "Vanilla Folder": vanilla_folder} # For clearer logging

    log_file_path = os.path.join(script_dir, "data/orphaned_files_deletion_log.txt")
    with open(log_file_path, "w", encoding="utf-8") as log_file:
        log_file.write("--- START OF ORPHANED FILE CLEANUP LOG ---\n\n")

        log_file.write("--- Folders Being Checked for ZIP Files ---\n") # Folder List Header
        for folder_name, folder_path in folders_to_check.items(): # Log Folders and Paths
#            log_file.write(f"{folder_name}: {folder_path}\n")
            pass
            
        log_file.write("\n--- Existing ZIP Files in Folders ---\n") # Existing ZIPs Header
        for folder_name, folder_path in folders_to_check.items():
            folder_zip_files = []
            if folder_path and os.path.isdir(folder_path):
                for item in os.listdir(folder_path):
                    if item.lower().endswith(".zip") and os.path.isfile(os.path.join(folder_path, item)):
                        existing_zip_files.add(item) # Populate existing_zip_files set
                        folder_zip_files.append(item) # For folder-specific logging
#            log_file.write(f"{folder_name}: {folder_zip_files}\n") # Log files in each folder
#        log_file.write(f"\nCombined list of existing zip files (for internal use): {existing_zip_files}\n\n") # Log combined set for debug
        #print(f"DEBUG: Existing zip files found: {existing_zip_files}") # Console debug print


        orphaned_files_log = []
        kept_files_log = []

        if os.path.exists(input_file):
#            log_file.write("\n--- Processing outputGOOD.txt lines ---\n")
            with open(input_file, 'r', encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if "(package)" in line and "(config picture)" in line:
                        parts = line.split(" - ")
                        if len(parts) == 3:
                            zip_package_part = parts[0]
                            # --- DEFINITIVE CORRECTION: Re-assign the result of replace() to internal_folder_name ---
                            internal_folder_name = parts[1].strip().replace('"', '').replace(' (internal folder name)', '') # CORRECTED PARSING
                            config_picture_path_relative = parts[2].split("(config picture)")[0].strip().replace('"', '')

                            zip_file_name_from_output = zip_package_part.split(" (package)")[0].strip()
                            config_picture_filename = os.path.basename(config_picture_path_relative)
                            config_picture_filename_base = os.path.splitext(config_picture_filename)[0]

                            # Construct expected filenames (unchanged)
                            expected_config_pic_filename = f"vehicles--{internal_folder_name}_{zip_file_name_from_output.replace('.zip', '')}.zip--{config_picture_filename}"
                            expected_individual_info_filename = f"vehicles--INDIVIDUAL--{internal_folder_name}_{zip_file_name_from_output.replace('.zip', '')}.zip--info_info_{config_picture_filename_base}.json"
                            expected_generic_info_filename = f"vehicles--{internal_folder_name}_{zip_file_name_from_output.replace('.zip', '')}.zip--info.json"


#                            log_file.write(f"\n  Processing line from outputGOOD.txt: '{line}'\n")
#                            log_file.write(f"    - Zip from line: '{zip_file_name_from_output}'\n")

                            # 3. Check for ZIP file existence
                            if zip_file_name_from_output not in existing_zip_files:
                                # ZIP file is missing, these files are orphaned
                                reason_prefix = f"Orphaned - ZIP file '{zip_file_name_from_output}' NOT found in watched folders"
#                                log_file.write(f"    - ZIP '{zip_file_name_from_output}' NOT FOUND. Checking for orphaned files.\n")

                                # Check ConfigPics file
                                config_pic_filepath = os.path.join(config_pics_folder, expected_config_pic_filename)
                                print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking ConfigPic path: {config_pic_filepath}") # <-- DEBUG PRINT
                                if os.path.exists(config_pic_filepath):
                                    orphaned_files_log.append((config_pic_filepath, f"{reason_prefix} - ConfigPic, associated with ZIP: '{zip_file_name_from_output}'"))
                                    # **CORRECTED Log Message - Use variable: expected_config_pic_filename**
#                                    log_file.write(f"      - [ORPHANED] ConfigPic: {expected_config_pic_filename}\n")
                                else:
                                    # **CORRECTED Log Message - Use variable: expected_config_pic_filename**
#                                    log_file.write(f"      - [NOT FOUND] ConfigPic: {expected_config_pic_filename} (already missing)\n")
                                    pass
                                    
                                # Check ConfigInfo files
                                individual_info_filepath = os.path.join(config_info_folder, expected_individual_info_filename)
                                print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking Individual Info path: {individual_info_filepath}") # <-- DEBUG PRINT
                                if os.path.exists(individual_info_filepath):
                                    orphaned_files_log.append((individual_info_filepath, f"{reason_prefix} - Individual Info, associated with ZIP: '{zip_file_name_from_output}'"))

                                    # --- ADDED DEBUGGING PRINTS ---
                                    #print(f"DEBUG - Individual Info - config_picture_filename_base: {config_picture_filename_base}, type: {type(config_picture_filename_base)}") # Check value and type
                                    #print(f"DEBUG - Individual Info - expected_individual_info_filename: {expected_individual_info_filename}") # Check full constructed filename
                                    # --- END DEBUGGING PRINTS ---

                                    # Log Message (Corrected - using variables)
#                                    log_file.write(f"      - [ORPHANED] Individual Info: {expected_individual_info_filename}\n") # <-- LINE A
                                else:
                                    # --- ADDED DEBUGGING PRINTS ---
                                    #print(f"DEBUG - Individual Info (NOT FOUND) - config_picture_filename_base: {config_picture_filename_base}, type: {type(config_picture_filename_base)}") # Check value and type
                                    #print(f"DEBUG - Individual Info (NOT FOUND) - expected_individual_info_filename: {expected_individual_info_filename}") # Check full constructed filename
                                    # --- END DEBUGGING PRINTS ---

                                    # Log Message (Corrected - using variables)
                                    log_file.write(f"      - [NOT FOUND] Individual Info: {expected_individual_info_filename} (already missing)\n") # <-- LINE B

                                generic_info_filepath = os.path.join(config_info_folder, expected_generic_info_filename)
                                print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking Generic Info path: {generic_info_filepath}") # <-- DEBUG PRINT
                                if os.path.exists(generic_info_filepath):
                                    orphaned_files_log.append((generic_info_filepath, f"{reason_prefix} - Generic Info, associated with ZIP: '{zip_file_name_from_output}'"))
                                    # CORRECTED Log Message - Use variable: expected_generic_info_filename
#                                    log_file.write(f"      - [ORPHANED] Generic Info: {expected_generic_info_filename}\n")
                                    pass
                                    
                                else:
                                    # CORRECTED Log Message - Use variable: expected_generic_info_filename
#                                    log_file.write(f"      - [NOT FOUND] Generic Info: {expected_generic_info_filename} (already missing)\n")
                                    pass
                            else:
                                # ZIP file exists, these files are NOT orphaned, but log kept files
                                reason_prefix = f"Kept - ZIP file '{zip_file_name_from_output}' FOUND in watched folders"
#                                log_file.write(f"    - ZIP '{zip_file_name_from_output}' FOUND. Keeping associated files.\n")
                                pass
                                
                                # Check ConfigPics file
                                config_pic_filepath = os.path.join(config_pics_folder, expected_config_pic_filename)
                                #print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking ConfigPic path (kept file): {config_pic_filepath}") # <-- DEBUG PRINT - KEPT FILE CHECK
                                if os.path.exists(config_pic_filepath):
                                    kept_files_log.append((config_pic_filepath, f"{reason_prefix} - ConfigPic, associated with ZIP: '{zip_file_name_from_output}'"))
                                    # CORRECTED Log Message - Use variable: expected_config_pic_filename
#                                    log_file.write(f"      - [KEPT] ConfigPic: {expected_config_pic_filename}\n")
                                    pass    
                                else:
                                    # CORRECTED Log Message - Use variable: expected_config_pic_filename
#                                    log_file.write(f"      - [NOT FOUND] ConfigPic: {expected_config_pic_filename} (unexpectedly missing, but ZIP exists)\n")
                                    pass
                                    
                                # Check ConfigInfo files
                                individual_info_filepath = os.path.join(config_info_folder, expected_individual_info_filename)
                                #print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking Individual Info path (kept file): {individual_info_filepath}") # <-- DEBUG PRINT - KEPT FILE CHECK
                                if os.path.exists(individual_info_filepath):
                                    kept_files_log.append((individual_info_filepath, f"{reason_prefix} - Individual Info, associated with ZIP: '{zip_file_name_from_output}'"))
                                    # CORRECTED Log Message - Use variable: expected_individual_info_filename
#                                    log_file.write(f"      - [KEPT] Individual Info: {expected_individual_info_filename}\n")
                                    pass    
                                
                                else:
                                    # CORRECTED Log Message - Use variable: expected_individual_info_filename
#                                    log_file.write(f"      - [NOT FOUND] Individual Info: {expected_individual_info_filename} (unexpectedly missing, but ZIP exists)\n")
                                    pass
                                    
                                generic_info_filepath = os.path.join(config_info_folder, expected_generic_info_filename)
                                #print(f"DEBUG: cleanup_orphaned_mod_files_simplified - Checking Generic Info path (kept file): {generic_info_filepath}") # <-- DEBUG PRINT - KEPT FILE CHECK
                                if os.path.exists(generic_info_filepath):
                                    kept_files_log.append((generic_info_filepath, f"{reason_prefix} - Generic Info, associated with ZIP: '{zip_file_name_from_output}'"))
                                    # Corrected Log Message - Use variable: expected_generic_info_filename
#                                    log_file.write(f"      - [KEPT] Generic Info: {expected_generic_info_filename}\n")
                                    pass
                                
                                else:
                                    # Corrected Log Message - Use variable: expected_generic_info_filename
#                                    log_file.write(f"      - [NOT FOUND] Generic Info: {expected_generic_info_filename} (unexpectedly missing, but ZIP exists)\n")
                                    pass
        
        else:
            log_file.write(f"Warning: {input_file} not found, skipping outputGOOD.txt processing.\n")


        # 4. Write deletion candidates AND kept files to log file
        if orphaned_files_log:
            log_file.write("\n--- Orphaned Files to be DELETED (Dry Run) ---\n")
            for filepath, reason in orphaned_files_log:
                log_file.write(f"File: {filepath}\nReason: {reason}\n\n")
                # 5. Comment out deletion (Dry Run - Logging only)
                try:
                    deleted_count = 0  # <--- Initialize deleted_count INSIDE try block, BEFORE os.remove
                    os.remove(filepath)
                    deleted_count += 1  # Increment AFTER successful deletion (though initialization already makes this redundant)
                    log_file.write(f"  [DELETED] {filepath}\n")
                except Exception as e:
                    log_file.write(f"  [ERROR deleting] {filepath} - {e}\n") # <-- ERROR LOG LINE - NO deleted_count HERE

        if kept_files_log:
#            log_file.write("\n--- Non-Orphaned Files (Kept) ---\n")
            pass
            
            for filepath, reason in kept_files_log:
#                log_file.write(f"File: {filepath}\nReason: {reason}\n\n")
                pass
                
                
        if not orphaned_files_log and not kept_files_log:
#            log_file.write("\nNo orphaned files found.\n")
            pass
        
        log_file.write("\n--- END OF ORPHANED FILE CLEANUP LOG ---\n") # Log file end marker

    print(f"DEBUG: Detailed log of orphaned and kept files (dry run) written to: {log_file_path}")

    if orphaned_files_log:
        print(f"Startup cleanup (simplified - dry run) completed. {len(orphaned_files_log)} orphaned files identified (deletion commented out).")
        print("--- SIMPLIFIED STARTUP CLEANUP FOR ORPHANED MOD FILES COMPLETED - deleting garbage (VERBOSE LOG) ---\n")
        return True
    else:
        print("Startup cleanup (simplified - dry run): No orphaned mod files found.")
        print("--- SIMPLIFIED STARTUP CLEANUP FOR ORPHANED MOD FILES COMPLETED - deleting garbage (VERBOSE LOG) ---\n") 
        return False 
            

def update_new_mods_txt_on_startup(script_dir):
    """
    Updates NewMods.txt with a list of ALL ZIP files from WatcherOutput.txt on startup.
    DEBUG PRINTS ADDED for troubleshooting.
    """
    new_mods_file = os.path.join(script_dir, "data/NewMods.txt")
    watcher_output_file = os.path.join(script_dir, "data/WatcherOutput.txt")

    print("\n--- DEBUG: update_new_mods_txt_on_startup() ENTRY ---") # DEBUG ENTRY

    try:
        # --- Always Delete existing NewMods.txt ---
        if os.path.exists(new_mods_file):
            print(f"DEBUG: NewMods.txt exists: {new_mods_file}") # DEBUG - File exists check
            try:
                os.remove(new_mods_file)
                print(f"DEBUG: Deleted existing NewMods.txt: {new_mods_file}") # Debug - Deletion success
            except OSError as e:
                print(f"Warning: Could not delete existing NewMods.txt: {new_mods_file}. Error: {e}") # Debug - Deletion warning
        else:
            print(f"DEBUG: NewMods.txt does not exist, will create: {new_mods_file}") # Debug - File does not exist

        # --- ALWAYS Populate from WatcherOutput.txt, includes vanilla zips ---
        print(f"DEBUG: Reading zip lists from WatcherOutput.txt: {watcher_output_file}") # DEBUG - Reading from WatcherOutput
        _, _, _, _, last_mods_files, last_repo_files, last_vanilla_files, _ = read_watcher_output(watcher_output_file)
        all_zip_files = set(last_mods_files.keys()) | set(last_repo_files.keys()) | set(last_vanilla_files.keys())  # Include vanilla
        newly_detected_zip_files = [os.path.basename(zip_path) for zip_path in all_zip_files]

        print(f"DEBUG: all_zip_files (count: {len(all_zip_files)})") # DEBUG - all_zip_files content
        print(f"DEBUG: newly_detected_zip_files (count: {len(newly_detected_zip_files)})") # DEBUG - newly_detected_zip_files content


        if newly_detected_zip_files: # Now uses the zip file list from WatcherOutput
            print(f"DEBUG: newly_detected_zip_files is NOT empty, proceeding to write NewMods.txt") # DEBUG - Not empty check
            print(f"DEBUG: Attempting to open NewMods.txt for writing: {new_mods_file}") # DEBUG - Before write open
            with open(new_mods_file, "w", encoding="utf-8") as f:
                print(f"DEBUG: NewMods.txt opened successfully for writing.") # DEBUG - After write open
                print(f"DEBUG: Writing {len(newly_detected_zip_files)} file names to NewMods.txt...") # DEBUG - Before write loop
                for file_name in newly_detected_zip_files:
                    f.write(f"{file_name}\n")
                    #print(f"  DEBUG: Wrote filename: {file_name}") # DEBUG - Write loop (can be verbose)
                print(f"DEBUG: Finished writing filenames to NewMods.txt.") # DEBUG - After write loop
            print(f"DEBUG: Created/Updated NewMods.txt with {len(newly_detected_zip_files)} mod(s) from WatcherOutput: {new_mods_file}")


        else:
            print("DEBUG: newly_detected_zip_files is empty (but using WatcherOutput data). No files to write to NewMods.txt.") # DEBUG - Empty list


    except Exception as e:
        print(f"ERROR: Error updating NewMods.txt: {e}") # ERROR - Exception
        print(f"  ERROR DETAILS: {e}") # ERROR - Exception details

    print("--- DEBUG: update_new_mods_txt_on_startup() EXIT ---\n") # DEBUG EXIT
        

def generate_data_subset_favorites(script_dir):
    """
    Generates data_subset_favorites.txt based on favorites.txt and data_subset.txt.
    """
    favorites_file_path = os.path.join(script_dir, "data/favorites.txt")
    data_subset_file_path = os.path.join(script_dir, "data/data_subset.txt")
    data_subset_favorites_file_path = os.path.join(script_dir, "data/data_subset_favorites.txt")

    if not os.path.exists(favorites_file_path):
        print(f"Warning: {favorites_file_path} not found. data_subset_favorites.txt will not be generated.")
        return

    if not os.path.exists(data_subset_file_path):
        print(f"Warning: {data_subset_file_path} not found. data_subset_favorites.txt will not be generated.")
        return

    favorite_configs = set()
    with open(favorites_file_path, 'r', encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if line:
                parts = line.split('|')
                if len(parts) == 2:
                    folder, config_pc = parts
                    config = config_pc.replace('.pc', '')
                    favorite_configs.add((folder.strip(), config.strip()))

    filtered_lines = []
    with open(data_subset_file_path, 'r', encoding="utf-8") as f_in, open(data_subset_favorites_file_path, 'w', encoding="utf-8") as f_out:
        for line in f_in:
            line = line.strip()
            if not line:
                continue

            parts = line.split('--')
            if len(parts) >= 3:  # Basic check to ensure line structure is somewhat valid
                folder_part = parts[1]
                config_name_part = parts[-1]  # Assuming config name is at the end
                config_name_base = os.path.splitext(config_name_part)[0] # Remove extension

                for fav_folder, fav_config in favorite_configs:
                    if fav_folder in folder_part and fav_config in config_name_base:
                        filtered_lines.append(line)
                        f_out.write(line + '\n') # Write to the output file immediately if match is found
                        break # Optimization: no need to check other favorites once a match is found for this line

    print(f"data_subset_favorites.txt generated with {len(filtered_lines)} lines.")
    
    
    
    
##############################################################
##############################################################
##############################################################



def generate_matches_txt(script_dir, config_info_folder):
    """
    Generates "Matches.txt" file with a list of JSON files and their content
    on startup if the file does not exist.

    Args:
        script_dir: Path to the script's directory.
        config_info_folder: Path to the ConfigInfo folder containing JSON files.
    """
    matches_file_path = os.path.join(script_dir, "data/Matches.txt")

    if not os.path.exists(matches_file_path):
        print("Matches.txt does not exist, creating it...")
        try:
            with open(matches_file_path, "w", encoding="utf-8") as matches_file:
                json_files = glob.glob(os.path.join(config_info_folder, "*.json"))
                for json_file in json_files:
                    filename = os.path.basename(json_file)
                    matches_file.write(f"{filename}\n")
                    try:
                        with open(json_file, "r", encoding="utf-8") as current_json_file:
                            content = current_json_file.read()
                            matches_file.write(content + "\n\n")
                    except Exception as e:
                        matches_file.write(f"Error reading content: {e}\n\n")
                print(f"Matches.txt file created at: {matches_file_path}")
        except Exception as e:
            print(f"Error creating Matches.txt: {e}")
    else:
        print("Matches.txt already exists, skipping creation.")






##############################################################
##############################################################
################################################################



class ConsoleWindow(tk.Toplevel):

    def __init__(self, master=None):
        super().__init__(master)


        if getattr(sys, 'frozen', False): # Check if running as a frozen executable (PyInstaller)
            script_dir = Path(os.path.dirname(sys.executable)) # Directory of the .exe
        else: # Running as a normal .py script
            script_dir = Path(__file__).parent # Directory of the .py script


        self.title("Console Output")
        self.geometry("1074x532")
        #self.overrideredirect(True)  # Remove window decorations
        #self.config(highlightthickness=12, highlightbackground="#555555") # Blue border

        icon_path = script_dir / "data/icon.png"

        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            self.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")


        # Create a Scrollbar
        self.scrollbar = tk.Scrollbar(self)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.text_area = tk.Text(
            self,
            wrap="word",
            bg="black",          # Set background color to black
            fg="white",         # Set text color to white
            font=("Cascadia Mono", 12), # Set font to Courier New, size 12 (adjust size as needed)
            highlightthickness=0 # Remove highlight from inside the text area
        )
        self.text_area.pack(expand=True, fill="both")
        self.text_area.config(state=tk.DISABLED) # Make it read-only

        # Configure Scrollbar to work with Text widget
        self.scrollbar.config(command=self.text_area.yview)


        # Draggable window variables
        self.is_dragging = False
        self.drag_start_x = 0
        self.drag_start_y = 0
        self.border_width = 5  # Width of the draggable border in pixels

        # Bind mouse events for dragging
        #self.bind("<ButtonPress-1>", self.start_drag)
        #self.bind("<B1-Motion>", self.on_drag)
        #self.bind("<ButtonRelease-1>", self.stop_drag)


    def write(self, text):
        self.text_area.config(state=tk.NORMAL) # Enable editing temporarily
        self.text_area.insert(tk.END, text)
        self.text_area.see(tk.END) # Autoscroll to the bottom
        self.text_area.config(state=tk.DISABLED) # Disable editing again

    def start_drag(self, event):
        """Start window dragging if click is on the border."""
        x, y = event.x, event.y
        width = self.winfo_width()
        height = self.winfo_height()

        # Check if click is within the border region
        if (x <= self.border_width or x >= width - self.border_width or
            y <= self.border_width or y >= height - self.border_width):
            self.is_dragging = True
            self.drag_start_x = event.x_root - self.winfo_rootx()
            self.drag_start_y = event.y_root - self.winfo_rooty()
        else:
            self.is_dragging = False  # Not dragging if clicked inside window (non-border)

    def on_drag(self, event):
        """Move window while dragging."""
        if self.is_dragging:
            x = event.x_root - self.drag_start_x
            y = event.y_root - self.drag_start_y
            self.geometry(f"+{x}+{y}")

    def stop_drag(self, event):
        """Stop window dragging."""
        self.is_dragging = False



# ------------------------------------------------------------
# ConfigViewerApp Class
# ------------------------------------------------------------
class ConfigViewerApp:




    def __init__(self, master, script_dir, input_file,
                 config_pics_folder, config_info_folder,
                 repo_folder, vehicles_content_folder, user_folder,
                 config_pics_custom_folder, hidden_txt_file):
        


        print("\n--- DEBUG PRINTS in ConfigViewerApp.__init__() ENTRY ---") # Debug Entry
        print(f"DEBUG-INIT: ConfigViewerApp instance created - SELF OBJECT ID: {id(self)}") # <--- DEBUG PRINT in __init__
        print(f"DEBUG-INIT: Type of config_pics_custom_folder (received): {type(config_pics_custom_folder)}, Value: {config_pics_custom_folder}") # Debug - Check type in __init__
        print(f"DEBUG-INIT: Type of config_pics_folder (received): {type(config_pics_folder)}, Value: {config_pics_folder}") # Debug - Check type in __init__ - ADDED
        print(f"DEBUG-INIT: Type of config_info_folder (received): {type(config_info_folder)}, Value: {config_info_folder}") # Debug - Check type in __init__ - ADDED
        print(f"DEBUG-INIT: Type of repo_folder (received): {type(repo_folder)}, Value: {repo_folder}") # Debug - Check type in __init__ - ADDED
        print(f"DEBUG-INIT: Type of script_dir (received): {type(script_dir)}, Value: {script_dir}") # Debug - Check type in __init__ - ADDED
        print("--- DEBUG PRINTS in ConfigViewerApp.__init__() EXIT ---\n") # Debug Exit

        self.master = master
        self.script_dir = script_dir
        self.input_file = input_file
        self.config_pics_folder = config_pics_folder
        self.config_info_folder = config_info_folder
        self.hidden_txt_file = hidden_txt_file

        self.DEFAULT_IMAGE_PATH = os.path.join("data/MissingZipConfigPic.png")

        self.show_scanning_window_count = 0 # Initialize the amount of times the window is called, the first couple of times it's called should have it be in the center of the screen, not the master
        self.show_scanning_window_currently_on_screen = False

        self.console_window = None
        self.original_stdout = sys.stdout
        self.original_stderr = sys.stderr
        self.is_console_visible = False


        self.ZIP_BASE_NAMES = []  # Initialize as an empty list

        main_script_directory = os.path.dirname(os.path.abspath(sys.argv[0])) # Get the directory of the MAIN script
        txt_file_path = os.path.join(main_script_directory, "data/beamng_VANILLA_vehicles_folder.txt")

        try:
            with open(txt_file_path, 'r', encoding="utf-8") as f:
                vehicles_folder = f.readline().strip() # Read the first line and remove whitespace

            if not vehicles_folder:
                print(f"Warning: '{txt_file_path}' is empty or contains no path. ZIP_BASE_NAMES will remain empty.")
            elif not os.path.isdir(vehicles_folder):
                print(f"Warning: Path '{vehicles_folder}' from '{txt_file_path}' is not a valid directory. ZIP_BASE_NAMES will remain empty.")
            else:
                for filename in os.listdir(vehicles_folder):
                    if filename.lower().endswith(".zip"): # Check for .zip extension (case-insensitive)
                        base_name = os.path.splitext(filename)[0] # Get filename without extension
                        self.ZIP_BASE_NAMES.append(base_name)
                if not self.ZIP_BASE_NAMES:
                    print(f"Warning: No ZIP files found in '{vehicles_folder}'. ZIP_BASE_NAMES will remain empty.")
                else:
                    print(f"ZIP files found in '{vehicles_folder}': {self.ZIP_BASE_NAMES}") # Optional: Print found ZIP files

        except FileNotFoundError:
            print(f"Warning: File '{txt_file_path}' not found. ZIP_BASE_NAMES will remain empty.")
        except Exception as e: # Catch other potential errors during file reading or directory access
            print(f"An error occurred while processing '{txt_file_path}': {e}")
            print("ZIP_BASE_NAMES will remain empty.")




        scanning_win = None  # Initialize scanning_win

        #scanning_win = self.show_scanning_window(text="Loading Mod Manager...")
            
            
        self.SPAWN_QUEUE_FILE = "data/spawn_queue.lua"
        self.SPAWN_QUEUE_TRANSIENT_FILE = "data/Spawn_Queue_Transient.lua"


        self.repo_folder = repo_folder
        self.vehicles_content_folder = vehicles_content_folder
        self.user_folder = user_folder
        self.config_pics_custom_folder = config_pics_custom_folder

        self.data_subset_file = "data/data_subset.txt" # Initialize data_subset_file path
        self.data_subset_favorites_file = "data/data_subset_favorites.txt"
        

        self.matches_txt = "data/matches.txt"

        self.button_style_args = {
            "relief": tk.FLAT, # Flat buttons
            "borderwidth": 0,
            "bg": "#555555", # Default button background color (dark grey)
            "fg": "white",    # Default text color
            "activebackground": "white", # Clicked background - will be set dynamically
            "activeforeground": "black", # Clicked text color - will be set dynamically
            "highlightthickness": 0 # Remove highlight
        }

        self.restart_button_active_fg_color = "white"

        self.warning_color_sidebar = "#ff4747" # Store the warning colors
        self.warning_color_restart_button = "#ffa1a1"

        self._fade_animation_running_sidebar = False # Flags to track if animation is running
        self._fade_animation_running_restart = False

        self.default_sidebar_color = "#ffffff"  # Changed to hex code for white
        self.default_restart_color = "#ffffff"


        self.pause_loading = False  # Initialize the pause_loading flag

        self.category_hidden_states = {} # Initialize category hidden states in __init__

        self.debounce_timer = None  # Initialize debounce timer attribute
        self.is_debouncing = False
        self.details_debounce_timer = None

        # Define resampling filter
        try:
            self.RESAMPLE_FILTER = Image.Resampling.LANCZOS  # For Pillow >= 10
        except AttributeError:
            self.RESAMPLE_FILTER = Image.LANCZOS


        self.main_grid_widget_cache = {}  # NEW: Cache for main grid item widgets - State-Aware Cache
        self.image_cache = {}
        self.image_cache_pil = {}  # Cache to store PIL Images
        self.individual_info_cache = {}  # NEW: In-memory cache for individual info JSON data  <--- INSERT HERE
        self.full_data_cache = {} # NEW: Cache for full_data from load_data
        self.data_cache = [] 
        self.config_info_cache = {}
        self._view_all_data_cache = {} # NEW: Initialize cache for "View All" data

        
               

        

        self.highlight_images = {}  # Dictionary to store highlight images per widget
        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=18)
        self.lock = threading.Lock()

        # Initialize image counts per category
        self.image_counts = {}


        # --- NEW: Disk Image Cache Directory --- # <---- INSERT HERE
        self.disk_image_cache_dir = os.path.join(self.script_dir, "data/image_cache_disk")
        if not os.path.exists(self.disk_image_cache_dir):
            os.makedirs(self.disk_image_cache_dir) # Create directory if it doesn't exist
        #disabling cache

        # Details Window state
        self.details_window_closed = True
        self.details_window = None
        self.details_scrollable_frame = None
        self.details_canvas_sub = None
        self.details_pagination_bar = None  # For details pagination

        self.details_window_should_open_in_favorites_mode = False

        self.no_configs_messagebox_condition = False

        details_widget_count = 0

        # Global Filters
        self.filters_window = None
        self.current_tooltip_global_filter_window = None
        self.tooltip_global_filter_original_bg_color = None
        self.on_off_buttons_list = []
        self.numeric_criteria = ["Top Speed (km/h)", "Power", "0-100 km/h", "Off-Road Score", "Braking G"]
        self.filter_settings_file = "data/global_filter_settings.txt"
        self.configinfo_folder = "data/configinfo" # Define configinfo folder
        self.filter_output_file = "data/filter_results.txt" # Define output file for filter results
        self.data_subset_file = "data/data_subset.txt"
        
        self.search_results_window = None


        self.is_search_results_window_active = False
        
        self.is_search_results_window_closing = False
        
        
        
        self.is_constraints_results_window_active = False 
        
        
        

        self.search_results_data = []          # Initialize data for search results window
        self.search_results_filtered_data = [] # Initialize filtered data for search results
        self.search_results_grouped_data = {}   # Initialize grouped data for search results
        
        

        # For pagination & searching in details
        self.details_data = []
        self.details_filtered_data = []
        self.details_page = 0
        self.items_per_page = 50  # (Still used in some fallback pagination logic)

        self.columns = None  # Initialize columns for main grid
        self.details_columns = None  # Initialize columns for details grid

        self.details_last_width = None
        self.details_last_height = None
        self.details_resize_timer = None

        # Keep track of main window size to prevent unnecessary reloads
        self.last_width = self.master.winfo_width()
        self.last_height = self.master.winfo_height()
        self.resize_timer = None

        # Flags for "Deleting..." flashing
        self.is_deleting = False
        self.deleting_color_flag = True
        self.deleting_label = None
        

        # Flags for details window "Deleting..."
        self.details_is_deleting = False
        self.details_deleting_color_flag = True
        self.details_deleting_label = None

        # Flags for "Editing Settings..."
        self.is_editing = False
        self.editing_color_flag = True
        self.editing_label = None

        # Categorization mode
        self.categorization_mode = 'Type'  # Default

        # Sort by install date
        self.sort_by_install_date = False


        self.global_highlight_color = "orange" # you can swap this out for other stuff in the future, like for eg making this a setting, but not right now

        # Switcher - Initialize settings_file_path **BEFORE loading settings**
        self.settings_file_path = os.path.join(script_dir, "data/MMSelectorSettings.txt") # <--- INITIALIZE settings_file_path HERE - CORRECT ORDER


        self.floating_window_last_position = None # Initialize to None, will be loaded or centered


        self.placeholder_settings = False
        self.middle_click_settings = False
        self.show_folder_settings = False

 
 
        self.collapse_categories_by_default = False # Initialize to False (Off) by default

        print("DEBUG-INIT: Calling load_settings() NOW (BEFORE format_grouped_data)...") # Debug - Call Order - BEFORE
        self.load_settings() # Load settings AFTER initializations, BEFORE GUI setup - CORRECTED CALL ORDER
        print("DEBUG-INIT: load_settings() RETURNED.") # Debug - Call Order - BEFORE


        geometry = self.load_window_geometry()
        if geometry:
            width, height, x, y = geometry
            self.master.geometry(f"{width}x{height}+{x}+{y}")
        else:
            # --- NEW: Center window if no saved geometry or invalid content ---
            screen_width = root.winfo_screenwidth()
            screen_height = root.winfo_screenheight()
            window_width = 1348  # Default width
            window_height = 600 # Default height
            x = (screen_width // 2) - (window_width // 2)
            y = (screen_height // 2) - (window_height // 2)
            self.master.geometry(f"{window_width}x{window_height}+{x}+{y}") # Centered default geometry
            print(f"DEBUG: No saved geometry or invalid content. Applying centered default geometry: {window_width}x{window_height}+{x}+{y}")
            # --- NEW: Center window if no saved geometry or invalid content ---
            
            

        # --------------------------------------------------------------------------------
        # MODIFICATION START - Load data AFTER GUI setup for testing
        # --------------------------------------------------------------------------------
        # Load data ONCE during initialization - COMMENTED OUT for test
        # self.original_data, self.original_full_data = self.load_data() # Store the ORIGINAL loaded data

        #if scanning_win:
        #    scanning_win.destroy()

 
        scanning_win = None

        self.scanning_win = self.show_scanning_window(text="Populating Caches...")



        self.load_all_info_data_on_startup() # <--- LOAD ALL DATA ON STARTUP HERE

        self.original_data, self.original_full_data = [], {} # Initialize as empty lists/dicts
        self.data = list(self.original_data) # Create a COPY for filtering/sorting (important!)
        self.full_data = dict(self.original_full_data) # Create a COPY for filtering/sorting (important!)
        print("DEBUG-INIT: Calling format_grouped_data() AFTER load_settings()") # Debug - Call Order - AFTER
        self.grouped_data = self.format_grouped_data(self.data) # Group the initial data
        
        self.main_grid_item_widgets = {} # Initialize dictionary to store widgets for main grid items

        
        
        print("DEBUG-INIT: format_grouped_data() RETURNED - AFTER load_settings()") # Debug - Call Order - AFTER
        # --------------------------------------------------------------------------------
        # MODIFICATION END - Load data AFTER GUI setup for testing
        # -------------------------------------------------------------------------------

        # --- NEW: Flag to track if all main grid images are cached ---
        self.all_main_grid_images_cached = False # Initialize to False

        # Added attributes for pausing/loading
        self.pause_loading = False
        self.loading_pause_timer = None

        # Added attributes for loading animation (main grid)
        self.loading_animation_running = False





        # --------------------------------------
        # NEW: Subgrid (details window) batch loading config
        # --------------------------------------
        # You can adjust these two variables to change how big each batch is
        # and how many milliseconds to wait between loading batches in the subgrid.
        self.details_batch_size = 10 # batches of
        self.details_batch_delay = 15 # schedule

        # Flag for details "Loading..." animation
        self.details_loading_animation_running = False

        self.scroll_animation_duration = 600  # milliseconds for scroll animation
        self.scroll_animation_steps = 30      # Number of animation steps
        self.scroll_target_yview = None       # Target yview for smooth scrolling
        self.scroll_current_yview = None      # Starting yview for animation
        self.scroll_animation_timer = None     # Timer ID for animation
        self.scroll_delta_units = 0           # Store scroll delta in units instead of pixels

        self.auto_reopen_details_after_change = False # Initialize flag for auto-reopen (this doesn't work properly right now)

        # --- NEW: Dynamic Batch Sizes ---
        self.main_grid_batch_sizes = [30, 10, 10, 10]  # Initial 30, then 3x 10
        self.details_grid_batch_sizes = [30, 10, 10, 10] # You can customize these separately
        self.default_batch_size = 10 # Default batch size after sequence ends

        self.current_main_batch_index_in_sequence = 0
        self.current_details_batch_index_in_sequence = 0


        self.scroll_animation_id = None
        self.scroll_target_y = 0
        self.scroll_start_y = 0
        self.scroll_duration = 200  # milliseconds for scroll animation (adjust as needed)
        self.scroll_start_time = 0

        # --- NEW: Highlight Pause Debounce Timer ---
        self.highlight_pause_debounce_timer = None

        # --- NEW: Skipped UI Update Queues ---
        self.main_grid_skipped_updates_queue = []
        self.details_grid_skipped_updates_queue = []

        # --- NEW: Printing Control ---  <----------------------  INSERT HERE
        self.original_print = builtins.print # Store the original print function
        self.disable_printing = False # Flag to control printing

        # --- NEW: Scroll Pause for Hover Effects ---
        self.is_scrolling_main_grid = False # Initialize to False (not scrolling initially)
        self.scroll_debounce_delay = 600 # milliseconds for debounce delay (600ms after scroll stop)
        self.scroll_debounce_timer_id = None # To keep track of the debounce timer

        self.matches_config_data = self.load_matches_config_data() 
        self.details_pause_counter = 0

        # --- Favorites Functionality ---
        self.filter_state = 0
        self.favorites_file_path = os.path.join(script_dir, "data/favorites.txt")
        self.favorite_configs = self.read_favorites()
        self.filter_options = [
            "View All",
            "Items with Config Preview Images [debug]",
            "Items Without Config Preview Images [debug]",
            "Only Mods",
            "Vanilla",
            "Favorites",
            "Unpacked Mods" #custom configurations are grouped into their relative zip file folders. this could be re-used for fully unpacked mods
        ]


        self.current_details_item_tooltip_window = None
        self.tooltip_debounce_timer = None  # For debouncing tooltip display
        self.tooltip_autodestroy_timer = None # For auto-destroying tooltip
        
        self.spawn_queue_window_was_open = False 


        self.use_disk_image_cache = False  # Set to False to disable disk image cache
        self.use_info_file_cache = False  # Set to False to disable info file cache

        self.omit_label = False  # Set to True to omit labels in the main grid

        self.items_to_be_hidden = False
        self.found_hidden_item = False
        self.main_grid_labels = [] # Initialize a list to store label widgets
        self.hidden_items_set = set() 


        # Build GUI - CORRECTED CALL ORDER - CALL GUI SETUP **BEFORE** loading data
        self.details_window_is_favorites_filtered = False
        self.setup_gui() # <---------------------------------- GUI SETUP NOW CALLED HERE - BEFORE DATA LOAD
        self.read_favorites()
        self.populate_initial_grid()
        self.details_sidebar_debounce_timer = None # Initialize debounce timer for details sidebar
        self.main_grid_sidebar_debounce_timer = None
        self.current_main_sidebar_item = None # To store the currently selected item in main grid sidebar


        # Switcher
        self.settings_file_path = os.path.join(script_dir, "data/MMSelectorSettings.txt")
        self.floating_window_last_position = None # Initialize to None, will be loaded or centered

        # debugging shortcuts
        self.enable_debug_shortcuts = False


        


        self.is_config_viewer_focused = True # NEW: Track focus state - Start with Config Viewer focused

        self.grouped_data = self.format_grouped_data(self.data)
        self.populate_initial_grid()
        self.details_sidebar_debounce_timer = None # Initialize debounce timer for details sidebar
        self.current_main_sidebar_item = None # To store the currently selected item in main grid sidebar

        print(f"config_pics_custom_folder: {self.config_pics_custom_folder}")  # Debugging print

        self.search_mode = "General"

        self.load_data_after_gui() # Call load_data AFTER GUI is setup  <----- Data load called AFTER GUI setup
        self.master.deiconify()

        # --------------------------------------------------------------------------------
        # HIDDEN WINDOW INITIALIZATION
        # -------------------------------------------------------------------------------

        # --- Hidden Vehicles Window Variables
        self.hidden_window = None  # Initialize hidden_window as None
        self.original_hidden_lines = []
        self.all_vehicles_data = self.load_hidden_vehicles_once() # Load all data ONCE in init
        self.hidden_vehicles_data = list(self.all_vehicles_data) # Initially display all
        self.hidden_window_search_after_id = None # For debouncing search
        self.vehicle_frames = [] # Initialize vehicle_frames
        self.hidden_window_search_DEBOUNCE_DELAY_MS = 300  # Debounce delay in milliseconds

        # Scrollbar variables - HIDDEN WINDOW
        self.hidden_window_custom_scrollbar_canvas_hidden = None # Will be created in create_widgets_hidden_window
        self.hidden_window_scrollbar_thumb_hidden = None # Will be created in create_widgets_hidden_window
        self.hidden_window_scrollbar_thumb_dragging_hidden = False
        self.hidden_window_scrollbar_thumb_start_y_hidden = 0
        self.hidden_window_scrollbar_mouse_start_y_hidden = 0
        self.hidden_window_scroll_animation_timer_hidden = None
        self.hidden_window_scroll_animation_id_hidden = None
        self.hidden_window_scroll_target_yview_hidden = 0.0
        self.hidden_window_scroll_start_y_hidden = 0.0
        self.hidden_window_scroll_start_time_hidden = 0
        self.hidden_window_scroll_duration = 200  # ms for smooth scroll animation - can be global if needed


        self.hidden_window_hidden_window_restart_button_active_fg_color = "white"
        self.hidden_window_warning_color_hidden_window_restart_button = "#ffa1a1"
        self._hidden_window_fade_animation_running_restart = False
        self.hidden_window_default_restart_color = "#ffffff"

        # --------------------------------------------------------------------------------
        # HIDDEN WINDOW INITIALIZATION END 
        # -------------------------------------------------------------------------------

        self.scanning_window = scanning_win  # Initialize scanning_window attribute

        print("--- DEBUG PRINTS in ConfigViewerApp.__init__() EXIT ---\n") # Debug Exit



        self.image_cache_capacity = 50 # Example capacity - adjust as needed
        self.image_cache = OrderedDict() # Using OrderedDict for LRU

        # --- NEW: Eviction Batching ---
        self.eviction_count = 0
        self.eviction_batch_delay_ms = 4000 # Print summary every 4 seconds
        self.eviction_timer_running = False





    def load_data_after_gui(self):
        self.original_data, self.original_full_data = self.load_data() # Load data NOW
        self.data = list(self.original_data)
        self.full_data = dict(self.original_full_data)
        self.grouped_data = self.format_grouped_data(self.data)
        self.update_grid_layout() # Update the grid AFTER data is loaded
        self.perform_search() # Re-apply search to the newly loaded data
        self.canvas.yview_moveto(0) # Reset scroll position



    def disable_prints(self):
        """Disables all print statements by replacing builtins.print with a no-op function."""
        if not self.disable_printing: # To prevent accidental repeated calls
            builtins.print = lambda *args, **kwargs: None # Replace print with a do-nothing function
            self.disable_printing = True
            print("Printing DISABLED.") #  This one will still print (using original_print in enable_prints if needed for feedback)

    def enable_prints(self):
        """Enables print statements by restoring the original builtins.print function."""
        if self.disable_printing: # To prevent accidental repeated calls
            builtins.print = self.original_print # Restore the original print function
            self.disable_printing = False
            print("Printing ENABLED.") # This one will now print as normal

    def preload_existing_files(self, folder_path: Path) -> set:
        """
        Preload existing files in the specified folder into a set for efficient lookup.
        
        Parameters:
        - folder_path: Path object representing the folder to preload.
        
        Returns:
        - A set containing the names of existing files in the folder.
        """
        return {file.name for file in folder_path.iterdir() if file.is_file()}
    
    # ------------------------------------------------------------
    # NEW: Integrated configpicextractor_CUSTOM functionality - DEBUGGING PRINTS ADDED - PATH CONVERSION FORCED
    # ------------------------------------------------------------
    def run_configpicextractor_custom_integrated(self): # <--- MODIFIED METHOD
        """
         Modified to call external function.
        """
        print("calling run_configpicextractor_custom_integrated from external file") # Debug
        run_configpicextractor_custom_integrated(self.script_dir, self.user_folder, self.config_pics_custom_folder)



    # ------------------------------------------------------------
    # Switcher
    # ------------------------------------------------------------
    
    
    def on_floating_window_unmapped(self, event=None):
      return on_floating_window_unmapped(self, event) # Call external function


    def destroy_floating_button_window(self):
       return destroy_floating_button_window(self) # Call external function

    def hide_floating_window(self):
       return hide_floating_window(self) # Call external function

    def show_floating_window(self):
      return show_floating_window(self) # Call external function

    def focus_config_viewer_from_floating_button(self):
        return focus_config_viewer_from_floating_button(self) # Call external function

    def remember_floating_window_position(self, event):
       return remember_floating_window_position(self, event) # Call external function

    def load_floating_window_position(self):
        return load_floating_window_position(self) # Call external function
    
    def save_floating_window_position(self):
        return save_floating_window_position(self) # Call external function

                
    # ----------------------------------------------
    # Added Methods for Handling Mouse Wheel Events
    # ----------------------------------------------
    def on_mousewheel_event(self):
        """Handle mouse wheel events to pause image loading."""
        self.pause_loading = True
        if self.loading_pause_timer:
            self.master.after_cancel(self.loading_pause_timer)
        # Resume loading after 200ms of no mouse wheel activity SCROLL DEBOUNCE
        self.loading_pause_timer = self.master.after(700, self.resume_loading)

    def resume_loading(self):
        """Resume image loading after pause. Processes skipped UI updates."""
        self.pause_loading = False
        self.loading_pause_timer = None
        print("Loading RESUMED (Mouse Wheel or Auto-Resume)") # Debug Print
        self.process_skipped_ui_updates() # Process skipped UI updates when resuming

    # --- NEW: Process Skipped UI Updates ---
    def process_skipped_ui_updates(self):
        """Processes queued UI updates that were skipped due to loading pause."""
        # print("Processing Skipped UI Updates...") # Debug Print

        # Process Main Grid skipped updates
        while self.main_grid_skipped_updates_queue:
            update_args = self.main_grid_skipped_updates_queue.pop(0) # FIFO queue
            self.master.after(0, lambda args=update_args: self.create_main_item_widgets(*args))
        # print(f"Processed {len(self.main_grid_skipped_updates_queue)} skipped Main Grid updates.") # Debug - Should be 0

        # Process Details Grid skipped updates
        while self.details_grid_skipped_updates_queue:
            update_args = self.details_grid_skipped_updates_queue.pop(0) # FIFO queue
            self.master.after(0, lambda args=update_args: self.create_details_item_widgets(*args))
        print(f"Processed {len(self.details_grid_skipped_updates_queue)} skipped Details Grid updates.") # Debug - Should be 0
        





    # ------------------------------------------------------------
    # NEW: We can trigger a custom config scan and refresh
    # ------------------------------------------------------------
    def trigger_custom_config_scan_and_refresh(self):
        """
        Pops up a small window saying 'Changes detected, scanning...',
        runs custom config scanning, then refreshes data AND CLEARS MAIN GRID CACHE.
        """
        print("\n--- ConfigViewerApp.trigger_custom_config_scan_and_refresh() ENTRY - DEBUG CHECK ---") # Debug - Entry Point - TRIGGER_CUSTOM_CONFIG_SCAN_AND_REFRESH
        scanning_win = self.show_scanning_window()

        # --- NEW: Clear main grid image cache BEFORE refresh ---
        print("Clearing Main Grid Cache before refresh...") # Debug Print
        self.clear_main_grid_cache() # Call the new cache clearing function
        print("Main Grid Cache Cleared.") # Debug Print

        # --- NEW: Close details window if it's open (as before) ---
        if self.details_window and not self.details_window_closed:

            #messagebox.showinfo(
            #    "Configs Changed",
            #    "Config(s) Removed or Added!\nPlease re-open custom config set to see updates.",
            #    parent=self.master # Set parent to main window to keep messagebox on top
            #)
            

            print("Closing Details Window before refresh...")
            self.on_details_window_close()
            print("Details Window Closed.")

        try:
            # Run the known function that scans custom configs
            print("Calling self.run_python_scripts_custom() ...") # Debug - Before Script Run
            self.run_python_scripts_custom()
            print("self.run_python_scripts_custom() RETURNED.") # Debug - After Script Run

            # Reload data
            print("Calling self.refresh_data_from_files() ...") # Debug - Before Data Refresh
            self.refresh_data_from_files()
            self.rebuild_main_grid()
            print("self.refresh_data_from_files() RETURNED.") # Debug - After Data Refresh
            

            # Refresh the UI
            print("Calling self.perform_search() ...") # Debug - Before Perform Search
            self.perform_search()
            print("self.perform_search() RETURNED.") # Debug - After Perform Search
        except Exception as e:
            messagebox.showerror("Error", f"Error during scanning: {e}")
        finally:
            scanning_win.destroy()
            print("--- ConfigViewerApp.trigger_custom_config_scan_and_refresh() EXIT ---\n") # Debug - Exit Point

    def rebuild_main_grid(self):
        """Destroys and rebuilds the main grid layout."""
        # 1. Clear existing widgets from the scrollable frame
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()

        # 2. Repopulate the grid layout by calling update_grid_layout
        self.update_grid_layout()

        # 3. Reset scroll position to the top (optional, but often desired)
        self.canvas.yview_moveto(0)


    # ----------------------------------------------------------------
    # NEW: For auto-removal in ConfigPicsCustom if user folder file is deleted
    # ----------------------------------------------------------------
    def remove_corresponding_custom_image(self, user_file_path):
        """
        Given something like .../vehicles/examplecar/example.png was deleted,
        remove 'vehicles--examplecar_user--example.png' if it exists in ConfigPicsCustom.
        Also works if user_file_path is .pc (just tries to remove matching .png/.jpg if it existed).
        """
        # We only proceed if user_file_path is inside the user folder
        if not self.user_folder or not user_file_path.lower().startswith(self.user_folder.lower()):
            return

        # Example: user_file_path = /User/Documents/BeamNG.drive/vehicles/examplecar/example.png
        # We want to parse out 'examplecar' and 'example'.
        folder_part, file_part = os.path.split(user_file_path)
        vehicle_folder = os.path.basename(folder_part)  # 'examplecar'
        base, ext = os.path.splitext(file_part)         # 'example', '.png'

        if not vehicle_folder or not base:
            return

        # Build the base name used in ConfigPicsCustom
        # e.g. vehicles--examplecar_user--example
        custom_prefix = f"vehicles--{vehicle_folder}_user--{base}"

        # We'll attempt .png, .jpg, .jpeg
        possible_extensions = [".png", ".jpg", ".jpeg"]
        for possible_ext in possible_extensions:
            candidate = custom_prefix + possible_ext
            candidate_path = os.path.join(self.config_pics_custom_folder, candidate)
            if os.path.exists(candidate_path):
                try:
                    os.remove(candidate_path)
                except Exception as e:
                    print(f"Error removing {candidate_path}: {e}")



        
    # ----------------------------------------------------------------
    # NEW: Smooth fade-in method for frames
    # ----------------------------------------------------------------
    def smooth_fade_in_frame(self, frame, start_color="#FFFFFF", end_color="#D3D3D3", steps=10, delay=30, exclude_widgets=[tk.Entry]):
        """
        Smoothly fades the background color of 'frame' from 'start_color' to 'end_color'.
        Widgets specified in 'exclude_widgets' will not have their background colors altered.

        :param frame: The Tkinter frame to apply the fade effect.
        :param start_color: The starting color in hex format (e.g., "#FFFFFF").
        :param end_color: The ending color in hex format (e.g., "#D3D3D3").
        :param steps: Number of steps in the fade transition.
        :param delay: Delay in milliseconds between each step.
        :param exclude_widgets: A list of widget classes to exclude from background changes.
        """
        if exclude_widgets is None:
            exclude_widgets = []

        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i + 2], 16) for i in (0, 2, 4))

        def rgb_to_hex(rgb):
            return f"#{rgb[0]:02x}{rgb[1]:02x}{rgb[2]:02x}"

        start_rgb = hex_to_rgb(start_color)
        end_rgb = hex_to_rgb(end_color)

        color_steps = []
        for i in range(steps + 1):
            factor = i / steps
            r = int(start_rgb[0] + factor * (end_rgb[0] - start_rgb[0]))
            g = int(start_rgb[1] + factor * (end_rgb[1] - start_rgb[1]))
            b = int(start_rgb[2] + factor * (end_rgb[2] - start_rgb[2]))
            color_steps.append(rgb_to_hex((r, g, b)))

        def animate_fade(step=0):
            if not frame.winfo_exists():
                return
            frame.config(bg=color_steps[step])
            for child in frame.winfo_children():
                # Check if the child's class is in the exclude list
                if isinstance(child, tuple(exclude_widgets)):
                    continue  # Skip altering this widget's background
                child.config(bg=color_steps[step])
            if step < len(color_steps) - 1:
                frame.after(delay, lambda: animate_fade(step + 1))

        animate_fade(0)





    # ------------------------------------------------------------
    # Deleting... Flash Methods
    # ------------------------------------------------------------
    def toggle_deleting_text(self):
        if not self.is_deleting or not self.deleting_label:
            return
        self.deleting_label.config(fg="red" if self.deleting_color_flag else "black")
        self.deleting_color_flag = not self.deleting_color_flag
        self.master.after(500, self.toggle_deleting_text)

    def toggle_details_deleting_text(self):
        if not self.details_is_deleting or not self.details_deleting_label:
            return
        if self.details_deleting_label.winfo_exists(): # Check if label exists
            self.details_deleting_label.config(fg="red" if self.details_deleting_color_flag else "black")
            self.details_deleting_color_flag = not self.details_deleting_color_flag
            if self.details_window and not self.details_window_closed:
                self.details_window.after(500, self.toggle_details_deleting_text)

    # ------------------------------------------------------------
    # Editing Settings... Flash Methods
    # ------------------------------------------------------------
    def toggle_editing_text(self):
        if not self.is_editing or not self.editing_label:
            return
        self.editing_label.config(fg="green" if self.editing_color_flag else "black", text="Editing Settings...")
        self.editing_color_flag = not self.editing_color_flag
        self.master.after(500, self.toggle_editing_text)

    # ------------------------------------------------------------
    # Run python Scripts for Mods 
    # ------------------------------------------------------------
    def run_ahk_scripts_mods(self):
        """
        Runs the main function from mod_command_line_config_gen, 
        making it behave as if it's running from guitest.py's directory.
        """
        module_name = "mod_command_line_config_gen"
        module_path = os.path.join(self.script_dir, "modules", f"{module_name}.py")

        if not os.path.exists(module_path):
            messagebox.showerror("Script Not Found", f"Python script not found: {module_path}")
            self.master.destroy()
            return

        # Dynamically load the module
        spec = importlib.util.spec_from_file_location(module_name, module_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        original_working_directory = os.getcwd()  # 1. Get current working directory
        try:
            os.chdir(self.script_dir)  # 2. Change working directory to guitest.py's dir
            print(f"DEBUG: Changed working directory to: {os.getcwd()}") # Debug - Verify directory change

            module.main()  # 3. Call module.main() - relative paths will be resolved from guitest.py's dir
            print(f"Successfully executed main() function from '{module_name}.py' in adjusted working directory.") # Success message

        except Exception as e:
            messagebox.showerror("Script Error", f"Error running main() function from '{module_name}.py': {e}")
            self.master.destroy()
            return
        finally:
            os.chdir(original_working_directory)  # 4. Restore original working directory
            print(f"DEBUG: Restored working directory to: {os.getcwd()}") # Debug - Verify directory restoration

            self.rebuild_main_grid()
            self.perform_search()
            self.canvas.yview_moveto(0)  # Reset scroll position to the top



    def show_message(title, message):
        """Utility function to show a message box."""
        root = tk.Tk()
        root.withdraw()  # Hide the main window
        messagebox.showerror(title, message)
        root.destroy()
        


            
    # ------------------------------------------------------------
    # NEW: Integrated MOD_COMMAND_LINE_CONFIG_GEN_CUSTOM.py functionality - DEBUGGING ADDED (EXTREME) - PATHLIB IMPORTED
    # ------------------------------------------------------------
    def run_mod_command_line_config_gen_custom_integrated(self): # <--- MODIFIED METHOD
         """
        Modified to call external function.
        """
         print("calling run_mod_command_line_config_gen_custom_integrated from external file") # Debug
         run_mod_command_line_config_gen_custom_integrated(self.script_dir, self.user_folder, self.config_pics_folder)




    def run_python_scripts_custom(self): # MODIFIED - No more script path arguments
        python_scripts = [
            # "MOD_COMMAND_LINE_CONFIG_GEN_CUSTOM.py",  <--- REMOVED from list
            # "configpicextractor_CUSTOM.py",  <--- REMOVED from list
            # "modify_output_good.py",  <--- REMOVED from list
        ]
        
        python_executable = sys.executable


        # --- NEW: Call integrated MOD_COMMAND_LINE_CONFIG_GEN_CUSTOM functionality DIRECTLY ---
        try:
            print("Calling self.run_mod_command_line_config_gen_custom_integrated() ...") # Debug
            self.run_mod_command_line_config_gen_custom_integrated() # <--- DIRECT METHOD CALL - NO subprocess
            print("self.run_mod_command_line_config_gen_custom_integrated() RETURNED.") # Debug
        except Exception as e:
            messagebox.showerror("Error", f"Error running run_mod_command_line_config_gen_custom_integrated(): {e}")
            self.master.destroy()
            return
        # --- NEW: Call integrated MOD_COMMAND_LINE_CONFIG_GEN_CUSTOM functionality DIRECTLY ---

        # ############# CONFIG PIC EXTRACTOR ################# 

 

        # --- NEW: Call integrated modify_output_good functionality DIRECTLY ---
        try:
            print("Calling self.run_modify_output_good_integrated() ...") # Debug
            self.run_modify_output_good_integrated() # <--- DIRECT METHOD CALL - NO subprocess
            print("self.run_modify_output_good_integrated() RETURNED.") # Debug
        except Exception as e:
            messagebox.showerror("Error", f"Error running run_modify_output_good_integrated(): {e}")
            self.master.destroy()
            return
        # --- NEW: Call integrated modify_output_good functionality DIRECTLY ---

        try:
            print("Calling self.run_configpicextractor_custom_integrated() ...") # Debug
            self.run_configpicextractor_custom_integrated() # <--- DIRECT METHOD CALL - NO subprocess
            print("self.run_configpicextractor_custom_integrated() RETURNED.") # Debug
        except Exception as e:
            messagebox.showerror("Error", f"Error running run_configpicextractor_custom_integrated(): {e}")
            self.master.destroy()
            return
            
    # ------------------------------------------------------------
    # NEW: Integrated modify_output_good functionality
    # ------------------------------------------------------------
    def run_modify_output_good_integrated(self):
        return run_modify_output_good_integrated(self)


    # ------------------------------------------------------------
    # Extract Fallback Info from JSON
    # ------------------------------------------------------------
    def extract_fallback_info(self, filepath):
        """
        Extracts fallback information from a JSON file, now including "Author".
        """
        required_keys = [
            "Name", "Brand", "Country", "Type", "Body Style", "Years", "Derby Class",
            "Description", "Slogan", "default_pc", "Author"  # <-- ADDED "Author" to required keys
        ]
        extracted_info = {}

        try:
            with open(filepath, "r", encoding="utf-8") as file:
                file_content = file.read()
                for key in required_keys:
                    if key == "Years":
                       pattern = r'"Years"\s*:\s*([^\}]*)' # Capture until closing curly brace
                       match = re.search(pattern, file_content, re.IGNORECASE)
                       if match:
                           value_str = match.group(1)
                           numbers = re.findall(r'\d+', value_str) # Find ALL numbers
                           if numbers:
                               extracted_info[key] = " ".join(numbers)
                           else:
                                extracted_info[key] = ""
                    else:
                        pattern = rf'"{key}"\s*:\s*"([^"]*)"'
                        match = re.search(pattern, file_content, re.IGNORECASE)
                        if match:
                            extracted_info[key] = match.group(1)

        except Exception as e:
            print(f"Error processing {filepath}: {e}")
        return extracted_info
        
    # ------------------------------------------------------------
    # Find Fallback Info
    # ------------------------------------------------------------
    def find_fallback_info(self, picture_filename):
        lower_filename = picture_filename.lower()
        for base_name in self.ZIP_BASE_NAMES:
            if base_name in lower_filename:
                pattern = f"_{base_name}.json"
                for root, _, files in os.walk(self.config_info_folder):
                    for file in files:
                        if pattern in file.lower() and file.lower().endswith(".json"):
                            info_path = os.path.join(root, file)
                            info_data = self.extract_fallback_info(info_path)
                            if info_data:
                                return info_data
        return {}

    # ------------------------------------------------------------
    # Load Data
    # ------------------------------------------------------------


    #@profile  
    def load_data(self):


        #FUNCTION FOR SORTING WOULD BE CALLED HERE 



        print("\n--- ConfigViewerApp.load_data() ENTRY ---")  # Debug - Entry Point
        data = {}
        full_data = {}
        self.individual_info_files = {} # NEW: Dictionary to store individual info file paths
        self.config_info_cache = {} # Clear cache at each load_data call to refresh <--- ADDED HERE

        # Pre-populate config info cache
        #self.populate_config_info_cache() # <--- CALL POPULATE CACHE HERE


        # from outputGOOD.txt
        try:
            if os.path.exists(self.input_file):

                print(f"Loading data from: {self.input_file}") # Debug

                self.filter_outputgood() #create the new outputgood file that excludes the previews
                #create the if branch here

                hidden_folders = self.get_hidden_folders() # Get the list of hidden folders

                if not self.placeholder_settings:
                    with open(os.path.join(self.script_dir, "data/outputgood_PreviewsPresent.txt"), "r", encoding="utf-8") as file:
                        lines = file.readlines()

                        filtered_lines = [
                            line for line in lines
                            if not any(
                                f"vehicles/{folder}/" in line.lower() or f"vehicles\\{folder}\\" in line.lower()
                                for folder in hidden_folders
                            )
                        ]

                        self.process_lines(filtered_lines, data, full_data, is_custom=False)


                if self.placeholder_settings:
                    with open(self.input_file, "r", encoding="utf-8") as file:
                        lines = file.readlines()

                        filtered_lines = [
                            line for line in lines
                            if not any(
                                f"vehicles/{folder}/" in line.lower() or f"vehicles\\{folder}\\" in line.lower()
                                for folder in hidden_folders
                            )
                        ]

                        self.process_lines(filtered_lines, data, full_data, is_custom=False)


            else:
                print(f"Warning: {self.input_file} not found. Skipping mod config loading.")
        except Exception as e:
            print(f"Error loading data from {self.input_file}: {e}")

        # from outputGOODcustom.txt
        custom_input_file = os.path.join(self.script_dir, "data/outputGOODcustom.txt")
        try:
            if os.path.exists(custom_input_file):
                print(f"Loading custom data from: {custom_input_file}") # Debug
                with open(custom_input_file, "r", encoding="utf-8") as file:
                    lines = file.readlines()

                    hidden_folders = self.get_hidden_folders() # Get the list of hidden folders

                    filtered_lines = [
                        line for line in lines
                        if not any(
                            f"vehicles/{folder}/" in line.lower() or f"vehicles\\{folder}\\" in line.lower() or f"vehicles--{folder}" in line.lower()
                            for folder in hidden_folders
                        )
                    ]

                    self.process_lines(filtered_lines, data, full_data, is_custom=True)
            else:
                print(f"Warning: {custom_input_file} not found. Skipping custom config loading.")
        except Exception as e:
            print(f"Error loading data from {custom_input_file}: {e}")



        self.full_data_cache = full_data # Cache full_data
        data_values = list(data.values())
        self.data_cache = data_values # Cache data list

        # Apply data subset filter AFTER loading all data
        self.data_cache = self.apply_data_subset_filter(data_values) # <--- APPLY DATA SUBSET FILTER HERE

        print(f"load_data - Loaded {len(data)} main items, {len(full_data)} full data groups.") # Debug - Data Counts
        print("--- ConfigViewerApp.load_data() EXIT ---\n") # Debug - Exit Point
        return list(self.data_cache), full_data

    def get_hidden_folders(self):
        hidden_folders = []
        hidden_file_path = os.path.join(self.script_dir, "data/Hidden.txt")
        if os.path.exists(hidden_file_path):
            with open(hidden_file_path, "r", encoding="utf-8") as f:
                for line in f:
                    parts = line.strip().split("|||")
                    if parts and parts[0].strip(): # Ensure there's a folder name and it's not empty
                        hidden_folders.append(parts[0].strip())
        return hidden_folders

    def filter_outputgood(self):
        """
        Filters outputgood.txt to remove lines containing "IMAGE_NOT_FOUND-USEMISSING"
        and the two lines following them.
        """

        outputgood_PreviewsPresent = os.path.join(self.script_dir, "data/outputgood_PreviewsPresent.txt")

        if not os.path.exists(self.input_file):
            print(f"Error: Input file '{self.input_file}' not found.")
            return

        filtered_lines = []
        skip_lines = 0
        try:
            with open(self.input_file, 'r', encoding="utf-8") as infile:
                for line in infile:
                    if skip_lines > 0:
                        skip_lines -= 1
                        continue  # Skip this line

                    if "IMAGE_NOT_FOUND-USEMISSING" in line:
                        skip_lines = 2  # Skip the next 2 lines as well
                        continue  # Skip the current line (containing the error)
                    else:
                        filtered_lines.append(line)

        except Exception as e:
            print(f"An error occurred while reading '{self.input_file}': {e}")
            return

        try:
            with open(outputgood_PreviewsPresent, 'w', encoding="utf-8") as outfile:
                outfile.writelines(filtered_lines)
            print(f"Filtered content written to '{outputgood_PreviewsPresent}'")

        except Exception as e:
            print(f"An error occurred while writing to '{outputgood_PreviewsPresent}': {e}")
    



        
    def populate_config_info_cache(self): # NEW FUNCTION - POPULATE CACHE
        """
        Populates the config info cache with data from all JSON files in configinfo folder.
        """
        print("\n--- populate_config_info_cache() ENTRY ---") # Debug Entry
        if not os.path.exists(self.config_info_folder):
            print(f"Warning: Configinfo folder '{self.config_info_folder}' not found, cache not populated.")
            return

        for filename in os.listdir(self.config_info_folder):
            if filename.endswith(".json"):
                filepath = os.path.join(self.config_info_folder, filename)
                try:
                    with open(filepath, 'r', encoding="utf-8") as f:
                        file_content = f.read()
                        self.config_info_cache[filename] = file_content # Cache the raw file content directly
                        #print(f"  DEBUG: Cached config info file: {filename}") # Debug - Cache Success
                except Exception as e:
                    print(f"Warning: Error reading config info file {filename}: {e}. File not cached.") # Debug - Cache Fail

        print(f"populate_config_info_cache - Cached {len(self.config_info_cache)} config info files.") # Debug - Cache Summary
        print("--- populate_config_info_cache() EXIT ---\n") # Debug Exit



    def find_individual_info_file(self, folder_name, zip_file_base_name, config_name):
        """
        Constructs and checks for the existence of an individual info file
        within the 'configinfo' directory relative to the script's location.
        Includes a fallback approach to handle tricky underscore cases.
        """
        try:
            # Determine the script's directory
            #script_dir = self.script_dir
            # Construct the path to the 'configinfo' folder
            #config_info_folder = os.path.join(script_dir, 'data/configinfo')

            # -- Original construction (unchanged) --
            individual_info_filename_1 = (
                f"vehicles--INDIVIDUAL--{folder_name}_{zip_file_base_name}.zip--info_info_{config_name}.json"
            )
            individual_info_path_1 = os.path.join(self.config_info_folder, individual_info_filename_1)
            # Debugging
            #print(f"DEBUG: Attempting original path: {individual_info_path_1}")

            if os.path.exists(individual_info_path_1):
                #print(f"DEBUG: Individual info file FOUND (original): {individual_info_path_1}")
                return individual_info_path_1

            # -- Fallback construction --
            # Handle cases where underscores might be causing issues
            fallback_combined = f"{folder_name}{'_' if folder_name and zip_file_base_name else ''}{zip_file_base_name}"
            individual_info_filename_2 = (
                f"vehicles--INDIVIDUAL--{fallback_combined}.zip--info_info_{config_name}.json"
            )
            individual_info_path_2 = os.path.join(self.config_info_folder, individual_info_filename_2)
            # Debugging
            #print(f"DEBUG: Attempting fallback path: {individual_info_path_2}")

            if os.path.exists(individual_info_path_2):
                #print(f"DEBUG: Individual info file FOUND (fallback): {individual_info_path_2}")
                return individual_info_path_2

            # If neither path exists, return None
            #print("DEBUG: Individual info file NOT FOUND at either path")
            return None

        except Exception as e:
            print(f"ERROR: Exception in find_individual_info_file: {e}")
            return None

    def extract_info_from_sidebar_image(self, picture_path):
        """
        Extracts the necessary information from the sidebar image filename
        to determine folder_name, zip_file_base_name, config_name.
        Returns a dictionary containing the extracted info, or None if extraction fails.
        """
        print(f"DEBUG: extract_info_from_sidebar_image - picture_path: {picture_path}")
        try:
            filename = os.path.basename(picture_path)
            print(f"  DEBUG: Filename extracted: {filename}")

            parts = filename.split('--')
            if len(parts) < 3:
                print("  DEBUG: Could not extract info from filename - unexpected format.")
                return None

            # If it's "vehicles--INDIVIDUAL--...", handle that separately (unchanged)
            if parts[1] == "INDIVIDUAL":
                folder_zip_part = parts[2].split("_", 1)[1]  # e.g. remove "INDIVIDUAL_" prefix
                folder_name = folder_zip_part.rsplit("_", 1)[0]
                zip_file_base_name = folder_zip_part.rsplit("_", 1)[1].replace(".zip", "")
                # --- MODIFIED: Extract config_name correctly ---
                config_name_with_ext = parts[3]  # Get the part with extension (e.g., "12.8L 6x4 Air(Low HP).jpg")
                config_name = os.path.splitext(config_name_with_ext)[0] # Remove extension, get "12.8L 6x4 Air(Low HP)"
                # --- MODIFIED: Extract config_name correctly ---


                print(f"  DEBUG: Extracted - folder_name: {folder_name}, zip_file_base_name: {zip_file_base_name}, config_name: {config_name}")
                return {
                    "folder_name": folder_name,
                    "zip_file_base_name": zip_file_base_name,
                    "config_name": config_name
                }
            else:
                # The "standard" mod config path:
                #  e.g.  vehicles--us_semi_us_semi.zip--t83_sleeper.jpg
                #        parts[1] = us_semi_us_semi.zip
                #        parts[2] = t83_sleeper.jpg
                raw_part = parts[1]  # e.g. "us_semi_us_semi.zip"
                main_str = raw_part.replace(".zip", "")  # "us_semi_us_semi"

                # --- Attempt Original Logic ---
                # Old approach: take the first underscore-chunk as folder_name,
                # everything else as zip_file_base_name
                folder_name_old = main_str.split("_", 1)[0]  # e.g. "us"
                zip_file_base_name_old = main_str.replace(f"{folder_name_old}_", "")  # e.g. "semi_us_semi"

                # If combined back, do we get the original main_str?
                reconstructed = folder_name_old + "_" + zip_file_base_name_old

                if reconstructed == main_str:
                    # Great, it matches: use the original approach
                    folder_name = folder_name_old
                    zip_file_base_name = zip_file_base_name_old
                else:
                    # Fallback: multi-underscore fiasco => treat the entire chunk as folder_name
                    # (and zip_file_base_name as blank or something minimal)
                    folder_name = main_str
                    zip_file_base_name = ""

                # --- MODIFIED: Extract config_name correctly ---
                config_name_with_ext = parts[2]  # Get the part with extension (e.g., "t83_sleeper.jpg")
                config_name = os.path.splitext(config_name_with_ext)[0] # Remove extension, get "t83_sleeper"
                # --- MODIFIED: Extract config_name correctly ---


                print(f"  DEBUG: Extracted - folder_name: {folder_name}, zip_file_base_name: {zip_file_base_name}, config_name: {config_name}")
                return {
                    "folder_name": folder_name,
                    "zip_file_base_name": zip_file_base_name,
                    "config_name": config_name
                }

        except Exception as e:
            print(f"ERROR: Exception during extraction: {e}")
            return None

    #@profile 
    def refresh_data_from_files(self):
        """Refreshes data from files, added search window update."""
        print("\n--- ConfigViewerApp.refresh_data_from_files() ENTRY ---")
        print("Refreshing data from files...")
        print("Calling self.load_data() ...")
        self.original_data, self.original_full_data = self.load_data()
        print("self.load_data() RETURNED.")
        self.data = list(self.original_data)
        self.full_data = dict(self.original_full_data)
        self.setup_sidebar_filter_dropdowns(self.sidebar_bottom_frame, 10)
        
        print("DEBUG: refresh_data_from_files - Manually calling write_watcher_output() BEFORE read_favorites()...")
        try:
            self.write_watcher_output(
                self.watcher_output_file,  # file_path
                self.check_mods,            # check_mods
                self.check_configs,         # check_configs
                self.current_user_vehicles_files, # user_vehicles_files
                self.current_config_pics_custom_files, # config_pics_custom_files
                self.current_mods_files,       # mods_files
                self.current_repo_files,       # repo_files
                self.current_vanilla_files,    # vanilla_files
                self.last_zip_count          # zip_count
            )
            print("DEBUG: refresh_data_from_files - write_watcher_output() BEFORE read_favorites() called successfully.")
        except Exception as e:
            print(f"Warning: Error writing WatcherOutput.txt in refresh_data_from_files BEFORE read_favorites(): {e}")
        
        self.read_favorites()
        print("Calling self.perform_search() ...")
        self.perform_search()
        print("self.perform_search() RETURNED.")
        self.canvas.yview_moveto(0)
        print("Data refresh complete.")
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE
        print("--- ConfigViewerApp.refresh_data_from_files() EXIT ---\n")

        
        
    def find_image_path(self, folder_name, file_name):
        # Helps locate the correct file in config_pics_custom_folder
        if file_name.lower().startswith(f"vehicles--{folder_name.lower()}_user--"):
            file_name = file_name[len(f"vehicles--{folder_name}_user--"):]

        base_candidate = f"vehicles--{folder_name}_user--{file_name}"
        has_extension = any(file_name.lower().endswith(ext) for ext in ['.jpg', '.jpeg', '.png'])

        if has_extension:
            candidate = base_candidate
            for existing_file in os.listdir(self.config_pics_custom_folder):
                if existing_file.lower() == candidate.lower():
                    found_path = os.path.join(self.config_pics_custom_folder, existing_file)
                    return found_path
        else:
            for ext in ['jpg', 'jpeg', 'png']:
                candidate = f"{base_candidate}.{ext}"
                for existing_file in os.listdir(self.config_pics_custom_folder):
                    if existing_file.lower() == candidate.lower():
                        found_path = os.path.join(self.config_pics_custom_folder, existing_file)
                        return found_path
        return None



    def find_config_pic(self, candidate_image_name, config_pics_folder):
        """Helper function to find config pic path given a base name and folder."""
        for ext in ['jpg', 'jpeg', 'png']:
            check_name = f"{candidate_image_name}.{ext}"
            check_path = os.path.join(config_pics_folder, check_name)
            if os.path.exists(check_path):
                return check_path
        return None
        
        
    def generate_info_key(self, info_data):
        brand = info_data.get("Brand", "Unknown").strip()
        vehicle_type = info_data.get("Type", "Unknown").strip()
        return f"{brand}_{vehicle_type}"




            
    # ------------------------------------------------------------
    # Setup Main GUI
    # ------------------------------------------------------------
    def setup_gui(self):
        self.setup_main_window()
        self.setup_top_frame()
        self.setup_bottom_frame()
        self.setup_main_frame()
        self.setup_canvas_and_scrollbar()
        self.setup_scrollable_frame()
        self.setup_sidebar_frame()
        self.setup_sidebar_top_frame_content()
        self.setup_sidebar_bottom_frame_content()
        self.setup_event_bindings()
        self.initialize_data_and_grid()
        self.log_folder_names_on_startup() # <--- CALL THE NEW LOGGING FUNCTION HERE, AFTER GUI SETUP
        self.log_folder_names_cache_on_startup() # <--- CALL THE NEW CACHE LOGGING FUNCTION HERE

        self.periodically_update_search_results_window_position() # <--- ADD THIS LINE TO START PERIODIC CHECK
        self.periodically_update_details_window_position() # <--- ADD THIS LINE - PERIODIC UPDATE FOR DETAILS WINDOW
        
        
        # Bind hover event to top bar, sidebar, bottom bar, and scrollable canvas
        if hasattr(self, 'top_frame'):
            self.top_frame.bind("<Enter>", self.lift_search_results_window_without_destroying_dropdowns)
        if hasattr(self, 'sidebar_frame'):
            self.sidebar_frame.bind("<Enter>", self.lift_search_results_window_without_destroying_dropdowns)
        if hasattr(self, 'bottom_frame'):
            self.bottom_frame.bind("<Enter>", self.lift_search_results_window_without_destroying_dropdowns)
        #if hasattr(self, 'canvas'):
        #    self.canvas.bind("<Enter>", self.lift_search_results_window_without_destroying_dropdowns)
        if hasattr(self, 'scrollable_frame'):
            self.scrollable_frame.bind("<Enter>", self.lift_search_results_window_without_destroying_dropdowns)
 


    def log_folder_names_cache_on_startup(self):
        """
        Logs all folder names (keys) present in self.full_data_cache to 'folder_names_cache.txt' on startup.
        """
        log_file_path = os.path.join(self.script_dir, "data/folder_names_cache.txt")
        try:
            with open(log_file_path, "w", encoding="utf-8") as log_file:
                log_file.write("--- Folder Names Cache Log ---\n\n")
                if self.full_data_cache:
                    log_file.write("Folder names (keys) from self.full_data_cache:\n")
                    for folder_name in self.full_data_cache.keys(): # Iterate through keys (folder names)
                        log_file.write(f"{folder_name}\n")
                else:
                    log_file.write("self.full_data_cache is empty. No folder names to log from cache.\n")

                log_file.write("\n--- End of Folder Names Cache Log ---\n")
            print(f"Folder names from cache logged to: {log_file_path}")
        except Exception as e:
            print(f"Error writing folder names from cache to log file: {e}")

    def log_folder_names_on_startup(self):
        """
        Logs all folder names associated with each item in self.data to 'folder_names.txt' on startup.
        """
        log_file_path = os.path.join(self.script_dir, "data/folder_names.txt")
        try:
            with open(log_file_path, "w", encoding="utf-8") as log_file:
                log_file.write("--- Folder Names Log ---\n\n")
                if self.data:
                    log_file.write("Folder names from self.data:\n")
                    for item in self.data:
                        if len(item) == 5:  # Check if item tuple has expected length
                            folder_name = item[4] # Assuming folder_name is the 5th element
                            log_file.write(f"- {folder_name}\n")
                        else:
                            log_file.write(f"- Warning: Item tuple does not have expected length: {item}\n")
                else:
                    log_file.write("self.data is empty. No folder names to log.\n")

                log_file.write("\n--- End of Folder Names Log ---\n")
            print(f"Folder names logged to: {log_file_path}")
        except Exception as e:
            print(f"Error writing folder names to log file: {e}")

    def setup_main_window(self):
        self.master.title("Ellexium's Mod Manager/Vehicle Selector (ver. 0.1.8)")
        #self.master.geometry("2920x1080")
        self.master.resizable(False, False)

        icon_path = self.script_dir / "data/icon.png"

        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            self.master.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")

    def setup_top_frame(self):
        top_frame = tk.Frame(self.master, bg="#333333", pady=10)
        top_frame.pack(side="top", fill="x")

        self.create_search_bar(top_frame)
        self.create_top_buttons(top_frame)
        self.create_loading_label(top_frame)
        self.create_progress_bar_main(top_frame) # Progress bar in top frame


		
		
    def create_search_bar(self, top_frame):
        """Creates the search bar with updated styling to match the dark theme and light grey background."""
        #search_label = tk.Label(top_frame, text="Search:", bg="#333333", fg="lightgrey", font=("Segoe UI", 12)) # MODIFICATION: REMOVE Search: label
        #search_label.pack(side="left", padx=(10, 5)) # MODIFICATION: REMOVE Search: label
        self.search_var = tk.StringVar()
        self.search_entry = search_entry = tk.Entry(top_frame, textvariable=self.search_var, font=("Segoe UI", 12), width=30, bg="lightgrey", fg="black", insertbackground="black") # <-- UPDATED bg to "lightgrey", fg to "black", insertbackground to "black"

        # --- COPY BUTTON STYLES FROM TOP/BOTTOM FRAME BUTTONS ---
        button_style_args = {
            "bg": "#555555",
            "fg": "white", # MODIFICATION: Change search icon emoji to white
            "relief": tk.FLAT, # Flatten the buttons
            "bd": 0, # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            #"font":("Segoe UI", 12, "bold") # NO BOLD FONT for search icon button
        }
        # --- COPY BUTTON STYLES FROM TOP/BOTTOM FRAME BUTTONS ---

        search_button = tk.Button(
            top_frame,
            text="",
            font=("Segoe UI", 12), # Font for the icon, keep it non-bold
            command=self.perform_search,
            **button_style_args # <--- APPLY BUTTON STYLES
        )

        def on_search_icon_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_search_icon_hover_leave(event, original_bg="#555555", original_fg="white"):
            event.widget.config(bg=original_bg, fg=original_fg)

        def on_search_icon_click(event):
            event.widget.config(bg="white", fg="black")
            # After click effect, revert back to hover style (orange) on enter, or default on leave
            event.widget.bind("<Enter>", on_search_icon_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_search_icon_hover_leave(e, bg, fg))


        search_button.bind("<Enter>", on_search_icon_hover_enter)
        search_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_search_icon_hover_leave(event, bg, fg))
        search_button.bind("<Button-1>", on_search_icon_click)


        search_button.pack(side="left", padx=(10, 10)) # MODIFICATION: Put search icon on the LEFT side of search bar, increased padx on the right to 5 for space
        search_entry.pack(side="left", padx=(0, 10)) # MODIFICATION: Put search bar to the RIGHT of the search icon, added padx on the right


        #search_entry.bind("<Return>", lambda event: self.perform_search())
        
        search_entry.bind("<KeyRelease>", lambda event: self.start_debounce_highlighting()) # <--- MODIFIED: Bind KeyRelease to start_debounce_highlighting
        #search_entry.bind("<KeyRelease>", lambda event: self.lift_search_results_window())

        def delayed_lift(event):
            self.master.after(500, self.lift_search_results_window_without_destroying_dropdowns) # Schedule lift after 2 seconds

        #search_entry.bind("<KeyRelease>", delayed_lift) # NEW - Delayed lift


    def start_debounce_highlighting(self):
        """
        Starts the debounce timer for label highlighting.
        """
        if self.debounce_timer:
            self.master.after_cancel(self.debounce_timer) # Cancel existing timer

        #self.debounce_timer = self.master.after(2000, self.actual_label_highlighting) # Set new timer
        self.debounce_timer = self.master.after(1000, self.perform_search)
        #self.lift_search_results_window()
        

    def destroy_search_mode_options_dropdown(self, event=None):
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            self.search_mode_options_dropdown_window.destroy()
            self.search_mode_options_dropdown_window = None

            


        
        
    def create_top_buttons(self, top_frame):
        """Creates and packs all top buttons in the given frame."""

        button_style_args = self._create_button_style()
        on_button_hover_enter, on_button_hover_leave, on_button_click = self._create_button_event_handlers()

        self._initialize_search_mode()
        self._create_search_mode_button(top_frame, button_style_args, on_button_hover_enter, on_button_hover_leave, on_button_click)
        self._create_filters_button(top_frame, button_style_args, on_button_hover_enter, on_button_hover_leave, on_button_click)
        self._create_subset_data_button(top_frame, button_style_args, on_button_click) # click is different for this button

        # --- NEW: Dropdown Buttons ---
        self.create_player_vehicle_dropdown_button(top_frame)
        self.create_remove_vehicles_dropdown_button(top_frame)
        self.create_add_vehicles_dropdown_button(top_frame)

        # --- NEW: Dropdown Buttons ---

        #self._create_resize_button(top_frame, button_style_args, on_button_hover_enter, on_button_hover_leave, on_button_click)
        self._create_show_switcher_button(top_frame, button_style_args, on_button_hover_enter, on_button_hover_leave, on_button_click)

        self.create_loading_label(top_frame) # Keep loading label creation here, assuming it's related to top frame



    def show_remove_vehicles_dropdown(self):
        self._show_dropdown_menu(self.remove_vehicles_button, [
            ("Remove Current Vehicle", self.on_delete_single_button_click),
            ("Remove All Other Vehicles", self.on_delete_all_other_vehicles_button_click),
            ("Remove Moving Traffic Vehicles", self.on_delete_traffic_vehicles_button_click),
            ("Remove Parked Vehicles", self.on_delete_parked_vehicles_button_click),
            ("Remove Parked and Traffic Vehicles", self.on_delete_parked_and_traffic_vehicles_button_click),
        ], 'remove_vehicles_dropdown_window')

    def show_add_vehicles_dropdown(self):
        self._show_dropdown_menu(self.add_vehicles_button, [
            ("Spawn Traffic/Parked Vehicles", self.on_spawn_traffic_vehicles_button_click),
            ("Spawn Queue", self.show_spawn_queue_window),
        ], 'add_vehicles_dropdown_window')

    def show_player_vehicle_dropdown(self):
        self._show_dropdown_menu(self.player_vehicle_button, [
            ("Spawn Default Vehicle", self.on_spawn_default_button_click),
            ("Replace Current with Default Vehicle", self.on_replace_with_default_button_click),
            ("Save Current Vehicle as Default", self.on_save_current_as_default_button_click),
        ], 'player_vehicle_dropdown_window')
        

    def _show_dropdown_menu(self, parent_button, options, dropdown_name):
        if hasattr(self, dropdown_name) and getattr(self, dropdown_name) and getattr(self, dropdown_name).winfo_exists():
            getattr(self, dropdown_name).destroy()
            return

        button_x = parent_button.winfo_rootx()
        button_y = parent_button.winfo_rooty() + parent_button.winfo_height()

        setattr(self, dropdown_name, tk.Toplevel(self.master))
        dropdown_window = getattr(self, dropdown_name)
        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        dropdown_window.geometry(f"+{button_x}+{button_y}")
        dropdown_window.config(bg="#333333")
        dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        def on_dropdown_option_click(command):
            command()
            dropdown_window.destroy()
            setattr(self, dropdown_name, None)

        for option_text, command in options:
            dropdown_button = tk.Button(
                dropdown_window,
                text=option_text,
                font=("Segoe UI", 10, "bold"),
                command=lambda cmd=command: on_dropdown_option_click(cmd),
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5,
                bg="#555555",
                fg="white"
            )
            dropdown_button.pack(fill="x")
            dropdown_button.bind("<Enter>", lambda event, btn=dropdown_button: btn.config(bg="lightgrey", fg="black"))
            dropdown_button.bind("<Leave>", lambda event, btn=dropdown_button: btn.config(bg="#555555", fg="white")) # Default style

        dropdown_window.bind("<FocusOut>", lambda event: self.destroy_dropdown_menu(dropdown_name))


    def destroy_dropdown_menu(self, dropdown_name):
        if hasattr(self, dropdown_name) and getattr(self, dropdown_name) and getattr(self, dropdown_name).winfo_exists():
            getattr(self, dropdown_name).destroy()
            setattr(self, dropdown_name, None)
        
 
    def close_all_vehicle_dropdowns(self):
        """Closes all vehicle-related dropdown menus."""
        dropdowns_to_close = [
            'remove_vehicles_dropdown_window',
            'add_vehicles_dropdown_window',
            'player_vehicle_dropdown_window'
        ]
        for dropdown_name in dropdowns_to_close:
            print(f"Attempting to destroy dropdown: {dropdown_name}")
            self.destroy_dropdown_menu(dropdown_name)
            print(f"Dropdown {dropdown_name} (if open) should now be destroyed.")
        
   
    def create_player_vehicle_dropdown_button(self, top_frame):
        button_style_args = self._create_button_style()
        # --- MODIFIED: Set default text color to orange ---
        button_style_args["fg"] = self.global_highlight_color
        # --- MODIFIED: Set default text color to orange ---
        on_button_hover_enter, on_button_hover_leave, on_button_click = self._create_button_event_handlers()

        self.player_vehicle_button = tk.Button(
            top_frame,
            text="Player Vehicle",
            command=self.show_player_vehicle_dropdown,
            **button_style_args
        )
        # --- MODIFIED: Store default text color as attribute ---
        self.player_vehicle_button.default_fg_color = self.global_highlight_color
        # --- MODIFIED: Store default text color as attribute ---
        self._bind_button_events_custom_fg(self.player_vehicle_button, on_button_hover_enter, on_button_hover_leave, on_button_click, default_fg=self.global_highlight_color) # Passing default_fg
        self.player_vehicle_button.pack(side="left", padx=(80, 10))

    def create_remove_vehicles_dropdown_button(self, top_frame):
        button_style_args = self._create_button_style()
        # --- MODIFIED: Set default text color to red ---
        button_style_args["fg"] = "#ffa1a1"
        # --- MODIFIED: Set default text color to red ---
        on_button_hover_enter, on_button_hover_leave, on_button_click = self._create_button_event_handlers()

        self.remove_vehicles_button = tk.Button(
            top_frame,
            text="Remove Vehicles",
            command=self.show_remove_vehicles_dropdown,
            **button_style_args
        )
        # --- MODIFIED: Store default text color as attribute ---
        self.remove_vehicles_button.default_fg_color = "#ffa1a1"
        # --- MODIFIED: Store default text color as attribute ---
        self._bind_button_events_custom_fg(self.remove_vehicles_button, on_button_hover_enter, on_button_hover_leave, on_button_click, default_fg="red") # Passing default_fg
        self.remove_vehicles_button.pack(side="left", padx=(0, 10))

    def create_add_vehicles_dropdown_button(self, top_frame):
        button_style_args = self._create_button_style()
        # --- MODIFIED: Set default text color to green ---
        button_style_args["fg"] = "lightgreen"
        # --- MODIFIED: Set default text color to green ---
        on_button_hover_enter, on_button_hover_leave, on_button_click = self._create_button_event_handlers()

        self.add_vehicles_button = tk.Button(
            top_frame,
            text="Spawn Vehicles",
            command=self.show_add_vehicles_dropdown,
            **button_style_args
        )
        # --- MODIFIED: Store default text color as attribute ---
        self.add_vehicles_button.default_fg_color = "lightgreen"
        # --- MODIFIED: Store default text color as attribute ---
        self._bind_button_events_custom_fg(self.add_vehicles_button, on_button_hover_enter, on_button_hover_leave, on_button_click, default_fg="green") # Passing default_fg
        self.add_vehicles_button.pack(side="left", padx=(0, 10))



    def _bind_button_events_custom_fg(self, button, on_button_hover_enter, on_button_hover_leave, on_button_click, default_fg):
        """Binds common events to a button, now with custom default foreground color."""
        button.bind("<Enter>", on_button_hover_enter)
        # --- MODIFIED: Pass custom default_fg to on_button_hover_leave ---
        button.bind("<Leave>", lambda event, bg="#555555", fg=default_fg: on_button_hover_leave(event, bg, fg)) # Use custom default_fg
        # --- MODIFIED: Pass custom default_fg to on_button_hover_leave ---
        button.bind("<Button-1>", on_button_click)




    def _create_button_style(self):
        """Defines the common style arguments for buttons."""
        return {
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT,
            "bd": 0,
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font": ("Segoe UI", 12,)
        }

    def _create_button_event_handlers(self):
        """Creates and returns button event handler functions."""
        def on_button_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_button_hover_leave(event, original_bg="#555555", original_fg="white"): # original_fg is now generic
            # --- MODIFIED: Use event.widget.default_fg_color to restore custom default fg ---
            original_fg_dynamic = getattr(event.widget, 'default_fg_color', "white") # Fallback to "white" if not set
            event.widget.config(bg=original_bg, fg=original_fg_dynamic) # Use dynamic original_fg
            # --- MODIFIED: Use event.widget.default_fg_color to restore custom default fg ---

        def on_button_click(event):
            event.widget.config(bg="white", fg="black")
            # Revert to hover style on enter, default on leave after click effect
            event.widget.bind("<Enter>", on_button_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_button_hover_leave(e, bg, fg))
        return on_button_hover_enter, on_button_hover_leave, on_button_click

 

    def _initialize_search_mode(self):
        """Initializes the search mode attribute if not already present."""
        if not hasattr(self, 'search_mode'):
            print("Warning: self.search_mode attribute not initialized. Defaulting to 'General'.")
            self.search_mode = "General"

    def _create_search_mode_button(self, top_frame, button_style_args, on_button_hover_enter, on_button_hover_leave, on_button_click):
        """Creates and packs the Search Mode button."""
        self.search_mode_button = tk.Button(
            top_frame,
            text=f"Search Mode: {self.search_mode}",
            command=self.show_search_mode_options_dropdown,
            **button_style_args
        )
        self._bind_button_events(self.search_mode_button, on_button_hover_enter, on_button_hover_leave, on_button_click)
        self.search_mode_button.pack(side="left", padx=(0, 10))

    def _create_filters_button(self, top_frame, button_style_args, on_button_hover_enter, on_button_hover_leave, on_button_click):
        """Creates and packs the Filters button."""
        self.filters_button = tk.Button(
            top_frame,
            text="Vehicle Filters:",
            command=self.show_filters_window,
            **button_style_args
        )
        self._bind_button_events(self.filters_button, on_button_hover_enter, on_button_hover_leave, on_button_click)
        self.filters_button.pack(side="left", padx=(0, 0))

    def _create_subset_data_button(self, top_frame, button_style_args, on_button_click):
        """Creates and packs the Subset Data button."""
        self.subset_data_button = tk.Button(
            top_frame,
            text="Off",  # Initial text
            #command=self.toggle_data_subset, # Call the toggle function - disabled
            **button_style_args
        )
        self.subset_data_button.bind("<Button-1>") # Keep click binding - but no click action defined here.
        #self.subset_data_button.bind("<Button-1>", on_button_click) # Original click binding - but not needed as per original code
        self.subset_data_button.pack(side="left", padx=(0, 10))
        if not hasattr(self, 'is_data_subset_active'):  # Initialize if not yet
            self.is_data_subset_active = False  # Initialize flag



    def _create_resize_button(self, top_frame, button_style_args, on_button_hover_enter, on_button_hover_leave, on_button_click):
        """Creates and packs the Resize Window button."""
        self.resize_button = tk.Button(
            top_frame,
            text="Change Window Size",
            command=self.open_resize_window,
            **button_style_args
        )
        self._bind_button_events(self.resize_button, on_button_hover_enter, on_button_hover_leave, on_button_click)
        self.resize_button.pack(side="right", padx=(0, 10))

    def _create_show_switcher_button(self, top_frame, button_style_args, on_button_hover_enter, on_button_hover_leave, on_button_click):
        """Creates and packs the Show Switcher button."""
        self.show_switcher_button = tk.Button(
            top_frame,
            text="Show Switcher",
            command=self.toggle_floating_window_visibility,
            **button_style_args
        )
        self._bind_button_events(self.show_switcher_button, on_button_hover_enter, on_button_hover_leave, on_button_click)
        self.show_switcher_button.pack(side="right", padx=(0, 10))

    def _bind_button_events(self, button, on_button_hover_enter, on_button_hover_leave, on_button_click):
        """Binds common events to a button."""
        button.bind("<Enter>", on_button_hover_enter)
        button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_button_hover_leave(event, bg, fg))
        button.bind("<Button-1>", on_button_click)

        






    def is_settings_dropdown_open(self):
        return hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists()


    def create_categorize_button(self, bottom_frame):
        button_style_args = {
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT,
            "bd": 0,
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font":("Segoe UI", 12)
        }
        disabled_button_style_args = button_style_args.copy()  # Copy base style
        disabled_button_style_args["fg"] = "grey" # Grey text for disabled state
        disabled_button_style_args["activebackground"] = "#555555" # No click effect
        disabled_button_style_args["activeforeground"] = "grey"

        def on_bottom_button_hover_enter(event):
            if not self.is_search_results_window_active: # Check if search results window is NOT active
                event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_bottom_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            if not self.is_search_results_window_active: # Check if search results window is NOT active
                event.widget.config(bg=original_bg, fg=original_fg)

        def on_bottom_button_click(event):
            if not self.is_search_results_window_active: # Check if search results window is NOT active
                event.widget.config(bg="white", fg="black")
                # After click effect, revert back to hover style (orange) on enter, or default on leave
                event.widget.bind("<Enter>", on_bottom_button_hover_enter)
                event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_bottom_button_hover_leave(e, bg, fg))

        self.categorize_button = tk.Button(
            bottom_frame,
            text=f"Categorize by: {self.categorization_mode}",
            command=self.show_categorize_dropdown,
            **button_style_args
        )
        self.categorize_button.bind("<Enter>", on_bottom_button_hover_enter)
        self.categorize_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_bottom_button_hover_leave(event, bg, fg))
        self.categorize_button.bind("<Button-1>", on_bottom_button_click)
        self.categorize_button.pack(side="left", padx=(10, 0))

        if self.is_search_results_window_active: # Initially set button state based on window status
            self.categorize_button.config(state=tk.DISABLED, **disabled_button_style_args)
        else:
            self.categorize_button.config(state=tk.NORMAL, **button_style_args)
  
  


    def show_categorize_dropdown(self):
        if hasattr(self, 'categorize_dropdown_window') and self.categorize_dropdown_window and self.categorize_dropdown_window.winfo_exists():
            self.categorize_dropdown_window.destroy()
            return

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot change Categorization mode while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 
        
        button = self.categorize_button
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty()
        button_height = button.winfo_height()

        self.categorize_dropdown_window = tk.Toplevel(self.master)
        self.categorize_dropdown_window.overrideredirect(True)  # Remove window border
        self.categorize_dropdown_window.tk.call('tk', 'scaling', 1.25)  # Set to 100% scaling
        self.categorize_dropdown_window.geometry(f"+{button_x}+{button_y - 115}") # Position above button - adjust offset as needed
        self.categorize_dropdown_window.config(bg="#555555") # Dark grey background for dropdown
        self.categorize_dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        categorize_options = ["Type", "Country", "None"] # Define categorize options

        def on_categorize_option_click(option):
            self.categorization_mode = option
            self.categorize_button.config(text=f"Categorize by: {self.categorization_mode}")
            self.grouped_data = self.format_grouped_data(self.data) # Re-group data
            self.update_grid_layout() # Re-layout grid
            self.canvas.yview_moveto(0) # Reset scroll
            self.perform_search() # Re-apply search
            self.categorize_dropdown_window.destroy()
            self.categorize_dropdown_window = None


        for option in categorize_options:
            bg_color = "#555555"
            fg_color = "white"
            if option == self.categorization_mode: # Highlight current mode
                bg_color = self.global_highlight_color
                fg_color = "white"

            dropdown_button = tk.Button(
                self.categorize_dropdown_window,
                text=f"Categorize by: {option}", # Display "Categorize by: " prefix in dropdown
                font=("Segoe UI", 10, "bold"),
                command=lambda opt=option: on_categorize_option_click(opt),
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5,
                bg=bg_color,
                fg=fg_color
            )
            dropdown_button.pack(fill="x")
            dropdown_button.bind("<Enter>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg="lightgrey", fg="black"))
            dropdown_button.bind("<Leave>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg=original_bg, fg=original_fg))

        self.categorize_dropdown_window.bind("<FocusOut>", lambda event: self.destroy_categorize_dropdown())

        self._update_filters_label_status()
  
        
        

    def destroy_categorize_dropdown(self):
        self.is_search_results_window_closing = True # <--- SET FLAG BEFORE DESTROY
        if hasattr(self, 'categorize_dropdown_window') and self.categorize_dropdown_window and self.categorize_dropdown_window.winfo_exists():
            self.categorize_dropdown_window.destroy()
            self.categorize_dropdown_window = None
        self.is_search_results_window_closing = False # <--- RESET FLAG AFTER DESTROY

            
            
            
            
            
            
    def create_loading_label(self, top_frame):
        # Create the Loading label, initially hidden
        self.loading_label = tk.Label(
            top_frame,
            text="Loading...",
            bg="lightgrey",
            font=("Segoe UI", 12, "bold"),
            fg="blue"
        )
        #self.loading_label.pack(side="left", padx=(0, 10))  # Place it next to the Search button
        self.loading_label.pack_forget()  # Initially hidden

    def setup_bottom_frame(self):
        bottom_frame = tk.Frame(self.master, bg="#333333", pady=10)
        bottom_frame.pack(side="bottom", fill="x")
        # self.smooth_fade_in_frame(bottom_frame, start_color="#FFFFFF", end_color="#D3D3D3", steps=15, delay=30, exclude_widgets=[tk.Entry]) # Comment out or delete this line

        self.create_filter_button(bottom_frame)
        self.create_categorize_button(bottom_frame)
        self.create_category_list_button(bottom_frame) # <-- ADDED THIS LINE
        self.create_no_configs_message_label(bottom_frame)
        self.create_status_labels(bottom_frame)
        
        self.create_isolated_mods_button(bottom_frame)
        self.create_hidden_vehicles_button(bottom_frame)
        self.create_restart_button(bottom_frame)
        self.create_resize_button(bottom_frame)
        self.create_settings_button(bottom_frame)


        #self.create_item_count_label(bottom_frame) # Item count label in bottom frame


    def create_category_list_button(self, bottom_frame):
        button_style_args = {
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT,
            "bd": 0,
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font":("Segoe UI", 12)
        }
        disabled_button_style_args = button_style_args.copy()  # Copy base style
        disabled_button_style_args["fg"] = "grey" # Grey text for disabled state
        disabled_button_style_args["activebackground"] = "#555555" # No click effect
        disabled_button_style_args["activeforeground"] = "grey"

        def on_bottom_button_hover_enter(event):
            if not self.is_search_results_window_active: # Check if search results window is NOT active
                event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_bottom_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            if not self.is_search_results_window_active: # Check if search results window is NOT active
                event.widget.config(bg=original_bg, fg=original_fg)

        def on_bottom_button_click(event):
            if not self.is_search_results_window_active: # Check if search results window is NOT active
                event.widget.config(bg="white", fg="black")
                # After click effect, revert back to hover style (orange) on enter, or default on leave
                event.widget.bind("<Enter>", on_bottom_button_hover_enter)
                event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_bottom_button_hover_leave(e, bg, fg))

        self.category_list_button = tk.Button(
            bottom_frame,
            text="Category List",
            command=self.show_category_list_dropdown,
            **button_style_args
        )
        self.category_list_button.bind("<Enter>", on_bottom_button_hover_enter)
        self.category_list_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_bottom_button_hover_leave(event, bg, fg))
        self.category_list_button.bind("<Button-1>", on_bottom_button_click)
        self.category_list_button.pack(side="left", padx=(10, 0))

        if self.is_search_results_window_active: # Initially set button state based on window status
            self.category_list_button.config(state=tk.DISABLED, **disabled_button_style_args)
        else:
            self.category_list_button.config(state=tk.NORMAL, **button_style_args)
 


    def destroy_category_list_dropdown(self):
        self.is_search_results_window_closing = True # <--- SET FLAG BEFORE DESTROY
        if hasattr(self, 'category_list_dropdown_window') and self.category_list_dropdown_window and self.category_list_dropdown_window.winfo_exists():
            self.category_list_dropdown_window.destroy()
            self.category_list_dropdown_window = None
        self.is_search_results_window_closing = False # <--- RESET FLAG AFTER DESTROY





    # ------------------------------------------------------------         
    #   Global Filters
    # ------------------------------------------------------------




    def apply_data_subset_filter(self, data_list):
        """
        Filters data list based on data_subset files, now with FAVORITES MODE handling.

        - In Favorites Mode with Global Filters OFF: Behaves like regular Favorites mode (data_subset files ignored for main grid).
        - In Favorites Mode with Global Filters ON: Filters using data_subset_favorites.txt.
        - In Non-Favorites Mode: Filters using data_subset.txt as before.
        """
        if not hasattr(self, 'is_data_subset_active') or self.is_data_subset_active is None:
            self.is_data_subset_active = False

        if not self.is_data_subset_active:
            return data_list

        subset_lines = set()
        data_subset_file_path = "" # Initialize to empty string

        # Determine which subset file to use based on mode and filters
        if self.filter_state == 5 and self.filter_options[self.filter_state] == "Favorites": # Favorites Mode
            if self.is_data_subset_active: # Global Filters ON in Favorites Mode
                data_subset_file_path = os.path.join(self.script_dir, "data/data_subset_favorites.txt")
                print("DEBUG: apply_data_subset_filter - Favorites Mode AND Global Filters ON - Using data_subset_favorites.txt")
            else:
                # Favorites Mode but Global Filters OFF - data_subset files are ignored for main grid filtering
                print("DEBUG: apply_data_subset_filter - Favorites Mode BUT Global Filters OFF - Ignoring data_subset files for main grid.")
                return data_list # Return original data list - data_subset files are ignored in this case

        else: # NOT Favorites Mode - use regular data_subset.txt
            data_subset_file_path = os.path.join(self.script_dir, self.data_subset_file)
            print("DEBUG: apply_data_subset_filter - NOT Favorites Mode - Using data_subset.txt")


        if data_subset_file_path and os.path.exists(data_subset_file_path): # Check if file path is set AND file exists
            with open(data_subset_file_path, 'r', encoding="utf-8") as f:
                for line in f:
                    subset_line = line.strip()
                    if subset_line:
                        subset_lines.add(subset_line)
        elif data_subset_file_path: # File path is set but doesn't exist (and it's supposed to be used in current mode)
            print(f"Warning: Data subset file not found at: {data_subset_file_path}. Returning empty subset.")
            return [] # Return empty list if data subset file is expected but not found
        else: # No data_subset file path set for the current mode (e.g., Favorites Mode, Global Filters OFF)
            return data_list # Return original list if no filtering needed


        if not subset_lines:
            return []

        filtered_data = []
        for item in data_list:
            pic_path = item[0]
            if pic_path:
                pic_filename = os.path.basename(pic_path)
                folder_name = item[4]

                required_prefix = f"vehicles--{folder_name}"
                is_substring_found = False

                for subset_line in subset_lines:
                    normalized_required_prefix = required_prefix.strip().lower()
                    normalized_subset_line = subset_line.strip().lower()

                    if normalized_required_prefix in normalized_subset_line:
                        filtered_data.append(item)
                        is_substring_found = True
                        break


        return filtered_data
  






    def destroy_search_mode_option_tooltip_global_filter(self):
        if self.current_tooltip_global_filter_window:
            self.current_tooltip_global_filter_window.destroy()
            self.current_tooltip_global_filter_window = None
            self.tooltip_global_filter_original_bg_color = None

    def show_search_mode_option_tooltip_global_filter(self, entry_widget, tip_text, tooltip_color="#555555", disappear_delay=0): # Added color and delay
        if self.current_tooltip_global_filter_window:
            self.destroy_search_mode_option_tooltip_global_filter()

        self.current_tooltip_global_filter_window = tk.Toplevel(self.master)
        
        self.current_tooltip_global_filter_window.overrideredirect(True)
        self.current_tooltip_global_filter_window.tk.call('tk', 'scaling', 1.25)
        self.current_tooltip_global_filter_window.attributes("-topmost", True)

        tooltip_global_filter_label = tk.Label(self.current_tooltip_global_filter_window, text=tip_text, font=("Segoe UI", 10, "bold", "italic"), fg="lightgrey", bg=tooltip_color, padx=5, pady=2, relief=tk.SOLID, borderwidth=1) # Use tooltip_color
        tooltip_global_filter_label.pack(padx=1, pady=1)
        self.tooltip_global_filter_original_bg_color = tooltip_color # Set original color

        entry_width = entry_widget.winfo_width()
        entry_height = entry_widget.winfo_height()
        entry_abs_x = entry_widget.winfo_rootx()
        entry_abs_y = entry_widget.winfo_rooty()

        tooltip_global_filter_x = entry_abs_x + entry_width + 5
        tooltip_global_filter_y = entry_abs_y + (entry_height // 2) - (self.current_tooltip_global_filter_window.winfo_reqheight() // 2) + 88

        self.current_tooltip_global_filter_window.geometry(f"+{tooltip_global_filter_x}+{tooltip_global_filter_y}")
        self.current_tooltip_global_filter_window.after(9000, self.current_tooltip_global_filter_window.destroy)

        if disappear_delay > 0: # Implement disappear delay
            self.master.after(disappear_delay, self.destroy_search_mode_option_tooltip_global_filter)

    def show_error_tooltip_global_filter(self, entry_widget, tip_text): # Error tooltip function
        self.show_search_mode_option_tooltip_global_filter(entry_widget, tip_text, tooltip_color="red", disappear_delay=4000)

    def flash_tooltip_global_filter_orange(self):
        if self.current_tooltip_global_filter_window and self.tooltip_global_filter_original_bg_color:
            tooltip_global_filter_label = self.current_tooltip_global_filter_window.winfo_children()[0]
            original_color = self.tooltip_global_filter_original_bg_color
            tooltip_global_filter_label.config(bg="red")
            self.master.after(100, lambda: tooltip_global_filter_label.config(bg=original_color))

    def validate_numeric_input(self, new_text):
        return new_text.isdigit() or new_text == ""

    def toggle_on_off(self, button):
        if button.cget("text") == "Off":
            button.config(text="On")
        else:
            button.config(text="Off")

    def set_button_orange(self, button):
        button.config(bg=self.global_highlight_color, fg="white")

    def reset_button_color(self, button, on_off_button_style_args):
        button.config(bg=on_off_button_style_args["bg"], fg=on_off_button_style_args["fg"])

    def clear_filters_and_reset_buttons(self, entry_widgets, on_off_button_style_args):
        filter_settings = {} # Empty settings for clear action
        self.save_filter_settings(filter_settings) # Save empty settings

        for entry_key, entry in entry_widgets.items():
            if isinstance(entry, ttk.Entry):
                entry.delete(0, tk.END)
            if isinstance(entry_key, tuple):
                criterion, entry_index = entry_key
                if entry_index == 1:
                    button = entry_widgets.get((criterion, "button1"))
                else:
                    button = entry_widgets.get((criterion, "button2"))
            else:
                button = entry_widgets.get((entry_key, "button"))

            if button:
                button.config(text="Off")
                self.reset_button_color(button, on_off_button_style_args)

        print("GlobalFiltersCleared")



    def clear_all_filters_and_files(self, entry_widgets, on_off_button_style_args):
        self.clear_filters_and_reset_buttons(entry_widgets, on_off_button_style_args) # Clear filters and reset buttons first

        # Delete filter settings file if it exists
        if os.path.exists(self.filter_settings_file):
            os.remove(self.filter_settings_file)
            print(f"Deleted: {self.filter_settings_file}")
        else:
            print(f"File not found, cannot delete: {self.filter_settings_file}")

        # Delete filter output file if it exists
        if os.path.exists(self.filter_output_file):
            os.remove(self.filter_output_file)
            print(f"Deleted: {self.filter_output_file}")
        else:
            print(f"File not found, cannot delete: {self.filter_output_file}")

        if os.path.exists(self.data_subset_file):
           os.remove(self.data_subset_file)
           print(f"Deleted: {self.data_subset_file}")
        else:
            print(f"File not found, cannot delete: {self.data_subset_file}")

        self.is_data_subset_active = False # <--- ALWAYS TURN SUBSET DATA OFF when "Clear Filters" is clicked
        self.subset_data_button.config(text="Off") # Update button text
        self.reset_button_color(self.subset_data_button, self.button_style_args)
        self.perform_search()

        # --- MODIFICATION START: Conditionally close Search Results window on Clear ---
        if not self.search_var.get().strip() and self.filter_state == 0: # Check for empty search bar AND "View All" filter
            if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
                self.destroy_search_results_window()
                self.search_results_window = None
                self.is_search_results_window_active = False
                print("DEBUG: clear_all_filters_and_files - Search Results window DESTROYED (Clear button - Empty Search Bar AND View All Filter).")
            else:
                print("DEBUG: clear_all_filters_and_files - Search Results window NOT open, no need to destroy.") # DEBUG - Window Not Open
        else:
            print("DEBUG: clear_all_filters_and_files - Search Results window KEPT OPEN (Clear button - Search Bar NOT empty OR Filter NOT View All).") # DEBUG - Window Kept Open
        # --- MODIFICATION END: Conditionally close Search Results window on Clear ---

        print("Data Subset Mode: OFF (Set by Clear Filters)") # Debug print
        
   



    def update_button_on_entry_change(self, button, entry, on_off_button_style_args):
        if entry.get():
            button.config(text="On")
            self.set_button_orange(button)
        else:
            button.config(text="Off")
            self.reset_button_color(button, on_off_button_style_args)

    def apply_filters(self, entry_widgets):
        filter_settings = {}
        filters_output_string = ""
        filter_segments = []
        has_error = False

        # Check for contradictory Contains/DoesNotContain and invalid numeric ranges BEFORE applying filters
        for criterion in ["Brand", "Configuration", "Fuel Type", "Drivetrain", "Transmission"]:
            entry1 = entry_widgets.get((criterion, 1))
            entry2 = entry_widgets.get((criterion, 2))
            if entry1 and entry2 and entry1.get() and entry2.get() and entry1.get().lower() == entry2.get().lower():
                self.show_error_tooltip_global_filter(entry_widgets.get((criterion, 2)), "Cannot have the same value for Both")
                has_error = True
                break

        if not has_error:
            for criterion in self.numeric_criteria:
                entry1 = entry_widgets.get((criterion, 1))
                entry2 = entry_widgets.get((criterion, 2))
                if entry1 and entry2 and entry1.get() and entry2.get():
                    try:
                        below_value = float(entry1.get())
                        above_value = float(entry2.get())
                        if above_value >= below_value:
                            self.show_error_tooltip_global_filter(entry_widgets.get((criterion, 2)), "Above number Cannot be higher than or equal to Below")
                            has_error = True
                            break
                    except ValueError:
                        pass

        if has_error:
            return None

        for entry_key, entry in entry_widgets.items():
            if isinstance(entry, ttk.Entry):
                filter_text = entry.get()
                if isinstance(entry_key, tuple):
                    criterion, entry_index = entry_key
                    button_key = (criterion, f"button{entry_index}")
                    button_state = entry_widgets[button_key].cget("text")
                    filter_settings.setdefault(criterion, []).append({"entry": filter_text, "button": button_state, "index": entry_index})
                    if filter_text: # Only add to filter string if there is text in the entry, regardless of button state
                        if criterion == "Top Speed (km/h)":
                            try:
                                top_speed_kmh = float(filter_text)
                                top_speed_ms = top_speed_kmh / 3.6
                                filter_text_ms = f"{top_speed_ms:.2f}"
                            except ValueError:
                                filter_text_ms = filter_text
                            filter_text_display = filter_text_ms
                            filter_type = "Below (m/s)" if entry_index == 1 else "Above (m/s)"
                        elif criterion in self.numeric_criteria:
                            filter_type = "Below" if entry_index == 1 else "Above"
                            filter_text_display = filter_text
                        else:
                            filter_type = "Contains" if entry_index == 1 else "DoesNotContain"
                            filter_text_display = filter_text
                        if button_state == "On": # <--- ADDED CHECK FOR BUTTON STATE BEFORE ADDING TO FILTER STRING
                            filter_segments.append(f"{criterion}{filter_type} \"{filter_text_display}\"") # <--- ONLY ADD IF BUTTON IS ON AND ENTRY HAS TEXT
                else:
                    button_key = (entry_key, "button")
                    button_state = entry_widgets[button_key].cget("text")
                    filter_settings[entry_key] = {"entry": filter_text, "button": button_state}
                    if filter_text: # Only add to filter string if there is text in the entry, regardless of button state
                        filter_type = "Contains"
                        if button_state == "On": # <--- ADDED CHECK FOR BUTTON STATE BEFORE ADDING TO FILTER STRING
                            filter_segments.append(f"{entry_key}{filter_type} \"{filter_text}\"") # <--- ONLY ADD IF BUTTON IS ON AND ENTRY HAS TEXT

        filters_output_string = " | ".join(filter_segments)

        self.save_filter_settings(filter_settings)

        if not filters_output_string.strip():
            print("GlobalFiltersCleared")
            return
            filters_variable = ""
        else:
            print("GlobalFiltersApplied")
            print(filters_output_string.strip())
            filters_variable = filters_output_string.strip()
            print("-" * 20)

        #if self.filters_window and self.filters_window.winfo_exists():
        #    self.filters_window.destroy()
        #    self.filters_window = None
        
        self.set_button_orange(self.subset_data_button) # <--- SET BUTTON ORANGE when "On"
        return filters_variable
        


    def center_window(self, toplevel):
        toplevel.update_idletasks()
        master_width = self.master.winfo_width()
        master_height = self.master.winfo_height()
        master_x = self.master.winfo_rootx()
        master_y = self.master.winfo_rooty()

        toplevel_width = toplevel.winfo_reqwidth()
        toplevel_height = toplevel.winfo_reqheight()

        if toplevel_width == 1:
            geometry_str = toplevel.geometry()
            toplevel_width = int(geometry_str.split('x')[0])
            toplevel_height = int(geometry_str.split('x')[1].split('+')[0])

        x = master_x + (master_width - toplevel_width) // 2
        y = master_y + (master_height - toplevel_height) // 2

        toplevel.geometry(f"+{x}+{y}")

    def save_filter_settings(self, filter_settings):
        with open(self.filter_settings_file, 'w', encoding="utf-8") as f:
            for criterion, value in filter_settings.items():
                if isinstance(value, list): # For dual entries
                    line_parts = [criterion]
                    for item in value:
                        line_parts.extend([item['entry'], item['button']])
                    f.write(','.join(line_parts) + '\n')
                else: # For single entry
                    f.write(f"{criterion},{value['entry']},{value['button']}\n")

    def load_filter_settings(self):
        filter_settings = {}
        if os.path.exists(self.filter_settings_file):
            with open(self.filter_settings_file, 'r', encoding="utf-8") as f:
                for line in f:
                    parts = line.strip().split(',')
                    if not parts:
                        continue # Skip empty lines
                    criterion = parts[0]
                    if len(parts) == 3: # Single entry
                        filter_settings[criterion] = {"entry": parts[1], "button": parts[2]}
                    elif len(parts) > 3 and len(parts) % 2 == 1: # Dual entries
                        filter_settings[criterion] = []
                        for i in range(1, len(parts), 2):
                            filter_settings[criterion].append({"entry": parts[i], "button": parts[i+1], "index": (i // 2) + 1})
        return filter_settings

    def show_filters_window(self):
        """
        Shows the filters window.
        - Closes existing filters window if already open.
        - Prevents opening if details window is open.
        """
        print("DEBUG: show_filters_window - Function entry") # <-- DEBUG: Function entry


        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot use filters while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
            return # EXIT if in Configs search mode
        


        if self.search_mode == "Configs": # <--- CHECK SEARCH MODE HERE
            #messagebox.showinfo(
            #    "Filters Unavailable",
            #    "Please switch out of 'Search Mode: Configs' before trying to apply filters.",
            #    parent=app.master
            #)
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot use filters in Config Search mode.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
            return # EXIT if in Configs search mode


        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
            self.spawn_queue_window.destroy()

        if hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists():
            self.hidden_window.withdraw()
        

        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists():
            self.filters_window.focus_set()
            self.filters_window.deiconify()
            return


        if self.details_window and not self.details_window_closed:
            # Details window is open, prevent opening filters window and show messagebox
            print("DEBUG: show_filters_window - Details window is open - Condition is TRUE") # <-- DEBUG: Condition check - TRUE
            print(f"  DEBUG: self.details_window: {self.details_window}") # <-- DEBUG: Check window object
            print(f"  DEBUG: self.details_window_closed: {self.details_window_closed}") # <-- DEBUG: Check closed flag

            print("DEBUG: show_filters_window - Attempting to show messagebox...") # <-- DEBUG: Before messagebox
            #messagebox.showinfo(
            #    "Filters Unavailable",
            #    "Cannot adjust filters while configuration details window is open.",
            #    parent=app.master # Set parent to main window to keep messagebox on top
            #)
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust filters while configurations window is open.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
#            print("DEBUG: show_filters_window - Messagebox.showinfo() call COMPLETED.") # <-- DEBUG: After messagebox

            if self.filters_window and self.filters_window.winfo_exists():
                self.filters_window.focus_set()
                self.filters_window.deiconify() # If filters window is open but hidden behind, focus it
            print("DEBUG: show_filters_window - Existing filters window focused (if it exists).") # <-- DEBUG: Focus call
            return

        else:
            print("DEBUG: show_filters_window - Details window is NOT open or is closed - Condition is FALSE") # <-- DEBUG: Condition check - FALSE

        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists():
            print("DEBUG: show_filters_window - Filters window already open, destroying it.")
            #self.filters_window.destroy()
            self.filters_window.focus_set()
            self.filters_window.deiconify()
            #self.filters_window = None

        self.filters_window = filters_window = tk.Toplevel(self.master)
        filters_window.title("Filters")
        filters_window.geometry("655x528")
        #filters_window.attributes("-topmost", True)
        #filters_window.transient(self.master) #dont uncomment this line or remove it
        filters_window.resizable(False, False)
        filters_window.config(bg="#333333")
        #filters_window.overrideredirect(True) # Remove window border
        filters_window.tk.call('tk', 'scaling', 1.25) # Set to 100% scaling


        icon_path = self.script_dir / "data/icon.png"

        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            self.filters_window.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")


        filter_frame = tk.Frame(filters_window, padx=10, pady=10, bg="#333333")
        filter_frame.pack(fill=tk.BOTH, expand=True)


        self.center_window(filters_window)

        style = ttk.Style()
        style.theme_use('clam')
        label_font = ("Segoe UI", 12, "bold")
        entry_font = ("Segoe UI", 11)

        style.configure("DarkTheme.TLabel", background="#333333", foreground="white", font=label_font)
        style.configure("DarkTheme.TEntry", fieldbackground="lightgrey", foreground="black", lightcolor="lightgrey", borderwidth=1, relief="solid", font=entry_font)
        style.configure("Title.DarkTheme.TLabel", background="#333333", foreground="white", font=("Segoe UI", 14, "bold"))

        bottom_button_style_args = {
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT, # Make flat
            "bd": 0,          # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font":("Segoe UI", 12),
        }

        on_off_button_style_args = {
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT, # Make flat
            "bd": 0,          # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font":("Segoe UI", 10),
        }

        equal_width = 5
        button_entry_padx = 10
        top_speed_entry_button_space_padx = 12
        row_pady = 10

        text_filter_criteria = [
            "Brand",
            "Country", # <--- ADDED "Country" HERE, UNDER BRAND
            #"Configuration", #the issue with this is that it will not file specific configurations if they aren't named within the json file (or there's no json file at all
            "Fuel Type",
            "Drivetrain",
            "Transmission",
        ]
        numeric_filter_criteria = [
            "Top Speed (km/h)",
            "Power",
            "0-100 km/h",
            "Off-Road Score",
            "Braking G",
        ]
        filter_criteria = text_filter_criteria + numeric_filter_criteria # Combine lists in desired order


        row_num = 1
        title_label = ttk.Label(filter_frame, text="Filters", style="Title.DarkTheme.TLabel", anchor=tk.CENTER)
        title_label.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, row_pady))

        entry_widgets = {}
        contains_criteria = ["Brand", "Configuration", "Fuel Type", "Drivetrain", "Transmission", "Country"] # <--- ADDED "Country" HERE
        validation_command = (filters_window.register(self.validate_numeric_input), '%P')
        loaded_settings = self.load_filter_settings() # Load settings here

        for criterion in filter_criteria:
            label = ttk.Label(filter_frame, text=criterion, anchor="e", style="DarkTheme.TLabel")
            label.grid(row=row_num, column=0, sticky="ne", pady=(row_pady, 5), padx=(0, 5))

            if criterion in ["Top Speed (km/h)", "Power", "0-100 km/h", "Off-Road Score", "Braking G", "Brand", "Configuration", "Fuel Type", "Drivetrain", "Transmission", "Country"]: # <--- ADDED "Country" HERE
                entry_frame = tk.Frame(filter_frame, bg="#333333")
                entry_frame.grid(row=row_num, column=1, sticky="ew", pady=(row_pady, 5))

                # First Button and Entry
                on_off_button1 = tk.Button(entry_frame, text="Off", width=equal_width,
                                         **on_off_button_style_args)
                on_off_button1.pack(side=tk.LEFT, padx=(0, button_entry_padx))
                self.on_off_buttons_list.append(on_off_button1)
                entry_widgets[(criterion, "button1")] = on_off_button1

                entry1 = ttk.Entry(entry_frame, style="DarkTheme.TEntry", width=equal_width, font=entry_font,
                                     validate="key", validatecommand=validation_command if criterion in self.numeric_criteria else None)
                entry1.pack(side=tk.LEFT, fill="x", expand=True)

                entry1.bind("<KeyRelease>", lambda event, btn=on_off_button1, entry=entry1, style_args=on_off_button_style_args: self.update_button_on_entry_change(btn, entry, style_args))
                entry1.bind("<Button-2>", lambda event, entry=entry1, criterion=criterion, btn=on_off_button1, style_args=on_off_button_style_args: [entry.delete(0, tk.END), btn.config(text="Off"), self.reset_button_color(btn, style_args)])

                if criterion in self.numeric_criteria:
                    entry1.bind("<KeyPress>", lambda event, entry=entry1: self.flash_tooltip_global_filter_orange() if not (event.char.isdigit() or event.char == "") and event.keysym != "BackSpace" else None)

                if criterion == "Top Speed (km/h)":
                    tooltip_global_filter_text1 = "Below this number (km/h)"
                    tooltip_global_filter_text2 = "Above this number (km/h)"
                elif criterion in self.numeric_criteria:
                    tooltip_global_filter_text1 = "Below this number"
                    tooltip_global_filter_text2 = "Above this number"
                elif criterion in contains_criteria:
                    tooltip_global_filter_text1 = "Contains"
                    tooltip_global_filter_text2 = "Does not contain"
                else: # Default case - if needed for other criteria in the future
                    tooltip_global_filter_text1 = "Enter filter value" # Or some default text
                    tooltip_global_filter_text2 = "Enter filter value" # Or some default text, or leave empty if no second entry for these


                entry1.bind("<FocusIn>", lambda event, entry=entry1, text=tooltip_global_filter_text1: self.show_search_mode_option_tooltip_global_filter(entry, text))
                entry1.bind("<FocusOut>", lambda event: self.destroy_search_mode_option_tooltip_global_filter())
                entry_widgets[(criterion, 1)] = entry1

                # Second Button and Entry
                button2_padx = button_entry_padx
                if criterion == "Top Speed (km/h)":
                    button2_padx = top_speed_entry_button_space_padx
                else:
                    button2_padx = button_entry_padx
                on_off_button2 = tk.Button(entry_frame, text="Off", width=equal_width,
                                         **on_off_button_style_args)
                on_off_button2.pack(side=tk.LEFT, padx=(button2_padx, button_entry_padx))
                self.on_off_buttons_list.append(on_off_button2)
                entry_widgets[(criterion, "button2")] = on_off_button2

                entry2 = ttk.Entry(entry_frame, style="DarkTheme.TEntry", width=equal_width, font=entry_font,
                                     validate="key", validatecommand=validation_command if criterion in self.numeric_criteria else None)
                entry2.pack(side=tk.LEFT, fill="x", expand=True)
                entry2.bind("<KeyRelease>", lambda event, btn=on_off_button2, entry=entry2, style_args=on_off_button_style_args: self.update_button_on_entry_change(btn, entry, style_args))
                entry2.bind("<Button-2>", lambda event, entry=entry2, criterion=criterion, btn=on_off_button2, style_args=on_off_button_style_args: [entry.delete(0, tk.END), btn.config(text="Off"), self.reset_button_color(btn, style_args)])


                if criterion in self.numeric_criteria:
                    entry2.bind("<KeyPress>", lambda event, entry=entry2: self.flash_tooltip_global_filter_orange() if not (event.char.isdigit() or event.char == "") and event.keysym != "BackSpace" else None)


                entry2.bind("<FocusIn>", lambda event, entry=entry2, text=tooltip_global_filter_text2: self.show_search_mode_option_tooltip_global_filter(entry, text))
                entry2.bind("<FocusOut>", lambda event: self.destroy_search_mode_option_tooltip_global_filter())
                entry_widgets[(criterion, 2)] = entry2

                # Load saved settings if available
                if criterion in loaded_settings and isinstance(loaded_settings[criterion], list):
                    for setting in loaded_settings[criterion]:
                        if setting['index'] == 1:
                            entry1.insert(0, setting['entry'])
                            entry_widgets[(criterion, "button1")].config(text=setting['button'])
                            if setting['button'] == "On":
                                self.set_button_orange(entry_widgets[(criterion, "button1")])
                        elif setting['index'] == 2:
                            entry2.insert(0, setting['entry'])
                            entry_widgets[(criterion, "button2")].config(text=setting['button'])
                            if setting['button'] == "On":
                                self.set_button_orange(entry_widgets[(criterion, "button2")])
                elif criterion in loaded_settings and not isinstance(loaded_settings[criterion], list): # Single entry criteria
                    entry1 = entry_widgets.get((criterion, 1)) # Use entry1 here as single entry uses entry1 only in this setup
                    if entry1:
                        entry1.insert(0, loaded_settings[criterion]['entry'])
                        entry_widgets[(criterion, "button1")].config(text=loaded_settings[criterion]['button'])
                        if loaded_settings[criterion]['button'] == "On":
                            self.set_button_orange(entry_widgets[(criterion, "button1")])


                row_num += 1
            elif criterion not in ["Top Speed (km/h)", "Power", "0-100 km/h", "Off-Road Score", "Braking G", "Brand", "Configuration", "Fuel Type", "Drivetrain", "Transmission", "Country"]: # Single Entry Criteria # <--- ADDED "Country" HERE
                entry = ttk.Entry(filter_frame, style="DarkTheme.TEntry", font=entry_font) # Single Entry if not in dual entry criteria
                entry.grid(row=row_num, column=1, sticky="ew", pady=(row_pady, 5))
                on_off_button = tk.Button(filter_frame, text="Off", width=equal_width, **on_off_button_style_args)
                on_off_button.grid(row=row_num, column=2, sticky="w", padx=(button_entry_padx, 0), pady=(row_pady, 5))

                entry.bind("<KeyRelease>", lambda event, btn=on_off_button, entry=entry, style_args=on_off_button_style_args: self.update_button_on_entry_change(btn, entry, style_args))
                entry.bind("<Button-2>", lambda event, entry=entry, btn=on_off_button, style_args=on_off_button_style_args: [entry.delete(0, tk.END), btn.config(text="Off"), self.reset_button_color(btn, style_args)])

                entry_widgets[(criterion, 1)] = entry # Still using index 1 for consistency, but it's a single entry now.
                entry_widgets[(criterion, "button")] = on_off_button

                # Load saved settings for single entry criteria
                if criterion in loaded_settings and not isinstance(loaded_settings[criterion], list): # Ensure not list in case of previous dual setup
                    if 'entry' in loaded_settings[criterion] and 'button' in loaded_settings[criterion]:
                        entry.insert(0, loaded_settings[criterion]['entry'])
                        on_off_button.config(text=loaded_settings[criterion]['button'])
                        if loaded_settings[criterion]['button'] == "On":
                            self.set_button_orange(on_off_button)
                row_num += 1


        def clear_focus_on_click(event):
            if event.widget not in entry_widgets.values():
                filters_window.focus_set()
        filters_window.bind("<Button-1>", clear_focus_on_click)

        filter_frame.columnconfigure(1, weight=1)

        buttons_frame = tk.Frame(filters_window, bg="#333333", pady=10)
        buttons_frame.pack(side=tk.BOTTOM, fill=tk.X)

        apply_button = tk.Button(buttons_frame, text="Apply Filters", command=lambda: self.apply_filters_and_run_filter(entry_widgets), **bottom_button_style_args) # Modified command
        apply_button.pack(side=tk.LEFT, padx=10, expand=True, fill=tk.X)

        clear_button = tk.Button(buttons_frame, text="Clear", command=lambda: self.clear_all_filters_and_files(entry_widgets, on_off_button_style_args), **bottom_button_style_args)
        clear_button.pack(side=tk.RIGHT, padx=10, expand=True, fill=tk.X)

        def on_enter_apply_clear(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_leave_apply_clear(event):
            event.widget.config(bg="#555555", fg="white")

        apply_button.bind("<Enter>", on_enter_apply_clear)
        apply_button.bind("<Leave>", on_leave_apply_clear)
        clear_button.bind("<Enter>", on_enter_apply_clear)
        clear_button.bind("<Leave>", on_leave_apply_clear)


        #self.center_window()
        
        
  
        

        
        
    def apply_filters_and_run_filter(self, entry_widgets):
        """Applies filters and runs file filtering, added search window update."""

        # --- MODIFICATION START: Check if filters are empty ---
        filters_are_empty = True
        for entry_key, entry in entry_widgets.items():
            if isinstance(entry, ttk.Entry) and entry.get().strip():
                filters_are_empty = False
                break
            if isinstance(entry_key, tuple): # Check dual entry criteria too
                criterion, entry_index = entry_key
                if isinstance(entry, ttk.Entry) and entry.get().strip():
                    filters_are_empty = False
                    break
        if filters_are_empty:
            print("DEBUG: apply_filters_and_run_filter - No filters entered (all entries empty). Triggering Clear Filters behavior.")
            self.clear_all_filters_and_files(entry_widgets, self.button_style_args) # Use self.button_style_args
            return  # Exit early, mimicking Clear button behavior
        # --- MODIFICATION END: Check if filters are empty ---


        filters_variable = self.apply_filters(entry_widgets)
        if filters_variable is not None:
            self.filter_config_files(filters_variable)
            self.is_data_subset_active = True
            self.subset_data_button.config(text="On")
            self.perform_search()
            print("Data Subset Mode: ON (Set by Apply Filters)")
            self.update_search_results_window_ui()

            # --- MODIFICATION START: Open Search Results Window after applying filters ---
            if not hasattr(self, 'search_results_window') or not self.search_results_window or not self.search_results_window.winfo_exists():
                self.search_results_window = self._create_search_results_window(self.data) # Pass current data
                print("DEBUG: apply_filters_and_run_filter - Search Results window CREATED after applying filters.")
            self.search_results_window.lift() # Bring to front if already open
            print("DEBUG: apply_filters_and_run_filter - Search Results window LIFTED after applying filters.")
            # --- MODIFICATION END: Open Search Results Window after applying filters ---

        self.lift_search_results_window()





    def get_json_value_safe(self, data, key, regex_pattern=None):
        # No JSON decoding anymore - data is always a string
        if regex_pattern and isinstance(regex_pattern, str):
            try:
                match = re.search(regex_pattern, data, re.IGNORECASE | re.MULTILINE) # Added re.MULTILINE for multiline JSON
                if match:
                    return match.group(1).strip() if match.groups() else match.group(0).strip() # Return captured group or full match
            except: # Regex error, return None
                return None
        return None # Key not found and regex failed or not provided

    def _parse_filters(self, filters_string):
        """Parses the filter string into individual filter conditions."""
        filter_conditions = []
        brand_filter = None
        country_filter = None

        if not filters_string:
            print("No filters applied for file filtering.")
            return filter_conditions, brand_filter, country_filter

        for segment in filters_string.split(" | "):
            parts = re.split(r'(Contains|DoesNotContain|Below \(m/s\)|Above \(m/s\)|Below|Above)', segment)
            if len(parts) == 3:
                criterion = parts[0].strip() # Added strip here to remove potential leading/trailing spaces
                filter_type = parts[1]
                filter_value = parts[2].strip().strip('"')
                condition = {'criterion': criterion, 'type': filter_type, 'value': filter_value}
                filter_conditions.append(condition)
                if criterion == "Brand":
                    brand_filter = condition
                elif criterion == "Country":
                    country_filter = condition
        return filter_conditions, brand_filter, country_filter

    def _check_condition(self, file_content, condition, filename=""):
        """Checks if a single filter condition is met for a given file content, reading content directly."""
        criterion = condition['criterion']
        filter_type = condition['type']
        filter_value = condition['value']
        file_value = None

        if file_content is None:
            return False, f"Error: File content for {filename} is missing."

        if criterion == "Brand":
            file_value = self.get_json_value_safe(file_content, "Brand", r'"Brand"\s*:\s*"([^"]*)"')
        elif criterion == "Country":
            file_value = self.get_json_value_safe(file_content, "Country", r'"Country"\s*:\s*"([^"]*)"')
        elif criterion == "Configuration":
            file_value_json = self.get_json_value_safe(file_content, "Configuration", r'"Configuration"\s*:\s*"([^"]*)"')
            name_parts = filename.split('--info_info_')
            file_value_name = name_parts[1].replace(".json", "_", "-") if len(name_parts) > 1 else None
            file_value = file_value_json or file_value_name
        elif criterion == "Top Speed (km/h)":
            top_speed_ms_str = self.get_json_value_safe(file_content, "Top Speed", r'"Top Speed"\s*:\s*([\d.]*)')
            if top_speed_ms_str:
                try:
                    top_speed_ms = float(top_speed_ms_str)
                    file_value = top_speed_ms * 3.6
                except ValueError:
                    file_value = None
        elif criterion == "Power":
            file_value = self.get_json_value_safe(file_content, "Power", r'"Power"\s*:\s*([\d.]*)')
        elif criterion == "0-100 km/h":
            file_value = self.get_json_value_safe(file_content, "0-100 km/h", r'"0-100 km/h"\s*:\s*([\d.]*)')
        elif criterion == "Off-Road Score":
            file_value = self.get_json_value_safe(file_content, "Off-Road Score", r'"Off-Road Score"\s*:\s*([\d.]*)')
        elif criterion == "Braking G":
            file_value = self.get_json_value_safe(file_content, "Braking G", r'"Braking G"\s*:\s*([\d.]*)')
        elif criterion == "Fuel Type":
            file_value = self.get_json_value_safe(file_content, "Fuel Type", r'"Fuel Type"\s*:\s*"([^"]*)"')
        elif criterion == "Drivetrain":
            file_value = self.get_json_value_safe(file_content, "Drivetrain", r'"Drivetrain"\s*:\s*"([^"]*)"')
        elif criterion == "Transmission":
            file_value = self.get_json_value_safe(file_content, "Transmission", r'"Transmission"\s*:\s*"([^"]*)"')

        if file_value is None and filter_type not in ["Contains", "DoesNotContain"]:
            return False, f"{criterion}: Value not found in file."

        condition_met = False
        if filter_type == "Contains":
            condition_met = filter_value.lower() in str(file_value).lower() if file_value is not None else False
        elif filter_type == "DoesNotContain":
            condition_met = filter_value.lower() not in str(file_value).lower() if file_value is not None else True # Handle None as not containing
        elif filter_type in ["Below", "Above", "Below (m/s)", "Above (m/s)"]:
            try:
                file_value_float = float(str(file_value)) if file_value is not None else None
                filter_value_float = float(filter_value)
                if file_value_float is not None: # Only compare if file_value is valid number
                    if filter_type in ["Below", "Below (m/s)"]:
                        condition_met = file_value_float < filter_value_float
                    elif filter_type in ["Above", "Above (m/s)"]:
                        condition_met = file_value_float > filter_value_float
            except (ValueError, TypeError):
                condition_met = False # Handle non-numeric comparisons as not met

        if not condition_met and file_value is not None: # Only provide reason if we could get a file_value
             return False, f"{criterion} {filter_type} {filter_value}, but file has value: '{file_value}'"
        elif not condition_met:
            return False, f"{criterion} {filter_type} {filter_value}, but value could not be determined in file." # More generic reason for no file_value
        return True, None





    def _process_main_info_files(self, matches_data, brand_filter, country_filter, outfile): # Modified to take matches_data
        """Processes main info files from matches_data, applying brand and country filters."""
        main_info_brand_check_results = {}
        main_info_country_check_results = {}
        not_matched_files_details = []

        outfile.write("---\nProcessing Main Info Files (Brand/Country Check):\n")
        for entry in matches_data: # Iterate through matches_data
            filename = entry['filename']
            file_content = entry['content']
            if "INDIVIDUAL" in filename: # Skip individual files here
                continue

            brand_check_failed_reason = None
            country_check_failed_reason = None
            is_match = True

            if brand_filter:
                condition_met, reason = self._check_condition(file_content, brand_filter, filename)
                if not condition_met:
                    is_match = False
                    brand_check_failed_reason = reason

            if country_filter:
                condition_met, reason = self._check_condition(file_content, country_filter, filename)
                if not condition_met:
                    is_match = False
                    country_check_failed_reason = reason
                    if brand_check_failed_reason:
                        brand_check_failed_reason += f"; and {country_check_failed_reason}"
                    else:
                        brand_check_failed_reason = country_check_failed_reason # Reusing variable name for combined reason


            main_zip_name_match = re.search(r'vehicles--(.+?\.zip)--info\.json', filename, re.IGNORECASE)
            main_zip_name = main_zip_name_match.group(1) if main_zip_name_match else None
            outfile.write(f"DEBUG: Main File - Filename: {filename}, main_zip_name: '{main_zip_name}', Brand/Country Check Result: {not brand_check_failed_reason}\n")
            main_info_brand_check_results[main_zip_name] = not brand_check_failed_reason
            main_info_country_check_results[main_zip_name] = not country_check_failed_reason

            if brand_check_failed_reason:
                not_matched_files_details.append({'filename': filename, 'content_summary': file_content[:200] + "...", 'reasons': [brand_check_failed_reason]})
                outfile.write(f"  Filename: {filename} - Brand/Country Check Failed\n")
                outfile.write(f"  Reasons: {brand_check_failed_reason}\n")
                outfile.write("-" * 20 + "\n")
            else:
                outfile.write(f"  Filename: {filename} - Brand/Country Check Passed (or no brand/country filter)\n")
                outfile.write("-" * 20 + "\n")


        return main_info_brand_check_results, main_info_country_check_results, not_matched_files_details


    def _process_individual_files(self, matches_data, filter_conditions, main_info_brand_check_results, main_info_country_check_results, outfile): # Modified to take matches_data
        """Processes individual files from matches_data, applying filters and considering main info file results."""
        matched_files_details = []
        not_matched_files_details = []
        data_subset_pairs = []
        main_info_matched_for_subset = set()

        outfile.write("\n---\nProcessing Individual Files:\n")
        for entry in matches_data: # Iterate through matches_data
            filename = entry['filename']
            file_content = entry['content']
            if "INDIVIDUAL" not in filename: # Skip main files here
                continue

            is_match = True
            reasons_not_matched = []
            brand_check_failed = False
            country_check_failed = False

            individual_zip_name_match = re.search(r'vehicles--INDIVIDUAL--(.+?\.zip)--info_info_.*\.json', filename, re.IGNORECASE)
            individual_zip_name = individual_zip_name_match.group(1) if individual_zip_name_match else None

            related_main_info_brand_check_passed = True # Default if no brand filter
            related_main_info_country_check_passed = True # Default if no country filter

            if any(cond['criterion'] == "Brand" for cond in filter_conditions): # Check if brand filter is applied at all
                related_main_info_brand_check_passed = main_info_brand_check_results.get(individual_zip_name, False)
            if any(cond['criterion'] == "Country" for cond in filter_conditions): # Check if country filter is applied at all
                related_main_info_country_check_passed = main_info_country_check_results.get(individual_zip_name, True)


            outfile.write(f"DEBUG: Individual File - Filename: {filename}, individual_zip_name: '{individual_zip_name}', related_main_info_brand_check_passed: {related_main_info_brand_check_passed}, related_main_info_country_check_passed: {related_main_info_country_check_passed}\n")


            if not related_main_info_brand_check_passed:
                is_match = False
                brand_check_failed = True
                reasons_not_matched.append("Related Main File Failed Brand Check (or missing Main Info File with Brand Filter active)")

            if not related_main_info_country_check_passed:
                is_match = False
                country_check_failed = True
                if not brand_check_failed:
                    reasons_not_matched.append("Related Main File Failed Country Check (or missing Main Info File with Country Filter active)")


            if is_match: # Only proceed with other filters if main file brand/country check passed or no brand/country filter
                for condition in filter_conditions:
                    if condition['criterion'] in ["Brand", "Country"]: # Skip Brand and Country here, already handled
                        continue

                    condition_met, reason = self._check_condition(file_content, condition, filename)
                    if not condition_met:
                        is_match = False
                        reasons_not_matched.append(reason)


            if is_match:
                matched_files_details.append({'filename': filename, 'content_summary': file_content[:200] + "...", 'reasons': "Matched all criteria"})
                outfile.write(f"  Filename: {filename} - Matched\n")
                outfile.write(f"  Reasons: Matched all criteria\n")
                outfile.write("-" * 20 + "\n")
                individual_zip_name_match_subset = re.search(r'vehicles--INDIVIDUAL--(.+?\.zip)--info_info_.*\.json', filename, re.IGNORECASE) # Re-extract for subset pairing to ensure correct zip name
                individual_zip_name_subset = individual_zip_name_match_subset.group(1) if individual_zip_name_match_subset else None
                data_subset_pairs.append({'main_file': individual_zip_name_subset, 'individual_file': filename})
                main_info_matched_for_subset.add(individual_zip_name_subset)

            else:
                not_matched_files_details.append({'filename': filename, 'content_summary': file_content[:200] + "...", 'reasons': reasons_not_matched})
                outfile.write(f"  Filename: {filename} - Not Matched\n")
                outfile.write(f"  Reasons: {reasons_not_matched}\n")
                outfile.write("-" * 20 + "\n")


        return matched_files_details, not_matched_files_details, data_subset_pairs, main_info_matched_for_subset



    def _write_output_summary(self, outfile, matched_files_details, not_matched_files_details, data_subset_pairs, main_info_files_from_matches): # Modified to take main_info_files from matches data
        """Writes the summary of matched and not matched files to the output file."""
        outfile.write("\n---\n--- Matched Files Summary ---\n")
        for file_detail in matched_files_details:
            outfile.write(f"Filename: {file_detail['filename']}\n")
            outfile.write(f"Reasons: {file_detail['reasons']}\n")
            outfile.write("-" * 20 + "\n")

        outfile.write("\n---\n--- Not Matched Files Summary ---\n")
        for file_detail in not_matched_files_details:
            outfile.write(f"Filename: {file_detail['filename']}\n")
            outfile.write(f"Reasons: {file_detail['reasons']}\n")
            outfile.write("-" * 20 + "\n")

        main_info_files_written = set()

        outfile.write("\n---\n--- DEBUG LOGS ---\n") # <--- ADDED DEBUG LOG SECTION HEADER

        outfile.write("\n---\n--- Data Subset Files ---\n")
        for pair in data_subset_pairs:
            main_file_zip_name = pair['main_file']
            individual_file_name = pair['individual_file']

            main_info_filename = None
            for main_filename in main_info_files_from_matches: # Use main_info_files from matches data
                if main_file_zip_name and main_file_zip_name in main_filename:
                    main_info_filename = main_filename
                    break

            if main_info_filename and main_info_filename not in main_info_files_written:
                outfile.write(f"Subset Main File: {main_info_filename}\n")
                main_info_files_written.add(main_info_filename)

            if main_info_filename:
                outfile.write(f"Subset Individual File: {individual_file_name}\n")



    def filter_config_files(self, filters_string):
        """Filters configuration files based on the provided filter string, reading from matches.txt."""

        if not os.path.exists(self.configinfo_folder):
            print(f"Error: Configinfo folder '{self.configinfo_folder}' not found.")
            return

        filter_conditions, brand_filter, country_filter = self._parse_filters(filters_string)

        matches_file_path = os.path.join(self.script_dir, self.matches_txt) # Path to matches.txt
        matches_data = []
        main_info_files_from_matches = [] # To track main info files from matches.txt

        try:
            with open(matches_file_path, 'r', encoding="utf-8") as f:
                current_filename = None
                current_content_lines = []
                reading_content = False
                for line in f:
                    line = line.strip()
                    if not line:
                        continue # Skip empty lines

                    if not reading_content:
                        if line == '}': # Check if a '}' appears unexpectedly as a filename
                            #print(f"Warning: Unexpected 'curly brace' as filename in {self.matches_txt}. Skipping line.")
                            continue # Skip this line and move to the next
                        current_filename = line
                        reading_content = True
                        if "INDIVIDUAL" not in current_filename and "info.json" in current_filename: # Track main files from matches.txt
                            main_info_files_from_matches.append(current_filename)
                    elif line == '}': # Assuming JSON ends with '}' at the end of content
                        current_content_lines.append(line)
                        content = "\n".join(current_content_lines)
                        matches_data.append({'filename': current_filename, 'content': content})
                        current_filename = None  # Reset filename IMMEDIATELY after processing content
                        current_content_lines = []
                        reading_content = False
                    elif reading_content:
                        current_content_lines.append(line)

        except FileNotFoundError:
            print(f"Error: {self.matches_txt} file not found in script directory: {self.script_dir}")
            return
        except json.JSONDecodeError as e:
            print(f"Error decoding JSON in {self.matches_txt}: {e}")
            return


        matched_files_details = [] # Initialize here to be used if no outfile context
        not_matched_files_details = []
        data_subset_pairs = []
        main_info_brand_check_results = {}
        main_info_country_check_results = {}
        main_info_matched_for_subset = set()


        with open(self.filter_output_file, 'w', encoding="utf-8") as outfile, open("data/data_subset.txt", 'w', encoding="utf-8") as subset_outfile:
            outfile.write("Filter Results:\n\n")

            main_info_brand_check_results, main_info_country_check_results, not_matched_files_details_main = self._process_main_info_files(
                matches_data, brand_filter, country_filter, outfile # Pass matches_data
            )
            not_matched_files_details.extend(not_matched_files_details_main) # Combine not matched from main files

            matched_files_details_ind, not_matched_files_details_ind, data_subset_pairs, main_info_matched_for_subset = self._process_individual_files(
                matches_data, filter_conditions, main_info_brand_check_results, main_info_country_check_results, outfile # Pass matches_data
            )
            matched_files_details.extend(matched_files_details_ind) # Combine matched from individual files
            not_matched_files_details.extend(not_matched_files_details_ind) # Combine not matched from individual files


            self._write_output_summary(outfile, matched_files_details, not_matched_files_details, data_subset_pairs, main_info_files_from_matches) # Pass main_info_files from matches

            main_info_files_written = set()
            for pair in data_subset_pairs:
                main_file_zip_name = pair['main_file']
                individual_file_name = pair['individual_file']

                main_info_filename = None
                for main_filename in main_info_files_from_matches: # Iterate from main_info_files_from_matches
                    if main_file_zip_name and main_file_zip_name in main_filename:
                        main_info_filename = main_filename
                        break

                if main_info_filename and main_info_filename not in main_info_files_written:
                    subset_outfile.write(f"{main_info_filename}\n")
                    main_info_files_written.add(main_info_filename)

                if main_info_filename:
                    subset_outfile.write(f"{individual_file_name}\n")


        print(f"Filter results written to {self.filter_output_file}")
        print(f"Data subset file list written to data_subset.txt")

        transformed_lines = self.process_individual_lines() # Assuming this method exists in your class

        if transformed_lines is not None:
            with open("data/data_subset.txt", 'w', encoding="utf-8") as subset_outfile: # Reopen to overwrite or consider different logic
                for line in transformed_lines:
                    subset_outfile.write(f"{line}\n")
            print(f"Transformed image file list written to data_subset.txt (overwritten)")
        else:
            print("No transformed lines generated or error in processing.")

        # Assuming generate_data_subset_favorites is a function you want to call
        # and it's defined elsewhere or needs to be defined within the class
        if hasattr(self, 'generate_data_subset_favorites'): # Check if it's a method of the class
            self.generate_data_subset_favorites(self.script_dir)
        elif 'generate_data_subset_favorites' in globals(): # Check if it's a global function (less likely in class context)
            generate_data_subset_favorites(self.script_dir) # Call as global function
        else:
            print("Warning: generate_data_subset_favorites function not found or not callable as class method.") # Handle if function is missing
 



    def process_individual_lines(self):
        """
        Reads the data_subset_file, processes lines containing '--INDIVIDUAL--',
        and returns a list of transformed lines, checking for file existence in ConfigPics.
        Includes the original line before the transformed lines in the output.

        For lines with '--INDIVIDUAL--', it:
        - Removes '--INDIVIDUAL--'
        - Removes 'info_info_'
        - Changes the extension to jpg, png, and jpeg, creating three lines for each original line.
        - Checks if the file exists in the ConfigPics folder before adding to output.
        - Includes the original input line before the generated lines.

        Returns:
            list: A list of strings, where each string is a processed line,
                  with original lines preceding their transformed counterparts if applicable.
        """
        transformed_lines = []
        try:
            #script_dir = os.path.dirname(os.path.abspath(__file__))
            config_pics_dir = os.path.join(self.script_dir, "data/ConfigPics")

            with open(self.data_subset_file, 'r', encoding="utf-8") as f:
                for line in f:
                    original_input_line = line.strip() # Store the original stripped line for later use
                    line = original_input_line # Use stripped line for processing
                    if "--INDIVIDUAL--" in line:
                        # Process individual line
                        transformed_lines.append(original_input_line) # Add the original line first

                        parts = line.split('--')
                        if len(parts) >= 4: # Ensure enough parts to process
                            base_path = parts[0]
                            zip_name = parts[2] # parts[1] is INDIVIDUAL which we remove
                            info_part = parts[3]

                            # Remove "info_info_" and get the identifier
                            identifier_with_ext = info_part.replace("info_info_", "")

                            if "." in identifier_with_ext:
                                identifier, old_ext = identifier_with_ext.rsplit('.', 1) # Split once at the first dot

                                base_output_line = f"{base_path}--{zip_name}--{identifier}"
                                extensions = ["jpg", "png", "jpeg"]
                                for ext in extensions:
                                    transformed_line = f"{base_output_line}.{ext}"
                                    file_path_to_check = os.path.join(config_pics_dir, transformed_line)
                                    if os.path.exists(file_path_to_check):
                                        transformed_lines.append(transformed_line)
                    # If you want to keep lines without --INDIVIDUAL-- as they are in the output file, uncomment this:
                    # else:
                    #     transformed_lines.append(original_input_line) # Append original line if not processed

        except FileNotFoundError:
            print(f"Error: File not found: {self.data_subset_file}")
            return [] # Or handle the error as needed

        return transformed_lines
        



    def edit_file_with_transformed_lines(self):
        """
        Processes the data_subset_file and overwrites it with the transformed lines.
        If you uncommented the `else` part in `process_individual_lines`, it will
        also keep the original lines that were not transformed in the output file.
        """
        transformed_lines = self.process_individual_lines()
        try:
            with open(self.data_subset_file, 'w', encoding="utf-8") as f: # Open file in write mode ('w' to overwrite)
                for line in transformed_lines:
                    f.write(line + '\n') # Write each transformed line to the file
            print(f"File '{self.data_subset_file}' updated with transformed lines.")
        except Exception as e:
            print(f"Error writing to file '{self.data_subset_file}': {e}")

    def toggle_data_subset(self):
        """Toggles data subset mode, added search window update."""
        pass #remove comment if you want to re-enable the toggle data subset button. # clicking on the button itself is disabled to prevent empty filters from being applied, don't remove comment
        if self.details_window and not self.details_window_closed:
            messagebox.showinfo(
                "Filter State Switching Unavailable",
                "Cannot adjust filters while configuration details window is open.",
                parent=self.master
            )
            return
        else:
            print("DEBUG: show_filters_window - Details window is NOT open or is closed - Condition is FALSE")

        if self.search_mode == "Configs":
            messagebox.showinfo(
                "Subset Data Unavailable",
                "Please switch out of 'Search Mode: Configs' before toggling Filters.",
                parent=self.master
            )
            return

        if not hasattr(self, 'is_data_subset_active'):
            self.is_data_subset_active = False

        self.is_data_subset_active = not self.is_data_subset_active
        if self.is_data_subset_active:
            self.subset_data_button.config(text="On")
            self.set_button_orange(self.subset_data_button)
        else:
            self.subset_data_button.config(text="Off")
            self.reset_button_color(self.subset_data_button, self.button_style_args)
        self.perform_search()
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE

       
        
        

    #   Global Filters End
    # ------------------------------------------------------------


    def create_filter_button(self, bottom_frame):
        button_style_args = { # Re-define button_style_args here to remove "bold" font
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT, # Flatten the buttons
            "bd": 0, # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font":("Segoe UI", 12) # REMOVE BOLD FONT - for bottom frame buttons
        }

        def on_bottom_button_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_bottom_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            event.widget.config(bg=original_bg, fg=original_fg)

        def on_bottom_button_click(event):
            event.widget.config(bg="white", fg="black")
            # After click effect, revert back to hover style (orange) on enter, or default on leave
            event.widget.bind("<Enter>", on_bottom_button_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_bottom_button_hover_leave(e, bg, fg))


        self.filter_button = tk.Button(
            bottom_frame,
            text=f"{self.filter_options[self.filter_state]} [0]",
            #font=("Segoe UI", 12), # Removed redundant font argument HERE
            command=self.show_filter_dropdown,
            **button_style_args # Apply the button styles
        )
        self.filter_button.bind("<Enter>", on_bottom_button_hover_enter)
        self.filter_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_bottom_button_hover_leave(event, bg, fg))
        self.filter_button.bind("<Button-1>", on_bottom_button_click)
        self.filter_button.pack(side="left", padx=(10, 0))


    def show_filter_dropdown(self):
        if hasattr(self, 'filter_dropdown_window') and self.filter_dropdown_window and self.filter_dropdown_window.winfo_exists():
            self.filter_dropdown_window.destroy()
            return

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot change main filter mode while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 
        
        button = self.filter_button
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty()
        button_height = button.winfo_height()

        self.filter_dropdown_window = tk.Toplevel(self.master)
        self.filter_dropdown_window.overrideredirect(True) # Remove window border
        self.filter_dropdown_window.geometry(f"+{button_x}+{button_y - 151}") # Position 220 pixels above
        self.filter_dropdown_window.tk.call('tk', 'scaling', 1.25)
        self.filter_dropdown_window.config(bg="#333333") # Dark grey background for dropdown
        self.filter_dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        def on_dropdown_button_click(index):
            self.filter_state = index # <--- FIX: Correctly update filter_state
            current_filter = self.filter_options[self.filter_state]
            self.filter_button.config(text=f"{current_filter} [0]")
            self.filter_dropdown_window.destroy()
            self.filter_dropdown_window = None

            # --- NEW: Reset Brand, Name, Bodystyle, and Country filters to "All..." when main filter changes ---
            brand_button = self.sidebar_filter_buttons.get("Brand")
            if brand_button:
                brand_button.config(text="All Brands")

            name_button = self.sidebar_filter_buttons.get("Name") # <--- Get Name button
            if name_button:
                name_button.config(text="All Names") # <--- Reset Name button to "All Names"

            bodystyle_button = self.sidebar_filter_buttons.get("Bodystyle") # <--- Get Bodystyle button
            if bodystyle_button:
                bodystyle_button.config(text="All BodyStyles") # <--- Reset Bodystyle button to "All BodyStyles"

            country_button = self.sidebar_filter_buttons.get("Country") # <--- Get Country button
            if country_button:
                country_button.config(text="All Countries") # <--- Reset Country button to "All Countries"
            # --- NEW: Reset Brand, Name, Bodystyle, and Country filters to "All..." when main filter changes ---


            self.perform_search() # <--- FIX: Call perform_search here to apply filter

            # --- MODIFICATION START: Open Search Results Window for non-"View All" filters ---
            if self.filter_state != 0: # Check if the selected filter is NOT "View All" (index 0)
                if not hasattr(self, 'search_results_window') or not self.search_results_window or not self.search_results_window.winfo_exists():
                    self.search_results_window = self._create_search_results_window(self.data) # Pass current data
                    print("DEBUG: show_filter_dropdown - Search Results window CREATED due to filter change (non-'View All').")
                self.search_results_window.lift() # Bring to front if already open
                print("DEBUG: show_filter_dropdown - Search Results window LIFTED.")


            elif hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
                # --- MODIFIED CONDITION: Check if search bar is EMPTY AND GLOBAL FILTERS ARE OFF before destroying ---
                if not self.search_var.get().strip() and not self.is_data_subset_active: # Check for empty search AND global filters OFF
                    self.destroy_search_results_window() # Close Search Results window if switching back to "View All" AND search bar is empty AND global filters are OFF
                    self.search_results_window = None
                    self.is_search_results_window_active = False
                    print("DEBUG: show_filter_dropdown - Search Results window DESTROYED (switching back to 'View All' AND search bar EMPTY AND Global Filters OFF).")
                else:
                    print("DEBUG: show_filter_dropdown - Keeping Search Results window OPEN (switching back to 'View All' BUT search bar NOT empty OR Global Filters ON).") # DEBUG - Window Kept Open
            # --- MODIFICATION END: Open Search Results Window for non-"View All" filters ---

            if hasattr(self, 'categorize_dropdown_window') and self.categorize_dropdown_window and self.categorize_dropdown_window.winfo_exists():

                self.categorize_dropdown_window.destroy()
                self.categorize_dropdown_window = None

        # --- MODIFICATION: Filter out the items to be hidden ---
        filtered_options_list = [option for index, option in enumerate(self.filter_options) if index not in [1, 2, 3]] # Indices of "Items with Config Preview Images [debug]", "Items Without Config Preview Images [debug]", "Only Mods"
        # --- MODIFICATION: Filter out the items to be hidden ---


        for index, option in enumerate(filtered_options_list): # Corrected enumerate here, now iterating over filtered list
            bg_color = "#555555" # Default medium grey background
            fg_color = "white" # Default white foreground


            if option == self.filter_options[self.filter_state]: # Compare against original list for highlighting
                bg_color = self.global_highlight_color # Orange background for current filter
                fg_color = "white" # White text for visibility on orange


            dropdown_button = tk.Button(
                self.filter_dropdown_window,
                text=option,
                font=("Segoe UI", 10, "bold"),
                command=lambda idx=self.filter_options.index(option): on_dropdown_button_click(idx), # <--- MODIFIED: Use original index from self.filter_options
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5,
                bg=bg_color, # Set background color here
                fg=fg_color,  # Set foreground color here
            )
            dropdown_button.pack(fill="x")
            dropdown_button.bind("<Enter>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg="lightgrey", fg="black")) # Store original bg and fg, set fg to black on hover
            dropdown_button.bind("<Leave>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg=original_bg, fg=original_fg)) # Revert to original bg and fg

        # Bind focus out to close the dropdown if clicked outside
        self.filter_dropdown_window.bind("<FocusOut>", lambda event: self.destroy_filter_dropdown())

        self._update_filters_label_status()
 

    def set_filter_to_view_all_and_turn_subset_off(self):
        """
        Sets the filter state to 'View All' and updates the UI accordingly.
        """
        view_all_index = 0 
        if 0 <= view_all_index < len(self.filter_options):
            self.filter_state = view_all_index
            current_filter = self.filter_options[self.filter_state]
            self.filter_button.config(text=f"{current_filter} [0]") # Update button text

            if self.filters_window and self.filters_window.winfo_exists():
                self.filters_window.destroy()
                self.filters_window = None

            # Clear Global Filters and Reset Buttons
            entry_widgets = {}
            on_off_button_style_args = self._create_button_style() # Or however you get button style args
            self.clear_all_filters_and_files(entry_widgets, on_off_button_style_args)


            # Disable Subset Mode
            self.is_data_subset_active = False
            self.subset_data_button.config(text="Off")
            self.reset_button_color(self.subset_data_button, self.button_style_args)

            self.search_var.set("")
            self.perform_search() 
            print("Filter set to 'View All'.")
        else:
            print("Error: 'View All' filter option not found.")



    def destroy_filter_dropdown(self):
        self.is_search_results_window_closing = True # <--- SET FLAG BEFORE DESTROY
        if hasattr(self, 'filter_dropdown_window') and self.filter_dropdown_window and self.filter_dropdown_window.winfo_exists():
            self.filter_dropdown_window.destroy()
            self.filter_dropdown_window = None
        self.is_search_results_window_closing = False # <--- RESET FLAG AFTER DESTROY
 
  
    def create_status_labels(self, bottom_frame):
        self.deleting_label = tk.Label(bottom_frame, text="", bg="#333333", fg="lightgrey", font=("Segoe UI", 12, "bold")) # Dark bg, lightgrey fg
        self.deleting_label.pack(side="left", expand=True, padx=(10, 0))




    def create_no_configs_message_label(self, bottom_frame):
        """Creates the 'No configurations available' label, initially hidden."""
        self.no_configs_label = tk.Label(
            bottom_frame,
            text="No configurations available for vehicle under filter restrictions",
            bg="#333333",
            fg=self.global_highlight_color,
            font=("Segoe UI", 12, "bold")
        )
        self.no_configs_label.pack(side="left", padx=(10, 0))  # Pack BEFORE settings button
        self.no_configs_label.pack_forget()  # Initially hidden


    def hide_no_configs_label(self):
        """Hides the 'No configurations available' label."""
        self.no_configs_label.pack_forget()

        if self.scanning_window:
            self.scanning_window.destroy()

        self.scanning_window = None


    def create_isolated_mods_button(self, bottom_frame):
        button_style_args = { # Re-define button_style_args here to remove "bold" font
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT, # Flatten the buttons
            "bd": 0, # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font":("Segoe UI", 12) # REMOVE BOLD FONT - for bottom frame buttons
        }

        def on_bottom_button_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_bottom_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            event.widget.config(bg=original_bg, fg=original_fg)

        def on_bottom_button_click(event):
            event.widget.config(bg="white", fg="black")
            # After click effect, revert back to hover style (orange) on enter, or default on leave
            event.widget.bind("<Enter>", on_bottom_button_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_bottom_button_hover_leave(e, bg, fg))


        self.isolated_mods_button = tk.Button(bottom_frame, text="Isolated Mods", #font=("Segoe UI", 12), # Removed redundant font argument HERE
                                        command=self.open_isolated_folder_in_explorer,
                                        **button_style_args # Apply the button styles
        )
        self.isolated_mods_button.bind("<Enter>", on_bottom_button_hover_enter)
        self.isolated_mods_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_bottom_button_hover_leave(event, bg, fg))
        self.isolated_mods_button.bind("<Button-1>", on_bottom_button_click)
        self.isolated_mods_button.pack(side="left", padx=(0, 10))



    def create_hidden_vehicles_button(self, bottom_frame):
        button_style_args = { # Re-define button_style_args here to remove "bold" font
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT, # Flatten the buttons
            "bd": 0, # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font":("Segoe UI", 12) # REMOVE BOLD FONT - for bottom frame buttons
        }

        def on_bottom_button_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_bottom_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            event.widget.config(bg=original_bg, fg=original_fg)

        def on_bottom_button_click(event):
            event.widget.config(bg="white", fg="black")
            # After click effect, revert back to hover style (orange) on enter, or default on leave
            event.widget.bind("<Enter>", on_bottom_button_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_bottom_button_hover_leave(e, bg, fg))


        self.hidden_vehicles_button = tk.Button(bottom_frame, text="Hidden Vehicles", #font=("Segoe UI", 12), # Removed redundant font argument HERE
                                        command=self.show_hidden_vehicles_window,
                                        **button_style_args # Apply the button styles
        )
        self.hidden_vehicles_button.bind("<Enter>", on_bottom_button_hover_enter)
        self.hidden_vehicles_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_bottom_button_hover_leave(event, bg, fg))
        self.hidden_vehicles_button.bind("<Button-1>", on_bottom_button_click)
        self.hidden_vehicles_button.pack(side="left", padx=(0, 10))



    def create_settings_button(self, bottom_frame):
        button_style_args = { # Re-define button_style_args here to remove "bold" font
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT, # Flatten the buttons
            "bd": 0, # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font":("Segoe UI", 12) # REMOVE BOLD FONT - for bottom frame buttons
        }

        def on_bottom_button_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_bottom_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            event.widget.config(bg=original_bg, fg=original_fg)

        def on_bottom_button_click(event):
            event.widget.config(bg="white", fg="black")
            # After click effect, revert back to hover style (orange) on enter, or default on leave
            event.widget.bind("<Enter>", on_bottom_button_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_bottom_button_hover_leave(e, bg, fg))


        self.settings_button = tk.Button(bottom_frame, text="Settings", #font=("Segoe UI", 12), # Removed redundant font argument HERE
                                        command=self.show_settings_dropdown,
                                        **button_style_args # Apply the button styles
        )
        self.settings_button.bind("<Enter>", on_bottom_button_hover_enter)
        self.settings_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_bottom_button_hover_leave(event, bg, fg))
        self.settings_button.bind("<Button-1>", on_bottom_button_click)
        self.settings_button.bind("<Button-3>", self.on_settings_button_right_click)
        self.settings_button.pack(side="right", padx=(10, 10))







    def create_restart_button(self, bottom_frame):
        button_style_args = { # Re-define button_style_args here to remove "bold" font
            "bg": "#555555",
            "fg": self.restart_button_active_fg_color,
            "relief": tk.FLAT, # Flatten the buttons
            "bd": 0, # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font":("Segoe UI", 12) # REMOVE BOLD FONT - for bottom frame buttons
        }

        def on_bottom_button_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_bottom_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            event.widget.config(bg=original_bg, fg=original_fg)

        def on_bottom_button_click(event):
            event.widget.config(bg="white", fg="black")
            # After click effect, revert back to hover style (orange) on enter, or default on leave
            event.widget.bind("<Enter>", on_bottom_button_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_bottom_button_hover_leave(e, bg, fg))


        self.restart_button = tk.Button(bottom_frame, text="Restart", #font=("Segoe UI", 12), # Removed redundant font argument HERE
                                        command=self.restart_script_and_save_settings,
                                        **button_style_args # Apply the button styles
        )
        self.restart_button.bind("<Enter>", on_bottom_button_hover_enter)
        self.restart_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_bottom_button_hover_leave(event, bg, fg))
        self.restart_button.bind("<Button-1>", on_bottom_button_click)
        self.restart_button.pack(side="left", padx=(0, 10))




    def create_resize_button(self, bottom_frame):
        button_style_args = { # Re-define button_style_args here to remove "bold" font
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT, # Flatten the buttons
            "bd": 0, # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font":("Segoe UI", 12) # REMOVE BOLD FONT - for bottom frame buttons
        }

        def on_bottom_button_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_bottom_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            event.widget.config(bg=original_bg, fg=original_fg)

        def on_bottom_button_click(event):
            event.widget.config(bg="white", fg="black")
            # After click effect, revert back to hover style (orange) on enter, or default on leave
            event.widget.bind("<Enter>", on_bottom_button_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_bottom_button_hover_leave(e, bg, fg))


        self.settings_button = tk.Button(bottom_frame, text="Change Window Size", #font=("Segoe UI", 12), # Removed redundant font argument HERE
                                        command=self.open_resize_window,
                                        **button_style_args # Apply the button styles
        )
        self.settings_button.bind("<Enter>", on_bottom_button_hover_enter)
        self.settings_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_bottom_button_hover_leave(event, bg, fg))
        self.settings_button.bind("<Button-1>", on_bottom_button_click)
        self.settings_button.pack(side="left", padx=(0, 0))


    def show_settings_dropdown(self):
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            self.settings_dropdown_window.destroy()
            return

        button = self.settings_button
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty()
        button_height = button.winfo_height()

        self.settings_dropdown_window = tk.Toplevel(self.master)
        self.settings_dropdown_window.overrideredirect(True)
        self.settings_dropdown_window.tk.call('tk', 'scaling', 1.25)
        self.settings_dropdown_window.geometry(f"+{button_x - 190}+{button_y - 260}") # Increased offset for new option
        self.settings_dropdown_window.config(bg="#333333")
        self.settings_dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        def on_settings_option_click(command):
            command()
            self.settings_dropdown_window.destroy()
            self.settings_dropdown_window = None
            self.update_settings_dropdown_button_text()

        settings_options = [
            #("Add Mod(s)", self.add_mods_action),

            #("Choose new User Vehicles Folder", self.choose_new_user_folder),

            ("Rescan All Mods & Configs", self.on_rescan_all_button_click),

            ("Attempt to Sort By Install Date: " + ("On" if self.sort_by_install_date else "Off"), self.toggle_sort_by_install_date),

            ("Show Switcher On Startup: " + ("On" if self.show_switcher_on_startup else "Off"), self.toggle_show_switcher_on_startup),

            ("Collapse Categories By Default: " + ("On" if self.collapse_categories_by_default else "Off"), self.toggle_collapse_categories_by_default), # NEW OPTION

            ("Show Configs Without Images: " + ("On" if self.placeholder_settings else "Off"), self.toggle_placeholder_settings), # NEW OPTION

            ("Double Click to Spawn: " + ("On" if self.middle_click_settings else "Off"), self.toggle_middle_click_settings),

            ("Display Vehicle Folder Names: " + ("On" if self.show_folder_settings else "Off"), self.toggle_show_folder_settings)

        ]

        for option_text, command in settings_options:
            dropdown_button = tk.Button(
                self.settings_dropdown_window,
                text=option_text,
                font=("Segoe UI", 10, "bold"),
                command=lambda cmd=command: on_settings_option_click(cmd),
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5,
                bg="#555555",
                fg="white"
            )
            dropdown_button.pack(fill="x")
            dropdown_button.bind("<Enter>", lambda event, btn=dropdown_button: btn.config(bg="lightgrey", fg="black"))
            dropdown_button.bind("<Leave>", lambda event, btn=dropdown_button: btn.config(bg="#555555", fg="white"))


        self.settings_dropdown_window.bind("<FocusOut>", lambda event: self.destroy_settings_dropdown())


    def on_settings_button_right_click(self, event):
        """
        This function is called when the settings button is right-clicked.
        It triggers the self.toggle_console() function.
        """
        self.toggle_console()
        self.enable_debug_shortcuts = True

        if self.enable_debug_shortcuts:

            self.master.bind_all("<Control-y>", lambda event: self.focus_beamng_window()) # <--- ADD THIS LINE
            self.master.bind_all("<Control-j>", lambda event: self.show_hidden_vehicles_window()) #debug
            self.master.bind_all("<Control-k>", lambda event: self.set_filter_to_view_all_and_turn_subset_off()) #debug
            self.master.bind_all("<Control-l>", lambda event: self.open_isolated_folder_in_explorer()) #debug
            self.master.bind_all("<Control-f>", lambda event: self.on_color_picker_replace_or_spawn()) #debug
            self.master.bind_all("<Control-g>", lambda event: self.color_picker1()) #debug
            self.master.bind_all("<Control-d>", lambda event: self.manual_gc_collect()) # Bind Ctrl+G to manual GC
            self.master.bind_all("<Control-a>", lambda event: self.update_grid_layout()) #debug


    def toggle_middle_click_settings(self):
        """Toggles the 'Double Click to Spawn setting and updates dropdown text."""

        self.middle_click_settings = not self.middle_click_settings
        self.update_settings_dropdown_button_text()
        self.save_settings()


    def toggle_show_folder_settings(self):
        """Toggles the 'Include Without Preview Images' setting and updates dropdown text."""

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot perform this action while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 
        
        self.show_folder_settings = not self.show_folder_settings
        self.update_settings_dropdown_button_text()
        self.save_settings()
        self.on_rescan_all_button_click()
        time.sleep(1)
        self.on_rescan_all_button_click()


    def toggle_placeholder_settings(self):
        """Toggles the 'Include Without Preview Images' setting and updates dropdown text."""

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot perform this action while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 
        
        self.placeholder_settings = not self.placeholder_settings
        self.update_settings_dropdown_button_text()
        self.save_settings()
        self.on_rescan_all_button_click()
        time.sleep(1)
        self.on_rescan_all_button_click()




    def load_settings(self):
        """Loads settings from settings file, including collapse categories by default."""
        default_show_switcher_on_startup = False
        self.show_switcher_on_startup = default_show_switcher_on_startup
        default_sort_by_install_date = False
        self.sort_by_install_date = default_sort_by_install_date
        # --- NEW: Default for collapse categories setting ---
        default_collapse_categories_by_default = False
        self.collapse_categories_by_default = default_collapse_categories_by_default
        # --- NEW: Default for collapse categories setting ---
        # --- NEW: Default for placeholder_settings setting ---
        default_placeholder_settings = False
        self.placeholder_settings = default_placeholder_settings

        default_middle_click_settings = False
        self.middle_click_settings = default_middle_click_settings

        default_show_folder_settings = False
        self.show_folder_settings = default_show_folder_settings

        # --- NEW: Default for placeholder_settings setting ---


        print("\n--- load_settings() DEBUG ENTRY ---") # Debug entry
        print(f"DEBUG: Initial self.show_switcher_on_startup: {self.show_switcher_on_startup}") # Debug initial value
        print(f"DEBUG: Initial self.sort_by_install_date: {self.sort_by_install_date}") # Debug initial value - sort date
        print(f"DEBUG: Initial self.collapse_categories_by_default: {self.collapse_categories_by_default}") # Debug initial value - collapse categories
        print(f"DEBUG: Initial self.placeholder_settings: {self.placeholder_settings}") # Debug initial value - placeholder_settings
        print(f"DEBUG: Initial self.middle_click_settings: {self.middle_click_settings}")
        print(f"DEBUG: Initial self.show_folder_settings: {self.show_folder_settings}")


        try:
            if os.path.exists(self.settings_file_path):
                print(f"DEBUG: Settings file exists: {self.settings_file_path}") # Debug - file exists
                with open(self.settings_file_path, "r", encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith("SwitcherPosition:"):
                            try:
                                pos_str = line[len("SwitcherPosition:"):].strip()
                                x_str, y_str = pos_str.strip("()").split(",")
                                x = int(x_str.strip())
                                y = int(y_str.strip())
                                self.floating_window_last_position = (x, y)
                                print(f"Loaded floating window position from file: {self.floating_window_last_position}") # Debug
                            except ValueError:
                                print("Warning: Invalid SwitcherPosition format in settings file.")
                                break # Stop processing after invalid line
                        elif line.startswith("ShowSwitcherOnStartup:"):
                            value_str = line[len("ShowSwitcherOnStartup:"):].strip().lower()
                            print(f"DEBUG: ShowSwitcherOnStartup line found, value_str: '{value_str}'") # Debug - value_str
                            if value_str == "on":
                                self.show_switcher_on_startup = True
                            elif value_str == "off":
                                self.show_switcher_on_startup = False
                            else:
                                print(f"Warning: Invalid ShowSwitcherOnStartup value: '{value_str}'. Using default.")
                        elif line.startswith("SortByInstallDate:"):
                            value_str = line[len("SortByInstallDate:"):].strip().lower()
                            print(f"DEBUG: SortByInstallDate line found, value_str: '{value_str}'") # Debug - value_str for sort date
                            if value_str == "on":
                                self.sort_by_install_date = True
                            elif value_str == "off":
                                self.sort_by_install_date = False
                            else:
                                print(f"Warning: Invalid SortByInstallDate value: '{value_str}'. Using default.")
                        elif line.startswith("CollapseCategoriesByDefault:"):
                            value_str = line[len("CollapseCategoriesByDefault:"):].strip().lower()
                            print(f"DEBUG: CollapseCategoriesByDefault line found, value_str: '{value_str}'") # Debug - value_str for collapse categories
                            if value_str == "on":
                                self.collapse_categories_by_default = True
                            elif value_str == "off":
                                self.collapse_categories_by_default = False
                            else:
                                print(f"Warning: Invalid CollapseCategoriesByDefault value: '{value_str}'. Using default.")

                        # --- NEW: Load Include No Preview Images Setting ---
                        elif line.startswith("PlaceholderSetting:"):
                            value_str = line[len("PlaceholderSetting:"):].strip().lower()
                            print(f"DEBUG: IncludeNoPreviewImages line found, value_str: '{value_str}'") # Debug - value_str for placeholder_settings
                            if value_str == "on":
                                self.placeholder_settings = True
                            elif value_str == "off":
                                self.placeholder_settings = False
                            else:
                                print(f"Warning: Invalid IncludeNoPreviewImages value: '{value_str}'. Using default.")
                        # --- NEW: Load Include No Preview Images Setting ---


                        elif line.startswith("middle_click_settings:"):
                            value_str = line[len("middle_click_settings:"):].strip().lower()
                            print(f"DEBUG: middle_click_settings line found, value_str: '{value_str}'") # Debug - value_str for placeholder_settings
                            if value_str == "on":
                                self.middle_click_settings = True
                            elif value_str == "off":
                                self.middle_click_settings = False
                            else:
                                print(f"Warning: Invalid middle_click_settings value: '{value_str}'. Using default.")

                        elif line.startswith("show_folder_settings:"):
                            value_str = line[len("show_folder_settings:"):].strip().lower()
                            print(f"DEBUG: show_folder_settings line found, value_str: '{value_str}'") # Debug - value_str for placeholder_settings
                            if value_str == "on":
                                self.show_folder_settings = True
                            elif value_str == "off":
                                self.show_folder_settings = False
                            else:
                                print(f"Warning: Invalid show_folder_settings value: '{value_str}'. Using default.")


                        else:
                            pass
            else:
                print(f"DEBUG: Settings file DOES NOT exist: {self.settings_file_path}") # Debug - file does not exist

        except Exception as e:
            print(f"Error loading floating window position and settings: {e}")

        print(f"DEBUG: Final self.show_switcher_on_startup value: {self.show_switcher_on_startup}") # Debug - final value
        print(f"DEBUG: Final self.sort_by_install_date value: {self.sort_by_install_date}") # Debug - final value - sort date
        print(f"DEBUG: Final self.collapse_categories_by_default value: {self.collapse_categories_by_default}") # Debug - final collapse categories value
        print(f"DEBUG: Final self.placeholder_settings value: {self.placeholder_settings}") # Debug - final placeholder_settings value
        print(f"DEBUG: Final self.middle_click_settings value: {self.middle_click_settings}") 
        print(f"DEBUG: Final self.show_folder_settings value: {self.show_folder_settings}") 

      
        

    def save_settings(self):
        """Saves settings to settings file, including collapse categories by default."""
        if self.floating_window_last_position:
            try:
                with open(self.settings_file_path, "w", encoding="utf-8") as f:
                    f.write(f"SwitcherPosition: {self.floating_window_last_position}\n")
                    f.write(f"ShowSwitcherOnStartup: {'on' if self.show_switcher_on_startup else 'off'}\n")
                    f.write(f"SortByInstallDate: {'on' if self.sort_by_install_date else 'off'}\n")
                    f.write(f"CollapseCategoriesByDefault: {'on' if self.collapse_categories_by_default else 'off'}\n")
                    # --- NEW: Save Include No Preview Images Setting ---
                    f.write(f"PlaceholderSetting: {'on' if self.placeholder_settings else 'off'}\n")
                    # --- NEW: Save Include No Preview Images Setting ---
                    f.write(f"middle_click_settings: {'on' if self.middle_click_settings else 'off'}\n")
                    f.write(f"show_folder_settings: {'on' if self.show_folder_settings else 'off'}\n")
            except Exception as e:
                print(f"Error saving floating window position and settings: {e}")
        else:
            print("Warning: No floating window position to save.")





    def toggle_show_switcher_on_startup(self):
        """Toggles the 'Show Switcher On Startup' setting and updates dropdown text."""
        print(f"toggle_show_switcher_on_startup - BEFORE toggle: self.show_switcher_on_startup = {self.show_switcher_on_startup}") # Debugging print
        self.show_switcher_on_startup = not self.show_switcher_on_startup
        print(f"toggle_show_switcher_on_startup - AFTER toggle: self.show_switcher_on_startup = {self.show_switcher_on_startup}") # Debugging print
        self.update_settings_dropdown_button_text() # Update dropdown text
        self.save_settings() # Save setting to file - MODIFIED to call save_settings
        
        

    def destroy_settings_dropdown(self):
        self.is_search_results_window_closing = True # <--- SET FLAG BEFORE DESTROY
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            self.settings_dropdown_window.destroy()
            self.settings_dropdown_window = None
        self.is_search_results_window_closing = False # <--- RESET FLAG AFTER DESTROY


    def create_item_count_label(self, bottom_frame):
        self.item_count_label = tk.Label(bottom_frame, text="", bg="#333333", fg="lightgrey", font=("Segoe UI", 12)) # Dark bg, lightgrey fg
        self.item_count_label.pack(side="right", padx=(10, 10))

    def setup_main_frame(self):
        main_frame = tk.Frame(self.master, bg="#333333") # <--- CHANGED bg to "#222222" - try setting main_frame background
        main_frame.pack(fill="both", expand=True)
        self.main_frame = main_frame # Store main_frame if needed elsewhere

    def setup_canvas_and_scrollbar(self):
        # Main grid Canvas
        self.canvas = tk.Canvas(self.main_frame, bg="#444444", highlightthickness=0, yscrollincrement=10)
        self.canvas.configure(yscrollcommand=self.custom_scrollbar_set)

        # Custom Scrollbar Canvas - NO PACKING HERE INITIALLY
        self.custom_scrollbar_canvas = tk.Canvas(self.main_frame, bg="#555555", highlightthickness=0, width=15)
        self.scrollbar_thumb = self.custom_scrollbar_canvas.create_rectangle(0, 0, 15, 20, fill=self.global_highlight_color, outline="")
        self.scrollbar_thumb_dragging = False
        self.scrollbar_thumb_start_y = 0
        self.scrollbar_mouse_start_y = 0

        self.custom_scrollbar_canvas.bind("<ButtonPress-1>", self.custom_scrollbar_click)
        self.custom_scrollbar_canvas.bind("<B1-Motion>", self.custom_scrollbar_drag)
        self.custom_scrollbar_canvas.bind("<ButtonRelease-1>", self.custom_scrollbar_release)


        self.canvas.pack(side="left", fill="both", expand=True) # Canvas takes up most space

        # Place the scrollbar using 'place' for absolute positioning BEHIND sidebar
        self.custom_scrollbar_canvas.place(relx=1.0, rely=0.0, anchor='ne', relheight=1.0, x=-310, bordermode="inside") # Position 330px from right edge


        # Initialize scrollbar to canvas link - needed for initial setup
        self.canvas.configure(yscrollcommand=self.custom_scrollbar_set)
  

  
    def setup_scrollable_frame(self):
        """Sets up the scrollable frame with a darker gray background."""
        self.scrollable_frame = tk.Frame(self.canvas, bg="#444444") # <--- DARKER GRAY BACKGROUND for scrollable_frame
        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")


    def setup_sidebar_bottom_frame_content(self):
        sidebar_padding = 10
        self.sidebar_filters_label = tk.Label(self.sidebar_bottom_frame, text="Constraints", font=("Segoe UI", 14, "bold"), bg="#333333", fg="white", justify="center") # Dark grey bg for Constraints section - CHANGED to "#333333" - MATCH TOP HALF
        self.sidebar_filters_label.pack(in_=self.sidebar_bottom_frame, side="top", fill="x", pady=(sidebar_padding*2, sidebar_padding), padx=sidebar_padding)

        self.create_sidebar_filter_dropdowns(self.sidebar_bottom_frame, sidebar_padding)
        
        
    def setup_sidebar_frame(self):
        # Sidebar Frame (Main Grid) - CONTAINER FRAME - NO BG COLOR
        self.sidebar_frame = tk.Frame(self.main_frame, width=300, highlightthickness=1, highlightbackground="#333333", bg="#333333") # Changed sidebar_frame bg to "#333333" - MATCH TOP HALF - CHANGED BACK TO "#333333"
        self.sidebar_frame.pack(side="right", fill="y", padx=(10, 0), pady=10,  expand=False,  )
        self.sidebar_frame.pack_propagate(False) # Prevent sidebar from resizing to content

        # Split sidebar into top and bottom halves - WITH background colors
        self.sidebar_top_frame = tk.Frame(self.sidebar_frame, bg="#333333", highlightthickness=0) # Top half for car info -  Keep at "#333333"
        self.sidebar_bottom_frame = tk.Frame(self.sidebar_frame, bg="#333333", highlightthickness=0) # Bottom half for filters label - CHANGED to MATCH TOP HALF - "#333333" - NOW MATCHES TOP HALF

        # --- MODIFIED PACKING ORDER - REVERSED TOP AND BOTTOM FRAMES ---
        self.sidebar_bottom_frame.pack(side="top", fill="x", expand=False, padx=0, pady=0) #  sidebar_bottom_frame (Constraints) packed FIRST at the TOP
        self.sidebar_top_frame.pack(side="bottom", fill="both", expand=True, padx=0, pady=0) # sidebar_top_frame (Car Info) packed SECOND below it, side=BOTTOM
        # --- MODIFIED PACKING ORDER ---
   

    def setup_sidebar_top_frame_content(self):
        sidebar_padding = 10
        self.sidebar_car_name_label = tk.Label(self.sidebar_top_frame, text="", font=("Segoe UI", 14, "bold"), bg="#333333", fg="lightgrey", wraplength=280, justify="center") # Dark bg, lightgrey fg
        self.sidebar_car_name_label.pack(in_=self.sidebar_top_frame, pady=(sidebar_padding*2, sidebar_padding), padx=sidebar_padding)

        # Placeholder image for sidebar - CHANGED placeholder to MATCH sidebar_top_frame BG COLOR - "#333333"
        placeholder_image = Image.new("RGB", (280, 150), "#333333") # CHANGED to "#333333" - MATCH sidebar_top_frame BG COLOR
        placeholder_photo = ImageTk.PhotoImage(placeholder_image)
        self.sidebar_image_label = tk.Label(self.sidebar_top_frame, image=placeholder_photo, bg="#333333") # Dark bg
        self.sidebar_image_label.image = placeholder_photo
        self.sidebar_image_label.pack(in_=self.sidebar_top_frame, pady=(0, sidebar_padding), padx=sidebar_padding)

        # Sidebar Loading Label
        self.sidebar_loading_label = tk.Label(self.sidebar_top_frame, text="Loading...", font=("Segoe UI", 10, "italic"), fg=self.global_highlight_color, bg="#333333") # Dark bg, orange fg
        self.sidebar_loading_label.pack(in_=self.sidebar_top_frame, pady=(0, sidebar_padding), padx=sidebar_padding)
        self.sidebar_loading_label.pack_forget()

        self.create_sidebar_info_labels(self.sidebar_top_frame, sidebar_padding)
        self.create_sidebar_zip_name_label(self.sidebar_top_frame, sidebar_padding)


    def create_sidebar_info_labels(self, sidebar_top_frame, sidebar_padding): # Modified to include Author labels
        info_font = ("Segoe UI", 11, "italic") # Smaller font for info labels
        category_font = ("Segoe UI", 11, "bold") # Smaller font for category labels

        self.sidebar_brand_label = tk.Label(sidebar_top_frame, text="", font=category_font, bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.sidebar_brand_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_brand_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_brand_info_label.config(text="")
        self.sidebar_brand_info_label.pack_forget()

        self.sidebar_description_label = tk.Label(sidebar_top_frame, text="", font=category_font, bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.sidebar_description_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_description_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_description_info_label.config(text="")
        self.sidebar_description_info_label.pack_forget()

        self.sidebar_slogan_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_slogan_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_slogan_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_slogan_info_label.config(text="")
        self.sidebar_slogan_info_label.pack_forget()

        self.sidebar_country_label = tk.Label(sidebar_top_frame, text="", font=category_font, bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.sidebar_country_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_country_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_country_info_label.config(text="")
        self.sidebar_country_info_label.pack_forget()

        self.sidebar_derbyclass_label = tk.Label(sidebar_top_frame, text="", font=category_font, bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.sidebar_derbyclass_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_derbyclass_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_derbyclass_info_label.config(text="")
        self.sidebar_derbyclass_info_label.pack_forget()

        # --- NEW: Author Labels ---
        self.sidebar_author_label = tk.Label(sidebar_top_frame, text="", font=category_font, bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.sidebar_author_label.pack(in_=sidebar_top_frame, fill="x", padx=sidebar_padding, pady=(sidebar_padding, 0))
        self.sidebar_author_info_label = tk.Label(sidebar_top_frame, text="", font=info_font, bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.sidebar_author_info_label.config(text="")
        self.sidebar_author_info_label.pack_forget()
        # --- NEW: Author Labels ---

    def create_sidebar_zip_name_label(self, sidebar_top_frame, sidebar_padding):
        # Sidebar Zip Name Label (at the bottom of top frame)
        self.sidebar_zip_name_label = tk.Label(sidebar_top_frame, text="", font=("Segoe UI", 10), bg="#333333", fg="lightgrey", wraplength=280, justify="center") # Dark bg, lightgrey fg
        self.sidebar_zip_name_label.config(text="") # Set to "" initially - ENSURE IT IS ""
        self.sidebar_zip_name_label.pack(in_=sidebar_top_frame, side="bottom", pady=sidebar_padding, padx=sidebar_padding)

    def setup_sidebar_bottom_frame(self): # MOVED TO THE TOP, THIS IS THE TOP SECTION OF THE SIDEBAR, DO NOT REMOVE THIS COMMENT
        # Sidebar Frame (Main Grid) - CONTAINER FRAME - NO BG COLOR
        self.sidebar_frame = tk.Frame(self.main_frame, width=300, highlightthickness=1, highlightbackground=self.global_highlight_color, bg="#333333")
        self.sidebar_frame.pack(side="right", fill="y", padx=(10, 0), pady=10,  expand=False,  )
        self.sidebar_frame.pack_propagate(False) # Prevent sidebar from resizing to content

        # Split sidebar into top and bottom halves - WITH background colors
        self.sidebar_top_frame = tk.Frame(self.sidebar_frame, bg="#333333", highlightthickness=0) # Top half for car info
        self.sidebar_bottom_frame = tk.Frame(self.sidebar_frame, bg="#222222", highlightthickness=0) # Bottom half for filters label - DARKER bg - CORRECT BG COLOR HERE

        # --- MODIFIED PACKING ORDER - REVERSED TOP AND BOTTOM FRAMES ---
        self.sidebar_bottom_frame.pack(side="top", fill="x", expand=False, padx=0, pady=0) #  sidebar_bottom_frame (Constraints) packed FIRST at the TOP
        self.sidebar_top_frame.pack(side="bottom", fill="both", expand=True, padx=0, pady=0) # sidebar_top_frame (Car Info) packed SECOND below it, side=BOTTOM
        # --- MODIFIED PACKING ORDER ---


    def _update_filters_label_status(self):
        """
        Checks the status of filter buttons and updates the "Filters" label accordingly.
        If any filter is active (not "All..."), the label turns orange and shows "(Active)".
        Otherwise, it reverts to the default style.
        MODIFIED to disable sidebar filter buttons under certain conditions. <----- ADDED
        """
        all_filters_all = True  # Assume all filters are "All..." initially
        filter_buttons = self.sidebar_filter_buttons

        # --- MODIFIED: Check conditions to disable sidebar filter buttons ---
        disable_sidebar_filters = False
        if self.is_data_subset_active: # Condition 1: Data Subset Active
            disable_sidebar_filters = True
        elif self.filter_state != 0: # Condition 2: Not View All or Favorites
            disable_sidebar_filters = True

        if disable_sidebar_filters:
            print("DEBUG: _update_filters_label_status - Disabling sidebar filter buttons (Subset Active OR Not View All/Favorites).") # Debug
            for filter_name in filter_buttons:
                button = filter_buttons[filter_name]
                button.config(state=tk.DISABLED, fg="grey") # Disable and grey out
        else:
            print("DEBUG: _update_filters_label_status - Enabling sidebar filter buttons.") # Debug
            for filter_name in filter_buttons:
                button = filter_buttons[filter_name]
                button.config(state=tk.NORMAL, fg="white") # Enable and set text color back to white
        # --- MODIFIED: Check conditions to disable sidebar filter buttons ---


        if filter_buttons["Brand"].cget("text") != "All Brands":
            all_filters_all = False
        if filter_buttons["Name"].cget("text") != "All Names":
            all_filters_all = False
        if filter_buttons["Country"].cget("text") != "All Countries":
            all_filters_all = False
        if filter_buttons["Bodystyle"].cget("text") != "All BodyStyles":
            all_filters_all = False

        if all_filters_all:
            self.sidebar_filters_label.config(fg="white", text="Constraints") # Default color and text

            # --- MODIFICATION START: Conditionally close Search Results window when Constraints become inactive ---
            if self.filter_state == 0 and not self.search_var.get().strip() and not self.is_data_subset_active: # Check for View All, empty search, and no global filters
                if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
                    self.destroy_search_results_window()
                    self.search_results_window = None
                    self.is_search_results_window_active = False
                    print("DEBUG: _update_filters_label_status - Search Results window DESTROYED because Constraints are inactive AND View All + Empty Search + No Global Filters.")
                else:
                    print("DEBUG: _update_filters_label_status - Search Results window NOT open, no need to destroy (Constraints inactive AND View All + Empty Search + No Global Filters).") # Debug - Window Not Open
            # --- MODIFICATION END: Conditionally close Search Results window when Constraints become inactive ---


        else:
            # --- MODIFICATION START: Open Search Results Window before setting label to "(Active)" ---
            if not hasattr(self, 'search_results_window') or not self.search_results_window or not self.search_results_window.winfo_exists():
                self.search_results_window = self._create_search_results_window(self.data) # Pass current data
                print("DEBUG: _update_filters_label_status - Search Results window CREATED because Constraints are becoming active.")
            self.search_results_window.lift() # Ensure it's visible
            self.is_search_results_window_active = True
            print("DEBUG: _update_filters_label_status - Search Results window LIFTED because Constraints are becoming active.")
            # --- MODIFICATION END: Open Search Results Window before setting label to "(Active)" ---

            self.sidebar_filters_label.config(fg=self.global_highlight_color, text="Constraints (Active)") # Keep orange for active state
 

        
 

    def _create_filter_dropdown_frame(self, sidebar_bottom_frame, sidebar_padding):
        """
        Creates the frame to hold filter dropdown elements.
        """
        sidebar_filter_dropdowns_frame = tk.Frame(sidebar_bottom_frame, bg="#333333")  # Frame for dropdowns - CHANGED to "#333333" - MATCH TOP HALF
        sidebar_filter_dropdowns_frame.pack(side="top", fill="x", padx=sidebar_padding, pady=(0, sidebar_padding))
        return sidebar_filter_dropdowns_frame


    def _add_filter_dropdown_elements(self, dropdown_frame, filter_options_data):
        """
        Adds labels and buttons (acting as dropdowns) for each filter option to the frame.
        """
        dropdown_row = 0
        dropdown_col = 0 # Column is always 0 for single column layout
        self.sidebar_filter_buttons = {}  # To store button references

        button_style_args_constraints = { # Define button_style_args for constraint buttons
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT, # Flatten the buttons
            "bd": 0, # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white"
        }

        def on_constraint_button_hover_enter(event):
            if event.widget['state'] != tk.DISABLED: # --- ADDED CHECK: if button is NOT disabled
                event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_constraint_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            if event.widget['state'] != tk.DISABLED: # --- ADDED CHECK: if button is NOT disabled
                event.widget.config(bg=original_bg, fg=original_fg)


        for filter_name, options in filter_options_data.items():
            label = tk.Label(dropdown_frame, text=f"{filter_name}:", font=("Segoe UI", 11, "bold"), bg="#333333", fg="lightgrey", anchor="w") # Dark grey bg for labels - CHANGED to "#333333" - MATCH TOP HALF
            label.grid(row=dropdown_row, column=dropdown_col, sticky="w", padx=(0, 5), pady=(2, 5))  # Right padding for label, sticky='w' for left align

            # --- Replace OptionMenu with Button ---
            button = tk.Button(
                dropdown_frame,
                text=options[0],  # Initial text is the first option ("All...")
                font=("Segoe UI", 10),
                command=lambda fn=filter_name.lower(): getattr(self, f"show_sidebar_{fn}_dropdown")(),  # Dynamic command
                width=12, # Fixed width for buttons (adjust as needed)
                **button_style_args_constraints # <--- APPLY BUTTON STYLES HERE
            )
            button.grid(row=dropdown_row, column=dropdown_col+1, sticky="ew", padx=(0, 5), pady=(2, 5))  # Right padding for dropdown, sticky='ew' to fill cell horizontally

            button.bind("<Enter>", on_constraint_button_hover_enter) # Bind hover enter event
            button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_constraint_button_hover_leave(event, bg, fg)) # Bind hover leave event

            self.sidebar_filter_buttons[filter_name] = button  # Store button reference

            dropdown_row += 1 # Increment row after each label-button pair


            

    def _configure_filter_dropdown_frame_layout(self, dropdown_frame):
        """
        Configures the column layout of the filter dropdown frame to allow expansion.
        Now configures TWO columns, one for label, one for button.
        """
        dropdown_frame.columnconfigure(1, weight=1)  # Ensure button column (column 1) expands


    def create_sidebar_filter_dropdowns(self, sidebar_bottom_frame, sidebar_padding):
        """
        Creates and configures filter dropdowns in the sidebar.
        """
        self.sidebar_filter_dropdowns_frame = self._create_filter_dropdown_frame(sidebar_bottom_frame, sidebar_padding)

        # --- MODIFIED: Filter options data WITHOUT Type and Author, and IN DESIRED ORDER for single column ---
        filter_options_data = {
            "Brand": ["All Brands"] + self.get_unique_brands(),
            "Name": ["All Names"] + self.get_unique_names(),  # Use dynamic name list here
            "Country": ["All Countries"] + self.get_unique_countries(), # NEW: Country options
            "Bodystyle": ["All BodyStyles"] + self.get_unique_body_styles(),  # NEW: Body Style options
            # "Author": ["All Authors", "Author 1", "Author 2"], # REMOVED Author
            # "Type": ["All Types", "Type 1", "Type 2"] # REMOVED Type
        }
        # --- MODIFIED: Filter options data WITHOUT Type and Author, and IN DESIRED ORDER for single column ---

        self._add_filter_dropdown_elements(self.sidebar_filter_dropdowns_frame, filter_options_data)

        self._configure_filter_dropdown_frame_layout(self.sidebar_filter_dropdowns_frame)



    def show_sidebar_brand_dropdown(self):
        self._show_sidebar_filter_dropdown("Brand", self.sidebar_filter_buttons["Brand"])



    def _filter_dropdown_options(self, search_text, original_options):
        """Filters dropdown options based on search text."""
        filtered_options = []
        for option in original_options:
            if search_text in option.lower():
                filtered_options.append(option)
        return filtered_options

    def _clear_dropdown_options(self, scrollable_frame):
        """Clears all widgets within the scrollable frame except the search entry."""
        widgets_to_destroy = []
        for widget in scrollable_frame.winfo_children():
            if not isinstance(widget, tk.Entry):
                widgets_to_destroy.append(widget)
        for widget in widgets_to_destroy:
            widget.destroy()
        scrollable_frame.update_idletasks() # Force update after destroy


    def _create_dropdown_option_buttons(self, scrollable_frame, current_options, button, dropdown_window):
        """Creates and packs option buttons in the scrollable frame."""
        for option in current_options:
            bg_color = "#555555"
            fg_color = "white"
            current_button_text = button.cget("text")
            if option == current_button_text:
                bg_color = self.global_highlight_color
                fg_color = "white"

            dropdown_button = tk.Button(
                scrollable_frame,
                text=option,
                font=("Segoe UI", 10, "bold"),
                command=lambda opt=option, fname="name": self._on_name_dropdown_button_click(opt, fname=fname, fbutton=button, fdropdown_window=dropdown_window),
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=2,
                bg=bg_color,
                fg=fg_color,
                width=240
            )
            dropdown_button.pack(fill="x")
            dropdown_button.bind("<Enter>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg="lightgrey", fg="black"))
            dropdown_button.bind("<Leave>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg=original_bg, fg=original_fg))


    def _on_name_dropdown_button_click(self, option_text, fname, fbutton, fdropdown_window):
        """Handles the button click event in the Name dropdown., added search window update."""
        print("    DEBUG: _on_name_dropdown_button_click() START")
        fbutton.config(text=option_text)
        self._filter_data_by_name(option_text)
        bodystyle_button = self.sidebar_filter_buttons.get("Bodystyle")
        if bodystyle_button:
            bodystyle_button.config(text="All BodyStyles")
        country_button = self.sidebar_filter_buttons.get("Country")
        if country_button:
            country_button.config(text="All Countries")

        self._update_ui_elements(fdropdown_window)
        self._update_filters_label_status()
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE
        print("    DEBUG: _on_name_dropdown_button_click() END")



    def _update_name_dropdown_options(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Updates the options displayed in the Name dropdown based on search input."""
        print("    DEBUG: _update_name_dropdown_options() START") # Debug

        search_text = search_var.get().strip().lower()
        filtered_options = self._filter_dropdown_options(search_text, original_options) # 1. Filter options

        # --- DEBUGGING: Inspect children BEFORE destruction ---
        print("    DEBUG: update_dropdown_options - --- BEFORE DESTROY ---")
        print("    DEBUG: update_dropdown_options - scrollable_frame children COUNT:", len(scrollable_frame.winfo_children()))
        for i, child in enumerate(scrollable_frame.winfo_children()):
            print(f"      DEBUG: Child {i}: Widget Class: {type(child)}, Widget Name: {child.winfo_name()}")

        self._clear_dropdown_options(scrollable_frame) # 2. Clear existing options

        # --- DEBUGGING: Inspect children AFTER destruction ---
        print("    DEBUG: update_dropdown_options - --- AFTER DESTROY ---")
        print("    DEBUG: update_dropdown_options - scrollable_frame children COUNT:", len(scrollable_frame.winfo_children()))
        for i, child in enumerate(scrollable_frame.winfo_children()):
            print(f"      DEBUG: Child {i}: Widget Class: {type(child)}, Widget Name: {child.winfo_name()}")


        # --- DEBUG PRINT: Check if search_entry still exists ---
        search_entry_exists = False
        for child in scrollable_frame.winfo_children():
            if isinstance(child, tk.Entry):
                search_entry_exists = True
                break
        print(f"    DEBUG: update_dropdown_options - search_entry EXISTS after destroy:", search_entry_exists) # Debug - Search Entry Check

        self._create_dropdown_option_buttons(scrollable_frame, filtered_options, button, dropdown_window) # 3. Create new option buttons


        canvas.config(scrollregion=canvas.bbox("all"))
        # --- DEBUG PRINT: End of update_dropdown_options ---
        print("    DEBUG: update_dropdown_options - current_options after update:", filtered_options) # Debug
        print("    DEBUG: _update_name_dropdown_options() END") # Debug


    def _get_dynamic_name_options(self):
        """Helper function to get dynamic name options based on selected brand."""
        brand_button = self.sidebar_filter_buttons.get("Brand")
        selected_brand = brand_button.cget("text") if brand_button else "All Brands"
        dynamic_name_options = ["All Names"] + self.get_unique_names(selected_brand)
        print("  DEBUG: dynamic_name_options after get_unique_names():", dynamic_name_options)  # Debug
        return dynamic_name_options



    def _filter_data_by_name(self, option_text):
        """Filters the displayed data by name, respecting the main search query and other filters. - MODIFIED to maintain query context and use data_cache"""
        filtered_data = []
        # --- MODIFIED: Start filtering from data_cache ALWAYS ---
        data_to_filter = list(self.data_cache) # Start with cached data

        # --- Apply main search query filter ---
        query = self.search_var.get().strip().lower()
        if query:
            query_filtered_data = []
            for item in data_to_filter:
                if self._perform_item_search(query, item):
                    query_filtered_data.append(item)
            data_to_filter = query_filtered_data # Use query-filtered data for further filtering
        # --- Apply main search query filter ---

        # --- NEW: Apply Brand filter BEFORE Name filter (respect additive filtering) ---
        brand_filter = self.sidebar_filter_buttons["Brand"].cget("text")
        if brand_filter != "All Brands":
            brand_filtered_list = []
            for item in data_to_filter: # Filter from query-filtered data
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand == brand_filter:
                    brand_filtered_list.append(item)
            data_to_filter = brand_filtered_list # Use brand-filtered data for further filtering
        # --- NEW: Apply Brand filter BEFORE Name filter (respect additive filtering) ---


        if option_text == "All Names":
            # When "All Names" is selected, use the data ALREADY filtered by query and Brand (if any)
            filtered_data = data_to_filter # <--- MODIFIED: Use data filtered by query and Brand, DO NOT reset to original
        else:
            # Apply Name filter on the data already filtered by query and Brand (if any)
            for item in data_to_filter: # <--- MODIFIED: Iterate over query and Brand-filtered data
                _, _, _, info_data, _ = item
                name = info_data.get("Name", "").strip()
                if name == option_text:
                    filtered_data.append(item)

        self.data = filtered_data
        self.grouped_data = self.format_grouped_data(self.data)
        self.update_grid_layout()
        self.canvas.yview_moveto(0)
        




    def _filter_data_by_bodystyle(self, option_text):
        """Filters the displayed data based on the selected bodystyle option, added search window update."""
        filtered_data = []
        data_to_filter = list(self.data_cache)

        query = self.search_var.get().strip().lower()
        if query:
            query_filtered_data = []
            for item in data_to_filter:
                if self._perform_item_search(query, item):
                    query_filtered_data.append(item)
            data_to_filter = query_filtered_data

        brand_filter = self.sidebar_filter_buttons["Brand"].cget("text")
        name_filter = self.sidebar_filter_buttons["Name"].cget("text")
        country_filter = self.sidebar_filter_buttons["Country"].cget("text")

        if brand_filter != "All Brands":
            brand_filtered_list = []
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand == brand_filter:
                    brand_filtered_list.append(item)
            data_to_filter = brand_filtered_list

        if name_filter != "All Names":
            name_filtered_list = []
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                name = info_data.get("Name", "").strip()
                if name == name_filter:
                    name_filtered_list.append(item)
            data_to_filter = name_filtered_list

        if country_filter != "All Countries":
            country_filtered_list = []
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                country = info_data.get("Country", "").strip()
                if country == country_filter:
                    country_filtered_list.append(item)
            data_to_filter = country_filtered_list

        if option_text == "All BodyStyles":
            filtered_data = data_to_filter
        else:
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                body_style = info_data.get("Body Style", "").strip()
                if body_style == option_text:
                    filtered_data.append(item)
        self.data = filtered_data

        self.grouped_data = self.format_grouped_data(self.data)
        self.update_grid_layout()
        self.canvas.yview_moveto(0)
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE

      
        


    def _filter_data_by_country(self, option_text):
        """Filters data by country, respecting Brand and Name filters, and now main search query, added search window update."""
        filtered_data = []
        data_to_filter = list(self.data_cache)

        query = self.search_var.get().strip().lower()
        if query:
            query_filtered_data = []
            for item in data_to_filter:
                if self._perform_item_search(query, item):
                    query_filtered_data.append(item)
            data_to_filter = query_filtered_data

        brand_filter = self.sidebar_filter_buttons["Brand"].cget("text")
        name_filter = self.sidebar_filter_buttons["Name"].cget("text")

        if brand_filter != "All Brands":
            brand_filtered_list = []
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand == brand_filter:
                    brand_filtered_list.append(item)
            data_to_filter = brand_filtered_list

        if name_filter != "All Names":
            name_filtered_list = []
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                name = info_data.get("Name", "").strip()
                if name == name_filter:
                    name_filtered_list.append(item)
            data_to_filter = name_filtered_list

        if option_text == "All Countries":
            filtered_data = data_to_filter
        else:
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                country = info_data.get("Country", "").strip()
                if country == option_text:
                    filtered_data.append(item)

        self.data = filtered_data
        self.grouped_data = self.format_grouped_data(self.data)
        self.update_grid_layout()
        self.canvas.yview_moveto(0)
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE


        

        
    def _reset_data_or_apply_brand_filter(self):
        """Resets data to original or applies brand filter when 'All Names' is selected."""
        brand_filter = self.sidebar_filter_buttons["Brand"].cget("text")
        if brand_filter == "All Brands":
            self.data = list(self.original_data) # Reset to original data
        else:
            # Apply ONLY the Brand filter
            filtered_data = []
            for item in self.original_data:
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand == brand_filter:
                    filtered_data.append(item)
            self.data = filtered_data


            self.update_search_results_window_ui() # <----- ADD THIS LINE HERE
            
            
            

    def _apply_name_and_brand_filters(self, option_text):
        """Applies both name and brand filters to the data."""
        filtered_data = []
        selected_name = option_text # Get the selected name

        # Find and set associated brand if Brand filter is "All Brands"
        if self.sidebar_filter_buttons["Brand"].cget("text") == "All Brands":
            associated_brand = self._find_associated_brand(selected_name)
            if associated_brand:
                self.sidebar_filter_buttons["Brand"].config(text=associated_brand) # Update Brand button text
                print(f"DEBUG: Brand filter set to: {associated_brand} based on Name selection.")

        # Apply Name and Brand filters
        for item in self.original_data:
            _, _, _, info_data, _ = item
            name = info_data.get("Name", "").strip()
            brand_filter = self.sidebar_filter_buttons["Brand"].cget("text")
            brand = info_data.get("Brand", "").strip()

            brand_condition = (brand_filter == "All Brands") or (brand == brand_filter)
            name_condition = (name == option_text)
            if name_condition and brand_condition:
                filtered_data.append(item)
        self.data = filtered_data
        self.update_search_results_window_ui() 
        

    def _find_associated_brand(self, selected_name):
        """Finds the associated brand for a given name from original data."""
        for item in self.original_data:
            _, _, _, info_data, _ = item
            name_from_data = info_data.get("Name", "").strip()
            if name_from_data == selected_name:
                associated_brand = info_data.get("Brand", "").strip()
                if associated_brand:
                    return associated_brand
        return None # Return None if no associated brand is found (or if brand is empty)


    def _update_ui_elements(self, fdropdown_window):
        """Updates the UI elements after data filtering, added search window update."""
        self.update_grid_layout()
        self.canvas.yview_moveto(0)
        fdropdown_window.destroy()
        setattr(self, f"sidebar_name_dropdown_window", None)
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE



    def _get_dynamic_name_options(self):
        """Helper function to get dynamic name options based on selected brand."""
        brand_button = self.sidebar_filter_buttons.get("Brand")
        selected_brand = brand_button.cget("text") if brand_button else "All Brands"
        dynamic_name_options = ["All Names"] + self.get_unique_names(selected_brand)
        print("  DEBUG: dynamic_name_options after get_unique_names():", dynamic_name_options)  # Debug
        return dynamic_name_options

    def _destroy_existing_dropdown(self, dropdown_attr_name):
        """Destroys an existing dropdown window if it exists."""
        if hasattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name).winfo_exists():
            getattr(self, dropdown_attr_name).destroy()

    def _create_dropdown_base(self, button, dropdown_attr_name):
        """Creates the base dropdown window, canvas, scrollbar, and frame (MODIFIED for scrolling)."""
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty()
        button_height = button.winfo_height()

        dropdown_window = tk.Toplevel(self.master)
        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        dropdown_window.geometry(f"+{button_x}+{button_y - 200}") # Initial position above to avoid flicker
        dropdown_window.config(bg="#333333")
        dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        canvas = tk.Canvas(dropdown_window, bg="#444444", highlightthickness=0, width=180, height=410) # dropdown width other dropdowns
        scrollbar = tk.Scrollbar(dropdown_window, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#333333") # modify width and height here for dropdown

        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        canvas.configure(yscrollcommand=scrollbar.set)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        # --- MODIFIED: Bind Mousewheel only on Canvas Enter/Leave ---
        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_dropdown_mousewheel(ev, canvas)))
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))
        # --- MODIFIED: Bind Mousewheel only on Canvas Enter/Leave ---

        def on_dropdown_canvas_enter(event, canvas):
            canvas.focus_set()

        dropdown_window.bind("<FocusOut>", lambda event, fname="name": self.destroy_sidebar_filter_dropdown(fname))
        setattr(self, dropdown_attr_name, dropdown_window)
        return scrollable_frame, dropdown_window, canvas


    def _create_name_dropdown_content(self, scrollable_frame, dynamic_name_options, button, dropdown_window, canvas):
        """Creates the content of the name dropdown: search entry and options."""
        search_var = tk.StringVar()
        search_entry = tk.Entry(scrollable_frame, textvariable=search_var, font=("Segoe UI", 10), bg="white", fg="black", width=18)
        search_entry.pack(pady=(5, 2), padx=5, fill="x")
        search_entry.focus_set()
        
        
        filter_options_data = { # NOTE: This is likely redundant and can be removed/reworked
            "Brand": ["All Brands"] + self.get_unique_brands(),
            "Name": dynamic_name_options,
            "Country": ["All Countries", "Country 1", "Country 2"],
            "Author": ["All Authors", "Author 1", "Author 2"],
            "Bodystyle": ["All Bodystyles", "Bodystyle 1", "Bodystyle 2"],
            "Type": ["All Types", "Type 1", "Type 2"]
        }
        original_options = filter_options_data["Name"] # NOTE: Redundant - dynamic_name_options is already calculated

        #search_entry.bind("<KeyRelease>", lambda event: self._update_name_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window)) #debounce this please
        search_entry.bind("<KeyRelease>", lambda event: self._debounced_update_name_dropdown(search_var, original_options, scrollable_frame, canvas, button, dropdown_window))
        
        self._update_name_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window) # Initial population

        


    def _debounced_update_name_dropdown(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Debounced version of _update_name_dropdown_options."""
        if self.debounce_timer:
            self.master.after_cancel(self.debounce_timer)
        self.debounce_timer = self.master.after(
            600,  # Adjust delay as needed (milliseconds)
            lambda: self._update_name_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window)
        )

    def show_sidebar_name_dropdown(self):  # --- MODIFIED: Refactored using smaller functions ---
        """Shows the dropdown for Name filter, now dynamically populated based on Brand."""
        print("\n--- show_sidebar_name_dropdown() DEBUG START ---") # Debug Entry

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust constraints while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 
        

        dropdown_attr_name = f"sidebar_name_dropdown_window"
        self._destroy_existing_dropdown(dropdown_attr_name) # 1. Destroy existing dropdown

        button = self.sidebar_filter_buttons["Name"]
        scrollable_frame, dropdown_window, canvas = self._create_dropdown_base(button, dropdown_attr_name) # 2. Create dropdown base

        dynamic_name_options = self._get_dynamic_name_options() # 3. Get dynamic name options

        self._create_name_dropdown_content(scrollable_frame, dynamic_name_options, button, dropdown_window, canvas) # 4. Create dropdown content

        button_x = button.winfo_rootx() # Position after content is created for better placement
        button_y = button.winfo_rooty()
        dropdown_window.geometry(f"+{button_x}+{button_y}") # Final position

        print("--- show_sidebar_name_dropdown() DEBUG END ---\n") # Debug Exit




    def show_sidebar_country_dropdown(self):
        """Shows the dropdown for Country filter, now dynamically populated based on Brand and Name selections."""
        print("\n--- show_sidebar_country_dropdown() DEBUG START ---") # Debug Entry

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust constraints while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 
        


        dropdown_attr_name = f"sidebar_country_dropdown_window"
        self._destroy_existing_dropdown(dropdown_attr_name) # 1. Destroy existing dropdown

        button = self.sidebar_filter_buttons["Country"]
        scrollable_frame, dropdown_window, canvas = self._create_dropdown_base(button, dropdown_attr_name) # 2. Create dropdown base

        # --- NEW: Get currently selected Brand and Name from buttons ---
        brand_button = self.sidebar_filter_buttons.get("Brand")
        selected_brand = brand_button.cget("text") if brand_button else "All Brands"
        name_button = self.sidebar_filter_buttons.get("Name")
        selected_name = name_button.cget("text") if name_button else "All Names"
        print(f"  DEBUG: show_sidebar_country_dropdown - Selected Brand: '{selected_brand}', Selected Name: '{selected_name}'") # Debug

        dynamic_country_options = ["All Countries"] + self.get_unique_countries(selected_brand, selected_name) # 3. Get dynamic country options - PASSING BRAND and NAME FILTERS
        print(f"  DEBUG: show_sidebar_country_dropdown - Dynamic Country Options: {dynamic_country_options}") # Debug

        self._create_country_dropdown_content(scrollable_frame, dynamic_country_options, button, dropdown_window, canvas) # 4. Create dropdown content - NEW CONTENT CREATION FUNCTION

        button_x = button.winfo_rootx() # Position after content is created for better placement
        button_y = button.winfo_rooty()
        dropdown_window.geometry(f"+{button_x}+{button_y}") # Final position

        print("--- show_sidebar_country_dropdown() DEBUG END ---\n") # Debug Exit
        

    def _create_country_option_buttons(self, scrollable_frame, current_options, button, dropdown_window):
        """Creates and packs option buttons in the scrollable frame for country."""
        for option in current_options:
            bg_color = "#555555"
            fg_color = "white"
            current_button_text = button.cget("text")
            if option == current_button_text:
                bg_color = self.global_highlight_color
                fg_color = "white"

            dropdown_button = tk.Button(
                scrollable_frame,
                text=option,
                font=("Segoe UI", 10, "bold"),
                command=lambda opt=option, fname="country": self._on_country_dropdown_button_click(opt, fname=fname, fbutton=button, fdropdown_window=dropdown_window), # Call _on_country_dropdown_button_click
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=2,
                bg=bg_color,
                fg=fg_color,
                width=240
            )
            dropdown_button.pack(fill="x")
            dropdown_button.bind("<Enter>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg="lightgrey", fg="black"))
            dropdown_button.bind("<Leave>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg=original_bg, fg=original_fg))

        

    def _update_country_dropdown_options(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Updates the options displayed in the Country dropdown based on search input."""
        print("    DEBUG: _update_country_dropdown_options() START") # Debug

        search_text = search_var.get().strip().lower()
        filtered_options = self._filter_dropdown_options(search_text, original_options) # 1. Filter options

        self._clear_dropdown_options(scrollable_frame) # 2. Clear existing options
        self._create_country_option_buttons(scrollable_frame, filtered_options, button, dropdown_window) # 3. Create new option buttons

        canvas.config(scrollregion=canvas.bbox("all"))
        # --- DEBUG PRINT: End of update_dropdown_options ---
        print("    DEBUG: _update_country_dropdown_options() END") # Debug
        

    def _create_country_dropdown_content(self, scrollable_frame, dynamic_country_options, button, dropdown_window, canvas):
        """Creates the content of the country dropdown: search entry and options."""
        search_var = tk.StringVar()
        search_entry = tk.Entry(scrollable_frame, textvariable=search_var, font=("Segoe UI", 10), bg="white", fg="black", width=18)
        search_entry.pack(pady=(5, 2), padx=5, fill="x")
        search_entry.focus_set()
        
        filter_options_data = { # NOTE: This is likely redundant and can be removed/reworked - but keep for now
            "Brand": ["All Brands"] + self.get_unique_brands(),
            "Name": ["All Names", "Name 1", "Name 2"],
            "Country": dynamic_country_options, # Pass dynamic options here
            "Author": ["All Authors", "Author 1", "Author 2"],
            "Bodystyle": ["All Bodystyles", "Bodystyle 1", "Bodystyle 2"],
            "Type": ["All Types", "Type 1", "Type 2"]
        }
        original_options = filter_options_data["Country"] # Get Country options

        #search_entry.bind("<KeyRelease>", lambda event: self._update_country_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window))
        #self._update_country_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window) # Initial population

        search_entry.bind("<KeyRelease>", lambda event: self._debounced_update_country_dropdown(search_var, original_options, scrollable_frame, canvas, button, dropdown_window))
        
        self._update_country_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window) # Initial population

        


    def _debounced_update_country_dropdown(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Debounced version of _update_country_dropdown_options."""
        if self.debounce_timer:
            self.master.after_cancel(self.debounce_timer)
        self.debounce_timer = self.master.after(
            600,  # Adjust delay as needed (milliseconds)
            lambda: self._update_country_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window)
        )
        

    def show_sidebar_bodystyle_dropdown(self):
        """Shows the dropdown for Body Style filter, now dynamically populated based on Brand, Name, and Country."""
        print("\n--- show_sidebar_bodystyle_dropdown() DEBUG START ---") # Debug Entry


        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust constraints while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 
        


        dropdown_attr_name = f"sidebar_bodystyle_dropdown_window"
        self._destroy_existing_dropdown(dropdown_attr_name) # 1. Destroy existing dropdown

        button = self.sidebar_filter_buttons["Bodystyle"]
        scrollable_frame, dropdown_window, canvas = self._create_dropdown_base(button, dropdown_attr_name) # 2. Create dropdown base

        # --- NEW: Get currently selected Brand, Name, and Country from buttons ---
        brand_button = self.sidebar_filter_buttons.get("Brand")
        selected_brand = brand_button.cget("text") if brand_button else "All Brands"
        name_button = self.sidebar_filter_buttons.get("Name")
        selected_name = name_button.cget("text") if name_button else "All Names"
        country_button = self.sidebar_filter_buttons.get("Country") # NEW: Get Country button
        selected_country = country_button.cget("text") if country_button else "All Countries" # NEW: Get selected Country
        print(f"  DEBUG: show_sidebar_bodystyle_dropdown - Selected Brand: '{selected_brand}', Selected Name: '{selected_name}', Selected Country: '{selected_country}'") # Debug

        dynamic_bodystyle_options = self.get_unique_body_styles(selected_brand, selected_name, selected_country) # 3. Get dynamic bodystyle options - PASSING BRAND, NAME, and COUNTRY FILTERS
        print(f"  DEBUG: show_sidebar_bodystyle_dropdown - Dynamic BodyStyle Options (BEFORE 'All' insertion): {dynamic_bodystyle_options}") # Debug

        # --- NEW: Ensure "All BodyStyles" is ALWAYS the first option (no change needed here) ---
        if "All BodyStyles" not in dynamic_bodystyle_options:
            dynamic_bodystyle_options.insert(0, "All BodyStyles") # Insert at the beginning if not present
        elif dynamic_bodystyle_options[0] != "All BodyStyles": # If present but not first, move to first
            dynamic_bodystyle_options.remove("All BodyStyles")
            dynamic_bodystyle_options.insert(0, "All BodyStyles")
        # --- NEW: Ensure "All BodyStyles" is ALWAYS the first option (no change needed here) ---
        print(f"  DEBUG: show_sidebar_bodystyle_dropdown - Dynamic BodyStyle Options (AFTER 'All' insertion/move): {dynamic_bodystyle_options}") # Debug

        self._create_bodystyle_dropdown_content(scrollable_frame, dynamic_bodystyle_options, button, dropdown_window, canvas) # 4. Create dropdown content

        button_x = button.winfo_rootx() # Position after content is created for better placement
        button_y = button.winfo_rooty()
        dropdown_window.geometry(f"+{button_x}+{button_y}") # Final position

        print("--- show_sidebar_bodystyle_dropdown() DEBUG END ---\n") # Debug Exit
        


    def _destroy_existing_dropdown(self, filter_name):
        """Destroys the existing dropdown window if it exists."""
        dropdown_attr_name = f"sidebar_{filter_name.lower()}_dropdown_window"
        if hasattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name).winfo_exists():
            getattr(self, dropdown_attr_name).destroy()
            return True  # Indicate dropdown was destroyed
        return False # Indicate no dropdown to destroy

    def _calculate_dropdown_position(self, button_widget):
        """Calculates the position for the dropdown window relative to the button."""
        button_x = button_widget.winfo_rootx()
        button_y = button_widget.winfo_rooty()
        return button_x, button_y

    def _create_dropdown_window(self, master, button_x, button_y):
        """Creates the toplevel dropdown window."""
        dropdown_window = tk.Toplevel(master)
        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        dropdown_window.geometry(f"+{button_x}+{button_y - 250}")  # Position below button, increased offset
        dropdown_window.config(bg="#444444")
        dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        return dropdown_window

    def _create_scrollable_canvas(self, dropdown_window, dropdown_width, dropdown_height):
        """Creates the scrollable canvas and frame within the dropdown window."""
        canvas = tk.Canvas(dropdown_window, bg="#444444", highlightthickness=0, width=dropdown_width, height=dropdown_height)
        scrollbar = tk.Scrollbar(dropdown_window, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#444444", width=dropdown_width, height=dropdown_height)

        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        canvas.configure(yscrollcommand=scrollbar.set)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        # --- NEW: Bind Mousewheel only on Canvas Enter/Leave ---
        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_dropdown_mousewheel(ev, canvas)))
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))
        # --- NEW: Bind Mousewheel only on Canvas Enter/Leave ---
        return canvas, scrollable_frame

    def _create_search_bar(self, scrollable_frame, search_var):
        """Creates the search bar entry in the scrollable frame."""
        search_bar_width = 18
        search_entry = tk.Entry(scrollable_frame, textvariable=search_var, font=("Segoe UI", 10), bg="white", fg="black", width=search_bar_width)
        search_entry.pack(pady=(5, 2), padx=5, fill="x")
        search_entry.focus_set()

        return search_entry

    def _update_dropdown_options(self, scrollable_frame, search_var, original_options, button_widget, dropdown_width, on_dropdown_button_click, canvas):
        """Updates the dropdown options based on the search input."""
        def update_options(event=None):
            search_text = search_var.get().strip().lower()
            filtered_options = [option for option in original_options if search_text in option.lower()]

            for widget in scrollable_frame.winfo_children()[1:]:  # Skip search entry (index 0)
                widget.destroy()

            self._create_dropdown_buttons(scrollable_frame, filtered_options, button_widget, dropdown_width, on_dropdown_button_click)
            canvas.config(scrollregion=canvas.bbox("all"))

        return update_options # Return the function to be bound

    def _create_dropdown_buttons(self, scrollable_frame, options, button_widget, dropdown_width, on_dropdown_button_click):
        """Creates the dropdown buttons in the scrollable frame."""
        for option in options:
            bg_color = "#555555"
            fg_color = "white"
            current_button_text = button_widget.cget("text")
            if option == current_button_text:
                bg_color = self.global_highlight_color
                fg_color = "white"

            dropdown_button = tk.Button(
                scrollable_frame,
                text=option,
                font=("Segoe UI", 10, "bold"),
                command=lambda opt=option: on_dropdown_button_click(opt),
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=2,
                bg=bg_color,
                fg=fg_color,
                width=240
            )
            dropdown_button.pack(fill="x")
            dropdown_button.bind("<Enter>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg="lightgrey", fg="black"))
            dropdown_button.bind("<Leave>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg=original_bg, fg=original_fg))


    def _on_dropdown_button_click_for_brands(self, option_text, filter_name, button_widget, dropdown_window):
        """Handles the click event for the BRANDS dropdown button and nothing else).
           MODIFIED to reset Bodystyle AND Country filters when Brand filter changes.
           MODIFIED to call _update_filters_label_status AFTER button config.
        """
        print(f"\n--- _on_dropdown_button_click_for_brands() DEBUG START ---")
        print(f"  DEBUG: filter_name: {filter_name}, option_text: {option_text}")

        button_widget.config(text=option_text)

        if filter_name.lower() == "brand": # Filtering logic for Brand - CASE INSENSITIVE COMPARISON
            print("  DEBUG: Inside filter_name.lower() == 'brand' block - CORRECT BLOCK NOW ENTERED") # Debug - Correct block entered
            if option_text == "All Brands":
                print("  DEBUG: option_text is 'All Brands'") # Debug - All Brands
                # --- MODIFIED: ALWAYS respect main filter when "All Brands" is selected ---
                print("    DEBUG: Main filter is ALWAYS respected for 'All Brands', using filtered_original_data_for_brands")
                self.data = list(self.filtered_original_data_for_brands) # Use filtered data
                # --- MODIFIED: ALWAYS respect main filter when "All Brands" is selected ---
            else:
                print(f"  DEBUG: option_text is a specific brand: '{option_text}' - filtering data") # Debug - Specific Brand
                filtered_data = []
                # --- MODIFIED: Filter based on filtered_original_data_for_brands instead of original_data ---
                for item in self.filtered_original_data_for_brands: # <--- MODIFIED: Use filtered data as source
                    _, _, _, info_data, _ = item
                    brand = info_data.get("Brand", "").strip()
                    if brand == option_text:
                        filtered_data.append(item)
                self.data = filtered_data
                # --- MODIFIED: Filter based on filtered_original_data_for_brands instead of original_data ---

            self.grouped_data = self.format_grouped_data(self.data)
            self.update_grid_layout()
            self.canvas.yview_moveto(0)

            name_button = self.sidebar_filter_buttons.get("Name") # Get the Name button widget
            if name_button:
                name_button.config(text="All Names") # Set text to "All Names"

            # --- NEW: Reset Bodystyle and Country filters to "All..." when Brand changes ---
            bodystyle_button = self.sidebar_filter_buttons.get("Bodystyle") # Get Bodystyle button
            if bodystyle_button:
                bodystyle_button.config(text="All BodyStyles") # Reset Bodystyle button text

            country_button = self.sidebar_filter_buttons.get("Country") # NEW: Get Country button
            if country_button:
                country_button.config(text="All Countries") # NEW: Reset Country button text
            # --- NEW: Reset Bodystyle and Country filters to "All..." when Brand changes ---


        elif filter_name.lower() == "name": # Filtering logic for Name
             # No changes needed here for Name filter itself (logic already in _on_name_dropdown_button_click)
             pass # Placeholder, keep existing Name filter logic in _on_name_dropdown_button_click

        elif filter_name.lower() == "bodystyle": # Filtering logic for Bodystyle
            self._on_bodystyle_dropdown_button_click(option_text, filter_name, button_widget, dropdown_window) # Call existing bodystyle handler
        elif filter_name.lower() == "country": # Filtering logic for Country
            self._on_country_dropdown_button_click(option_text, filter_name, button_widget, dropdown_window) # Call existing country handler
        elif filter_name.lower() == "author": # REMOVE THIS BRANCH
            pass # Add any specific logic for Author if needed, currently generic # REMOVE THIS LINE
        elif filter_name.lower() == "type": # REMOVE THIS BRANCH
            pass # Add any specific logic for Type if needed, currently generic # REMOVE THIS LINE


        dropdown_window.destroy()
        dropdown_attr_name = f"sidebar_{filter_name.lower()}_dropdown_window"
        setattr(self, dropdown_attr_name, None)
        self._update_filters_label_status() # <--- UPDATE FILTERS LABEL STATUS HERE
        
        print("--- _on_dropdown_button_click_for_brands() DEBUG END ---\n")
        self.update_search_results_window_ui() 


    def _on_country_dropdown_button_click(self, option_text, fname, fbutton, fdropdown_window):
        """Handles the button click event in the Country dropdown.
           MODIFIED to reset Bodystyle filter when Country changes.
           MODIFIED to call _update_filters_label_status AFTER button config.
        """
        print("    DEBUG: _on_country_dropdown_button_click() START") # Debug
        fbutton.config(text=option_text)
        self._filter_data_by_country(option_text) # Call country-specific filter function

        # --- NEW: Reset Bodystyle filter to "All BodyStyles" when Country changes ---
        bodystyle_button = self.sidebar_filter_buttons.get("Bodystyle") # Get Bodystyle button
        if bodystyle_button:
            bodystyle_button.config(text="All BodyStyles") # Reset Bodystyle button text
        # --- NEW: Reset Bodystyle filter to "All BodyStyles" when Country changes ---

        self._update_ui_elements(fdropdown_window)
        self._update_filters_label_status() # <--- UPDATE FILTERS LABEL STATUS HERE
        print("    DEBUG: _on_country_dropdown_button_click() END") # Debug
        
        
        
    def _show_sidebar_filter_dropdown(self, filter_name, button_widget): #FOR BRANDS
        """Displays the sidebar filter dropdown."""


        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust constraints while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 
        

        
        if self._destroy_existing_dropdown(filter_name):
            return

        button_x, button_y = self._calculate_dropdown_position(button_widget)
        dropdown_window = self._create_dropdown_window(self.master, button_x, button_y)
        canvas, scrollable_frame = self._create_scrollable_canvas(dropdown_window, 180, 410) # dropdown width Brands

        search_var = tk.StringVar()
        search_entry = self._create_search_bar(scrollable_frame, search_var)

        filter_options_data = {
            "Brand": ["All Brands"] + self.get_unique_brands(),
            "Name": ["All Names", "Name 1", "Name 2"],
            "Country": ["All Countries"] + self.get_unique_countries(),
            # "Author": ["All Authors", "Author 1", "Author 2"], # REMOVED Author
            "Bodystyle": ["All Bodystyles"] + self.get_unique_body_styles(),
            # "Type": ["All Types", "Type 1", "Type 2"] # REMOVED Type
        }
        original_options = filter_options_data[filter_name]
        current_options = list(original_options)

        on_dropdown_button_click_lambda = lambda opt: self._on_dropdown_button_click_for_brands(opt, filter_name, button_widget, dropdown_window)
        update_dropdown_options_func = self._update_dropdown_options(
            scrollable_frame, search_var, original_options, button_widget, 240, on_dropdown_button_click_lambda, canvas
        )

        def debounced_update_dropdown_options(event):
            if self.debounce_timer:
                self.master.after_cancel(self.debounce_timer)
            self.debounce_timer = self.master.after(600, lambda: update_dropdown_options_func(event)) # 200ms delay

        search_entry.bind("<KeyRelease>", debounced_update_dropdown_options)

        self._create_dropdown_buttons(scrollable_frame, current_options, button_widget, 240, on_dropdown_button_click_lambda)


        dropdown_window.bind("<FocusOut>", lambda event, fname=filter_name: self.destroy_sidebar_filter_dropdown(fname))
        dropdown_attr_name = f"sidebar_{filter_name.lower()}_dropdown_window"
        setattr(self, dropdown_attr_name, dropdown_window)
        dropdown_window.geometry(f"+{button_x}+{button_y}")


        dropdown_window.bind("<FocusOut>", lambda event, fname=filter_name: self.destroy_sidebar_filter_dropdown(fname))
        dropdown_attr_name = f"sidebar_{filter_name.lower()}_dropdown_window"
        setattr(self, dropdown_attr_name, dropdown_window)
        dropdown_window.geometry(f"+{button_x}+{button_y}")

        
        
    def on_dropdown_mousewheel(self, event, canvas):
        """Handles mousewheel scrolling for dropdown canvas with ease-out (size-independent)."""
        if not canvas.winfo_exists():
            return

        if event.delta:
            scroll_units = int(-1 * (event.delta / 120))

            current_y = canvas.yview()[0]
            max_y_scroll = 1.0
            scrollable_height = canvas.bbox("all")[3] - canvas.bbox("all")[1] if canvas.bbox("all") else 0
            canvas_height = canvas.winfo_height()

            if scrollable_height <= canvas_height:
                return

            # Calculate scroll step based on a fraction of the *visible* canvas height
            scroll_fraction = 0.7  # Adjust this fraction (e.g., 0.1, 0.15, 0.25) for sensitivity
            scroll_step_normalized = (canvas_height / scrollable_height) * scroll_fraction * scroll_units
            # Explanation:
            # - (canvas_height / scrollable_height):  This is the proportion of the *total* content that is visible.
            # - scroll_fraction:  We want to scroll by a fraction of this visible portion.
            # - scroll_units:  Multiply by the scroll units.

            target_y_normalized = current_y + scroll_step_normalized
            target_y_normalized = max(0.0, min(max_y_scroll, target_y_normalized))

            self.scroll_target_y = target_y_normalized
            self.scroll_start_y = current_y
            self.scroll_start_time = self.master.tk.call('clock', 'milliseconds')

            if self.scroll_animation_id:
                canvas.after_cancel(self.scroll_animation_id)
            self.animate_dropdown_scroll(canvas)


    def animate_dropdown_scroll(self, canvas):
        """Animates the canvas scroll with ease-out."""
        current_time = self.master.tk.call('clock', 'milliseconds')
        time_elapsed = current_time - self.scroll_start_time
        progress = min(1.0, time_elapsed / self.scroll_duration) # Normalized progress (0 to 1)

        # Ease-out function (simple quadratic)
        ease_out_progress = progress * (2 - progress) #  f(t) = t * (2 - t)

        # Calculate current scroll position based on eased progress
        current_y_normalized = self.scroll_start_y + (self.scroll_target_y - self.scroll_start_y) * ease_out_progress

        canvas.yview_moveto(current_y_normalized)

        if progress < 1.0:
            self.scroll_animation_id = canvas.after(10, self.animate_dropdown_scroll, canvas) # 10ms delay for animation step
        else:
            self.scroll_animation_id = None # Animation finished
            


    def destroy_sidebar_filter_dropdown(self, filter_name):
        dropdown_attr_name = f"sidebar_{filter_name.lower()}_dropdown_window"
        if hasattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name).winfo_exists():
            getattr(self, dropdown_attr_name).destroy()
            setattr(self, dropdown_attr_name, None) # Clear dropdown window attribute

    def setup_event_bindings(self):
        self.master.bind("<Configure>", self.combined_configure_handler)
        self.canvas.bind("<Enter>", lambda e: self.canvas.bind_all("<MouseWheel>", self.on_mousewheel_main))
        self.canvas.bind("<Leave>", lambda e: self.canvas.unbind_all("<MouseWheel>"))

        self.master.bind_all("<Control-y>", lambda event: self.focus_beamng_window())

        self.master.bind("<Button-1>", self.on_main_window_click) # <--- ADD THIS LINE
        self.master.bind("<FocusIn>", self.lift_search_results_window) # <--- ADDED THIS LINE

        self.prev_master_x = self.master.winfo_x()
        self.prev_master_y = self.master.winfo_y()
        self.prev_master_width = self.master.winfo_width()
        self.prev_master_height = self.master.winfo_height()




    def combined_configure_handler(self, event):
        """
        Combines the functionality of throttled_resize and update_window_geometries
        into a single handler for the <Configure> event.
        """
        self.throttled_resize(event)
        self.update_window_geometries(event)
        self.on_master_window_moved(event)

        
    def on_master_window_moved(self, event):
        """
        This method is called whenever the master window is moved or resized.
        It compares the current window position and size to the previous ones and
        triggers self.on_main_window_click() only if they are different.
        """
        current_x = self.master.winfo_x()
        current_y = self.master.winfo_y()
        current_width = self.master.winfo_width()
        current_height = self.master.winfo_height()

        if (current_x != self.prev_master_x or
            current_y != self.prev_master_y or
            current_width != self.prev_master_width or
            current_height != self.prev_master_height):

            #print("Master window was moved or resized (position or size changed)!")
            #print(f"Old position: x={self.prev_master_x}, y={self.prev_master_y}")
            #print(f"Old size: width={self.prev_master_width}, height={self.prev_master_height}")
            #print(f"New position: x={current_x}, y={current_y}")
            #print(f"New size: width={current_width}, height={current_height}")

            self.on_main_window_click(event)

            # Update previous position and size to the current ones
            self.prev_master_x = current_x
            self.prev_master_y = current_y
            self.prev_master_width = current_width
            self.prev_master_height = current_height
        else:
            #print("Master window was moved or resized, but position and size are unchanged.")
            pass
            
            
    def lift_search_results_window(self, event=None):
        """
        Lifts the search results window, details window, and filters window to the top when the main window gains focus,
        with existence checks and conditional lifting for details window.
        """
        if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
            print("DEBUG: lift_search_results_window - Search Results window exists and is active - lifting.")
            self.search_results_window.lift()

        # --- MODIFIED: Check for details window existence AND if it's open before lifting ---
        if hasattr(self, 'details_window') and self.details_window and self.details_window.winfo_exists() and not self.details_window_closed:
            print("DEBUG: lift_search_results_window - Details window exists and is OPEN - lifting and grabbing focus.")
            self.details_window.lift()
            #self.details_window.grab_set() # Grab focus only if details window is open
            if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
                self.current_detail_window.lift()

        else:
            print("DEBUG: lift_search_results_window - Details window NOT lifted (not existing or closed).")

        # --- MODIFIED: Check for filters window existence before lifting ---
        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            print("DEBUG: lift_search_results_window - Filters window exists and Details window is CLOSED - lifting Filters window.")
            self.filters_window.lift()
        elif hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists() and self.is_details_window_open():
             print("DEBUG: lift_search_results_window - Filters window exists BUT Details window is OPEN - NOT lifting Filters window (Details window has priority).")
        elif hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.spawn_queue_window.lift()
        elif hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.hidden_window.lift()


        else:
            print("DEBUG: lift_search_results_window - Filters window NOT lifted (not existing or Details window is open).")
        # --- MODIFIED: Check for filters window existence before lifting ---
        
        # --- START: Dropdown menu destruction logic from on_main_window_click ---
        if self.is_filter_dropdown_open():
            self.destroy_filter_dropdown()
        if self.is_categorize_dropdown_open():
            self.destroy_categorize_dropdown()
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            self.destroy_search_mode_options_dropdown_menu()
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            self.destroy_settings_dropdown()
        if self.is_category_list_dropdown_open():
            self.destroy_category_list_dropdown()

        self.close_all_vehicle_dropdowns()
        
        filter_names = ["brand", "name", "country", "author", "bodystyle", "type"]
        for fname in filter_names:
            if self.is_sidebar_filter_dropdown_open(fname):
                self.destroy_sidebar_filter_dropdown(fname)
        # --- END: Dropdown menu destruction logic from on_main_window_click ---
        
        

    def lift_search_results_window_without_destroying_dropdowns(self, event=None):
        """
        Lifts the search results window, details window, and filters window to the top when the main window gains focus,
        with existence checks and conditional lifting for details window.
        """
        if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
            print("DEBUG: lift_search_results_window - Search Results window exists and is active - lifting.")
            self.search_results_window.lift()
            self.lift_all_dropdowns()

        # --- MODIFIED: Check for details window existence AND if it's open before lifting ---
        if hasattr(self, 'details_window') and self.details_window and self.details_window.winfo_exists() and not self.details_window_closed:
            print("DEBUG: lift_search_results_window - Details window exists and is OPEN - lifting and grabbing focus.")
            self.details_window.lift()
            #self.details_window.grab_set() # Grab focus only if details window is open
            if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
                self.current_detail_window.lift()

        else:
            print("DEBUG: lift_search_results_window - Details window NOT lifted (not existing or closed).")

        # --- MODIFIED: Check for filters window existence before lifting ---
        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            print("DEBUG: lift_search_results_window - Filters window exists and Details window is CLOSED - lifting Filters window.")
            self.filters_window.lift()
            self.lift_all_dropdowns()

        elif hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists() and self.is_details_window_open():
             print("DEBUG: lift_search_results_window - Filters window exists BUT Details window is OPEN - NOT lifting Filters window (Details window has priority).")
        elif hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.spawn_queue_window.lift()
        elif hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.hidden_window.lift()

            self.lift_all_dropdowns()


        else:
            print("DEBUG: lift_search_results_window - Filters window NOT lifted (not existing or Details window is open).")
        # --- MODIFIED: Check for filters window existence before lifting ---


    def lift_all_dropdowns(self):
        """
        Lifts all currently open dropdown windows to the front.
        """
        dropdown_window_attributes = [
            'filter_dropdown_window',
            'categorize_dropdown_window',
            'search_mode_options_dropdown_window',
            'settings_dropdown_window',
            'category_list_dropdown_window',
            'zip_search_dropdown_window',
            'player_vehicle_dropdown_window',
            'remove_vehicles_dropdown_window',
            'add_vehicles_dropdown_window'
        ]

        print("\n--- lift_all_dropdowns() DEBUG ENTRY ---") # Debug Entry

        for attr_name in dropdown_window_attributes:
            dropdown_window = getattr(self, attr_name, None)  # Get attribute value, default to None if not exists
            if dropdown_window and dropdown_window.winfo_exists():
                print(f"  DEBUG: lift_all_dropdowns - Lifting dropdown window: {attr_name}") # Debug - Lifting Window
                dropdown_window.lift()
            else:
                print(f"  DEBUG: lift_all_dropdowns - Dropdown window NOT lifted: {attr_name} (not existing or not mapped)") # Debug - Window Not Lifted

        print("--- lift_all_dropdowns() DEBUG EXIT ---\n") # Debug Exit

        
        
    def on_main_window_click(self, event):
        """Handles clicks on the main window to close dropdown menus and unfocus search bar."""
        if self.is_filter_dropdown_open():
            if not self.is_descendant_of(event.widget, self.filter_dropdown_window):
                self.destroy_filter_dropdown()
        if self.is_categorize_dropdown_open():
            if not self.is_descendant_of(event.widget, self.categorize_dropdown_window):
                self.destroy_categorize_dropdown()
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            if not self.is_descendant_of(event.widget, self.search_mode_options_dropdown_window) and event.widget != self.search_mode_button and event.widget != self.search_entry:
                self.destroy_search_mode_options_dropdown_menu()
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            if not self.is_descendant_of(event.widget, self.settings_dropdown_window) and event.widget != self.settings_button:
                self.destroy_settings_dropdown()
        if self.is_category_list_dropdown_open(): # <-- ADDED THIS LINE
            if not self.is_descendant_of(event.widget, self.category_list_dropdown_window) and event.widget != self.category_list_button: # <-- AND THIS CONDITION
                self.destroy_category_list_dropdown() # <-- AND THIS CALL
                

        self.close_all_vehicle_dropdowns()   

        if event.widget != self.search_entry:
            self.master.focus_set()

        filter_names = ["brand", "name", "country", "author", "bodystyle", "type"]
        for fname in filter_names:
            if self.is_sidebar_filter_dropdown_open(fname):
                dropdown_window = getattr(self, f"sidebar_{fname}_dropdown_window")
                if not self.is_descendant_of(event.widget, dropdown_window):
                    self.destroy_sidebar_filter_dropdown(fname)


    def is_zip_search_dropdown_open(self):
        """Check if the zip search dropdown menu is currently open."""
        return hasattr(self, 'zip_search_dropdown_window') and self.zip_search_dropdown_window and self.zip_search_dropdown_window.winfo_exists()



        
        
    def show_search_mode_options_dropdown(self, event=None):
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            return

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot switch Search Mode while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
            return 
        

        button = self.search_mode_button
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty() + button.winfo_height()

        self.search_mode_options_dropdown_window = tk.Toplevel(self.master)
        self.search_mode_options_dropdown_window.overrideredirect(True)
        self.search_mode_options_dropdown_window.tk.call('tk', 'scaling', 1.25)
        self.search_mode_options_dropdown_window.geometry(f"+{button_x}+{button_y}")
        self.search_mode_options_dropdown_window.config(bg="#333333")
        self.search_mode_options_dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        search_modes = ["General", "Configs"] # Define search mode options
        self.current_tooltip_window = None # Initialize to None to track current tooltip

        def show_search_mode_option_tooltip(mode, button_widget): # Modified to take button_widget
            if self.current_tooltip_window:
                self.destroy_search_mode_option_tooltip_global_filter() # Destroy any existing tooltip

            self.current_tooltip_window = tk.Toplevel(self.master)
            self.current_tooltip_window.overrideredirect(True) # No border for tooltip
            self.current_tooltip_window.tk.call('tk', 'scaling', 1.25)

            tip_text = ""
            if mode == "General":
                tip_text = "Search for Name, Brand, Type, Zip, etc..."
            elif mode == "Configs":
                tip_text = "Search for Config Name, Config File Name"

            tooltip_label = tk.Label(self.current_tooltip_window, text=tip_text, font=("Segoe UI", 10, "bold", "italic"), fg="lightgrey", bg="#555555", padx=5, pady=2, relief=tk.SOLID, borderwidth=1) # Darker bg for tooltip
            tooltip_label.pack(padx=1, pady=1) # Padding inside tooltip

            # Position tooltip to the right of the button
            button_width = button_widget.winfo_width()
            button_height = button_widget.winfo_height()
            button_abs_x = button_widget.winfo_rootx()
            button_abs_y = button_widget.winfo_rooty()

            tooltip_x = button_abs_x + button_width + 5 # 5px gap
            tooltip_y = button_abs_y + (button_height + 67) - (self.current_tooltip_window.winfo_reqheight() // 2)

            self.current_tooltip_window.geometry(f"+{tooltip_x}+{tooltip_y}")
            self.current_tooltip_window.after(4000, self.current_tooltip_window.destroy)

        def destroy_search_mode_option_tooltip():
            if self.current_tooltip_window:
                self.current_tooltip_window.destroy()
                self.current_tooltip_window = None


        def on_search_mode_option_click(mode):
            if mode == "Configs":
                # Destroy Filters Window
                if self.filters_window and self.filters_window.winfo_exists():
                    self.filters_window.destroy()
                    self.filters_window = None

                # Clear Global Filters and Reset Buttons
                entry_widgets = {}  # Assuming you have access to entry_widgets in this scope or can retrieve them
                on_off_button_style_args = self._create_button_style() # Or however you get button style args
                self.clear_all_filters_and_files(entry_widgets, on_off_button_style_args)


                # Disable Subset Mode
                self.is_data_subset_active = False
                self.subset_data_button.config(text="Off")
                self.reset_button_color(self.subset_data_button, self.button_style_args)

            self.search_var.set("") # Clear the search bar text
            self.search_mode = mode
            self.search_mode_button.config(text=f"Search Mode: {self.search_mode}")
            self.perform_search() # Perform search after mode change # <--- ADDED perform_search() HERE
            self.destroy_search_mode_options_dropdown_menu()
            destroy_search_mode_option_tooltip() # Destroy tooltip when option is clicked

            # Update Filters Button state based on search mode
            button_style_args = self._create_button_style()
            disabled_button_style_args = button_style_args.copy()
            disabled_button_style_args["fg"] = "grey"
            disabled_button_style_args["activebackground"] = "#555555"
            disabled_button_style_args["activeforeground"] = "grey"

            if self.search_mode == "Configs":
                self.filters_button.config(
                    command=None, # Disable command
                    **disabled_button_style_args # Apply disabled style
                )
                self.filters_button.unbind("<Enter>") # Unbind hover
                self.filters_button.unbind("<Leave>") # Unbind leave
                self.filters_button.unbind("<Button-1>") # Unbind click
            else: # General mode
                self.filters_button.config(
                    command=self.show_filters_window, # Re-enable command
                    **button_style_args # Apply normal style
                )
                on_button_hover_enter, on_button_hover_leave, on_button_click = self._create_button_event_handlers()
                self._bind_button_events(self.filters_button, on_button_hover_enter, on_button_hover_leave, on_button_click) # Re-bind events


        search_modes = ["General", "Configs"]
        dropdown_row = 0
        for mode in search_modes:
            bg_color = "#555555"
            fg_color = "white"
            if mode == self.search_mode:
                bg_color = self.global_highlight_color
                fg_color = "white"

            dropdown_button = tk.Button(
                self.search_mode_options_dropdown_window,
                text=f"{mode}",
                font=("Segoe UI", 10, "bold"),
                command=lambda m=mode: on_search_mode_option_click(m),
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5,
                bg=bg_color,
                fg=fg_color
            )
            dropdown_button.pack(fill="x")
            dropdown_button.bind("<Enter>", lambda event, btn=dropdown_button, m=mode: [btn.config(bg="lightgrey", fg="black"), show_search_mode_option_tooltip(m, btn)]) # Pass button widget to tooltip func
            dropdown_button.bind("<Leave>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: [btn.config(bg=original_bg, fg=original_fg), destroy_search_mode_option_tooltip()]) # Call destroy tooltip on leave
            dropdown_row += 1

        self.search_mode_options_dropdown_window.bind("<FocusOut>", self.destroy_search_mode_options_dropdown) # Bind focus out to window


        


    def destroy_search_mode_options_dropdown_menu(self):
        self.is_search_results_window_closing = True # <--- SET FLAG BEFORE DESTROY
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            self.search_mode_options_dropdown_window.destroy()
            self.search_mode_options_dropdown_window = None
        self.is_search_results_window_closing = False # <--- RESET FLAG AFTER DESTROY

            
            
    def is_sidebar_filter_dropdown_open(self, filter_name):
        dropdown_attr_name = f"sidebar_{filter_name}_dropdown_window"
        return hasattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name) and getattr(self, dropdown_attr_name).winfo_exists()
        
    # --- Helper functions to check if dropdowns are open ---
    def is_filter_dropdown_open(self):
        return hasattr(self, 'filter_dropdown_window') and self.filter_dropdown_window and self.filter_dropdown_window.winfo_exists()


    def is_categorize_dropdown_open(self):
        return hasattr(self, 'categorize_dropdown_window') and self.categorize_dropdown_window and self.categorize_dropdown_window.winfo_exists()

    def is_category_list_dropdown_open(self): # <-- ADDED THIS FUNCTION
        return hasattr(self, 'category_list_dropdown_window') and self.category_list_dropdown_window and self.category_list_dropdown_window.winfo_exists()







    def initialize_data_and_grid(self):
        self.grouped_data = self.format_grouped_data(self.data)
        self.populate_initial_grid()
        self.details_sidebar_debounce_timer = None # Initialize debounce timer for details sidebar
        self.current_main_sidebar_item = None # To store the currently selected item in main grid sidebar

        print(f"config_pics_custom_folder: {self.config_pics_custom_folder}")  # Debugging print







    def show_scanning_window(self, text="Changes detected, scanning..."):
        self.show_scanning_window_count += 1 # Increment the counter each time the function is called

        

        scanning_window = tk.Toplevel(self.master)
        scanning_window.title("Ellexium's Mod Manager/Vehicle Selector")

        icon_path = self.script_dir / "data/icon.png"

        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            scanning_window.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")

        scanning_window.attributes('-topmost', True)
        #scanning_window.overrideredirect(True)  # Remove window border
        scanning_window.tk.call('tk', 'scaling', 1.25)
        scanning_window.resizable(False, False)

        # Define scanning window size - default values
        window_width = 600
        window_height = 70

        # Check if text contains "restart the game" and adjust window size if it does
        if "restart the game" in text.lower(): # Convert text to lowercase for case-insensitive check
            window_width = 700  # Smaller width
            window_height = 140 # Smaller height

        # Check if text contains "disappears" and adjust window size if it does
        if "disappears" in text.lower(): # Convert text to lowercase for case-insensitive check
            window_width = 600  # Smaller width
            window_height = 140 # Smaller height


        # Set background color of the window
        scanning_window.configure(bg="#333333")  # Set background color

        # Ensure the main window's geometry is updated
        self.master.update_idletasks()

        # --- Centering Logic ---
        if self.show_scanning_window_count <= 2:
            # Center on screen for the first two calls
            screen_width = scanning_window.winfo_screenwidth()
            screen_height = scanning_window.winfo_screenheight()
            pos_x = (screen_width // 2) - (window_width // 2)
            pos_y = (screen_height // 2) - (window_height // 2)
            scanning_window.overrideredirect(True)  # Remove window border
            scanning_window.config(highlightthickness=5, highlightbackground="#555555") # Add border here

            
        else:
            # Center relative to master window for subsequent calls
            # Get main window's position and size
            master_x = self.master.winfo_rootx()
            master_y = self.master.winfo_rooty()
            master_width = self.master.winfo_width()
            master_height = self.master.winfo_height()
            

            # Calculate position for the scanning window to be centered relative to master
            pos_x = master_x + (master_width // 2) - (window_width // 2)
            pos_y = master_y + (master_height // 2) - (window_height // 2)
            scanning_window.overrideredirect(True)  # Remove window border
            scanning_window.config(highlightthickness=5, highlightbackground="#555555") # Add border here
            # Schedule destroy_lingering_scanning_windows after 7 seconds
            scanning_window.after(7000, lambda window=scanning_window: window.destroy())


        # Set the geometry of the scanning window
        scanning_window.geometry(f"{window_width}x{window_height}+{pos_x}+{pos_y}")

        lbl = tk.Label(
            scanning_window,
            text=text,
            font=("Segoe UI", 12, "bold"),
            fg="#ffffff",  # Start with white text (or very light grey)
            bg="#333333"
        )
        lbl.pack(expand=True, padx=20, pady=20)

        scanning_window.update()

        # --- Fade-in animation (rest of your code remains unchanged) ---
        start_color_rgb = (1.0, 1.0, 1.0)  # White in RGB (normalized 0.0-1.0)
        end_color_rgb = (1.0, 0.65, 0.0)  # Orange in RGB (normalized 0.0-1.0, roughly)
        duration_ms = 1000  # 1 second
        steps = 50  # Number of steps in the animation
        delay_ms = duration_ms // steps

        '''
        def fade_text_color(step):
            if step <= steps:
                # Interpolate RGB values
                r = start_color_rgb[0] + (end_color_rgb[0] - start_color_rgb[0]) * step / steps
                g = start_color_rgb[1] + (end_color_rgb[1] - start_color_rgb[1]) * step / steps
                b = start_color_rgb[2] + (end_color_rgb[2] - start_color_rgb[2]) * step / steps

                # Convert RGB (0.0-1.0) to hex color string
                hex_color = "#{:02x}{:02x}{:02x}".format(int(r * 255), int(g * 255), int(b * 255))
                lbl.config(fg=hex_color)
                scanning_window.after(delay_ms, fade_text_color, step + 1) # Call next step

        fade_text_color(0) # Start the fade animation
        '''
        return scanning_window

    def destroy_scanning_window(self):
        """Destroys the scanning window if it exists."""
        self.scanning_window.destroy()
        
        return


    ######################################################################
    #               start of interaction with beamng                  #
    ######################################################################

    def focus_beamng_window(self):
        beamng_window_handle = None
        window_title_regex = r"BeamNG\.drive.*"  # CHANGED REGEX HERE!
        process_name_check = 'BeamNG.drive.x64.exe'

        def window_enum_handler(hwnd, wildcard):
            nonlocal beamng_window_handle

            if not win32gui.IsWindowVisible(hwnd): # First check if window is visible, skip if not
                return True

            # --- Use ctypes to call GetWindowThreadProcessId ---
            try:
                process_id = ctypes.c_ulong()
                thread_id = ctypes.c_ulong()

                # GetWindowThreadProcessId function from user32.dll
                get_process_thread_id_func = ctypes.windll.user32.GetWindowThreadProcessId
                get_process_thread_id_func(hwnd, ctypes.byref(process_id)) # Call the function

                process_id = process_id.value # Extract process ID value
                thread_id_val = thread_id.value # Not really needed in this ctypes version, but kept for potential debugging

                last_error = ctypes.GetLastError() # Get last error using ctypes


            except Exception as e_ctypes_call: # Catch exceptions during ctypes call
                return True # Skip to next window
            # --- End ctypes call ---


            process_name = None # Initialize process_name
            try:
                current_process = psutil.Process(process_id) # Try to get process object IMMEDIATELY
                process_name = current_process.name() # Get process name
            except psutil.NoSuchProcess as e: # Catch NoSuchProcess right after PID retrieval
                return True # Skip to next window
            except Exception as e_process_get: # Catch any other exception when getting process info
                return True


            if process_name != process_name_check: # Check process name *before* title
                return True # Not BeamNG.drive, skip to next window

            # ONLY if it's the correct process, check the title:
            window_text = win32gui.GetWindowText(hwnd)
            match_result = re.search(window_title_regex, window_text)

            if match_result:
                beamng_window_handle = hwnd
                return False # Stop enumeration

            return True # Continue enumeration

        # --- MODIFIED: Try-except block with retry for EnumWindows ---
        attempts = 2  # Number of attempts
        for attempt in range(attempts):
            try:
                win32gui.EnumWindows(window_enum_handler, None)
                break  # If EnumWindows succeeds, break out of the loop
            except pywintypes.error as e:
                if e.args[0] == 2 and attempt < attempts - 1: # Check for error code 2 and if retries are remaining
                    print(f"Warning: EnumWindows failed on attempt {attempt + 1} with error: {e}. Retrying in 0.1s...")
                    time.sleep(0.1) # Small delay before retry
                    continue # Retry EnumWindows
                else:
                    print(f"Error: EnumWindows failed after {attempts} attempts with error: {e}")
                    break # Break loop if it's not error code 2 or no retries left
        # --- MODIFIED: Try-except block with retry for EnumWindows ---

        if beamng_window_handle:
            if win32gui.IsIconic(beamng_window_handle): # Check if minimized
                print("BeamNG.drive window is minimized.") # Optional print for console
                return False # Stop focusing and return False
            else:
                win32gui.ShowWindow(beamng_window_handle, 5) # SW_RESTORE
                win32gui.SetForegroundWindow(beamng_window_handle)
                self.on_details_window_close()
                return True
        else:
            print("BeamNG.drive window not found.") # Keep this print
            return False

    def is_beamng_running(self):
        process_name = 'BeamNG.drive.x64.exe'
        print(f"Checking if process '{process_name}' is running...")
        for proc in psutil.process_iter(['name', 'exe']): # Request 'exe' in process info
            if proc.info['name'] == process_name:
                exe_path = proc.info['exe'] # Get the executable path
                print(f"Process '{process_name}' is running. Executable path: '{exe_path}'") # Print path
                return True
        print(f"Process '{process_name}' is not running.")
        return False
    

    def send_escape(self, event=None):

        if not self.is_beamng_running():
            #messagebox.showerror("Error", "BeamNG.drive is not running.")
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="BeamNG.drive does not appear to be running.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()
            return False # Indicate failure

        self.on_details_window_close()
        print("BeamNG.drive is running.") # Added print
        #time.sleep(0.125) # Reduced time.sleep to quarter

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        time.sleep(0.125) # Reduced time.sleep to quarter
        if not self.focus_beamng_window():

            scanning_win = self.show_scanning_window(text="Please ensure BeamNG.drive is open and not minimized.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()

            #messagebox.showerror("Error", "BeamNG.drive window not found.")
            return False # Indicate failure

        print("BeamNG.drive window focused.") # Added print
        #time.sleep(0.125) # Reduced time.sleep to quarter


        pydirectinput.keyDown('esc')
        time.sleep(0.125)
        pydirectinput.keyUp('esc')
        

    def send_j(self, event=None):

        if not self.is_beamng_running():
            #messagebox.showerror("Error", "BeamNG.drive is not running.")
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="BeamNG.drive does not appear to be running.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()
            return False # Indicate failure

        self.on_details_window_close()
        print("BeamNG.drive is running.") # Added print
        #time.sleep(0.125) # Reduced time.sleep to quarter

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        time.sleep(0.125) # Reduced time.sleep to quarter
        if not self.focus_beamng_window():

            scanning_win = self.show_scanning_window(text="Please ensure BeamNG.drive is open and not minimized.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()

            #messagebox.showerror("Error", "BeamNG.drive window not found.")
            return False # Indicate failure

        print("BeamNG.drive window focused.") # Added print


        pydirectinput.keyDown('j')
        time.sleep(0.125)
        pydirectinput.keyUp('j')

        

    def run_spawn_queue(self, retry=False, attempt_number=1):


        if retry:
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text=f"Spawn queue spawning attempts: {attempt_number}")
            time.sleep(0.725)
            if scanning_win:
                scanning_win.destroy()


        scanning_window = None # Initialize scanning_window outside try block

        scanning_window = self.show_scanning_window(text="Attempting to spawn multiple vehicles from Spawn Queue, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
        # Make the window visible
        scanning_window.deiconify()
        self.master.update_idletasks() # Force window to appear immediately

        try:
            with open(self.SPAWN_QUEUE_FILE, 'r', encoding="utf-8") as f:
                commands = f.readlines()
                pass

        except FileNotFoundError:

            print(f"spawn queue file doesn't exist")
            #messagebox.showerror("Error", f"Spawn queue file '{self.SPAWN_QUEUE_FILE}' not found.")

            if scanning_window:
                scanning_window.destroy()
            scanning_win = self.show_scanning_window(text="Spawn queue empty.")
            time.sleep(3.125)
            scanning_win.destroy()
            self.show_spawn_queue_window()
            return
        


        if not self.is_beamng_running():
            #messagebox.showerror("Error", "BeamNG.drive is not running.")
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="BeamNG.drive does not appear to be running.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()
            return False # Indicate failure


        print("BeamNG.drive is running.") # Added print
        time.sleep(1.125) # Reduced time.sleep to quarter

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        time.sleep(1.125) # Reduced time.sleep to quarter
        if not self.focus_beamng_window():

            scanning_win = self.show_scanning_window(text="Please ensure BeamNG.drive is open and not minimized.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()

            #messagebox.showerror("Error", "BeamNG.drive window not found.")
            return False # Indicate failure

        print("BeamNG.drive window focused.") # Added print
        time.sleep(1.125) # Reduced time.sleep to quarter

        self.focus_beamng_window()

        pydirectinput.keyDown('shift')
        pydirectinput.keyDown('ctrl')
        pydirectinput.keyDown('alt')
        pydirectinput.keyDown('f11')

        # Wait for the specified hold time
        time.sleep(0.125)

        pydirectinput.keyUp('f11')
        pydirectinput.keyUp('alt')
        pydirectinput.keyUp('ctrl')
        pydirectinput.keyUp('shift')

        self.on_details_window_close()

        if scanning_window:
            scanning_window.destroy() # Destroy the scanning window after spawn attempt
        
        print(f"Spawn Queue actions completed. ATTEMPT {attempt_number}") # Updated message


        data_folder = self.script_dir / "data"
        COMMANDconfirmation = data_folder / "commandconfirmation.txt"

        max_attempts = 7

        # --- NOW CHECK FOR THE FILE AFTER RUNNING ACTIONS ---
        print(f"Checking for file '{COMMANDconfirmation}' - Attempt {attempt_number}/{max_attempts}...")
        if os.path.exists(COMMANDconfirmation):
            print(f"File '{COMMANDconfirmation}' exists after actions on attempt {attempt_number}. Deleting it.")
            try:
                os.remove(COMMANDconfirmation)
                print(f"File '{COMMANDconfirmation}' deleted successfully.")
                return True # Indicate success (file existed and was deleted)
            except OSError as e:
                print(f"Error deleting file '{COMMANDconfirmation}': {e}")
                return False # Indicate failure (file deletion error)

        else: # File does not exist AFTER running actions
            if attempt_number >= max_attempts: # Check attempt number for max retries
                print(f"File '{COMMANDconfirmation}' still does not exist after {max_attempts} attempts. Stopping.")

                scanning_win = None  # Initialize scanning_win

                scanning_win = self.show_scanning_window(text=f"Maximum number of attempts ({attempt_number}) to spawn multiple vehicles from Spawn Queue reached. \nPlease ensure EllexiumModManagerInput.zip is in the mods folder and restart the game.")
                time.sleep(5.725)
                if scanning_win:
                    scanning_win.destroy()

                return False # Indicate failure (file never appeared after max attempts)
            else:
                print(f"File '{COMMANDconfirmation}' does not exist on attempt {attempt_number}. Retrying function...")
                time.sleep(1.125) # Reduced time.sleep to quarter
                return self.run_spawn_queue(retry=True, attempt_number=attempt_number + 1) # Recursive call, incrementing attempt_number


    def run_spawn_queue_transient(self, retry=False, attempt_number=1): # NEW FUNCTION FOR TRANSIENT QUEUE, added retry parameter


        if retry:
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text=f"Spawn/Replace/Delete/Save attempts: {attempt_number}")
            time.sleep(0.725)
            if scanning_win:
                scanning_win.destroy()



        # --- RUN THE FUNCTION ACTIONS FIRST ---
        if not self.is_beamng_running():
            #messagebox.showerror("Error", "BeamNG.drive is not running.")
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="BeamNG.drive does not appear to be running.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()
            return False # Indicate failure


        print("BeamNG.drive is running.") # Added print
        time.sleep(1.125) # Reduced time.sleep to quarter

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        time.sleep(1.125) # Reduced time.sleep to quarter
        if not self.focus_beamng_window():

            scanning_win = self.show_scanning_window(text="Please ensure BeamNG.drive is open and not minimized.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()

            #messagebox.showerror("Error", "BeamNG.drive window not found.")
            return False # Indicate failure

        print("BeamNG.drive window focused.") # Added print

        self.focus_beamng_window()

        # Press and hold Shift, Ctrl, and Alt keys
        pydirectinput.keyDown('shift')
        pydirectinput.keyDown('ctrl')
        pydirectinput.keyDown('alt')
        pydirectinput.keyDown('f12')

        # Wait for the specified hold time
        time.sleep(0.125)


        pydirectinput.keyUp('f12')
        pydirectinput.keyUp('alt')
        pydirectinput.keyUp('ctrl')
        pydirectinput.keyUp('shift')

        self.on_details_window_close()



        

        print(f"Transient Spawn Queue actions completed. ATTEMPT {attempt_number}") # Updated message


        data_folder = self.script_dir / "data"
        COMMANDconfirmation = data_folder / "commandconfirmation.txt"

        max_attempts = 7 #change back to 7

        # --- NOW CHECK FOR THE FILE AFTER RUNNING ACTIONS ---
        print(f"Checking for file '{COMMANDconfirmation}' - Attempt {attempt_number}/{max_attempts}...")
        if os.path.exists(COMMANDconfirmation):
            print(f"File '{COMMANDconfirmation}' exists after actions on attempt {attempt_number}. Deleting it.")
            try:
                os.remove(COMMANDconfirmation)
                print(f"File '{COMMANDconfirmation}' deleted successfully.")
                return True # Indicate success (file existed and was deleted)
            except OSError as e:
                print(f"Error deleting file '{COMMANDconfirmation}': {e}")
                return False # Indicate failure (file deletion error)

        else: # File does not exist AFTER running actions
            if attempt_number >= max_attempts: # Check attempt number for max retries
                print(f"File '{COMMANDconfirmation}' still does not exist after {max_attempts} attempts. Stopping.")

                scanning_win = None  # Initialize scanning_win

                scanning_win = self.show_scanning_window(text=f"Maximum number of attempts ({attempt_number}) to spawn, replace, save or delete vehicle(s) reached. \nPlease ensure EllexiumModManagerInput.zip is in the mods folder and restart the game.")
                time.sleep(5.725)
                if scanning_win:
                    scanning_win.destroy()

                return False # Indicate failure (file never appeared after max attempts)
            else:
                print(f"File '{COMMANDconfirmation}' does not exist on attempt {attempt_number}. Retrying function...")
                time.sleep(1.125) # Reduced time.sleep to quarter
                return self.run_spawn_queue_transient(retry=True, attempt_number=attempt_number + 1) # Recursive call, incrementing attempt_number




##################################################### SPAWNING VEHICLES 


    
    def on_color_picker_replace_or_spawn(self):
        print("on_color_picker_replace_or_spawn function called in ConfigViewerApp!")

        scanning_window = self.show_scanning_window(text="Attempting to spawn/replace vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
        # Make the window visible
        scanning_window.deiconify()
        self.master.update_idletasks() # Force window to appear immediately

        self.is_details_sidebar_sticky = True
        self.is_details_sidebar_showing_default = False
        # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
        try:
            print(f"Running Spawn Queue Transient Directly (likely through the color picker)")
            self.run_spawn_queue_transient(retry=False, attempt_number=1)
        except Exception as e:
            #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
            print(f"ERROR: Failed to spawn: {e}") # Error print
        # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---


    def on_spawn_new_button_click(self):
        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = None
        info_data = None
        picture_path = None
        zip_file = None

        if self.is_details_sidebar_showing_default: # NEW: Check if sidebar is showing DEFAULT config
            print("DEBUG: Spawn New Click - Sidebar showing DEFAULT config, attempting to extract data from labels...") # Debug
            # --- NEW: Get FULL spawn_cmd from the LABEL's stored attribute, not label text ---
            spawn_cmd = getattr(self.details_sidebar_config_name_label, 'spawn_command', None) # Get FULL spawn_cmd from label attribute
            if spawn_cmd:
                print(f"  DEBUG: Extracted spawn_cmd from label attribute: '{spawn_cmd}'") # Debug - Extracted from label attribute
            else:
                print("  Warning: Could not extract spawn_cmd from sidebar label attribute (default config).") # Debug - Label Extract Fail
                spawn_cmd = None # Ensure spawn_cmd is None if extraction fails

            # --- For info_data and picture_path, we might have to use the default config item again (less ideal) ---
            default_config_item = self.find_default_config_item_details(self.details_data, self.current_details_zip_file)
            if default_config_item:
                picture_path, _, _, info_data, _ = default_config_item # Get from default config item again
            else:
                info_data = {} # Fallback to empty info_data
                picture_path = None # Fallback to None picture path
                print("  Warning: Could not retrieve default_config_item for info_data/picture_path.") # Debug - Default Item Retrieval Fail
            zip_file = self.current_details_zip_file # Zip file is still known

        elif hasattr(self, 'current_details_sidebar_spawn_cmd'): # Fallback to existing logic if NOT default config
            print("DEBUG: Spawn New Click - Sidebar showing CLICKED image config, using stored attributes...") # Debug
            spawn_cmd = self.current_details_sidebar_spawn_cmd # Use stored attributes (as before)
            info_data = self.current_details_sidebar_info_data
            picture_path = self.current_details_sidebar_picture_path
            zip_file = self.current_details_sidebar_zip_file
        else:
            print("Warning: Spawn command not available for Spawn New action.")
            return # Exit if no spawn command available

        scanning_window = None # Initialize scanning_window outside try block
        if spawn_cmd: # Only proceed if spawn_cmd is successfully obtained (either from label or stored attribute)
            try:
                scanning_window = self.show_scanning_window(text="Attempting to spawn vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
                # Make the window visible
                scanning_window.deiconify()
                self.master.update_idletasks() # Force window to appear immediately

                self.is_details_sidebar_sticky = True
                self.is_details_sidebar_showing_default = False
                # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
                try:
                    with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                        modified_lines = []
                        for line in spawn_cmd.splitlines():
                            use_index = line.find('(USE')
                            if use_index != -1:
                                modified_lines.append(line[:use_index])  # Keep only the part before (USE
                            else:
                                modified_lines.append(line) # Keep the line as is if (USE is not found

                        modified_spawn_cmd = '\n'.join(modified_lines)
                        f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                        f.write(modified_spawn_cmd + '\n') # Write command to file
                    #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                    print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                    self.run_spawn_queue_transient(retry=False, attempt_number=1)
                except Exception as e:
                    #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                    print(f"ERROR: Failed to spawn: {e}") # Error print
                # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

            except Exception as e:
                print(f"Error during spawn process: {e}")
            finally: # Ensure scanning window is always destroyed
                if scanning_window:
                    scanning_window.destroy() # Destroy the scanning window after spawn attempt

        else:
            print("Warning: Spawn command STILL not available for writing to Spawn Queue.") # Debug - Still no spawn command
            
        

    def on_replace_current_button_click(self, spawn_cmd=None, event=None):
        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        #spawn_cmd = None
        info_data = None
        picture_path = None
        zip_file = None

        #if self.is_details_sidebar_showing_default: # NEW: Check if sidebar is showing DEFAULT config
        print("DEBUG: Spawn New Click - attempting to extract data from labels...") # Debug
        # --- NEW: Get FULL spawn_cmd from the LABEL's stored attribute, not label text ---

        if not spawn_cmd:
            spawn_cmd = getattr(self.details_sidebar_config_name_label, 'spawn_command', None) # Get FULL spawn_cmd from label attribute


        if spawn_cmd:
            spawn_cmd = spawn_cmd.replace("spawnNewVehicle", "replaceVehicle")

            print(f"  DEBUG: Extracted spawn_cmd from label attribute: '{spawn_cmd}'") # Debug - Extracted from label attribute
        else:
            print("  Warning: Could not extract spawn_cmd from sidebar label attribute (default config).") # Debug - Label Extract Fail
            spawn_cmd = None # Ensure spawn_cmd is None if extraction fails

        # --- For info_data and picture_path, we might have to use the default config item again (less ideal) ---
        default_config_item = self.find_default_config_item_details(self.details_data, self.current_details_zip_file)
        if default_config_item:
            picture_path, _, _, info_data, _ = default_config_item # Get from default config item again
        else:
            info_data = {} # Fallback to empty info_data
            picture_path = None # Fallback to None picture path
            print("  Warning: Could not retrieve default_config_item for info_data/picture_path.") # Debug - Default Item Retrieval Fail
        zip_file = self.current_details_zip_file # Zip file is still known



        scanning_window = None # Initialize scanning_window outside try block
        if spawn_cmd: # Only proceed if spawn_cmd is successfully obtained (either from label or stored attribute)
            try:
                scanning_window = self.show_scanning_window(text="Attempting to replace vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
                # Make the window visible
                scanning_window.deiconify()
                self.master.update_idletasks() # Force window to appear immediately

                self.is_details_sidebar_sticky = True
                self.is_details_sidebar_showing_default = False
                # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
                try:
                    with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                        modified_lines = []
                        for line in spawn_cmd.splitlines():
                            use_index = line.find('(USE')
                            if use_index != -1:
                                modified_lines.append(line[:use_index])  # Keep only the part before (USE
                            else:
                                modified_lines.append(line) # Keep the line as is if (USE is not found

                        modified_spawn_cmd = '\n'.join(modified_lines)
                        f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                        f.write(modified_spawn_cmd + '\n') # Write command to file
                    #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                    print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                    self.run_spawn_queue_transient(retry=False, attempt_number=1)
                except Exception as e:
                    #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                    print(f"ERROR: Failed to spawn: {e}") # Error print
                # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

            except Exception as e:
                print(f"Error during spawn process: {e}")
            finally: # Ensure scanning window is always destroyed
                if scanning_window:
                    scanning_window.destroy() # Destroy the scanning window after spawn attempt

        else:
            print("Warning: Spawn command STILL not available for writing to Spawn Queue.") # Debug - Still no spawn command
            
            
            
    def on_add_to_queue_button_click(self):
        return # this is unused and unreliable
        """Handles click on the 'Add to Spawn New' button in the details sidebar.
        Modified to write the spawn command to the spawn queue file
        and refresh the Spawn Queue window if it is open.
        """
        spawn_cmd = None
        info_data = None
        picture_path = None
        zip_file = None

        if self.is_details_sidebar_showing_default:
            print("DEBUG: Spawn New Click - Sidebar showing DEFAULT config, attempting to extract data from labels...")
            spawn_cmd = getattr(self.details_sidebar_config_name_label, 'spawn_command', None)
            if spawn_cmd:
                print(f"  DEBUG: Extracted spawn_cmd from label attribute: '{spawn_cmd}'")
            else:
                print("  Warning: Could not extract spawn_cmd from sidebar label attribute (default config).")
                spawn_cmd = None

            default_config_item = self.find_default_config_item_details(self.details_data, self.current_details_zip_file)
            if default_config_item:
                picture_path, _, _, info_data, _ = default_config_item
            else:
                info_data = {}
                picture_path = None
                print("  Warning: Could not retrieve default_config_item for info_data/picture_path.")
            zip_file = self.current_details_zip_file

        elif hasattr(self, 'current_details_sidebar_spawn_cmd'):
            print("DEBUG: Spawn New Click - Sidebar showing CLICKED image config, using stored attributes...")
            spawn_cmd = self.current_details_sidebar_spawn_cmd
            info_data = self.current_details_sidebar_info_data
            picture_path = self.current_details_sidebar_picture_path
            zip_file = self.current_details_sidebar_zip_file
        else:
            print("Warning: Spawn command not available for Spawn New action.")
            return

        scanning_window = None
        if spawn_cmd:
            try:

                self.is_details_sidebar_sticky = True
                self.is_details_sidebar_showing_default = False
                # --- MODIFIED: Write to spawn queue file and refresh window if open ---
                try:
                    
                    spawn_cmd = re.sub(r'\((USE', '--(USE', spawn_cmd, count=1)
                    print(f"Modified spawn_cmd: {spawn_cmd}")
                    
                    with open(self.SPAWN_QUEUE_FILE, 'a', encoding="utf-8") as f:
                        f.write(f"{spawn_cmd} -- (USE 1|||{picture_path}||| 2[{zip_file}]\n")


                        
                    #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to persistent spawn queue file: \n\n'{self.SPAWN_QUEUE_FILE}'")
                    print(f"DEBUG: Command written to spawn queue file: '{self.SPAWN_QUEUE_FILE}'")

                    # --- NEW: Refresh Spawn Queue Window if open ---
                    if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
                        print("DEBUG: Spawn Queue window is open, refreshing content...")
                        self.populate_spawn_queue_window(self.spawn_queue_scrollable_frame) # Refresh content
                        print("DEBUG: Spawn Queue window content refreshed.")
                    # --- NEW: Refresh Spawn Queue Window if open ---

                except Exception as e:
                    print(f"ERROR: Failed to add spawn queue: {e}")
                # --- MODIFIED: Write to spawn queue file and refresh window if open ---

            except Exception as e:
                print(f"Error during spawn process: {e}")

        else:
            print("Warning: Spawn command STILL not available for writing to Spawn Queue.")

            
            
    def on_delete_single_button_click(self):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = "be:getPlayerVehicle(0):delete()"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to delete current vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt

    def on_delete_all_other_vehicles_button_click(self):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = "core_multiSpawn.deleteVehicles()"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to delete all vehicles except current, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
     

    def on_delete_traffic_vehicles_button_click(self):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = "gameplay_traffic.deleteVehicles()"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to delete all moving traffic vehicles, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
                

    def on_delete_parked_vehicles_button_click(self):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = "gameplay_parking.deleteVehicles()"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to delete parked vehicles, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
                
     
     
    def on_spawn_traffic_vehicles_button_click(self):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = "gameplay_traffic.setupTraffic()"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to spawn traffic vehicles, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
     
     
    def on_delete_parked_and_traffic_vehicles_button_click(self):
        self.on_delete_parked_and_traffic_vehicles_button_click_handle(retry=False, attempt_number=1)


    def on_delete_parked_and_traffic_vehicles_button_click_handle(self, retry=False, attempt_number=1):


        if retry:
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text=f"Delete attempts: {attempt_number}")
            time.sleep(0.725)
            if scanning_win:
                scanning_win.destroy()


        if not self.is_beamng_running():
            #messagebox.showerror("Error", "BeamNG.drive is not running.")
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="BeamNG.drive does not appear to be running.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()
            return False # Indicate failure



        print("BeamNG.drive is running.") # Added print
        time.sleep(1.125) # Reduced time.sleep to quarter

        print("Focusing BeamNG.drive window...") # Added print
        self.focus_beamng_window()

        time.sleep(1.125) # Reduced time.sleep to quarter
        if not self.focus_beamng_window():

            scanning_win = self.show_scanning_window(text="Please ensure BeamNG.drive is open and not minimized.")
            time.sleep(1.125)
            if scanning_win:
                scanning_win.destroy()

            #messagebox.showerror("Error", "BeamNG.drive window not found.")
            return False # Indicate failure

        print("BeamNG.drive window focused.") # Added print

        self.focus_beamng_window()

        pydirectinput.keyDown('shift')
        pydirectinput.keyDown('ctrl')
        pydirectinput.keyDown('alt')
        pydirectinput.keyDown('f10')

        # Wait for the specified hold time
        time.sleep(0.125)

        pydirectinput.keyUp('f10')
        pydirectinput.keyUp('alt')
        pydirectinput.keyUp('ctrl')
        pydirectinput.keyUp('shift')


        self.on_details_window_close()

        print(f"Deletion completed. ATTEMPT {attempt_number}") # Updated message


        data_folder = self.script_dir / "data"
        COMMANDconfirmation = data_folder / "commandconfirmation.txt"

        max_attempts = 7

        # --- NOW CHECK FOR THE FILE AFTER RUNNING ACTIONS ---
        print(f"Checking for file '{COMMANDconfirmation}' - Attempt {attempt_number}/{max_attempts}...")
        if os.path.exists(COMMANDconfirmation):
            print(f"File '{COMMANDconfirmation}' exists after actions on attempt {attempt_number}. Deleting it.")
            try:
                os.remove(COMMANDconfirmation)
                print(f"File '{COMMANDconfirmation}' deleted successfully.")
                return True # Indicate success (file existed and was deleted)
            except OSError as e:
                print(f"Error deleting file '{COMMANDconfirmation}': {e}")
                return False # Indicate failure (file deletion error)

        else: # File does not exist AFTER running actions
            if attempt_number >= max_attempts: # Check attempt number for max retries
                print(f"File '{COMMANDconfirmation}' still does not exist after {max_attempts} attempts. Stopping.")

                scanning_win = None  # Initialize scanning_win

                scanning_win = self.show_scanning_window(text=f"Maximum number of attempts ({attempt_number}) to delete vehicle(s) reached. \nPlease ensure EllexiumModManagerInput.zip is in the mods folder and restart the game.")
                time.sleep(5.725)
                if scanning_win:
                    scanning_win.destroy()

                return False # Indicate failure (file never appeared after max attempts)
            else:
                print(f"File '{COMMANDconfirmation}' does not exist on attempt {attempt_number}. Retrying function...")
                time.sleep(1.125) # Reduced time.sleep to quarter
                return self.on_delete_parked_and_traffic_vehicles_button_click_handle(retry=True, attempt_number=attempt_number + 1) # Recursive call, incrementing attempt_number
  
     
     
    def on_save_current_as_default_button_click(self):

        """Handles click on the 'Spawn New' button in the details sidebar.
        Modified to write the spawn command to the transient spawn queue file
        instead of copying to clipboard.
        """
        spawn_cmd = "core_vehicle_partmgmt.save('settings/default.pc')"


        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to save current vehicle as default, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: '{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt

     
    def on_spawn_default_button_click(self):
        """Handles click on the 'Spawn Default' button.
        MODIFIED: Extracts {model} from default.pc dynamically.
        """
        model_name = None  # Initialize model_name to None

        # 1. Construct the path to default.pc
        #script_dir = os.path.dirname(os.path.abspath(__file__))
        settings_dir = os.path.dirname(os.path.dirname(self.script_dir)) # Go up two levels
        default_pc_path = os.path.join(settings_dir, "settings", "default.pc")

        print(f"DEBUG: spawn_default_button_click - Constructed default.pc path: {default_pc_path}") # DEBUG

        # 2. Read and Parse default.pc to extract "model"
        try:
            if os.path.exists(default_pc_path):
                with open(default_pc_path, 'r', encoding="utf-8") as f:
                    default_pc_content = f.read()

                # Use regex to find the "model" value
                model_match = re.search(r'"model"\s*:\s*"([^"]*)"', default_pc_content)
                if model_match:
                    model_name = model_match.group(1)
                    print(f"DEBUG: spawn_default_button_click - Extracted model name from default.pc: {model_name}") # DEBUG
                else:
                    print("Warning: spawn_default_button_click - Could not find 'model' key in default.pc using regex.") # Warning
            else:
                print(f"Warning: spawn_default_button_click - default.pc file not found at: {default_pc_path}") # Warning
                #messagebox.showwarning("File Not Found", f"default.pc file not found at: {default_pc_path}", parent=self.master) # User feedback
                #return  # Exit if default.pc is not found

        except Exception as e:
            print(f"ERROR: spawn_default_button_click - Error reading or parsing default.pc: {e}") # Error handling
            #messagebox.showerror("Error", f"Error reading default.pc: {e}", parent=self.master) # User feedback
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Unable to spawn default vehicle configuration")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
            return  # Exit on error

        if model_name:      
            spawn_cmd = f'core_vehicles.spawnNewVehicle("{model_name}", {{config = \'settings/default.pc\'}})'
            
        else:    
            spawn_cmd = f'core_vehicles.spawnNewVehicle("pickup", {{config = \'vehicles/pickup/d15_4wd_A.pc\'}})'



        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to spawn default vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: {self.SPAWN_QUEUE_TRANSIENT_FILE}") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
     
    def on_replace_with_default_button_click(self):
        """Handles click on the 'Spawn Default' button.
        MODIFIED: Extracts {model} from default.pc dynamically.
        """
        model_name = None  # Initialize model_name to None

        # 1. Construct the path to default.pc
        #script_dir = os.path.dirname(os.path.abspath(__file__))
        settings_dir = os.path.dirname(os.path.dirname(self.script_dir)) # Go up two levels
        default_pc_path = os.path.join(settings_dir, "settings", "default.pc")

        print(f"DEBUG: spawn_default_button_click - Constructed default.pc path: {default_pc_path}") # DEBUG

        # 2. Read and Parse default.pc to extract "model"
        try:
            if os.path.exists(default_pc_path):
                with open(default_pc_path, 'r', encoding="utf-8") as f:
                    default_pc_content = f.read()

                # Use regex to find the "model" value
                model_match = re.search(r'"model"\s*:\s*"([^"]*)"', default_pc_content)
                if model_match:
                    model_name = model_match.group(1)
                    print(f"DEBUG: spawn_default_button_click - Extracted model name from default.pc: {model_name}") # DEBUG
                else:
                    print("Warning: spawn_default_button_click - Could not find 'model' key in default.pc using regex.") # Warning
            else:
                print(f"Warning: spawn_default_button_click - default.pc file not found at: {default_pc_path}") # Warning
                #messagebox.showwarning("File Not Found", f"default.pc file not found at: {default_pc_path}", parent=self.master) # User feedback
                #return  # Exit if default.pc is not found

        except Exception as e:
            print(f"ERROR: spawn_default_button_click - Error reading or parsing default.pc: {e}") # Error handling
            #messagebox.showerror("Error", f"Error reading default.pc: {e}", parent=self.master) # User feedback

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Unable to spawn default vehicle configuration")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
            return  # Exit on error

        if model_name:      
            spawn_cmd = f'core_vehicles.replaceVehicle("{model_name}", {{config = \'settings/default.pc\'}})'
            
        else:    
            spawn_cmd = f'core_vehicles.replaceVehicle("pickup", {{config = \'vehicles/pickup/d15_4wd_A.pc\'}})'



        scanning_window = None # Initialize scanning_window outside try block
        try:
            scanning_window = self.show_scanning_window(text="Attempting to replace current with default vehicle, please wait...\nPlease try not to click anything until this notification disappears.") # Show window with specific text
            # Make the window visible
            scanning_window.deiconify()
            self.master.update_idletasks() # Force window to appear immediately

            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---
            try:
                with open(self.SPAWN_QUEUE_TRANSIENT_FILE, 'w', encoding="utf-8") as f: # Open in write mode
                    f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
                    f.write(spawn_cmd + '\n') # Write command to file
                #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                print(f"DEBUG: Command written to transient spawn queue file: {self.SPAWN_QUEUE_TRANSIENT_FILE}") # Debug
                self.run_spawn_queue_transient(retry=False, attempt_number=1)
            except Exception as e:
                #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                print(f"ERROR: Failed to spawn: {e}") # Error print
            # --- MODIFIED: Write to transient spawn queue file instead of clipboard ---

        except Exception as e:
            print(f"Error during spawn process: {e}")
        finally: # Ensure scanning window is always destroyed
            if scanning_window:
                scanning_window.destroy() # Destroy the scanning window after spawn attempt
      


####################################################################



    def show_spawn_queue_window(self):
        """Displays the Spawn Queue window."""
        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
            self.spawn_queue_window.focus_set()
            self.spawn_queue_window.deiconify()
            return

        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists():
            self.filters_window.destroy()

        if hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists():
            self.hidden_window.withdraw()
            
        
        self.spawn_queue_window = dropdown_window = tk.Toplevel(self.master)
        dropdown_window.title("Spawn Queue")
        dropdown_window.overrideredirect(False)  # Keep window decorations
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        #dropdown_window.transient(self.master)
        #dropdown_window.attributes("-topmost", True) # Always on top
        dropdown_window.config(bg="#333333") # Dark background
        dropdown_window.geometry("442x500")
        dropdown_window.resizable(False, True)

        icon_path = self.script_dir / "data/icon.png"

        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            dropdown_window.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")


        # **Spawn Queue Title**
        title_label = tk.Label(dropdown_window, text="Spawn Queue", font=("Segoe UI", 13, "bold"), fg="white", bg="#333333") # Bold title
        title_label.pack(pady=(10, 0)) # Add padding above the title

        main_frame = tk.Frame(dropdown_window, bg="#333333", padx=10, pady=10) # Main frame with padding
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Scrollable Canvas for Queue Items
        self.spawn_queue_canvas = canvas = tk.Canvas(main_frame, bg="#444444", highlightthickness=0, yscrollincrement=10) # <-- ADDED CANVAS - assign to self.spawn_queue_canvas
        canvas.configure(yscrollcommand=self.custom_spawn_queue_scrollbar_set) # <-- Configure with custom scrollbar set command

        # Custom Scrollbar Canvas for Spawn Queue Window
        self.custom_scrollbar_canvas_spawn_queue = tk.Canvas(main_frame, bg="#555555", highlightthickness=0, width=15)
        self.scrollbar_thumb_spawn_queue = self.custom_scrollbar_canvas_spawn_queue.create_rectangle(0, 0, 15, 20, fill=self.global_highlight_color, outline="")
        self.scrollbar_thumb_dragging_spawn_queue = False
        self.scrollbar_thumb_start_y_spawn_queue = 0
        self.scrollbar_mouse_start_y_spawn_queue = 0

        self.custom_scrollbar_canvas_spawn_queue.bind("<ButtonPress-1>", self.custom_spawn_queue_scrollbar_click)
        self.custom_scrollbar_canvas_spawn_queue.bind("<B1-Motion>", self.custom_spawn_queue_scrollbar_drag)
        self.custom_scrollbar_canvas_spawn_queue.bind("<ButtonRelease-1>", self.custom_spawn_queue_scrollbar_release)


        self.spawn_queue_scrollable_frame = scrollable_frame = tk.Frame(canvas, bg="#444444") # Scrollable frame

        canvas.pack(side="left", fill=tk.BOTH, expand=True) # <-- PACK CANVAS
        #canvas.configure(yscrollcommand=scrollbar.set) # <-- CONFIGURE CANVAS YSCROLLCOMMAND
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")

        # --- NEW: Bind Mousewheel to the canvas for smooth scrolling ---
        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_mousewheel_spawn_queue(ev, canvas)))
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))
        # --- NEW: Bind Mousewheel to the canvas for smooth scrolling ---

        # Position custom scrollbar - place after canvas packing
        self.custom_scrollbar_canvas_spawn_queue.place(relx=1.0, rely=0.0, anchor='ne', relheight=1.0, bordermode="inside")


        # Button Frame at the Bottom (anchored)
        button_frame = tk.Frame(dropdown_window, bg="#333333", pady=10) # Frame for buttons at bottom
        button_frame.pack(side="bottom", fill="x", anchor="s") # Anchor to bottom

        # Define default button style and hover style
        default_button_style = self.button_style_args if hasattr(self, 'button_style_args') else {'bg': '#444444', 'fg': 'white', 'relief': tk.RAISED, 'borderwidth': 2}
        hover_button_style = {'bg': 'orange', 'fg': 'white', 'relief': tk.FLAT, 'borderwidth': 0}

        spawn_button = tk.Button(button_frame, text="Spawn", font=("Segoe UI", 12), command=self.on_spawn_queue_spawn_button_click, **default_button_style)
        clear_button = tk.Button(button_frame, text="Clear", font=("Segoe UI", 12), command=self.on_spawn_queue_clear_button_click, **default_button_style)

        def on_enter(event):
            event.widget.config(**hover_button_style)

        def on_leave(event):
            event.widget.config(**default_button_style)

        spawn_button.bind("<Enter>", on_enter)
        spawn_button.bind("<Leave>", on_leave)
        clear_button.bind("<Enter>", on_enter)
        clear_button.bind("<Leave>", on_leave)


        spawn_button.pack(side="left", fill="x", expand=True, padx=(10,5)) # Fill X and expand
        clear_button.pack(side="right", fill="x", expand=True, padx=(5,10)) # Fill X and expand

        # Populate the queue window with items
        self.populate_spawn_queue_window(scrollable_frame)

        dropdown_window.protocol("WM_DELETE_WINDOW", self.destroy_spawn_queue_window)
        self.center_window(dropdown_window) # Center the new window
        self.center_window_spawn_queue(dropdown_window)


    def center_window_spawn_queue(self, window):
        """Centers the given window on the master window."""
        window.update_idletasks() # Update window geometry to get correct sizes

        master_width = self.master.winfo_width()
        master_height = self.master.winfo_height()
        master_x = self.master.winfo_x()
        master_y = self.master.winfo_y()

        window_width = window.winfo_width()
        window_height = window.winfo_height()

        x = master_x + (master_width - window_width) // 2
        y = master_y + (master_height - window_height) // 2

        window.geometry(f"+{x}+{y}")

    def custom_spawn_queue_scrollbar_click(self, event):
        """Start thumb dragging on mouse click for Spawn Queue window."""
        self.scrollbar_thumb_dragging_spawn_queue = True
        self.scrollbar_thumb_start_y_spawn_queue = self.custom_scrollbar_canvas_spawn_queue.coords(self.scrollbar_thumb_spawn_queue)[1]
        self.scrollbar_mouse_start_y_spawn_queue = event.y

    def custom_spawn_queue_scrollbar_drag(self, event):
        """Drag thumb and update canvas view for Spawn Queue window."""
        if not self.scrollbar_thumb_dragging_spawn_queue:
            return

        mouse_y = event.y
        delta_y = mouse_y - self.scrollbar_mouse_start_y_spawn_queue
        new_thumb_y = self.scrollbar_thumb_start_y_spawn_queue + delta_y

        canvas_height = self.spawn_queue_canvas.winfo_height() # Use spawn_queue_canvas here
        scroll_range = self.spawn_queue_canvas.bbox("all") # Use spawn_queue_canvas here
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height:
            return # No scrolling needed if content fits

        thumb_height = self.custom_scrollbar_canvas_spawn_queue.coords(self.scrollbar_thumb_spawn_queue)[3] - self.custom_scrollbar_canvas_spawn_queue.coords(self.scrollbar_thumb_spawn_queue)[1]
        max_thumb_y = canvas_height - thumb_height
        new_thumb_y = max(0, min(max_thumb_y, new_thumb_y)) # Clamp thumb position

        self.custom_scrollbar_canvas_spawn_queue.coords(self.scrollbar_thumb_spawn_queue, 0, new_thumb_y, 15, new_thumb_y + thumb_height)

        scroll_fraction = new_thumb_y / max_thumb_y if max_thumb_y > 0 else 0
        self.spawn_queue_canvas.yview_moveto(scroll_fraction) # Use spawn_queue_canvas here


    def custom_spawn_queue_scrollbar_release(self, event):
        """Stop thumb dragging on mouse release for Spawn Queue window."""
        self.scrollbar_thumb_dragging_spawn_queue = False

    def custom_spawn_queue_scrollbar_set(self, *args):
        """Custom scrollbar set command to update thumb position for Spawn Queue window."""
        if self.scrollbar_thumb_dragging_spawn_queue:
            return # Prevent updates if dragging manually

        start, end = args[0:2]
        canvas_height = self.spawn_queue_canvas.winfo_height() # Use spawn_queue_canvas here
        scroll_range = self.spawn_queue_canvas.bbox("all") # Use spawn_queue_canvas here
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height: # NO SCROLLING NEEDED - SET TO GREY
            self.custom_scrollbar_canvas_spawn_queue.itemconfig(self.scrollbar_thumb_spawn_queue, fill="#555555")
        else: # SCROLLING IS POSSIBLE - KEEP ORANGE (or set back to orange if it was grey)
            self.custom_scrollbar_canvas_spawn_queue.itemconfig(self.scrollbar_thumb_spawn_queue, fill=self.global_highlight_color)

        thumb_height = max(20, canvas_height * (canvas_height / scrollable_height)) if scrollable_height > canvas_height else canvas_height # Minimum thumb height
        thumb_y_start = canvas_height * float(start)
        thumb_y_end = thumb_y_start + thumb_height
        self.custom_scrollbar_canvas_spawn_queue.coords(self.scrollbar_thumb_spawn_queue, 0, thumb_y_start, 15, thumb_y_end)




    def on_mousewheel_spawn_queue(self, event, canvas):
        """Handle mouse wheel events for smooth scrolling in the spawn queue window."""
        if canvas.winfo_exists():
            if os.name == 'nt':
                delta = int(event.delta / 120) # Removed negation here
            else:
                delta = int(event.delta) # Removed negation here
            # --- MODIFIED: Initiate smooth scroll animation for spawn queue ---
            self.start_smooth_scroll_spawn_queue(delta, canvas) # Call smooth scroll for search results
            #canvas.yview_scroll(delta, "units") # Original non-smooth scroll

    def start_smooth_scroll_spawn_queue(self, delta_units, canvas_sub):
        """Starts smooth scrolling animation for the spawn queue canvas - NORMALIZED SPEED."""
        if self.scroll_animation_timer:
            self.spawn_queue_window.after_cancel(self.scroll_animation_timer)  # Cancel any existing animation

        scroll_delta_units = delta_units  # Store delta in UNITS

        current_yview = canvas_sub.yview()  # Get current yview
        current_pos = current_yview[0]  # Get the current top position (0.0 to 1.0)

        canvas_height = canvas_sub.winfo_height()
        scrollable_height = canvas_sub.bbox("all")[3] if canvas_sub.bbox("all") else canvas_height # Use canvas height as fallback
        if scrollable_height <= 0:
            scrollable_height = canvas_height # Prevent division by zero

        # Calculate scroll step based on a fraction of the *visible* canvas height
        scroll_fraction = 0.7  # Adjust this fraction (e.g., 0.1, 0.15, 0.25) for sensitivity
        scroll_step_normalized = (canvas_height / scrollable_height) * scroll_fraction * scroll_delta_units
        # Explanation:
        # - (canvas_height / scrollable_height):  This is the proportion of the *total* content that is visible.
        # - scroll_fraction:  We want to scroll by a fraction of this visible portion.
        # - scroll_units:  Multiply by the scroll units.

        target_y_normalized = current_pos - scroll_step_normalized # Changed + to - here to correct direction
        target_y_normalized = max(0.0, min(1.0, target_y_normalized))

        self.scroll_target_yview = target_y_normalized
        self.scroll_start_y = current_pos
        self.scroll_start_time = self.master.tk.call('clock', 'milliseconds')

        if self.scroll_animation_id:
            canvas_sub.after_cancel(self.scroll_animation_id)
        self.animate_scroll_spawn_queue(0, canvas_sub)

    def animate_scroll_spawn_queue(self, step, canvas_sub):
        """Animates the canvas scroll with ease-out for the spawn queue window."""
        current_time = self.master.tk.call('clock', 'milliseconds')
        time_elapsed = current_time - self.scroll_start_time
        progress = min(1.0, time_elapsed / self.scroll_duration) # Normalized progress (0 to 1)

        # Ease-out function (simple quadratic)
        ease_out_progress = progress * (2 - progress) #  f(t) = t * (2 - t)

        # Calculate current scroll position based on eased progress
        current_y_normalized = self.scroll_start_y + (self.scroll_target_yview - self.scroll_start_y) * ease_out_progress

        canvas_sub.yview_moveto(current_y_normalized)

        if progress < 1.0:
            self.scroll_animation_id = canvas_sub.after(10, lambda: self.animate_scroll_spawn_queue(step + 1, canvas_sub)) # 10ms delay for animation step
        else:
            self.scroll_animation_id = None # Animation finished


    def destroy_spawn_queue_window(self):
        """Destroys the Spawn Queue window and clears the reference."""
        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
            self.spawn_queue_window.destroy()
            self.spawn_queue_window = None





    def populate_spawn_queue_window(self, parent_frame):
        """Populates the Spawn Queue window with items from Spawn_Queue_Transient.txt."""
        # --- NEW: Clear existing items in the scrollable frame ---
        for widget in parent_frame.winfo_children():
            widget.destroy()
        self.spawn_queue_items = []
        print("DEBUG: populate_spawn_queue_window - Cleared existing items from scrollable frame.")
        # --- NEW: Clear existing items in the scrollable frame ---

        try:
            with open(self.SPAWN_QUEUE_FILE, 'r', encoding="utf-8") as f:
                commands = f.readlines()
        except FileNotFoundError:
            commands = []

        self.spawn_queue_items = []

        for command_line in commands:
            command_line = command_line.strip()
            if not command_line:
                continue

            if command_line.lower().startswith("local"): # Using lower() for case-insensitive check
                print(f"DEBUG: Skipping line starting with 'local': {command_line}")
                continue # Skip to the next line

            item_frame = tk.Frame(parent_frame, bg="#444444", pady=5)
            item_frame.pack(fill="x", padx=10, pady=2)

            model_match = re.search(r'core_vehicles\.spawnNewVehicle\("([^"]+)"', command_line)
            config_match = re.search(r'config\s*=\s*\'([^\']+)\'', command_line)
            picture_path_match = re.search(r'USE 1\|\|\|(.*?)\|\|\|', command_line)

            model_name = model_match.group(1) if model_match else "Unknown Model"
            config_path = config_match.group(1) if config_match else "settings/default.pc"
            config_name_base = os.path.splitext(os.path.basename(config_path))[0]
            picture_path_str = picture_path_match.group(1) if picture_path_match else None

            config_display_name = config_name_base

            info_data = {}
            if picture_path_str:
                config_info_path = self.get_config_info_path_from_picture_path(picture_path_str)
                if config_info_path:
                    info_data, _ = self._load_individual_info(config_info_path)
                    config_display_name = info_data.get("Configuration", config_name_base)

            # --- Placeholder image loading ---**
            placeholder_image = Image.new("RGB", (110, 60), "lightgrey")
            placeholder_photo = ImageTk.PhotoImage(placeholder_image)

            # --- Image Loading Logic ---
            image_photo = placeholder_photo
            if picture_path_str:
                try:
                    image = Image.open(picture_path_str)
                    image = image.resize((110, 60))
                    image_photo = ImageTk.PhotoImage(image)
                except FileNotFoundError:
                    print(f"Warning: Image file not found: {picture_path_str}")
                except Exception as e:
                    print(f"Error loading image from {picture_path_str}: {e}")

            image_label = tk.Label(item_frame, image=image_photo, bg="#444444")
            image_label.image = image_photo
            image_label.pack(side="left", padx=5, pady=5)

            config_label = tk.Label(item_frame, text=config_display_name, font=("Segoe UI", 10, "bold"), fg="white", bg="#444444", anchor="w", wraplength=250, justify=tk.LEFT)
            config_label.pack(side="top", fill="x", padx=5)

            # --- Hover Functionality for Remove Button ---
            def on_enter(event):
                event.widget.config(bg=self.global_highlight_color, fg="white") # Hover color

            def on_leave(event):
                event.widget.config(bg=self.button_style_args["bg"], fg=self.button_style_args["fg"]) # Revert to default

            remove_button = tk.Button(item_frame, text="Remove", command=lambda cmd=command_line, frame=item_frame: self.on_remove_queue_item(cmd, frame), **self.button_style_args)
            remove_button.pack(side="bottom", padx=5, pady=(2, 0), anchor="w", fill="x")

            remove_button.bind("<Enter>", on_enter)
            remove_button.bind("<Leave>", on_leave)
            # --- End Hover Functionality ---

            self.spawn_queue_items.append({'frame': item_frame, 'command': command_line, 'picture_path': picture_path_str})


            
            

    def get_config_info_path_from_picture_path(self, picture_path):
        """
        Constructs the ConfigInfo path from a ConfigPics path extracted from the spawn queue command.
        """
        if not picture_path:
            return None

        filename = os.path.basename(picture_path)
        parts = filename.split('--')
        if len(parts) < 3:
            return None

        vehicle_part = parts[1]  # e.g., "pab_e39_e39kenemationV14.zip"
        config_part = parts[2]   # e.g., "2.0_520d_M_late.jpg"
        config_name_base = os.path.splitext(config_part)[0] # remove extension

        config_info_filename = f"vehicles--INDIVIDUAL--{vehicle_part}--info_info_{config_name_base}.json"
        config_info_path = os.path.join(self.config_info_folder, config_info_filename)

        if os.path.exists(config_info_path):
            return config_info_path
        else:
            return None


    def on_remove_queue_item(self, command_line, item_frame):
        """Removes a specific item from the Spawn Queue window and Spawn_Queue_Transient.txt,
        and deletes the file if it becomes empty.
        """
        item_frame.destroy() # Remove item frame from UI
        self.spawn_queue_items = [item for item in self.spawn_queue_items if item['frame'] != item_frame] # Update item list

        try:
            with open(self.SPAWN_QUEUE_FILE, 'r', encoding="utf-8") as f_in:
                lines = f_in.readlines()
            with open(self.SPAWN_QUEUE_FILE, 'w', encoding="utf-8") as f_out:
                for line in lines:
                    if line.strip() != command_line.strip(): # Compare stripped lines
                        f_out.write(line)

            # Check if the queue is now empty after removing the item
            if not self.spawn_queue_items:
                try:
                    os.remove(self.SPAWN_QUEUE_FILE)
                    print(f"Spawn queue file '{self.SPAWN_QUEUE_FILE}' deleted as queue is empty.")
                except FileNotFoundError:
                    print(f"Warning: Spawn queue file '{self.SPAWN_QUEUE_FILE}' not found when attempting to delete (queue empty).")
                except Exception as delete_e:
                    print(f"Error deleting {self.SPAWN_QUEUE_FILE}: {delete_e}")

        except Exception as e:
            print(f"Error updating {self.SPAWN_QUEUE_FILE}: {e}")

        self.spawn_queue_scrollable_frame.update_idletasks()
        self.spawn_queue_scrollable_frame.master.config(scrollregion=self.spawn_queue_scrollable_frame.master.bbox("all"))


    def on_spawn_queue_spawn_button_click(self):
        """Handles the 'Spawn' button click in the Spawn Queue window."""
        self.destroy_spawn_queue_window()
        self.run_spawn_queue(retry=False, attempt_number=1) # Execute spawn queue commands


    def on_spawn_queue_clear_button_click(self):
        """Handles the 'Clear' button click in the Spawn Queue window by DELETING the queue file."""
        # Clear UI list
        for item in self.spawn_queue_items:
            item['frame'].destroy()
        self.spawn_queue_items = []

        # Delete Spawn_Queue.txt
        try:
            if os.path.exists(self.SPAWN_QUEUE_FILE): # Check if file exists before attempting to delete
                os.remove(self.SPAWN_QUEUE_FILE)
                print(f"Successfully deleted {self.SPAWN_QUEUE_FILE}")
            else:
                print(f"Warning: {self.SPAWN_QUEUE_FILE} not found, cannot delete.")
        except FileNotFoundError:
            print(f"Warning: {self.SPAWN_QUEUE_FILE} not found, cannot delete (FileNotFoundError).")
        except Exception as e:
            print(f"Error deleting {self.SPAWN_QUEUE_FILE}: {e}")

        self.spawn_queue_scrollable_frame.update_idletasks()
        self.spawn_queue_scrollable_frame.master.config(scrollregion=self.spawn_queue_scrollable_frame.master.bbox("all"))


    def check_and_auto_close_details_window(self):
        """
        Checks the auto-close condition for the details window and closes it if met.
        This function is scheduled with a delay from perform_details_search.
        """
        # --- NEW: Auto-close Details Window if empty and search bar is empty ---
        if not self.details_filtered_data and not self.details_search_var.get().strip():
            print("  DEBUG: check_and_auto_close_details_window - [Delayed Check] No items in subgrid AND search bar is empty. Closing Details Window.")
            self.on_details_window_close()
            print("  DEBUG: check_and_auto_close_details_window - Details window CLOSED due to empty search results and empty search bar (delayed).")
            # --- NEW: Show "No configurations available" label ---
            self.no_configs_label.config(text="No configurations available for vehicle model under filter restrictions") # Set text
            self.no_configs_label.pack(side="left", padx=(10, 10)) # Make label visible
            self.master.after(3000, self.hide_no_configs_label) # Schedule hide after 2 seconds
            # --- NEW: Show "No configurations available" label ---
        else:
            print("  DEBUG: check_and_auto_close_details_window - [Delayed Check] Subgrid NOT empty OR search bar NOT empty. Keeping Details Window open.")
        # --- NEW: Auto-close Details Window if empty and search bar is empty ---




##################################################### SPAWNING VEHICLES END



    ######################################################################
    # to be depreciated or modified
    
    def create_floating_button_window(self):
        return create_floating_button_window(self)

    def on_floating_window_mapped(self, event=None):
        return on_floating_window_mapped(self, event)

    def on_floating_window_unmapped(self, event=None):
        return on_floating_window_unmapped(self, event)

    def toggle_floating_window_visibility(self):
       return toggle_floating_window_visibility(self)

    '''
    def toggle_focus_beamng(self):
       return toggle_focus_beamng(self) # Call external function
    '''
    
    
    #
    ######################################################################
    #               end of interaction with beamng                      #
    ######################################################################


    def show_sidebar_info(self, info_data, picture_path, zip_file, folder_name):
        """Shows sidebar info labels and updates content."""
        self.update_sidebar_content(info_data, picture_path, zip_file, folder_name)
        self.sidebar_brand_info_label.pack(fill="x", padx=10, pady=(0, 0))
        self.sidebar_description_info_label.pack(fill="x", padx=10, pady=(0, 0))
        self.sidebar_slogan_info_label.pack(fill="x", padx=10, pady=(0, 0))
        self.sidebar_country_info_label.pack(fill="x", padx=10, pady=(0, 0))
        self.sidebar_derbyclass_info_label.pack(fill="x", padx=10, pady=(0, 10))

    def hide_sidebar_info(self):
        """Hides sidebar info labels and clears all sidebar content, now including Author labels."""
        # Placeholder image for sidebar - CHANGED placeholder to MATCH sidebar_top_frame BG COLOR - "#333333"
        placeholder_image = Image.new("RGB", (280, 150), "#333333") # CHANGED to "#333333" - MATCH sidebar_top_frame BG COLOR
        placeholder_photo = ImageTk.PhotoImage(placeholder_image)

        # Clear ALL sidebar labels and reset image
        self.sidebar_car_name_label.config(text="") # Reset car name label to "" (empty string)
        self.sidebar_image_label.config(image=placeholder_photo) # Reset image to placeholder
        self.sidebar_image_label.image = placeholder_photo # Keep reference to placeholder
        self.sidebar_brand_info_label.config(text="") # Clear Brand info
        self.sidebar_description_info_label.config(text="") # Clear Description
        self.sidebar_slogan_info_label.config(text="") # Clear Slogan
        self.sidebar_country_info_label.config(text="") # Clear Country
        self.sidebar_derbyclass_info_label.config(text="") # Clear Derby Class
        self.sidebar_zip_name_label.config(text="") # Clear Zip Name
        self.sidebar_author_info_label.config(text="") # Clear Author Info - NEW

        # Hide category AND info labels - keep these hidden for mouse leave
        self.sidebar_brand_label.pack_forget() # Hide Brand category
        self.sidebar_brand_info_label.pack_forget() # Hide Brand info
        self.sidebar_description_label.pack_forget() # Hide Description category
        self.sidebar_description_info_label.pack_forget() # Hide Description info
        self.sidebar_slogan_label.pack_forget() # Hide Slogan category
        self.sidebar_slogan_info_label.pack_forget() # Hide Slogan info
        self.sidebar_country_label.pack_forget() # Hide Country category
        self.sidebar_country_info_label.pack_forget() # Hide Country info
        self.sidebar_derbyclass_label.pack_forget() # Hide Derby Class category
        self.sidebar_derbyclass_info_label.pack_forget() # Hide Derby Class info
        # --- NEW: Hide Author Labels ---
        self.sidebar_author_label.pack_forget() # Hide Author category
        self.sidebar_author_info_label.pack_forget() # Hide Author info
        # --- NEW: Hide Author Labels ---
        


    def process_lines(self, lines, data, full_data, is_custom):
        return process_lines(self, lines, data, full_data, is_custom)
   
  
        
    def find_config_pic(self, candidate_image_name, config_pics_folder):
        """Helper function to find config pic path given a base name and folder."""
        for ext in ['jpg', 'jpeg', 'png']:
            check_name = f"{candidate_image_name}.{ext}"
            check_path = os.path.join(config_pics_folder, check_name)
            if os.path.exists(check_path):
                return check_path
        return None
        
        
    def update_sidebar_content(self, info_data, picture_path, zip_file, folder_name):
        """
        Updates sidebar with car name, picture, zip/folder name, and JSON details, now including Author.
        """

        #if self.items_to_be_hidden:
        #    return
        
        # Car Name Label (top)
        brand = info_data.get("Brand", "").strip()
        name = info_data.get("Name", "").strip()
        vehicle_type = info_data.get("Type", "").strip()
        if brand:
            if name:
                display_name_text = f"{brand} {name}"
            elif vehicle_type:
                display_name_text = f"{brand} {vehicle_type}"
            else:
                display_name_text = brand
        elif name:
            display_name_text = name
        elif vehicle_type:
            display_name_text = vehicle_type
        else:
            display_name_text = "Unknown"
        self.sidebar_car_name_label.config(text=display_name_text if display_name_text else "Unknown")

        # Image Loading (unchanged)
        self.sidebar_loading_label.pack(pady=(0, 10), padx=10)
        try:
            if picture_path and os.path.exists(picture_path):
                img = Image.open(picture_path).convert("RGB")
                img = img.resize((275, 153), self.RESAMPLE_FILTER)
                photo = ImageTk.PhotoImage(img)
                self.sidebar_image_label.config(image=photo)
                self.sidebar_image_label.image = photo
            else:
                placeholder_image = Image.new("RGB", (280, 157), "lightgrey")
                placeholder_photo = ImageTk.PhotoImage(placeholder_image)
                self.sidebar_image_label.config(image=placeholder_photo)
                self.sidebar_image_label.image = placeholder_photo
        except Exception as e:
            print(f"Error loading sidebar image: {e}")
            placeholder_image = Image.new("RGB", (280, 157), "lightgrey")
            placeholder_photo = ImageTk.PhotoImage(placeholder_image)
            self.sidebar_image_label.config(image=placeholder_photo)
            self.sidebar_image_label.image = placeholder_photo
            self.sidebar_car_name_label.config(text=f"Error Loading Image for: {display_name_text}")
        finally:
             self.sidebar_loading_label.pack_forget()

        self.update_sidebar_zip_name(zip_file, folder_name)

        # --- NEW: Update Sidebar JSON Info Labels - CORRECT ASSIGNMENT (including Author) ---
        # Brand Name, Country, Derby Class are already set in sidebar_car_name_label

        # Brand
        brand_text = info_data.get("Brand", "").strip()
        if brand_text:
            self.sidebar_brand_info_label.config(text=f"{brand_text}")
            self.sidebar_brand_label.config(text="Brand") # Set category label text
            self.sidebar_brand_label.pack(fill="x", padx=10, pady=(10, 0)) # Make category label visible
            self.sidebar_brand_info_label.pack(fill="x", padx=10, pady=(0, 0)) # Make info label visible
        else:
            self.sidebar_brand_info_label.config(text="Brand Not Specified")
            self.sidebar_brand_label.config(text="Brand") # Set category label text
            self.sidebar_brand_label.pack(fill="x", padx=10, pady=(10, 0)) # Make category label visible
            self.sidebar_brand_info_label.pack(fill="x", padx=10, pady=(0, 0)) # Make info label visible

        # Country
        country_text = info_data.get("Country", "").strip()
        if country_text:
            self.sidebar_country_info_label.config(text=f"{country_text}")
            self.sidebar_country_label.config(text="Country") # Set category label text
            self.sidebar_country_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_country_info_label.pack(fill="x", padx=10, pady=(0, 0))
        else:
            self.sidebar_country_info_label.config(text="Country Not Specified")
            self.sidebar_country_label.config(text="Country") # Set category label text
            self.sidebar_country_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_country_info_label.pack(fill="x", padx=10, pady=(0, 0))

        # Derby Class
        derbyclass_text = info_data.get("Derby Class", "").strip()
        if derbyclass_text:
            self.sidebar_derbyclass_info_label.config(text=f"{derbyclass_text}")
            self.sidebar_derbyclass_label.config(text="Derby Class") # Set category label text
            self.sidebar_derbyclass_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_derbyclass_info_label.pack(fill="x", padx=10, pady=(0, 10)) # Bottom padding
        else:
            self.sidebar_derbyclass_info_label.config(text="Derby Class Not Specified")
            self.sidebar_derbyclass_label.config(text="Derby Class") # Set category label text
            self.sidebar_derbyclass_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_derbyclass_info_label.pack(fill="x", padx=10, pady=(0, 10)) # Bottom padding

        # --- NEW: Author Section Update ---
        author_text = info_data.get("Author", "").strip()
        if author_text:
            self.sidebar_author_info_label.config(text=f"{author_text}")
            self.sidebar_author_label.config(text="Author")  # Set category label text
            self.sidebar_author_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_author_info_label.pack(fill="x", padx=10, pady=(0, 10)) # Bottom padding
        else:
            self.sidebar_author_info_label.config(text="Author Not Specified")
            self.sidebar_author_label.config(text="Author") # Set category label text
            self.sidebar_author_label.pack(fill="x", padx=10, pady=(10, 0))
            self.sidebar_author_info_label.pack(fill="x", padx=10, pady=(0, 10)) # Bottom padding
        # --- NEW: Author Section Update ---
            
            
    def update_sidebar_zip_name(self, zip_file, folder_name):
            """Updates the zip file or folder name label in the sidebar to display ALL associated ZIPs."""
            if zip_file == "user_custom_configs":
                if self.is_search_results_window_active:
                    text_to_display = f"Custom Configs for:\n({folder_name})"
                if not self.is_search_results_window_active:
                    text_to_display = f"Custom Configs for:\n[{folder_name}]\n(Right Click to hide/unhide vehicle)"
            else:
                # --- NEW: Get all associated zip files from full_data ---
                associated_zip_files = set()
                if folder_name in self.full_data:
                    for config_item in self.full_data[folder_name]:
                        config_zip = config_item[2]
                        if config_zip != "user_custom_configs": # Exclude custom configs from mod zip list
                            associated_zip_files.add(config_zip)

                if associated_zip_files:
                    num_zips = len(associated_zip_files)
                    zip_label = "Zip File" if num_zips == 1 else "Zip Files" # Determine singular or plural
                    zip_list_text = "\n".join(sorted(list(associated_zip_files))) # Create multi-line string

                if self.is_search_results_window_active:
                    text_to_display = f"{zip_list_text}\n({folder_name})"
                if not self.is_search_results_window_active:
                    text_to_display = f"{zip_list_text}\n({folder_name})\n(Right Click to hide/unhide vehicle)"

                # --- NEW: Get all associated zip files from full_data ---

            self.sidebar_zip_name_label.config(text=text_to_display)

    # ------------------------------------------------------------
    # Cycle Filter
    # ------------------------------------------------------------
    def cycle_filter(self):
        self.filter_state = (self.filter_state + 1) % len(self.filter_options)
        current_filter = self.filter_options[self.filter_state]
        self.filter_button.config(text=f"{current_filter} [0]")
        self.perform_search()

        
    # ------------------------------------------------------------
    # Resize and scroll.py
    # ------------------------------------------------------------
    

    def throttled_resize(self, event):
        return throttled_resize(self, event) # Call external function

    def on_resize_complete(self):
        return on_resize_complete(self) # Call external function

    def on_mousewheel_main(self, event):
         return on_mousewheel_main(self, event)

    def on_mousewheel_details(self, event, canvas_sub):
        return on_mousewheel_details(self, event, canvas_sub)

    def ease_out_quintic_modified_speed(self, t, speed_factor=1.0):
        return ease_out_quintic_modified_speed(t, speed_factor)

    def start_scroll_debounce_timer_main_grid(self):
         return start_scroll_debounce_timer_main_grid(self)

    def on_scroll_debounce_complete_main_grid(self):
         return on_scroll_debounce_complete_main_grid(self)
        
    def is_descendant_of(self, widget, ancestor):
       return is_descendant_of(self, widget, ancestor)

    def start_smooth_scroll_main(self, delta_units):
        return start_smooth_scroll_main(self, delta_units)

    def start_smooth_scroll_details(self, delta_units, canvas_sub):
        return start_smooth_scroll_details(self, delta_units, canvas_sub)

    def animate_scroll_main(self, step):
        return animate_scroll_main(self, step)

    def animate_scroll_details(self, step, canvas_sub):
         return animate_scroll_details(self, step, canvas_sub)

    def calculate_columns_for_width(self, width, is_details=False):
       return calculate_columns_for_width(self, width, is_details)
   
    def on_mousewheel_search_results(self, event):
        """Handle mouse wheel events for smooth scrolling in the search results window."""
        if self.search_results_canvas.winfo_exists():
            if os.name == 'nt':
                delta = int(-1 * (event.delta / 120))
            else:
                delta = int(-1 * (event.delta))
            # --- MODIFIED: Initiate smooth scroll animation for search results ---
            self.start_smooth_scroll_search_results(delta, self.search_results_canvas) # Call smooth scroll for search results
            #self.search_results_canvas.yview_scroll(delta, "units") # Original non-smooth scroll

    def start_smooth_scroll_search_results(self, delta_units, canvas_sub):
        """Starts smooth scrolling animation for the search results canvas - NORMALIZED SPEED."""
        if self.scroll_animation_timer:
            self.search_results_window.after_cancel(self.scroll_animation_timer)  # Cancel any existing animation

        self.scroll_delta_units = delta_units  # Store delta in UNITS

        current_yview = canvas_sub.yview()  # Get current yview
        current_pos = current_yview[0]  # Get the current top position (0.0 to 1.0)

        canvas_height = canvas_sub.winfo_height()
        scrollable_height = canvas_sub.bbox("all")[3] if canvas_sub.bbox("all") else canvas_height # Use canvas height as fallback
        if scrollable_height <= 0:
            scrollable_height = canvas_height # Prevent division by zero

        # --- NEW: Calculate scroll step based on item height and canvas size ---
        estimated_item_height = 160  # Estimate item height in pixels (image + label + padding) - ADJUST IF NEEDED
        items_visible_in_viewport = canvas_height / estimated_item_height
        scroll_units_per_item = items_visible_in_viewport / (scrollable_height / estimated_item_height) if scrollable_height > 0 else 0.1 # Fallback if scrollable_height is 0

        scroll_step_units = scroll_units_per_item * 0.35 # Adjust multiplier (1.5) for overall speed - HIGHER = FASTER
        target_pos_units = current_pos + (delta_units * scroll_step_units)
        target_pos_units = max(0.0, min(1.0, target_pos_units))  # Clamp between 0.0 and 1.0

        self.scroll_current_yview = current_pos
        self.scroll_target_yview = target_pos_units
        animate_scroll_search_results(self, 0, canvas_sub)  # Start details animation from step 0
 
 
 

    def custom_scrollbar_click(self, event):
        """Start thumb dragging on mouse click."""
        self.scrollbar_thumb_dragging = True
        self.scrollbar_thumb_start_y = self.custom_scrollbar_canvas.coords(self.scrollbar_thumb)[1]
        self.scrollbar_mouse_start_y = event.y


    def custom_scrollbar_drag(self, event):
        """Drag thumb and update canvas view."""
        if not self.scrollbar_thumb_dragging:
            return

        mouse_y = event.y
        delta_y = mouse_y - self.scrollbar_mouse_start_y
        new_thumb_y = self.scrollbar_thumb_start_y + delta_y

        canvas_height = self.canvas.winfo_height()
        scroll_range = self.canvas.bbox("all")
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height:
            return # No scrolling needed if content fits

        thumb_height = self.custom_scrollbar_canvas.coords(self.scrollbar_thumb)[3] - self.custom_scrollbar_canvas.coords(self.scrollbar_thumb)[1]
        max_thumb_y = canvas_height - thumb_height
        new_thumb_y = max(0, min(max_thumb_y, new_thumb_y)) # Clamp thumb position

        self.custom_scrollbar_canvas.coords(self.scrollbar_thumb, 0, new_thumb_y, 15, new_thumb_y + thumb_height)

        scroll_fraction = new_thumb_y / max_thumb_y if max_thumb_y > 0 else 0
        self.canvas.yview_moveto(scroll_fraction)


    def custom_scrollbar_release(self, event):
        """Stop thumb dragging on mouse release."""
        self.scrollbar_thumb_dragging = False
        
    
    def custom_details_scrollbar_click(self, event):
        """Start thumb dragging on mouse click for DETAILS WINDOW."""
        self.scrollbar_thumb_dragging_details = True
        self.scrollbar_thumb_start_y_details = self.custom_scrollbar_canvas_details.coords(self.scrollbar_thumb_details)[1]
        self.scrollbar_mouse_start_y_details = event.y


    def custom_details_scrollbar_drag(self, event):
        """Drag thumb and update canvas view for DETAILS WINDOW."""
        if not self.scrollbar_thumb_dragging_details:
            return

        mouse_y = event.y
        delta_y = mouse_y - self.scrollbar_mouse_start_y_details
        new_thumb_y = self.scrollbar_thumb_start_y_details + delta_y

        canvas_height = self.details_canvas_sub.winfo_height()
        scroll_range = self.details_canvas_sub.bbox("all")
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height:
            return # No scrolling needed if content fits

        thumb_height = self.custom_scrollbar_canvas_details.coords(self.scrollbar_thumb_details)[3] - self.custom_scrollbar_canvas_details.coords(self.scrollbar_thumb_details)[1]
        max_thumb_y = canvas_height - thumb_height
        new_thumb_y = max(0, min(max_thumb_y, new_thumb_y)) # Clamp thumb position

        self.custom_scrollbar_canvas_details.coords(self.scrollbar_thumb_details, 0, new_thumb_y, 15, new_thumb_y + thumb_height)

        scroll_fraction = new_thumb_y / max_thumb_y if max_thumb_y > 0 else 0
        self.details_canvas_sub.yview_moveto(scroll_fraction)





    def custom_details_scrollbar_release(self, event):
        """Stop thumb dragging on mouse release for DETAILS WINDOW."""
        self.scrollbar_thumb_dragging_details = False
        
        

    def custom_scrollbar_set(self, *args):
        """Custom scrollbar set command to update thumb position."""
        if self.scrollbar_thumb_dragging:
            return # Prevent updates if dragging manually

        start, end = args[0:2]
        canvas_height = self.canvas.winfo_height()
        scroll_range = self.canvas.bbox("all")
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height: # NO SCROLLING NEEDED - SET TO GREY
            self.custom_scrollbar_canvas.itemconfig(self.scrollbar_thumb, fill="#555555")
        else: # SCROLLING IS POSSIBLE - KEEP ORANGE (or set back to orange if it was grey)
            self.custom_scrollbar_canvas.itemconfig(self.scrollbar_thumb, fill=self.global_highlight_color)

        thumb_height = max(20, canvas_height * (canvas_height / scrollable_height)) if scrollable_height > canvas_height else canvas_height # Minimum thumb height
        thumb_y_start = canvas_height * float(start)
        thumb_y_end = thumb_y_start + thumb_height
        self.custom_scrollbar_canvas.coords(self.scrollbar_thumb, 0, thumb_y_start, 15, thumb_y_end)



    def custom_details_scrollbar_set(self, *args):
        """Custom scrollbar set command for DETAILS WINDOW to update thumb position."""
        if self.scrollbar_thumb_dragging_details:
            return # Prevent updates if dragging manually

        start, end = args[0:2]
        canvas_height = self.details_canvas_sub.winfo_height()
        scroll_range = self.details_canvas_sub.bbox("all")
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height: # NO SCROLLING NEEDED - SET TO GREY
            self.custom_scrollbar_canvas_details.itemconfig(self.scrollbar_thumb_details, fill="#555555")
        else: # SCROLLING IS POSSIBLE - KEEP ORANGE (or set back to orange if it was grey)
            self.custom_scrollbar_canvas_details.itemconfig(self.scrollbar_thumb_details, fill=self.global_highlight_color)


        thumb_height = max(20, canvas_height * (canvas_height / scrollable_height)) if scrollable_height > canvas_height else canvas_height # Minimum thumb height
        thumb_y_start = canvas_height * float(start)
        thumb_y_end = thumb_y_start + thumb_height
        self.custom_scrollbar_canvas_details.coords(self.scrollbar_thumb_details, 0, thumb_y_start, 15, thumb_y_end)
            
    def custom_search_results_scrollbar_set(self, *args):
        """Custom scrollbar set command for SEARCH RESULTS WINDOW to update thumb position."""
        if self.scrollbar_thumb_dragging_search_results:
            return # Prevent updates if dragging manually

        start, end = args[0:2]
        canvas_height = self.search_results_canvas.winfo_height()
        scroll_range = self.search_results_canvas.bbox("all")
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height: # NO SCROLLING NEEDED - SET TO GREY
            self.custom_scrollbar_canvas_search_results.itemconfig(self.scrollbar_thumb_search_results, fill="#555555")
        else: # SCROLLING IS POSSIBLE - KEEP ORANGE (or set back to orange if it was grey)
            self.custom_scrollbar_canvas_search_results.itemconfig(self.scrollbar_thumb_search_results, fill=self.global_highlight_color)

        thumb_height = max(20, canvas_height * (canvas_height / scrollable_height)) if scrollable_height > canvas_height else canvas_height # Minimum thumb height
        thumb_y_start = canvas_height * float(start)
        thumb_y_end = thumb_y_start + thumb_height
        self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results, 0, thumb_y_start, 15, thumb_y_end)


    def custom_search_results_scrollbar_click(self, event):
        """Start thumb dragging on mouse click for SEARCH RESULTS WINDOW."""
        self.scrollbar_thumb_dragging_search_results = True
        self.scrollbar_thumb_start_y_search_results = self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results)[1]
        self.scrollbar_mouse_start_y_search_results = event.y


    def custom_search_results_scrollbar_drag(self, event):
        """Drag thumb and update canvas view for SEARCH RESULTS WINDOW."""
        if not self.scrollbar_thumb_dragging_search_results:
            return

        mouse_y = event.y
        delta_y = mouse_y - self.scrollbar_mouse_start_y_search_results
        new_thumb_y = self.scrollbar_thumb_start_y_search_results + delta_y

        canvas_height = self.search_results_canvas.winfo_height()
        scroll_range = self.search_results_canvas.bbox("all")
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height:
            return # No scrolling needed if content fits

        thumb_height = self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results)[3] - self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results)[1]
        max_thumb_y = canvas_height - thumb_height
        new_thumb_y = max(0, min(max_thumb_y, new_thumb_y)) # Clamp thumb position

        self.custom_scrollbar_canvas_search_results.coords(self.scrollbar_thumb_search_results, 0, new_thumb_y, 15, new_thumb_y + thumb_height)

        scroll_fraction = new_thumb_y / max_thumb_y if max_thumb_y > 0 else 0
        self.search_results_canvas.yview_moveto(scroll_fraction)


    def custom_search_results_scrollbar_release(self, event):
        """Stop thumb dragging on mouse release for SEARCH RESULTS WINDOW."""
        self.scrollbar_thumb_dragging_search_results = False
  
 
    def save_window_geometry(self, width, height, x, y):
        """Saves the window geometry to MMSelectorSize.txt."""
        try:
            with open("data/MMSelectorSize.txt", "w") as f:
                f.write(f"{width}\n")
                f.write(f"{height}\n")
                f.write(f"{x}\n")
                f.write(f"{y}\n")
            print(f"Window geometry saved to MMSelectorSize.txt: {width}x{height}+{x}+{y}")
        except Exception as e:
            print(f"Error saving window geometry: {e}")

    def load_window_geometry(self):
        """Loads the window geometry from MMSelectorSize.txt if it exists and is valid.
        Returns saved geometry or default 800x600 centered on screen if loading fails. <--- MODIFIED DOCSTRING
        """
        default_width = 1366
        default_height = 700

        try:
            if os.path.exists("data/MMSelectorSize.txt"):
                with open("data/MMSelectorSize.txt", "r") as f:
                    lines = f.readlines()
                    if len(lines) == 4:
                        width = int(lines[0].strip())
                        height = int(lines[1].strip())
                        x = int(lines[2].strip())
                        y = int(lines[3].strip())
                        print(f"Window geometry loaded from MMSelectorSize.txt: {width}x{height}+{x}+{y}")
                        return width, height, x, y
        except Exception as e:
            print(f"Error loading window geometry: {e}")


        # Calculate centered position for default geometry
        screen_width = self.master.winfo_screenwidth() # Get screen width dynamically
        screen_height = self.master.winfo_screenheight() # Get screen height dynamically
        x = (screen_width // 2) - (default_width // 2)
        y = (screen_height // 2) - (default_height // 2)

        print(f"No valid geometry in MMSelectorSize.txt. Returning DEFAULT CENTERED geometry: {default_width}x{default_height}+{x}+{y}") # Debug print for default geometry
        return default_width, default_height, x, y

    def open_resize_window(self):
        """Opens the Resize window, modal and flush with master."""
        if hasattr(self, 'resize_window') and self.resize_window and self.resize_window.winfo_exists():
            self.resize_window.focus_set()
            return

        self.resize_window = resize_window = tk.Toplevel(self.master)
        resize_window.title("Resize")
        resize_window.overrideredirect(False)
        resize_window.tk.call('tk', 'scaling', 1.25)
        resize_window.transient(self.master)
        resize_window.grab_set()

        icon_path = self.script_dir / "data/icon.png"


        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            resize_window.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")

        # Geometry and position same as details window (or main if details not open)
        if self.details_window and not self.details_window_closed:
            geometry_str = self.details_window.geometry()
        else:
            geometry_str = self.master.geometry()
        resize_window.geometry(geometry_str)

        # Transparent window - adjust alpha for desired transparency (25% more transparent than 0.8)
        resize_window.attributes('-alpha', 0.8 * 0.75) # 25% more transparent

        # Function to update resize label text
        def update_resize_label_text():
            width = resize_window.winfo_width()
            height = resize_window.winfo_height()
            self.resize_label.config(text=f"Resize to\n{width} (Width)\n{height} (Height)\n\nDrag the edges of this window to the match the desired\nheight/width of the window then click here to resize. \nClosing this window cancels resizing.\nClicking here to resize will restart the application.")

        # Label in the middle, bigger font, orange hover, INITIAL TEXT with dimensions
        initial_width = resize_window.winfo_width()
        initial_height = resize_window.winfo_height()
        resize_label = self.resize_label = tk.Label(resize_window, text=f"Resize to {initial_width} (Width) X {initial_height} (Height)", font=("Segoe UI", 30, "bold"), bg=resize_window.cget('bg'), cursor="hand2") # Bigger font, hand2 cursor
        resize_label.pack(expand=True, fill='both')

        # Hover effect
        def on_resize_hover_enter(event):
            resize_label.config(fg="black")

            resize_window.update_idletasks() # Force Resize window to update
            resize_width = resize_window.winfo_width()
            resize_height = resize_window.winfo_height()
            resize_x_root = resize_window.winfo_rootx()
            resize_y_root = resize_window.winfo_rooty()
            resize_x_local = resize_window.winfo_x()
            resize_y_local = resize_window.winfo_y()

            # --- NEW: Minimum width and height and SNAP BACK ---
            min_width = 1348
            min_height = 600
            original_resize_width = resize_width  # Store original size before clamping
            original_resize_height = resize_height
            resize_width = max(resize_width, min_width) # Ensure width is at least min_width
            resize_height = max(resize_height, min_height) # Ensure height is at least min_height

            if original_resize_width < min_width or original_resize_height < min_height:
                # Snap resize window back to minimum size
                resize_window.geometry(f"{min_width}x{min_height}+{resize_x_root}+{resize_y_root}") # Snap Resize window back
                update_resize_label_text() # Update label text to reflect snapped size
                print("Resize window snapped back to minimum size: 1348x600") # Debug message - snap back

            # --- NEW: Minimum width and height and SNAP BACK --


        def on_resize_hover_leave(event):
            resize_label.config(fg="black") # Or whatever default fg is, setting to black for now

        resize_label.bind("<Enter>", on_resize_hover_enter)
        resize_label.bind("<Leave>", on_resize_hover_leave)

        # Click event to resize and close
        def on_resize_click(event):
            resize_window.update_idletasks() # Force Resize window to update
            resize_width = resize_window.winfo_width()
            resize_height = resize_window.winfo_height()
            resize_x_root = resize_window.winfo_rootx()
            resize_y_root = resize_window.winfo_rooty()
            resize_x_local = resize_window.winfo_x()
            resize_y_local = resize_window.winfo_y()

            # Calculate decoration offsets
            offset_x = resize_x_root - resize_x_local
            offset_y = resize_y_root - resize_y_local

            corrected_resize_x = resize_x_root - offset_x
            corrected_resize_y = resize_y_root - offset_y


            # --- NEW: Minimum width and height and SNAP BACK ---
            min_width = 1348
            min_height = 600
            original_resize_width = resize_width  # Store original size before clamping
            original_resize_height = resize_height
            resize_width = max(resize_width, min_width) # Ensure width is at least min_width
            resize_height = max(resize_height, min_height) # Ensure height is at least min_height

            if original_resize_width < min_width or original_resize_height < min_height:
                # Snap resize window back to minimum size
                resize_window.geometry(f"{min_width}x{min_height}+{resize_x_root}+{resize_y_root}") # Snap Resize window back
                update_resize_label_text() # Update label text to reflect snapped size
                print("Resize window snapped back to minimum size: 1348x600") # Debug message - snap back

            # --- NEW: Minimum width and height and SNAP BACK --
            


            master_width_before = self.master.winfo_width() # Get master window size BEFORE geometry change
            master_height_before = self.master.winfo_height()
            master_x_before = self.master.winfo_rootx()    # Get master window position BEFORE
            master_y_before = self.master.winfo_rooty()

            print("--- Before Geometry Change ---") # Debugging section
            print(f"Resize Window Geometry - Width: {resize_width}, Height: {resize_height}, Root X: {resize_x_root}, Root Y: {resize_y_root}, Local X: {resize_x_local}, Local Y: {resize_y_local}") # DEBUG PRINT
            print(f"Offsets - Offset X: {offset_x}, Offset Y: {offset_y}") # DEBUG PRINT - Offsets
            print(f"Corrected Resize Position - X: {corrected_resize_x}, Y: {corrected_resize_y}") # DEBUG PRINT - Corrected Position
            print(f"Master Window Geometry (Before) - Width: {master_width_before}, Height: {master_height_before}, X: {master_x_before}, Y: {master_y_before}")

            '''
            self.master.geometry(f"{resize_width}x{resize_height}+{corrected_resize_x}+{corrected_resize_y}") # Apply size AND CORRECTED position

            self.master.update_idletasks() # Process any pending tasks
            self.master.update() # Force immediate update of master window
            self.master.focus_set() # Ensure Master window gets focus after resize

            master_width_after = self.master.winfo_width()  # Get master window size AFTER geometry change
            master_height_after = self.master.winfo_height()
            master_x_after = self.master.winfo_rootx()     # Get master window position AFTER
            master_y_after = self.master.winfo_rooty()

            print("--- After Geometry Change ---") # Debugging section
            print(f"Master Window Geometry (After) - Width: {master_width_after}, Height: {master_height_after}, X: {master_x_after}, Y: {master_y_after}")
            print("--- Geometry Change Completed ---")
            '''

            # Save geometry and restart
            self.save_window_geometry(resize_width, resize_height, corrected_resize_x, corrected_resize_y)


            self.save_settings()

            self.restart_script() # Call restart function after saving 
    

        resize_label.bind("<Button-1>", on_resize_click)

        # Bind <Configure> event to update label on resize
        resize_window.bind("<Configure>", lambda event: update_resize_label_text())

        # Store initial master window size
        self.initial_master_width = self.master.winfo_width()
        self.initial_master_height = self.master.winfo_height()

        resize_window.protocol("WM_DELETE_WINDOW", self.on_resize_window_cancel)
   
    def on_resize_window_cancel(self):
        """Handles closing the Resize window without resizing master, previously on_resize_window_close."""
        if self.resize_window:
            self.resize_window.destroy()
            self.resize_window = None

   

    def manual_gc_collect(self):
        """
        Manually triggers garbage collection and prints a message to the console.
        This is for debugging purposes to help identify potential memory leaks.
        """
        print("--- Manual Garbage Collection Triggered ---")
        collected = gc.collect()
        print(f"Garbage collector: collected {collected} objects.")
        print("--- Manual Garbage Collection Completed ---\n")
   
    # ------------------------------------------------------------
    # Format Grouped Data
    # ------------------------------------------------------------

    #@profile 
    def format_grouped_data(self, data_list):
        print("\n--- format_grouped_data() DEBUG ENTRY ---")
        print(f"DEBUG: format_grouped_data - self.sort_by_install_date: {self.sort_by_install_date}")
        print(f"DEBUG: format_grouped_data - self.collapse_categories_by_default: {self.collapse_categories_by_default}")

        grouped = {}
        zip_creation_times = {}
        folder_zip_latest_mtimes = {}

        if self.sort_by_install_date:
            parent_dir = os.path.dirname(self.repo_folder)
            for item in data_list:
                zip_file = item[2]
                folder_name = item[4]
                if zip_file != "user_custom_configs":
                    if not zip_file.lower().endswith(".zip"):
                        zip_file_name = zip_file + ".zip"
                    else:
                        zip_file_name = zip_file
                    zip_path_repo = os.path.join(self.repo_folder, zip_file_name)
                    zip_path_parent = os.path.join(parent_dir, zip_file_name)
                    modification_time = 0
                    if os.path.exists(zip_path_repo):
                        modification_time = os.path.getmtime(zip_path_repo)
                    elif os.path.exists(zip_path_parent):
                        modification_time = os.path.getmtime(zip_path_parent)
                    zip_creation_times[zip_file] = modification_time

                    if folder_name not in folder_zip_latest_mtimes:
                        folder_zip_latest_mtimes[folder_name] = modification_time
                    else:
                        folder_zip_latest_mtimes[folder_name] = max(folder_zip_latest_mtimes[folder_name], modification_time)


        for item in data_list:
            pic, spawn_cmd, zip_file, info_data, folder_name = item
            if info_data:
                brand = info_data.get("Brand", "").strip()
                vehicle_type = info_data.get("Type", "").strip()
                country = info_data.get("Country", "").strip() # <-- Get country from info_data
            else:
                brand = ""
                vehicle_type = ""
                country = "" # <-- Initialize country to empty string if no info_data

            if self.categorization_mode == 'Brand':
                if zip_file == "user_custom_configs":
                    if (brand or vehicle_type):
                        category = brand if brand else vehicle_type
                    else:
                        category = "Custom"
                else:
                    if brand:
                        category = brand
                    elif vehicle_type:
                        category = f"{vehicle_type} (Brand Unavailable)"
                    else:
                        category = "|Unknown|"
            elif self.categorization_mode == 'Country': # <-- NEW elif block for "Country"
                if country: # Group by country if country info is available
                    category = country
                else:
                    category = "|Unknown Country|" # Fallback category if country is missing
            elif self.categorization_mode == 'None':
                category = "All Items"
            else: # Assuming this is 'Type' mode
                if vehicle_type:
                    category = vehicle_type
                else:
                    category = "|Unknown Type|"

            grouped.setdefault(category, []).append(item)


        print("\n--- format_grouped_data() DEBUGGING: Representative Image Selection ---")
        print("  DEBUG: Clearing Main Grid Image Cache BEFORE representative image selection...")
        self.clear_main_grid_cache()
        print("  DEBUG: Main Grid Cache Cleared.")

        updated_data_items = []

        for category, items in grouped.items():
            if items:
                representative_picture = None
                folder_name_for_category = items[0][4]

                print(f"  DEBUG: Category: {category} - Finding representative image from folder: {folder_name_for_category}")
                representative_picture_path_from_folder = self.find_representative_image_in_folder(folder_name_for_category)
                print(f"  DEBUG: Representative image path from folder (returned): {representative_picture_path_from_folder}")

                if representative_picture_path_from_folder:
                    representative_picture = representative_picture_path_from_folder
                else:
                    if items[0][2] == "user_custom_configs":
                        representative_picture = os.path.join(self.script_dir, "data/MissingCustomConfigPic.png")
                        print(f"  DEBUG: No suitable image found in folder. Using CUSTOM placeholder: {os.path.basename(representative_picture)}")
                    else:
                        representative_picture = os.path.join(self.script_dir, "data/MissingZipConfigPic.png")
                        print(f"  DEBUG: No suitable image found in folder. Using ZIP placeholder: {os.path.basename(representative_picture)}")

                for item in items:
                    updated_item = (
                        representative_picture,
                        item[1],
                        item[2],
                        item[3],
                        item[4]
                    )
                    updated_data_items.append(updated_item)

        print("--- format_grouped_data() DEBUGGING: Representative Image Selection END ---\n")


        # --- MODIFIED: Collapse Categories by Default Logic - PERSISTENT STATES ---
        print("DEBUG: format_grouped_data - Applying Collapse Categories Logic (Persistent).")
        for category in grouped:
            if self.collapse_categories_by_default:
                print(f"  DEBUG: Category '{category}' - Defaulting to COLLAPSED if not already set.")
                self.category_hidden_states.setdefault(category, True) # Collapse by default if not set
            else:
                print(f"  DEBUG: Category '{category}' - Defaulting to EXPANDED if not already set.")
                self.category_hidden_states.setdefault(category, False) # Expand by default if not set
        # --- MODIFIED: Collapse Categories by Default Logic - PERSISTENT STATES ---


        for category, items in grouped.items():
            if self.sort_by_install_date:
                items.sort(key=lambda x: (
                    zip_creation_times.get(x[2], 0) if x[2] != "user_custom_configs" else float('inf'),
                    x[4] if x[2] == "user_custom_configs" else "",
                    x[3].get("Brand", ""),
                    x[3].get("Name", "")
                ), reverse=True)
            else:
                if category == "Custom":
                    items.sort(key=lambda x: (x[4], os.path.splitext(os.path.basename(x[0]))[0]))
                else:
                    items.sort(key=lambda x: (x[3].get("Brand", ""), x[3].get("Name", "")))

        if self.sort_by_install_date:
            category_sort_keys = {}
            for category, items in grouped.items():
                latest_mtime = folder_zip_latest_mtimes.get(category, 0)
                category_sort_keys[category] = latest_mtime
            sorted_categories = sorted(
                grouped.keys(),
                key=lambda c: category_sort_keys.get(c, 0),
                reverse=True
            )
            grouped = {category: grouped[category] for category in sorted_categories}

        return grouped
        print("--- format_grouped_data() DEBUG EXIT ---\n")
 


        
        

    def find_representative_image_in_folder(self, folder_name):
        """
        Scans the given vehicle folder for a representative image.
        """
        #print("\n--- find_representative_image_in_folder() DEBUGGING ---") # Debug Entry
        #print(f"  DEBUG: folder_name received: {folder_name}") # Debug - folder_name
        #print(f"  DEBUG: self.user_folder: {self.user_folder}") # Debug - self.user_folder

        vehicle_folder_path = os.path.join(self.user_folder, folder_name)
        #print(f"  DEBUG: Constructed vehicle_folder_path: {vehicle_folder_path}") # Debug - Constructed path

        if not os.path.isdir(vehicle_folder_path):
            print(f"  WARNING: Vehicle folder NOT FOUND: {vehicle_folder_path}") # Debug - Folder not found
            return None
        else:
            print(f"  DEBUG: Vehicle folder FOUND: {vehicle_folder_path}") # Debug - Folder found

        image_extensions = ['.png', '.jpg', '.jpeg']
        for filename in os.listdir(vehicle_folder_path):
            base, ext = os.path.splitext(filename)
            if ext.lower() in image_extensions:
                pc_candidate_path = os.path.join(vehicle_folder_path, f"{base}.pc")
                if os.path.exists(pc_candidate_path):
                    image_path = os.path.join(vehicle_folder_path, filename)
                    print(f"  DEBUG: Found representative image in folder: {image_path}") # Debug
                    print("--- find_representative_image_in_folder() DEBUGGING END ---\n") # Debug Exit
                    return image_path  # Return the first suitable image found

        print(f"  DEBUG: No representative image with corresponding .pc found in folder: {vehicle_folder_path}") # Debug
        print("--- find_representative_image_in_folder() DEBUGGING END ---\n") # Debug Exit
        return None


    # ------------------------------------------------------------
    # Toggle Categorization Mode
    # ------------------------------------------------------------
    def toggle_categorization_mode(self):
        """Toggles the categorization mode, added search window update."""
        if self.categorization_mode == 'Type':
            self.categorization_mode = 'Brand'
            self.categorize_button.config(text="Categorize by: Brand")
        elif self.categorization_mode == 'Brand':
            self.categorization_mode = 'None'
            self.categorize_button.config(text="Categorize by: None")
        else:
            self.categorization_mode = 'Type'
            self.categorize_button.config(text="Categorize by: Type")

        self.grouped_data = self.format_grouped_data(self.data)
        self.update_grid_layout()
        self.canvas.yview_moveto(0)
        self.perform_search()
        self.canvas.yview_moveto(0)
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE



    def show_category_list_dropdown(self):
        if hasattr(self, 'category_list_dropdown_window') and self.category_list_dropdown_window and self.category_list_dropdown_window.winfo_exists():
            self.category_list_dropdown_window.destroy()
            return

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot adjust category visibility while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 


        button = self.category_list_button
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty()
        button_height = button.winfo_height()

        self.category_list_dropdown_window = dropdown_window = tk.Toplevel(self.master)
        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        dropdown_window.geometry(f"+{button_x}+{button_y - 208}")
        dropdown_window.config(bg="#333333")
        dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        canvas = tk.Canvas(dropdown_window, bg="#333333", highlightthickness=0, width=250, height=200)
        scrollbar = tk.Scrollbar(dropdown_window, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#333333")

        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="left", fill="both", expand=True)
        canvas.configure(yscrollcommand=scrollbar.set)
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw", width=250)

        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_dropdown_mousewheel(ev, canvas)))
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))

        categories = list(self.grouped_data.keys())
        category_vars = {}  # Initialize category_vars here
        category_buttons = {}  # ADDED: Dictionary to store buttons for each category
        cat_buttons = []

        # --- STORE ORIGINAL CATEGORY STATES ---
        self.original_category_states = {}  # Initialize here
        for category in categories:
            self.original_category_states[category] = "Shown" if not self.category_hidden_states.get(category, False) else "Hidden"
        print(f"DEBUG: Stored original category states: {self.original_category_states}")

        def toggle_category_in_dropdown(category):
            current_text = category_vars[category].get()

            if " (Shown)" in current_text:
                category_vars[category].set(category.replace(" (Shown)", "") + " (Hidden - Pending)")
            elif " (Hidden)" in current_text:
                category_vars[category].set(category.replace(" (Hidden)", "") + " (Shown - Pending)")
            elif " (Hidden - Pending)" in current_text or " (Shown - Pending)" in current_text:
                # Revert to original state
                original_state = self.original_category_states[category]
                category_vars[category].set(category + " (Shown)" if original_state == "Shown" else category + " (Hidden)")
            else:  # Should not reach here normally, but as a fallback, set to hidden pending
                category_vars[category].set(category + " (Hidden - Pending)")

            # ADDED: Update the corresponding button's color based on the new text
            try:
                btn = category_buttons[category]
                if "- Pending" in category_vars[category].get():
                    btn.config(bg=self.global_highlight_color, fg="white")
                    btn.unbind("<Leave>")
                    btn.bind("<Leave>", lambda event: event.widget.config(bg=self.global_highlight_color, fg="white"))
                else:
                    btn.config(bg="#555555", fg="white")
                    btn.unbind("<Leave>")
                    btn.bind("<Leave>", lambda event: event.widget.config(bg="#555555", fg="white"))
            except KeyError:
                pass

        def update_category_buttons(search_query=""):
            print(f"DEBUG: update_category_buttons - START - search_query: '{search_query}'")
            nonlocal cat_buttons
            print(f"  DEBUG: update_category_buttons - cat_buttons before clear: {cat_buttons}")

            for btn in cat_buttons:
                btn.destroy()
            cat_buttons.clear()
            category_buttons.clear()  # ADDED: Clear the category_buttons dictionary
            print(f"  DEBUG: update_category_buttons - cat_buttons after clear: {cat_buttons}")

            print("  DEBUG: update_category_buttons - Starting button creation loop")
            for category in categories:
                if not search_query or search_query.lower() in category.lower():
                    # Check if there's an existing StringVar for this category
                    if category in category_vars:
                        current_var = category_vars[category]
                    else:
                        current_var = tk.StringVar()
                        category_vars[category] = current_var  # Initialize if it doesn't exist yet

                    # Determine the initial text based on category_vars if it exists, otherwise default to hidden state
                    if category in category_vars and category_vars[category].get():  # Check if StringVar has a value
                        initial_button_text = category_vars[category].get()  # Use existing text (preserves pending state)
                        print(f"    DEBUG: update_category_buttons - Category: {category}, Using existing category_vars text: '{initial_button_text}'")
                    else:
                        is_category_hidden = self.category_hidden_states.get(category, False)
                        initial_button_text = category + (" (Shown)" if not is_category_hidden else " (Hidden)")  # Default based on hidden state
                        print(f"    DEBUG: update_category_buttons - Category: {category}, No existing category_vars text, using hidden state: {is_category_hidden}, text: '{initial_button_text}'")

                    category_vars[category].set(initial_button_text)  # Ensure category_vars is updated with the determined text

                    button_text = category_vars[category].get()

                    cat_button = tk.Button(scrollable_frame, textvariable=category_vars[category],
                                           font=("Segoe UI", 10, "bold"),
                                           command=lambda cat=category: toggle_category_in_dropdown(cat),
                                           bg="#555555", fg="white", relief=tk.FLAT, bd=1, anchor="w", padx=10)

                    original_button_bg = "#555555"
                    original_button_fg = "white"

                    if "- Pending" in button_text:
                        cat_button.config(bg=self.global_highlight_color, fg="white")
                        original_button_bg = self.global_highlight_color
                        original_button_fg = "white"

                    cat_button.bind("<Enter>", lambda event: event.widget.config(bg="white", fg="black"))
                    cat_button.bind("<Leave>", lambda event, bg=original_button_bg, fg=original_button_fg: event.widget.config(bg=bg, fg=fg))

                    cat_button.pack(fill="x", pady=1)
                    cat_buttons.append(cat_button)
                    category_buttons[category] = cat_button  # ADDED: Store the button in the category_buttons dictionary
                    print(f"    DEBUG: update_category_buttons - Created button for: {category}, text: '{button_text}'")
            print("  DEBUG: update_category_buttons - Button creation loop END")
            print(f"  DEBUG: update_category_buttons - cat_buttons after creation loop: {cat_buttons}")

            canvas.config(scrollregion=canvas.bbox("all"))
            print("DEBUG: update_category_buttons - END")


        def hide_all_categories_in_dropdown():
            print("DEBUG: hide_all_categories_in_dropdown - START")
            for category in categories:
                category_vars[category].set(category + " (Hidden - Pending)") # Update category_vars FIRST
                print(f"  DEBUG: hide_all_categories_in_dropdown - Setting category_vars['{category}'] to: '{category_vars[category].get()}'")
            update_category_buttons(search_query_var.get()) # THEN call update_category_buttons
            dropdown_window.update_idletasks()
            print("DEBUG: hide_all_categories_in_dropdown - END")


        def show_all_categories_in_dropdown():
            print("DEBUG: show_all_categories_in_dropdown - START")
            for category in categories:
                category_vars[category].set(category + " (Shown - Pending)") # Update category_vars FIRST
                print(f"  DEBUG: show_all_categories_in_dropdown - Setting category_vars['{category}'] to: '{category_vars[category].get()}'")
            update_category_buttons(search_query_var.get()) # THEN call update_category_buttons
            dropdown_window.update_idletasks()
            print("DEBUG: show_all_categories_in_dropdown - END")


        def apply_category_visibility():
            for category in categories:
                if category_vars[category].get().endswith(" (Hidden - Pending)"):
                    self.category_hidden_states[category] = True
                elif category_vars[category].get().endswith(" (Shown - Pending)"):
                    self.category_hidden_states[category] = False
            self.update_grid_layout()
            dropdown_window.destroy()
            self.category_list_dropdown_window = None

        button_frame = tk.Frame(dropdown_window, bg="#333333")
        button_frame.pack(fill="x", side="bottom")

        search_query_var = tk.StringVar()
        search_entry = tk.Entry(button_frame, textvariable=search_query_var, font=("Segoe UI", 10), bg="white", fg="black")
        search_entry.pack(pady=2, fill="x")

        search_entry.bind("<KeyRelease>", lambda event: update_category_buttons(search_query_var.get()))
        search_entry.bind("<KeyRelease>", lambda event, canvas=canvas: canvas.yview_moveto(0), add='+')


        hide_all_button = tk.Button(button_frame, text="Hide All", font=("Segoe UI", 10, "bold"), command=hide_all_categories_in_dropdown, bg="#555555", fg="white", relief=tk.RAISED, bd=1)
        show_all_button = tk.Button(button_frame, text="Show All", font=("Segoe UI", 10, "bold"), command=show_all_categories_in_dropdown, bg="#555555", fg="white", relief=tk.RAISED, bd=1)
        apply_button = tk.Button(button_frame, text="Apply", font=("Segoe UI", 10, "bold"), command=apply_category_visibility, bg="#555555", fg="white", relief=tk.RAISED, bd=1)

        hide_all_button.pack(fill="x", pady=2, in_=button_frame)
        show_all_button.pack(fill="x", pady=2, in_=button_frame)
        apply_button.pack(fill="x", pady=2, in_=button_frame, side="bottom")


        update_category_buttons() # Call update_category_buttons initially to populate list

        dropdown_window.bind("<FocusOut>", lambda event: self.destroy_category_list_dropdown())

 








    def toggle_sort_by_install_date(self):
        """Toggles the 'Sort by Install Date' setting, updates UI, and saves setting.""" # Modified docstring
        print(f"toggle_sort_by_install_date - BEFORE toggle: self.sort_by_install_date = {self.sort_by_install_date}") # Debugging print
        self.sort_by_install_date = not self.sort_by_install_date
        print(f"toggle_sort_by_install_date - AFTER toggle: self.sort_by_install_date = {self.sort_by_install_date}") # Debugging print
        # Removed button text update as button is no longer in top_frame
        # --- MODIFIED: Re-group and re-sort based on the *current* self.data ---
        self.grouped_data = self.format_grouped_data(self.data) # Re-group and re-sort
        self.update_grid_layout()
        self.canvas.yview_moveto(0)
        self.perform_search()
        self.canvas.yview_moveto(0)
        self._update_filters_label_status()
        self.update_settings_dropdown_button_text() # Call function to update button text
        self.save_settings() # Save setting to file - ADDED




    def toggle_collapse_categories_by_default(self):
        """Toggles the 'Collapse Categories By Default' setting and updates dropdown text."""
        self.collapse_categories_by_default = not self.collapse_categories_by_default
        self.update_settings_dropdown_button_text()
        self.save_settings()
    # --- NEW: Toggle Collapse Categories Setting ---




    def update_settings_dropdown_button_text(self):
        """Updates button texts in the settings dropdown (Sort Date and Show Switcher).""" # Modified docstring
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            # Find and update "Show Switcher On Startup" button
            for child in self.settings_dropdown_window.winfo_children():
                if isinstance(child, tk.Button) and "Show Switcher On Startup" in child.cget("text"):
                    current_text = "Show Switcher On Startup: " + ("On" if self.show_switcher_on_startup else "Off")
                    child.config(text=current_text)
                    print(f"update_settings_dropdown_button_text - Show Switcher Button text updated to: {current_text}") # Debugging print

            # Find and update "Attempt to Sort By Install Date" button
            for child in self.settings_dropdown_window.winfo_children():
                if isinstance(child, tk.Button) and "Attempt to Sort By Install Date" in child.cget("text"):
                    child.config(text="Attempt to Sort By Install Date: " + ("On" if self.sort_by_install_date else "Off"))
                    print(f"update_settings_dropdown_button_text - Sort Date Button text updated.") # Debugging print
                    
                    
                    
           # --- NEW: Update "Collapse Categories By Default" button text ---
            for child in self.settings_dropdown_window.winfo_children():
                if isinstance(child, tk.Button) and "Collapse Categories By Default" in child.cget("text"):
                    child.config(text="Collapse Categories By Default: " + ("On" if self.collapse_categories_by_default else "Off"))
            # --- NEW: Update "Collapse Categories By Default" button text --- 
        
        
    # ------------------------------------------------------------
    # sidebar filters
    # ------------------------------------------------------------
    def get_unique_brands(self):
        """
        Extracts unique brand names from the **filtered_original_data_for_brands** data set. - MODIFIED TO USE FILTERED DATA
        """
        brands = set()
        # Iterate over self.filtered_original_data_for_brands to get filtered brands
        if hasattr(self, 'filtered_original_data_for_brands'): # Defensive check
            for item in self.filtered_original_data_for_brands: # <--- MODIFIED: Use filtered data source
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand:
                    brands.add(brand)
        else:
            #print("Warning: filtered_original_data_for_brands attribute not initialized. Returning empty brand list.") # Defensive warning
            pass
        return sorted(list(brands))
    
    
    def get_unique_names(self, selected_brand="All Brands"):
        """
        Extracts unique names, dynamically filtered by brand and respecting the main search query.
        - MODIFIED to use filtered_original_data_for_brands and respect selected_brand
        """
        names = set()
        if hasattr(self, 'filtered_original_data_for_brands'): # Defensive check
            filtered_data_source = self.filtered_original_data_for_brands # <--- MODIFIED: Use filtered data source

            if selected_brand != "All Brands": # Apply brand filter if a specific brand is selected
                filtered_data = [
                    item for item in filtered_data_source # <--- MODIFIED: Iterate over filtered data source
                    if item[3].get("Brand", "").strip() == selected_brand
                ]
            else:
                filtered_data = filtered_data_source # <--- MODIFIED: Use filtered data source directly for 'All Brands'

            for item in filtered_data: # Iterate over filtered data
                _, _, _, info_data, _ = item
                name = info_data.get("Name", "").strip()
                if name:
                    names.add(name)
        else:
            print("Warning: filtered_original_data_for_brands attribute not initialized. Returning empty name list.") # Defensive warning

        return sorted(list(names))


    def get_unique_body_styles(self, selected_brand="All Brands", selected_name="All Names", selected_country="All Countries"):
        """
        Extracts unique body style names, now dynamically filtered by selected brand, name, AND country,
        and respecting the main search query. - MODIFIED to use filtered_original_data_for_brands
        """
        body_styles = set()
        if hasattr(self, 'filtered_original_data_for_brands'): # Defensive check
            filtered_data_source = self.filtered_original_data_for_brands # Use filtered data source


            if selected_name != "All Names": # Name filter still has highest priority
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    name = info_data.get("Name", "").strip()
                    if name == selected_name:
                        body_style = info_data.get("Body Style", "").strip()
                        if body_style:
                            body_styles.add(body_style)
                return sorted(list(body_styles)) # Return early - name filter takes precedence


            if selected_country != "All Countries":
                country_filtered_data = []
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    country = info_data.get("Country", "").strip()
                    if country == selected_country:
                        country_filtered_data.append(item)

                if selected_brand != "All Brands":
                    for item in country_filtered_data:
                        _, _, _, info_data, _ = item
                        brand = info_data.get("Brand", "").strip()
                        if brand == selected_brand:
                            body_style = info_data.get("Body Style", "").strip()
                            if body_style:
                                body_styles.add(body_style)
                else: # If "All Brands" with Country filter
                    for item in country_filtered_data:
                         _, _, _, info_data, _ = item
                         body_style = info_data.get("Body Style", "").strip()
                         if body_style:
                             body_styles.add(body_style)


            elif selected_brand != "All Brands": # Brand filter (if no Name or Country filter)
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    brand = info_data.get("Brand", "").strip()
                    if brand == selected_brand:
                        body_style = info_data.get("Body Style", "").strip()
                        if body_style:
                            body_styles.add(body_style)

            else: # "All Brands" and "All Names" and "All Countries" case
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    body_style = info_data.get("Body Style", "").strip()
                    if body_style:
                        body_styles.add(body_style)
        else:
            print("Warning: filtered_original_data_for_brands attribute not initialized. Returning empty body style list.") # Defensive warning

        return sorted(list(body_styles))
        


    def get_unique_countries(self, selected_brand="All Brands", selected_name="All Names"):
        """
        Extracts unique country names, now dynamically filtered by selected brand AND name,
        and respecting the main search query. - MODIFIED to use filtered_original_data_for_brands
        """
        countries = set()
        if hasattr(self, 'filtered_original_data_for_brands'): # Defensive check
            filtered_data_source = self.filtered_original_data_for_brands # Use filtered data source

            if selected_name != "All Names":
                # If a specific name is selected, get countries for that name only (within selected brand, if any)
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    name = info_data.get("Name", "").strip()
                    if name == selected_name:
                        country = info_data.get("Country", "").strip()
                        if country and country != "N/A":
                            countries.add(country)
                return sorted(list(countries)) # Return early - name filter takes precedence for countries


            if selected_brand != "All Brands":
                # If a specific brand is selected (and no specific name), get countries for that brand
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    brand = info_data.get("Brand", "").strip()
                    if brand == selected_brand:
                        country = info_data.get("Country", "").strip()
                        if country and country != "N/A":
                            countries.add(country)
            else:
                # If "All Brands" and "All Names" are selected, get all countries from the filtered data
                for item in filtered_data_source:
                    _, _, _, info_data, _ = item
                    country = info_data.get("Country", "").strip()
                    if country and country != "N/A":
                        countries.add(country)
        else:
            print("Warning: filtered_original_data_for_brands attribute not initialized. Returning empty country list.") # Defensive warning

        return sorted(list(countries))



    def _filter_data_by_brand(self, option_text):
        """Filters data by brand, respecting the main search query, added search window update."""
        filtered_data = []
        data_to_filter = list(self.data_cache)

        query = self.search_var.get().strip().lower()
        if query:
            query_filtered_data = []
            for item in data_to_filter:
                if self._perform_item_search(query, item):
                    query_filtered_data.append(item)
            data_to_filter = query_filtered_data

        if option_text == "All Brands":
            filtered_data = data_to_filter
        else:
            for item in data_to_filter:
                _, _, _, info_data, _ = item
                brand = info_data.get("Brand", "").strip()
                if brand == option_text:
                    filtered_data.append(item)

        self.data = filtered_data
        self.grouped_data = self.format_grouped_data(self.data)
        self.update_grid_layout()
        self.canvas.yview_moveto(0)
        self.update_search_results_window_ui() # <----- ADD THIS LINE HERE

        

        

    def setup_sidebar_filter_dropdowns(self, sidebar_bottom_frame, sidebar_padding):
        # --- Dynamic Brand List (no changes needed here as it's already using get_unique_brands) ---
        brand_options_dynamic = ["All Brands"] + self.get_unique_brands() # <--- MODIFIED: Now uses filtered brands

        # --- NEW: Dynamic Name List - using get_unique_names now ---
        name_options_dynamic = ["All Names"] + self.get_unique_names() # Populate with names
        # --- NEW: Dynamic Name List - using get_unique_names now ---

        # --- NEW: Dynamic Body Style List - using get_unique_body_styles now ---
        bodystyle_options_dynamic = ["All BodyStyles"] + self.get_unique_body_styles() # Populate with body styles
        # --- NEW: Dynamic Body Style List - using get_unique_body_styles now ---

        # --- NEW: Dynamic Country List ---
        country_options_dynamic = ["All Countries"] + self.get_unique_countries() # NEW: Dynamic countries list
        # --- NEW: Dynamic Country List ---

        # --- MODIFIED: Filter options data WITHOUT Type and Author, and IN DESIRED ORDER for single column ---
        filter_options_data = {
            "Brand": brand_options_dynamic,
            "Name": name_options_dynamic,  # Use dynamic name list here
            "Country": country_options_dynamic, # NEW: Country options
            "Bodystyle": bodystyle_options_dynamic,  # NEW: Body Style options
            # "Author": ["All Authors", "Author 1", "Author 2"], # REMOVED Author
            # "Type": ["All Types", "Type 1", "Type 2"] # REMOVED Type
        }
        # --- MODIFIED: Filter options data WITHOUT Type and Author, and IN DESIRED ORDER for single column ---

        self._add_filter_dropdown_elements(self.sidebar_filter_dropdowns_frame, filter_options_data)

        self._configure_filter_dropdown_frame_layout(self.sidebar_filter_dropdowns_frame)


    def _create_bodystyle_dropdown_content(self, scrollable_frame, dynamic_bodystyle_options, button, dropdown_window, canvas):
        """Creates the content of the bodystyle dropdown: search entry and options, ensuring 'All BodyStyles' is always first."""
        search_var = tk.StringVar()
        search_entry = tk.Entry(scrollable_frame, textvariable=search_var, font=("Segoe UI", 10), bg="white", fg="black", width=18)
        search_entry.pack(pady=(5, 2), padx=5, fill="x")
        search_entry.focus_set()
        
        filter_options_data = { # NOTE: This is likely redundant and can be removed/reworked - but keep for now
            "Brand": ["All Brands"] + self.get_unique_brands(),
            "Name": ["All Names", "Name 1", "Name 2"],
            "Country": ["All Countries"] + self.get_unique_countries(),
            "Author": ["All Authors", "Author 1", "Author 2"],
            "Bodystyle": dynamic_bodystyle_options, # Pass dynamic options here
            "Type": ["All Types", "Type 1", "Type 2"]
        }
        # --- MODIFIED: Ensure 'All BodyStyles' is at the beginning of original_options ---
        original_options = filter_options_data["Bodystyle"]
        if "All BodyStyles" in original_options:
            original_options.remove("All BodyStyles") # Remove if present anywhere
        original_options.insert(0, "All BodyStyles") # Insert at the beginning
        # --- MODIFIED: Ensure 'All BodyStyles' is at the beginning of original_options ---


        #search_entry.bind("<KeyRelease>", lambda event: self._update_bodystyle_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window))
        #self._update_bodystyle_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window) # Initial population


        search_entry.bind("<KeyRelease>", lambda event: self._debounced_update_bodystyle_dropdown(search_var, original_options, scrollable_frame, canvas, button, dropdown_window))
        
        self._update_bodystyle_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window) # Initial population

        


    def _debounced_update_bodystyle_dropdown(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Debounced version of _update_name_dropdown_options."""
        if self.debounce_timer:
            self.master.after_cancel(self.debounce_timer)
        self.debounce_timer = self.master.after(
            600,  # Adjust delay as needed (milliseconds)
            lambda: self._update_bodystyle_dropdown_options(search_var, original_options, scrollable_frame, canvas, button, dropdown_window)
        )


    def _update_bodystyle_dropdown_options(self, search_var, original_options, scrollable_frame, canvas, button, dropdown_window):
        """Updates the options displayed in the Bodystyle dropdown based on search input."""
        print("    DEBUG: _update_bodystyle_dropdown_options() START") # Debug

        search_text = search_var.get().strip().lower()
        filtered_options = self._filter_dropdown_options(search_text, original_options) # 1. Filter options

        self._clear_dropdown_options(scrollable_frame) # 2. Clear existing options
        self._create_bodystyle_option_buttons(scrollable_frame, filtered_options, button, dropdown_window) # 3. Create new option buttons


        canvas.config(scrollregion=canvas.bbox("all"))
        # --- DEBUG PRINT: End of update_dropdown_options ---
        print("    DEBUG: _update_bodystyle_dropdown_options() END") # Debug


    def _create_bodystyle_option_buttons(self, scrollable_frame, current_options, button, dropdown_window):
        """Creates and packs option buttons in the scrollable frame for bodystyle."""
        for option in current_options:
            bg_color = "#555555"
            fg_color = "white"
            current_button_text = button.cget("text")
            if option == current_button_text:
                bg_color = self.global_highlight_color
                fg_color = "white"

            dropdown_button = tk.Button(
                scrollable_frame,
                text=option,
                font=("Segoe UI", 10, "bold"),
                command=lambda opt=option, fname="bodystyle": self._on_bodystyle_dropdown_button_click(opt, fname=fname, fbutton=button, fdropdown_window=dropdown_window), # Call _on_bodystyle_dropdown_button_click
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=2,
                bg=bg_color,
                fg=fg_color,
                width=240
            )
            dropdown_button.pack(fill="x")
            dropdown_button.bind("<Enter>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg="lightgrey", fg="black"))
            dropdown_button.bind("<Leave>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg=original_bg, fg=original_fg))


    def _on_bodystyle_dropdown_button_click(self, option_text, fname, fbutton, fdropdown_window):
        """Handles the button click event in the Bodystyle dropdown.
           MODIFIED to call _update_filters_label_status AFTER button config.
        """
        print("    DEBUG: _on_bodystyle_dropdown_button_click() START") # Debug
        fbutton.config(text=option_text)
        self._filter_data_by_bodystyle(option_text)
        self._update_ui_elements(fdropdown_window)
        self._update_filters_label_status() # <--- UPDATE FILTERS LABEL STATUS HERE
        print("    DEBUG: _on_bodystyle_dropdown_button_click() END") # Debug
        
        
    # ------------------------------------------------------------
    # Add Mods action
    # ------------------------------------------------------------
    def add_mods_action(self):
        mod_folder = os.path.join(self.script_dir, os.pardir)
        if not os.path.exists(mod_folder):
            try:
                os.makedirs(mod_folder)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to create 'mods' folder: {e}")
                return

        file_paths = filedialog.askopenfilenames(
            title="Select Mod Zip Files",
            filetypes=[("Zip files", "*.zip")],
            initialdir=os.path.expanduser("~")
        )
        if not file_paths:
            #messagebox.showinfo("Info", "No files selected.")
            

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="No files selected.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
            return

        moved_files = []
        for file_path in file_paths:
            try:
                destination_path = os.path.join(mod_folder, os.path.basename(file_path))
                shutil.move(file_path, destination_path)
                moved_files.append(os.path.basename(file_path))
            except Exception as e:
                messagebox.showerror("Error", f"Failed to move '{os.path.basename(file_path)}': {e}")

        # try:
        #     skip_custom_file = os.path.join(self.script_dir, "SkipCustomForceModCheck.txt")
        #     with open(skip_custom_file, "w") as f:
        #         f.write("This file tells the script to skip custom config scanning and force mod checking.")
        # except Exception as e:
        #     messagebox.showerror("Error", f"Failed to create SkipCustomForceModCheck.txt: {e}")

        if moved_files:
            try:
                new_mods_file = os.path.join(self.script_dir, "data/NewMods.txt")
                with open(new_mods_file, "w", encoding="utf-8") as f:
                    for file_name in moved_files:
                        f.write(f"{file_name}\n")
                        
                        
                # messagebox.showinfo("Success",
                #                    f"Moved {len(moved_files)} file(s) to 'mods' folder. "
                #                    "Application will now restart to refresh the listing.")
                # self.restart_script()
                # ----------RESTART NO LONGER NECESSARY
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to create NewMods.txt: {e}")
        else:
            messagebox.showinfo("Info", "No files were moved.")

    # ------------------------------------------------------------
    # Perform Search
    # ------------------------------------------------------------
    
    
    
    
    def _initialize_search_attributes(self):
        """Initializes search-related attributes and handles default search mode."""
        print("    _initialize_search_attributes()")
        if not hasattr(self, 'search_mode'):
            print("    Warning: search_mode attribute not initialized. Defaulting to 'General'.")
            self.search_mode = "General"

    def _reset_sidebar_filters_on_search(self):
        """Resets sidebar filters to 'All...' when a search is initiated."""
        print("    _reset_sidebar_filters_on_search()")
        if hasattr(self, 'sidebar_filter_buttons') and self.sidebar_filter_buttons:
            print("    DEBUG: Search Started - Resetting Sidebar Filters to 'All...'")
            filter_names = ["Brand", "Name", "Bodystyle", "Country", "Author", "Type"]
            for filter_name in filter_names:
                button = self.sidebar_filter_buttons.get(filter_name)
                if button:
                    all_text = f"All {filter_name}s" if filter_name in ["Bodystyle", "Type"] else f"All {filter_name}s" if filter_name != "Name" else "All Names"
                    button.config(text=all_text)
                    print(f"      DEBUG: Resetting {filter_name} filter button to '{all_text}'")
            self._repopulate_sidebar_dropdowns_on_reset()
        else:
            print("    Warning: sidebar_filter_buttons not initialized yet. Skipping sidebar filter reset in perform_search.")

    def _repopulate_sidebar_dropdowns_on_reset(self):
        """Repopulates dynamic dropdown options after sidebar filter reset."""
        print("    _repopulate_sidebar_dropdowns_on_reset()")
        print("    DEBUG: Repopulating dynamic dropdown options after filter reset (Search Start)...")
        self.setup_sidebar_filter_dropdowns(self.sidebar_bottom_frame, 10)
        print("    DEBUG: Dynamic dropdown options repopulated (Search Start).")

    def _perform_item_search(self, query, item):
        """Performs the actual search logic for a single item based on search mode."""
        pic, spawn_cmd, zip_file, info_data, folder_name = item
        matches = False
        if query:
            if self.search_mode == "Configs":
                matches = self._check_config_search_matches(query, item)
            else: # General Search Mode
                matches = self._check_general_search_matches(query, item)
        else: # No query, show all (subject to main filter)
            matches = True
        return matches

    def _check_config_search_matches(self, query, item):
        """
        Checks if an item matches the search query in 'Configs' search mode,
        matching against Configuration values in ALL matches_config.txt entries
        associated with the representative image's folder, and PC filename.
        Loads and parses matches_config.txt entries DIRECTLY within this function (no cache).
        """
        pic, spawn_cmd, zip_file, info_data, folder_name = item
        associated_config_names = set()
        is_favorites_filter_active = (self.filter_state == 5 and self.filter_options[self.filter_state] == "Favorites")
        favorite_configs_set = self.favorite_configs if is_favorites_filter_active else None

        zip_file_base_name = zip_file.replace(".zip", "") # Remove extension
        pc_file_name_match = False # Initialize PC file name match flag - keep this check

        # --- NEW: Iterate through matches_config_data to find associated configs ---
        for filename, config_name_from_file in self.matches_config_data.items(): # Iterate through ALL matches_config.txt entries
            if folder_name in filename and "--INDIVIDUAL--" in filename: # Check if folder_name is in the filename AND it's an individual config
                # --- NEW: Apply Favorites Filter to matches_config.txt entries ---
                if is_favorites_filter_active: # If Favorites filter is active
                    config_name_base_inner = self.extract_name_from_spawn_command_from_matches_config_filename(filename) # Extract config name from filename
                    if config_name_base_inner:
                        fav_key = f"{folder_name}|{config_name_base_inner}.pc" # Construct favorite key
                        if fav_key not in favorite_configs_set:
                            continue # Skip to the next config if not a favorite
                # --- NEW: Apply Favorites Filter to matches_config.txt entries ---

                if query in config_name_from_file.lower(): # Check query against config name from matches_config.txt
                    associated_config_names.add(config_name_from_file.lower()) # Add config name to associated names

        # --- NEW: Check PC Filename Match (as before) ---
        pc_file_name = self.extract_name_from_spawn_command(spawn_cmd) # Keep PC filename check as is, OUTSIDE the loop
        if pc_file_name and query in pc_file_name.lower():
            pc_file_name_match = True # Set PC filename match flag if matched
        # --- NEW: Check PC Filename Match (as before) ---


        is_match_normal = bool(associated_config_names) or pc_file_name_match # Check for match in associated config names OR PC filename

        # --- CALL PC_PRIORITY VERSION ---
        is_match_pc_priority = self._check_config_search_matches_PC_PRIORITY(query, item)
        # --- CALL PC_PRIORITY VERSION ---

        # --- COMBINE RESULTS ---
        is_match_combined = is_match_normal or is_match_pc_priority
        return is_match_combined


    def extract_name_from_spawn_command_from_matches_config_filename(self, matches_config_filename):
        """
        Extracts config name base from matches_config.txt filename (similar to extract_name_from_spawn_command).
        e.g., from "vehicles--INDIVIDUAL--pickup_pickup.zip--info_info_config_name.json" to "config_name".
        """
        match = re.search(r'--info_info_([^\.]+)\.json', matches_config_filename, re.IGNORECASE)
        if match:
            return match.group(1) # Returns the config name (e.g., "config_name")
        return None # Returns None if no match found


    def _check_config_search_matches_PC_PRIORITY(self, query, item):
        """
        Checks if an item matches the search query in 'Configs' search mode,
        matching against Configuration values in ALL matches_config.txt entries
        associated with the representative image's folder, AND PC filename (prioritized). <--- MODIFIED DOCSTRING
        Loads and parses associated JSON files DIRECTLY within this function (no cache).
        """
        pic, spawn_cmd, zip_file, info_data, folder_name = item
        associated_config_names = set()
        is_favorites_filter_active = (self.filter_state == 5 and self.filter_options[self.filter_state] == "Favorites")
        favorite_configs_set = self.favorite_configs if is_favorites_filter_active else None

        zip_file_base_name = zip_file.replace(".zip", "") # Remove extension
        config_name_base = self.extract_name_from_spawn_command(spawn_cmd)

        # --- NEW: Check PC Filename Match FIRST and PRIORITIZE it ---
        pc_file_name_match = False  # Initialize PC file name match flag
        pc_file_name = self.extract_name_from_spawn_command(spawn_cmd)
        if pc_file_name and query in pc_file_name.lower():
            pc_file_name_match = True  # Set PC filename match flag if matched
            #print(f"DEBUG: _check_config_search_matches - PC Filename MATCH FOUND for query '{query}' - Filename: {os.path.basename(pic)}, PC Filename: {pc_file_name}") # Debug - PC Filename Match

        if pc_file_name_match: # If PC filename matches, return True immediately - PRIORITIZE PC FILENAME MATCH
            return True # <-- EARLY RETURN if PC filename matches
        # --- NEW: Check PC Filename Match FIRST and PRIORITIZE it ---

        '''
        # --- Open constructednames.txt for writing (append mode) ---
        constructed_names_file = os.path.join(self.script_dir, "constructednames.txt")
        try:
            with open(constructed_names_file, "a") as outfile: # Open in append mode
                #outfile.write(f"\n--- Checking item: {os.path.basename(pic)} ---\n") # --- Log START of item check ---
                pass
        '''        
        if folder_name in self.full_data:
            for config_item in self.full_data[folder_name]:
                config_spawn_cmd = config_item[1]
                config_name_base_inner = self.extract_name_from_spawn_command(config_spawn_cmd)
                if is_favorites_filter_active:
                    fav_key = f"{folder_name}|{config_name_base_inner}.pc"
                    if fav_key not in favorite_configs_set:
                        continue

                if config_name_base_inner:
                    associated_config_names.add(config_name_base_inner.lower())

                    ''' # --- REMOVED: not needed in PC Priority, this just makes the search slower and it doesn't work properly ---
                    # Construct the expected filename for individual info file
                    individual_info_filename = (
                        f"vehicles--INDIVIDUAL--{folder_name}_{zip_file_base_name}.zip--info_info_{config_name_base_inner}.json"
                    )

                    # --- NEW: Write constructed filename to file ---
                    #outfile.write(f"    DEBUG: Constructed Filename: {individual_info_filename}\n") # Log constructed filename

                    # --- MODIFIED: Load config name DIRECTLY from file (NO cache, NO _load_individual_info) ---
                    individual_info_path = self.find_individual_info_file(
                        folder_name,
                        zip_file_base_name=zip_file_base_name,
                        config_name=config_name_base_inner
                    )
                    if individual_info_path and os.path.exists(individual_info_path):
                        try:
                            with open(individual_info_path, 'r', encoding='utf-8') as f: # Open and read file directly
                                file_content = f.read()
                                config_info_value = self.get_json_value_safe(file_content, "Configuration", r'"Configuration"\s*:\s*"([^"]*)"') # Extract config name using regex
                                if config_info_value:
                                    associated_config_names.add(config_info_value.lower()) # Use config name from file
                        except Exception as e_load:
                            print(f"Warning: Error loading/parsing {individual_info_path}: {e_load}") # Print warning on file load/parse error
                        '''

        #except Exception as e_file_write: # Catch file writing errors
            #print(f"Warning: Error writing to constructednames.txt: {e_file_write}") # Print error message
        #    pass
            

        found_in_any_config_name = False
        for config_name in associated_config_names:
            if query in config_name:
                found_in_any_config_name = True
                break


        is_match = found_in_any_config_name or pc_file_name_match # Check for match in associated config names OR PC filename

        # --- NEW: Debug Print - Log matching filenames to console ---
        #if is_match:
        #    print(f"DEBUG: _check_config_search_matches - MATCH FOUND for query '{query}' - Representative Image: {os.path.basename(pic)}") # Print filename if it's a match
        # --- NEW: Debug Print - Log matching filenames to console ---

        # --- NEW: Debug Print - Log NOT matching filenames to console ---
        #if not is_match:
        #    print(f"DEBUG: _check_config_search_matches - MATCH NOT FOUND for query '{query}' - Representative Image: {os.path.basename(pic)}") # Print filename if it's NOT a match
        # --- NEW: Debug Print - Log NOT matching filenames to console ---

        return is_match
        
        
 
    

    def _check_general_search_matches(self, query, item):
        """Checks if an item matches the search query in 'General' search mode."""
        pic, spawn_cmd, zip_file, info_data, folder_name = item

        # Combined Text Label Search
        brand_for_main = info_data.get("Brand", "Unknown")
        if not brand_for_main.strip():
            brand_for_main = "Unknown"
        type_for_main = info_data.get("Type", "Unknown")
        if not type_for_main.strip():
            type_for_main = "Unknown"
        if brand_for_main == "Unknown":
            brand_for_main = type_for_main

        name_for_main = info_data.get("Name")
        if not name_for_main or not name_for_main.strip():
            name_for_main = self.extract_name_from_spawn_command(spawn_cmd)

        combined_text = f"{brand_for_main} - {name_for_main}"
        combined_text_lower = combined_text.lower()

        if query in combined_text_lower:
            return True

        # Search ALL Zip Files Associated with Folder
        associated_zip_files = set()
        if folder_name in self.full_data:
            for config_item in self.full_data[folder_name]:
                config_zip_file = config_item[2]
                associated_zip_files.add(config_zip_file.lower())

        found_in_any_zip = False
        for zip_name in associated_zip_files:
            if query in zip_name:
                found_in_any_zip = True
                break

        if found_in_any_zip:
            return True

        # Existing Zip File Name, folder name, info_data values search
        if query in zip_file.lower():
            return True
        if query in folder_name.lower():
            return True
        if any(query in str(v).lower() for v in info_data.values()):
            return True

        return False

    def _apply_main_filter(self, filtered_items):
        """Applies the main filter to the search results."""
 


        print("    _apply_main_filter()")
        final_list = []
        filtered_original_data_for_brands = [] # For brand filter later
        default_zips = [name.lower() for name in self.ZIP_BASE_NAMES]
        current_filter = self.filter_options[self.filter_state]

        for it in filtered_items:
            zip_lower = it[2].lower()
            folder_lower = it[4].lower()
            include_for_brand_filter = False

            if current_filter == "View All": # <--- NEW FILTER OPTION
                final_list.append(it)
                include_for_brand_filter = True
            elif current_filter == "Items with Config Preview Images [debug]":
                if not self.is_placeholder(it[0]):
                    final_list.append(it)
                    include_for_brand_filter = True
            elif current_filter == "Items Without Config Preview Images [debug]":
                if self.is_placeholder(it[0]):
                    final_list.append(it)
                    include_for_brand_filter = True
            elif current_filter == "Only Mods":
                if folder_lower not in default_zips and zip_lower != "user_custom_configs":
                    final_list.append(it)
                    include_for_brand_filter = True
            elif current_filter == "Vanilla":
                if folder_lower in default_zips:
                    final_list.append(it)
                    include_for_brand_filter = True
            elif current_filter == "Unpacked Mods":
                if zip_lower == "user_custom_configs":
                    final_list.append(it)
                    include_for_brand_filter = True
            elif current_filter == "Favorites":
                fav_folders = set()
                for fav in self.favorite_configs:
                    fav_folders.add(fav.split('|')[0].lower())
                if folder_lower in fav_folders:
                    final_list.append(it)
                    include_for_brand_filter = True
            else: # Default case - should not be reached, but for safety
                final_list.append(it)
                include_for_brand_filter = True

            if include_for_brand_filter:
                filtered_original_data_for_brands.append(it)

        self.filtered_original_data_for_brands = filtered_original_data_for_brands
        return final_list  


    def _update_search_results_ui(self, final_list, current_filter):
        """Updates the UI elements after search and filtering are complete."""

        print("\n--- _update_search_results_ui() DEBUG ENTRY ---") # Debug Entry
        print(f"DEBUG: _update_search_results_ui - final_list received (count): {len(final_list)}") 

        print("    _update_search_results_ui()")
        self.data = final_list[:]
        print("    Calling self.format_grouped_data() ...")
        self.grouped_data = self.format_grouped_data(self.data)
        print("    self.format_grouped_data() RETURNED.")
        self.update_grid_layout()
        self.canvas.yview_moveto(0)
        item_count = len(final_list)
        self.filter_button.config(text=f"{current_filter} [{item_count}]")
        self._update_filters_label_status()


    #@profile 
    def perform_search(self):
        
        print("\n--- ConfigViewerApp.perform_search() ENTRY ---")

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot search while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 

        self._initialize_search_attributes()
        self._reset_sidebar_filters_on_search()

        self.lift_search_results_window()
        query = self.search_var.get().strip().lower()
        filtered = []

        data_to_search = list(self.data_cache)
        data_to_search = self.apply_data_subset_filter(data_to_search)

        for item in data_to_search:
            if self._perform_item_search(query, item):
                filtered.append(item)

        final_list = self._apply_main_filter(filtered)
        current_filter = self.filter_options[self.filter_state]

        # --- MODIFICATION START: Check for empty query AND "View All" filter AND GLOBAL FILTERS OFF to close search results window ---
        # --- MODIFIED CONDITION: Added DEBUG prints to check condition values ---
        print("DEBUG: perform_search - Checking window destruction condition:")
        print(f"  DEBUG: perform_search - query is empty: {not query}")
        print(f"  DEBUG: perform_search - self.filter_state == 0 (View All): {self.filter_state == 0}")
        print(f"  DEBUG: perform_search - not self.is_data_subset_active (Global Filters OFF): {not self.is_data_subset_active}")

        if not query and self.filter_state == 0 and not self.is_data_subset_active:
            print("  DEBUG: perform_search - Condition MET for Search Results window DESTRUCTION.") # Debug - Condition Met
            if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
                self.destroy_search_results_window()
                self.search_results_window = None
                self.is_search_results_window_active = False
                print("DEBUG: perform_search - Search Results window DESTROYED (Empty query AND View All filter AND Global Filters OFF).")
            else:
                print("DEBUG: perform_search - Search Results window NOT open, no need to destroy (Empty query AND View All filter AND Global Filters OFF).") # Debug - Window Not Open
            self.data = final_list[:] # Still update self.data
            self.grouped_data = self.format_grouped_data(self.data) # Still update grouped_data
            item_count = len(final_list)
            self.filter_button.config(text=f"{current_filter} [{item_count}]")
            self._update_filters_label_status()
            self.update_search_results_window_ui() # Update search results window if open
            print("--- ConfigViewerApp.perform_search() EXIT - Skipped Layout Update AND Destroyed Search Results Window ---\n")
            return  # Exit here, skipping full layout update and destroying search results window
        # --- MODIFICATION END: Check for empty query AND "View All" filter AND GLOBAL FILTERS OFF to close search results window ---


        # --- MODIFICATION START: Check for empty query and skip layout update ---
        if not query:
            print("DEBUG: perform_search - Empty query detected. Skipping full update_grid_layout().")
            self.data = final_list[:] # Still update self.data
            self.grouped_data = self.format_grouped_data(self.data) # Still update grouped_data
            item_count = len(final_list)
            self.filter_button.config(text=f"{current_filter} [{item_count}]")
            self._update_filters_label_status()
            self.update_search_results_window_ui() # Update search results window if open
            print("--- ConfigViewerApp.perform_search() EXIT - Skipped Layout Update ---\n")
            return # Exit here, skipping full layout update
        # --- MODIFICATION END: Check for empty query and skip layout update ---


        if query:
            if not hasattr(self, 'search_results_window') or not self.search_results_window or not self.search_results_window.winfo_exists():
                self.search_results_window = self._create_search_results_window(final_list)
                print("DEBUG: perform_search - Search Results window CREATED. is_search_results_window_active set to TRUE")

            self.search_results_window.lift()
        elif hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
            self.destroy_search_results_window()
            self.search_results_window = None
            self.is_search_results_window_active = False

        if self.search_mode == "Configs":
            categories_to_remove = []
            for category, items in self.grouped_data.items():
                if not items:
                    categories_to_remove.append(category)
            for category in categories_to_remove:
                del self.grouped_data[category]

        print(f"DEBUG: perform_search - final_list (count): {len(final_list)}") # <-- ADD THIS LINE

        self._update_search_results_ui(final_list, current_filter)
        self.update_search_results_window_ui()
        self.master.after(50, self.inherit_category_visibility_search_results)
        self.lift_search_results_window()

        print("--- ConfigViewerApp.perform_search() EXIT ---\n")

        
 


       



    ##############################################################
    #               search window start  - search results window #
    ##############################################################


    def _create_search_results_window(self, final_list=None):
        """Creates and configures the Search Results window with smooth scrolling and dynamic resizing.
        MODIFIED to include CUSTOM SCROLLBAR for search results window.
        """

        self.canvas.yview_moveto(0) # Reset main grid scroll to top

        search_results_window = tk.Toplevel(self.master)
        search_results_window.overrideredirect(True)  # Remove window decorations
        search_results_window.tk.call('tk', 'scaling', 1.25)
        search_results_window.title("Search Results")
        #search_results_window.transient(self.master)
        self.is_search_results_window_active = True
        
        disabled_button_style_args = self.button_style_args.copy()
        disabled_button_style_args["fg"] = "grey"
        disabled_button_style_args["activebackground"] = "#555555"
        disabled_button_style_args["activeforeground"] = "grey"

        if hasattr(self, 'categorize_button'):
            self.categorize_button.config(state=tk.DISABLED, **disabled_button_style_args)
        if hasattr(self, 'category_list_button'):
            self.category_list_button.config(state=tk.DISABLED, **disabled_button_style_args)
        

        # Main Canvas for Search Results Window
        self.search_results_canvas = tk.Canvas(search_results_window, bg="#444444", highlightthickness=0, yscrollincrement=10)
        self.search_results_canvas.configure(yscrollcommand=self.custom_search_results_scrollbar_set) # Use CUSTOM SCROLLBAR SET

        # Custom Scrollbar Canvas for Search Results Window
        self.custom_scrollbar_canvas_search_results = tk.Canvas(search_results_window, bg="#555555", highlightthickness=0, width=15) # Grey track
        self.scrollbar_thumb_search_results = self.custom_scrollbar_canvas_search_results.create_rectangle(0, 0, 15, 20, fill=self.global_highlight_color, outline="") # Orange thumb
        self.scrollbar_thumb_dragging_search_results = False # Initialize dragging flag
        self.scrollbar_thumb_start_y_search_results = 0
        self.scrollbar_mouse_start_y_search_results = 0

        self.custom_scrollbar_canvas_search_results.bind("<ButtonPress-1>", self.custom_search_results_scrollbar_click)
        self.custom_scrollbar_canvas_search_results.bind("<B1-Motion>", self.custom_search_results_scrollbar_drag)
        self.custom_scrollbar_canvas_search_results.bind("<ButtonRelease-1>", self.custom_search_results_scrollbar_release)


        self.search_results_scrollable_frame = tk.Frame(self.search_results_canvas, bg="#444444")


        self.search_results_scrollable_frame.bind(
            "<Configure>",
            lambda e: self.search_results_canvas.configure(scrollregion=self.search_results_canvas.bbox("all"))
        )
        self.search_results_canvas.create_window((0, 0), window=self.search_results_scrollable_frame, anchor="nw")
        self.search_results_canvas.configure(yscrollcommand=self.custom_search_results_scrollbar_set) # Configure canvas to use CUSTOM scrollbar


        self.search_results_canvas.pack(side="left", fill="both", expand=True) # Canvas takes up most space on the LEFT
        self.custom_scrollbar_canvas_search_results.pack(side="right", fill="y") # Custom scrollbar on the RIGHT edge


        # --- NEW: Bind Mousewheel to the search results canvas for smooth scrolling ---
        self.search_results_canvas.bind("<Enter>", lambda e: self.search_results_canvas.bind_all("<MouseWheel>", self.on_mousewheel_search_results))
        self.search_results_canvas.bind("<Leave>", lambda e: self.search_results_canvas.unbind_all("<MouseWheel>"))
        # --- NEW: Bind Mousewheel to the search results canvas for smooth scrolling ---

        # --- Bind main window's <Configure> event to update search results window position and size ---
        #self.master.bind("<Configure>", self.update_window_geometries)
        # --- Bind main window's <Configure> event to update search results window position and size ---


        # --- MODIFIED: Populate with final_list (or last search results) ---
        data_to_populate = final_list # Use final_list if provided
        if data_to_populate is None:
            data_to_populate = self.search_results_data # Fallback to last search results if final_list is None
            print("DEBUG: _create_search_results_window - Using self.search_results_data for population (final_list was None).") # Debug
        else:
            print("DEBUG: _create_search_results_window - Using provided final_list for population.") # Debug


        if hasattr(self, 'search_results_scrollable_frame') and self.search_results_scrollable_frame:
            for widget in self.search_results_scrollable_frame.winfo_children():
                widget.destroy()
            self.populate_search_results_window(self.search_results_scrollable_frame, final_list)

        self.update_window_geometries() # Call it once initially to set correct position and size

        search_results_window.bind("<Button-1>", self.debounced_on_search_results_window_click)

        self.master.after(50, self.inherit_category_visibility_search_results)

  

        return search_results_window # Return the newly created window



    def debounced_on_search_results_window_click(self, event=None):
        """
        Debounced version of on_search_results_window_click, ensuring the first click is always registered.
        """
        delay_ms = 400  # Adjust this delay (in milliseconds) as needed

        if not self.is_debouncing:
            # First click, execute immediately and start debouncing
            self.is_debouncing = True
            self.on_search_results_window_click(event)

        if self.debounce_timer:
            self.master.after_cancel(self.debounce_timer)  # Cancel the existing timer

        self.debounce_timer = self.master.after(delay_ms, self._reset_debounce_flag) # Reset flag after delay

    def _reset_debounce_flag(self):
        """
        Resets the debouncing flag after the delay period.
        """
        self.is_debouncing = False
        self.debounce_timer = None  # Clear the timer


        
    def on_search_results_window_click(self, event):
        """
        Handles click events on the search results window itself.
        """
        print("\n--- WINDOW CLICKED ---")
        self.search_results_window.lift()
        self.master.lift()
        self.search_results_window.lift()

        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            print("DEBUG: lift_search_results_window - Filters window exists and Details window is CLOSED - lifting Filters window.")
            self.filters_window.lift()
            
        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.spawn_queue_window.lift()

        if hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists() and not self.is_details_window_open(): # Added check for details window being closed
            self.hidden_window.lift()


        if self.is_filter_dropdown_open():
            self.destroy_filter_dropdown()
        if self.is_categorize_dropdown_open():
            self.destroy_categorize_dropdown()
        if hasattr(self, 'search_mode_options_dropdown_window') and self.search_mode_options_dropdown_window and self.search_mode_options_dropdown_window.winfo_exists():
            self.destroy_search_mode_options_dropdown_menu()
        if hasattr(self, 'settings_dropdown_window') and self.settings_dropdown_window and self.settings_dropdown_window.winfo_exists():
            self.destroy_settings_dropdown()
        if self.is_category_list_dropdown_open():
            self.destroy_category_list_dropdown()

        self.close_all_vehicle_dropdowns()
        
        filter_names = ["brand", "name", "country", "author", "bodystyle", "type"]
        for fname in filter_names:
            if self.is_sidebar_filter_dropdown_open(fname):
                self.destroy_sidebar_filter_dropdown(fname)
        # --- END: Dropdown menu destruction logic from on_main_window_click ---


        
        
    def destroy_search_results_window(self):
        if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
            self.search_results_window.destroy()
            self.search_results_window = None
            self.is_search_results_window_active = False

            # Enable categorize by and category list buttons when search results window is closed
            button_style_args = self.button_style_args.copy() # Get base style back
            if hasattr(self, 'categorize_button'):
                self.categorize_button.config(state=tk.NORMAL, **button_style_args)
            if hasattr(self, 'category_list_button'):
                self.category_list_button.config(state=tk.NORMAL, **button_style_args)


    def inherit_category_visibility_search_results(self):
        """
        Inherits category visibility from the main window to the search results window.
        Called with a delay after the search results window is created.
        MODIFIED to update category header text to indicate "(Hidden)" status. <----- ADDED
        """
        print("\n--- inherit_category_visibility_search_results() ENTRY ---") # Debug Entry
        print("DEBUG: inherit_category_visibility_search_results - Inheriting category visibility from main window to search results.") # Debug Message

        if not hasattr(self, 'search_results_header_frames'):
            print("  Warning: search_results_header_frames not initialized yet. Skipping category visibility inheritance.") # Warning
            return

        for category in self.search_results_header_frames:
            if category in self.category_hidden_states:
                header_frame = self.search_results_header_frames[category] # Get header frame
                header_label = None
                for widget in header_frame.winfo_children(): # Find header label within frame
                    if isinstance(widget, tk.Label):
                        header_label = widget
                        break

                if self.category_hidden_states[category]:
                    print(f"  DEBUG: Category '{category}' is hidden in main window. Hiding in search results and updating header text.") # Debug - Hiding Category
                    if category not in self.search_results_category_hidden_states or not self.search_results_category_hidden_states[category]: # Prevent redundant toggling
                        self.toggle_category_visibility_search_results(category, self.search_results_scrollable_frame)
                    if header_label: # Update header label text to indicate hidden
                        current_text = header_label.cget("text")
                        if "(Hidden)" not in current_text: # Avoid adding "(Hidden)" multiple times
                            header_text_with_hidden = f"{category} (Hidden)"
                            # --- MODIFIED: Retain count in header text if present ---
                            match = re.search(r'^(.*?) \((Hidden|Shown)\) \((\d+)\)$', current_text) # Regex to find existing count
                            if match:
                                base_text, _, count = match.groups()
                                header_text_with_hidden = f"{base_text} (Hidden) ({count})" # Reconstruct with count
                            else:
                                match_no_state = re.search(r'^(.*?)\s*\((\d+)\)$', current_text) # Regex to find count without state
                                if match_no_state:
                                    base_text_no_state, count = match_no_state.groups()
                                    header_text_with_hidden = f"{base_text_no_state} (Hidden) ({count})" # Reconstruct with count
                                else:
                                    header_text_with_hidden = f"{category} (Hidden) (0)" # Fallback with default count 0
                            # --- MODIFIED: Retain count in header text if present ---
                            header_label.config(text=header_text_with_hidden)
                            print(f"    DEBUG: Header label text updated to: '{header_text_with_hidden}'") # Debug - Header Text Update
                else:
                    print(f"  DEBUG: Category '{category}' is shown in main window. Showing in search results and updating header text.") # Debug - Showing Category
                    if category in self.search_results_category_hidden_states and self.search_results_category_hidden_states[category]: # Prevent redundant toggling
                         self.toggle_category_visibility_search_results(category, self.search_results_scrollable_frame)
                    if header_label: # Update header label text to remove "Hidden" indicator
                        current_text = header_label.cget("text")
                        header_text_shown = f"{category}"
                         # --- MODIFIED: Retain count in header text when showing ---
                        match = re.search(r'^(.*?) \((Hidden|Shown)\) \((\d+)\)$', current_text) # Regex to find existing count
                        if match:
                            base_text, _, count = match.groups()
                            header_text_shown = f"{base_text} ({count})" # Reconstruct with count

                        else:
                             match_hidden_no_count = re.search(r'^(.*?) \(Hidden\)$', current_text) # Regex to find if only "Hidden" is present
                             if match_hidden_no_count:
                                 base_text_hidden_no_count = match_hidden_no_count.groups()[0]
                                 header_text_shown = f"{base_text_hidden_no_count} (0)" # Reconstruct with default count 0

                        # --- MODIFIED: Retain count in header text when showing ---
                        header_label.config(text=header_text_shown)
                        print(f"    DEBUG: Header label text updated to: '{header_text_shown}'") # Debug - Header Text Update
            else:
                print(f"  DEBUG: Category '{category}' not found in main window's hidden states. Defaulting to shown.") # Debug - Category Not Found

        print("--- inherit_category_visibility_search_results() EXIT ---\n") # Debug Exit
  



        
 
    def update_search_results_window_geometry(self, event=None):
        """Updates the size and position of the search results window based on the main window."""
        if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
            # Get master window position and dimensions
            master_x = self.master.winfo_rootx()
            master_y = self.master.winfo_rooty()
            master_width = self.master.winfo_width()
            master_height = self.master.winfo_height()

            # Calculate new window position and size
            new_window_width = master_width - 310 # Same calculation as before
            new_window_height = master_height - 100 # Same calculation as before
            new_window_x = master_x
            new_window_y = master_y + 50

            # Apply new geometry
            self.search_results_window.geometry(f"{new_window_width}x{new_window_height}+{new_window_x}+{new_window_y}")

        
    def periodically_update_search_results_window_position(self):
        """
        Checks every 2 seconds if the search results window is open and repositions it if it is.
        """
        if hasattr(self, 'search_results_window') and self.search_results_window and self.search_results_window.winfo_exists():
            self.update_window_geometries() # <--- ADD THIS LINE TO UPDATE GEOMETRY PERIODICALLY

            #print("DEBUG: periodically_update_search_results_window_position - Search Results window was open, position adjusted.") # Optional debug print
        # else: # Optional else block for debugging when window is NOT open
        #     print("DEBUG: periodically_update_search_results_window_position - Search Results window is NOT open.")

        # Schedule the function to run again after 2000 milliseconds (2 seconds)
        self.master.after(2000, self.periodically_update_search_results_window_position)
        
        
 
 

    def update_search_results_window_ui(self):
        """
        Updates the UI of the search results window, repopulating it with the current self.data.
        This function is called whenever self.data changes and the search results window is active.
        MODIFIED: Added check for window and scrollable frame existence at start.
        """
        # --- MODIFICATION START: Check if window and scrollable_frame exist ---
        if not hasattr(self, 'search_results_window') or not getattr(self, 'search_results_window', None) or not self.search_results_window.winfo_exists(): # <-- Corrected check
            print("DEBUG: update_search_results_window_ui - Search Results window does not exist, skipping UI update.")
            return  # Exit early if window doesn't exist

        if not hasattr(self, 'search_results_scrollable_frame') or not self.search_results_scrollable_frame:
            print("DEBUG: update_search_results_window_ui - search_results_scrollable_frame does not exist, skipping UI update.")
            return  # Exit early if scrollable_frame doesn't exist
        # --- MODIFICATION END: Check if window and scrollable_frame exist ---


        if self.is_search_results_window_active:
            print("DEBUG: update_search_results_window_ui - Search Results window is active, updating UI.")
            # Clear existing content before repopulating
            for widget in self.search_results_scrollable_frame.winfo_children():
                widget.destroy()
            self.populate_search_results_window(self.search_results_scrollable_frame, self.data)
            self.search_results_window.lift()  # Bring to front after update
        else:
            print("DEBUG: update_search_results_window_ui - Search Results window is not active, skipping UI update.")
            

    def load_image_item_search_results(self, item, category_subframe, category):
        """Loads and displays an image item in the search results window, similar to main grid."""
        # Extract item details (same as in main grid)
        if isinstance(item, dict) and 'configs' in item:
            config = item['configs'][0]  # Adjust if necessary
            picture_path, spawn_cmd, zip_file, info_data, folder_name = config
        else:
            picture_path, spawn_cmd, zip_file, info_data, folder_name = item

        # Retrieve current image count for the category in search results window
        count = self.image_counts_search_results.get(category, 0)
        row = count // self.columns_search_results[0]
        col = count % self.columns_search_results[0]

        item_frame = tk.Frame(category_subframe, bg="#444444")
        item_frame.grid(row=row, column=col, padx=self.column_padding_search_results, pady=5, sticky="n")

        # Increment the image count for the category in search results window
        self.image_counts_search_results[category] += 1

        # Load and display the image (reusing main grid's image loading function)
        self.executor.submit(
            self.load_and_display_image_search_results, # Use a new function for search results images
            picture_path,
            item_frame,
            zip_file,
            spawn_cmd,
            info_data,
            folder_name
        )

    def load_and_display_image_search_results(self, picture_path, parent_frame, zip_file, spawn_cmd, info_data, folder_name):
        """Loads and displays image in search results window, reusing main grid's function for image loading."""
        try:
            # Reuse the existing image loading function from the main grid
            # This assumes load_and_display_image is generic enough to be reused
            self.load_and_display_image(picture_path, parent_frame, zip_file, spawn_cmd, info_data, folder_name)
        except Exception as e:
            print(f"Error loading image for search results window: {e}")

    def populate_search_results_window(self, scrollable_frame, data_list):
        """Populates the given scrollable frame with search results data, ensuring correct label-pictures order and toggling."""

        print("\n--- populate_search_results_window() DEBUG ENTRY ---") # Debug Entry
        print(f"DEBUG: populate_search_results_window - data_list received (count): {len(data_list)}")

        grouped_data = self.format_grouped_data(data_list)
        self.columns_search_results = self.columns
        self.column_padding_search_results = self.column_padding
        self.image_counts_search_results = {}
        self.search_results_category_hidden_states = {}
        self.search_results_header_frames = {}
        self.search_results_subframes = {} # NEW: Store subframes for toggling

        last_packed_widget = None

        for category in grouped_data:
            category_items = grouped_data[category]
            if not category_items:
                continue

            # --- Create Collapsible Category Header ---
            header_frame = tk.Frame(scrollable_frame, bg="#444444", cursor="hand2")
            if last_packed_widget:
                header_frame.pack(fill=tk.X, pady=(5, 0), after=last_packed_widget)
            else:
                header_frame.pack(fill=tk.X, pady=(5, 0))
            last_packed_widget = header_frame
            self.search_results_header_frames[category] = header_frame

            self.search_results_category_hidden_states[category] = False

            item_count = len(category_items)
            header_text_with_count = f"{category} ({item_count})"

            header_label = tk.Label(header_frame, text=header_text_with_count, font=("Segoe UI", 14, "bold"), bg="#444444", fg="lightgrey", anchor="w", cursor="hand2") # Added cursor="hand2" for visual feedback
            header_label.pack(side=tk.LEFT, padx=10, pady=(10, 0))

            separator = tk.Frame(header_frame, height=4, bd=1, relief="sunken", bg="lightgrey", cursor="hand2") # Added cursor="hand2" for visual feedback
            separator.pack(side=tk.BOTTOM, fill="x", padx=10, pady=(0, 10))

            # Create subframe for images - pack AFTER header, store reference
            category_subframe_search_results = tk.Frame(scrollable_frame, bg="#444444")
            category_subframe_search_results.pack(fill="x", after=header_frame)
            setattr(header_frame, 'category_subframe', category_subframe_search_results)
            self.search_results_subframes[category] = category_subframe_search_results # Store subframe for toggling
            last_packed_widget = category_subframe_search_results # Update last_packed_widget to subframe


            def toggle_func(event, cat=category): # Define a local function to avoid lambda in loop issues
                self.toggle_category_visibility_search_results(cat, scrollable_frame)

            header_frame.bind("<Enter>", lambda event, cat=category, header=header_label, sep=separator, count=item_count: self.on_category_hover_enter_search_results(event, cat, header, sep, count))
            header_frame.bind("<Leave>", lambda event, cat=category, header=header_label, sep=separator, count=item_count: self.on_category_hover_leave_search_results(event, cat, header, sep, count))
            header_frame.bind("<Button-1>", toggle_func) # Use the local function
            separator.bind("<Button-1>", toggle_func) # Separator also triggers toggle

            header_label.bind("<Button-1>", toggle_func) # Bind the label as well!


            self.search_results_category_hidden_states[category] = False

            # Initialize image count and load items - pass correct subframe
            self.image_counts_search_results[category] = 0
            for item in category_items:
                if isinstance(item, dict) and 'configs' in item:
                    for config in item['configs']:
                        self.load_image_item_search_results(config, category_subframe_search_results, category)
                elif len(item) == 5:
                    self.load_image_item_search_results(item, category_subframe_search_results, category)

        scrollable_frame.update_idletasks()
        scrollable_frame.master.config(scrollregion=scrollable_frame.master.bbox("all"))
        
    def toggle_category_visibility_search_results(self, category, scrollable_frame): # Removed subframe, header_frame args
        """Toggles category visibility, now retrieving subframe and header directly."""
        current_state = self.search_results_category_hidden_states[category]
        new_state = not current_state
        self.search_results_category_hidden_states[category] = new_state
        category_subframe = self.search_results_subframes[category] # Get subframe from stored dict
        header_frame = self.search_results_header_frames[category] # Get header frame from stored dict # <-- ADDED

        if new_state:
            category_subframe.pack_forget() # Hide subframe
            print(f"  DEBUG: toggle_category_visibility_search_results - Hiding category subframe: {category}")
        else:
            # --- MODIFIED: Pack subframe AFTER its header frame to maintain order ---
            category_subframe.pack(fill="x", after=header_frame) # Pack AFTER header_frame, retrieved from stored dict
            print(f"  DEBUG: toggle_category_visibility_search_results - Showing category subframe: {category}, Packing AFTER header_frame.")
            # --- MODIFIED: Pack subframe AFTER its header frame to maintain order ---

    def on_category_hover_enter_search_results(self, event, category, header_label, separator, count):
        """Handles mouse hover enter event for category headers in Search Results window."""
        separator.config(bg=self.global_highlight_color)
        header_label.config(fg=self.global_highlight_color)
        if self.search_results_category_hidden_states.get(category, False):
            header_label.config(text=f"{category} (Show) ({count})")
        else:
            header_label.config(text=f"{category} (Hide) ({count})")

    def on_category_hover_leave_search_results(self, event, category, header_label, separator, count):
        """Handles mouse hover leave event for category headers in Search Results window."""
        separator.config(bg="lightgrey")
        header_label.config(fg="lightgrey")
        if self.search_results_category_hidden_states.get(category, False):
            header_label.config(text=f"{category} (Hidden) ({count})")
        else:
            header_text = category
            if self.search_results_category_hidden_states.get(category, False):
                header_text += " (Hidden)"
            header_label.config(text=f"{header_text} ({count})")
      


    def is_details_window_open(self):
        """
        Checks if a details window is currently open.

        Returns:
            bool: True if a details window is open, False otherwise.
        """
        return hasattr(self, 'details_window') and self.details_window and not self.details_window_closed


    #############################################################

    #hold on to that, put it at the top of update grid layout to prevent the main grid from updating while the search results window is active

    #        if self.is_search_results_window_active: # MODIFIED Condition - Now checks only for window active
    #            print("DEBUG: update_grid_layout - Search Results window is active. SKIPPING main grid layout update.")
    #            return # Exit function early if search results window is active
    #############################################################




    #######################################################
    #               search window end                     #
    #######################################################

        
    def is_placeholder(self, picture_path):
        missing_custom_pic_path = os.path.join(self.script_dir, "data/MissingCustomConfigPic.png")
        missing_zip_pic_path = os.path.join(self.script_dir, "data/MissingZipConfigPic.png")
        return picture_path in [missing_custom_pic_path, missing_zip_pic_path]

    # ------------------------------------------------------------
    # Populate Initial Grid
    # ------------------------------------------------------------
    def populate_initial_grid(self):
        self.load_floating_window_position()
        self.perform_search()
        self.update_grid_layout()
        self.all_main_grid_images_cached = self.are_all_main_grid_images_cached()
        print(f"populate_initial_grid - all_main_grid_images_cached set to: {self.all_main_grid_images_cached}")

    def are_all_main_grid_images_cached(self):
        """
        Checks if all images intended for the main grid in the current dataset are already in the image cache.
        """
        # print("Checking are_all_main_grid_images_cached...")
        all_picture_paths = set()
        for category_name, category_items in self.grouped_data.items():
            # print(f"  Category: {category_name}")
            for item in category_items:
                picture_path = None
                if isinstance(item, dict) and 'configs' in item:
                    for config in item['configs']:
                        picture_path = config[0]
                elif len(item) == 5:
                    picture_path = item[0]

                if picture_path:
                    all_picture_paths.add(picture_path)

        print(f"  Total picture paths to check: {len(all_picture_paths)}")

        for picture_path in all_picture_paths:
            # --- Normalize picture_path BEFORE checking cache ---
            normalized_picture_path = os.path.normpath(os.path.abspath(picture_path)) # Normalize Path - ADDED NORMALIZATION HERE!

            is_cached = normalized_picture_path in self.image_cache # Check CACHE using NORMALIZED PATH
            is_placeholder_img = self.is_placeholder(picture_path)
            # print(f"  Checking: {os.path.basename(picture_path)}, Normalized Path: {normalized_picture_path}, Cached: {is_cached}, Placeholder: {is_placeholder_img}")
            if not is_cached and not is_placeholder_img:
                # print("    NOT all images cached - returning False")
                return False
        print("  All images cached (or placeholder) - returning True")
        return True

        
    #@profile
    def load_next_batch(self):
        if self.pause_loading:
            # If loading is paused, try again after 100ms
            self.master.after(100, self.load_next_batch)
            # print("Load Next Batch - PAUSED (Main Grid - Paused Flag Active)") # Debug Print - MODIFIED message
            return  # EXIT if loading is paused

        if self.current_category_index >= len(self.category_batches):
            # All categories loaded
            self.canvas.config(scrollregion=self.canvas.bbox("all"))
            # Stop loading animation
            self.stop_loading_animation()
            self.hide_progress_bar_main() # ADDED back to hide progress bar when all done
            # --- NEW: Call cache check AFTER loading completes ---
            self.check_all_main_grid_images_cached()  # CALL CACHE CHECK HERE!
            return

        category, batches, category_subframe = self.category_batches[self.current_category_index]

        # --- NEW: Check if category is hidden (collapsed) ---
        if self.category_hidden_states.get(category, False):
            print(f"DEBUG: load_next_batch - Category '{category}' is collapsed. Skipping image loading.")
            self.current_category_index += 1  # Move to the next category
            self.current_batch_index = 0      # Reset batch index for the next category
            self.current_main_batch_index_in_sequence = 0 # Reset sequence index for new category
            self.master.after(0, self.load_next_batch) # Schedule next category batch
            return  # Skip loading for this category

        if self.current_batch_index >= len(batches):
            # Finished batches in current category, move to next category
            self.current_category_index += 1
            self.current_batch_index = 0
            self.current_main_batch_index_in_sequence = 0 # Reset sequence index for new category
            self.master.after(0, self.load_next_batch)  # Schedule next category batch
            return

        batch = batches[self.current_batch_index]
        self.current_batch_index += 1

        # --- NEW: Dynamic Batch Size Logic + Cached Images Batching ---
        if self.all_main_grid_images_cached:
            batch_size_to_load = 100 # Load in larger batches if all cached
            # print("  Using batch_size_to_load = 50 (all_main_grid_images_cached is True)") # ADDED
        elif self.current_main_batch_index_in_sequence < len(self.main_grid_batch_sizes):
            batch_size_to_load = self.main_grid_batch_sizes[self.current_main_batch_index_in_sequence]
            # print(f"  Using batch_size_to_load = {batch_size_to_load} (dynamic batch size sequence)") # ADDED
        else:
            batch_size_to_load = self.default_batch_size # Use default after sequence
            # print(f"  Using batch_size_to_load = {batch_size_to_load} (default batch size)") # ADDED

        items_to_load_this_time = batch[:batch_size_to_load] # Load only up to batch_size_to_load items
        batch = batch[batch_size_to_load:] # Update batch to remove loaded items - for next iteration
        batches[self.current_batch_index - 1] = batch # Update the batches list in category_batches

        if not items_to_load_this_time: # If no more items to load in this batch (batch is now empty)
            self.current_main_batch_index_in_sequence += 1 # Move to next batch size in sequence
            self.master.after(100, self.load_next_batch) # Schedule next batch load immediately
            return

        total_items_in_grid = sum(len(b) for _, batches, _ in self.category_batches for b in batches)
        items_loaded_so_far = 0

        # Recalculate items_loaded_so_far more accurately
        for cat_index in range(self.current_category_index): # Loop through previous categories
            cat_batches = self.category_batches[cat_index][1] # Get batches for category
            for bat in cat_batches:
                if isinstance(bat, list):
                    items_loaded_so_far += len(bat)
        # Add items from already loaded batches in the current category
        current_cat_batches = self.category_batches[self.current_category_index][1] # Get batches for current category
        for batch_index in range(self.current_batch_index - 1): # Loop through previous batches in current category
            bat = current_cat_batches[batch_index]
            if isinstance(bat, list):
                items_loaded_so_far += len(bat)
        # Add items to be loaded in this batch
        items_loaded_so_far += len(items_to_load_this_time)

        self.update_progress_bar_main(items_loaded_so_far, total_items_in_grid)

        for item in items_to_load_this_time: # Iterate over items to load in THIS batch iteration
            if item is None:
                continue
            if isinstance(item, dict) and 'configs' in item:
                for config in item['configs']:
                    self.load_image_item(config, category_subframe, category)
            else:
                if len(item) == 5:
                    picture_path, spawn_cmd, zip_file, info_data, folder_name = item
                    self.load_image_item(item, category_subframe, category)
                else:
                    continue

        self.current_main_batch_index_in_sequence += 1 # Move to next batch size in sequence

        # Schedule the next batch after a short delay (e.g., 150 milliseconds)
        if self.all_main_grid_images_cached:
            self.master.after(0, self.load_next_batch) # Load next batch immediately if all cached
            # print("load_next_batch EXIT (Scheduled next batch - all cached - after 0ms)") # ADDED
        else:
            self.master.after(150, self.load_next_batch) # Schedule the next batch after a short delay (e.g., 150 milliseconds)
            # print("load_next_batch EXIT (Scheduled next batch - not all cached - after 150ms)") # ADDED
    
    
        #if self.scanning_window:
        #    self.scanning_window.destroy()
        #
        #self.scanning_window = None







    def create_progress_bar_main(self, parent_frame):
        self.progress_bar_bg_main = tk.Frame(parent_frame, height=15, width=200, bg="white", bd=1, relief=tk.SOLID)
        self.progress_bar_fill_main = tk.Frame(self.progress_bar_bg_main, height=13, width=0, bg=self.global_highlight_color)
        self.progress_bar_fill_main.place(x=1, y=1)
        self.progress_bar_bg_main.pack(side="right", padx=10, fill=tk.X, expand=False)
        self.progress_bar_bg_main.pack_forget() # Initially hidden


    def update_progress_bar_main(self, loaded_count, total_count):
        if total_count > 0:
            progress_percent = (loaded_count / total_count) * 100
            fill_width = (200 * progress_percent) / 100
            self.progress_bar_fill_main.config(width=fill_width)
            if not self.progress_bar_bg_main.winfo_ismapped():
                self.progress_bar_bg_main.pack(side="right", padx=10, fill=tk.X, expand=False)
        else:
            self.progress_bar_fill_main.config(width=0)

    def update_progress_bar_details(self, loaded_count, total_count):
        if total_count > 0:
            progress_percent = (loaded_count / total_count) * 100
            fill_width = (200 * progress_percent) / 100
            self.progress_bar_fill_details.config(width=fill_width)
            if not self.progress_bar_bg_details.winfo_ismapped():
                self.progress_bar_bg_details.pack(side="right", padx=10, fill=tk.X, expand=False)
        else:
            self.progress_bar_fill_details.config(width=0)

    def hide_progress_bar_main(self):
        self.progress_bar_bg_main.pack_forget()
        
        if self.scanning_window:
            self.scanning_window.destroy()

        self.scanning_window = None

        if self.scanning_win:
            self.scanning_win.destroy()

 
        self.scanning_win = None



    def hide_progress_bar_details(self):
        self.progress_bar_bg_details.pack_forget()



    def create_progress_bar_details(self, parent_frame):
        self.progress_bar_bg_details = tk.Frame(parent_frame, height=15, width=200, bg="white", bd=1, relief=tk.SOLID)
        self.progress_bar_fill_details = tk.Frame(self.progress_bar_bg_details, height=13, width=0, bg=self.global_highlight_color)
        self.progress_bar_fill_details.place(x=1, y=1)
        self.progress_bar_bg_details.pack(side="right", padx=10, fill=tk.X, expand=False)
        self.progress_bar_bg_details.pack_forget() # Initially hidden


    def update_progress_bar_details(self, loaded_count, total_count):
        if total_count > 0:
            progress_percent = (loaded_count / total_count) * 100
            fill_width = (200 * progress_percent) / 100
            self.progress_bar_fill_details.config(width=fill_width)
            if not self.progress_bar_bg_details.winfo_ismapped():
                self.progress_bar_bg_details.pack(side="right", padx=10, fill=tk.X, expand=False)
        else:
            self.progress_bar_fill_details.config(width=0)


    def hide_progress_bar_details(self):
        self.progress_bar_bg_details.pack_forget()
  

    def show_progress_bar_details(self):
        self.progress_bar_bg_details.pack(side="right", padx=10, fill=tk.X, expand=False)
      





    def check_all_main_grid_images_cached(self):
        """
        Calls are_all_main_grid_images_cached and sets the flag.
        Called AFTER initial batch loading is complete.
        """
        is_cached = self.are_all_main_grid_images_cached()
        self.all_main_grid_images_cached = is_cached
        # print(f"check_all_main_grid_images_cached - all_main_grid_images_cached set to: {self.all_main_grid_images_cached}") # Debug print

    def start_details_loading_animation(self):
        """
        Starts a flashing 'Loading...' animation for the details window
        using self.details_loading_label.
        """
        
        return #using the progress bar for details as well, no need for this anymore
        
        
        if not self.details_loading_animation_running:
            self.details_loading_animation_running = True
            self.details_loading_label.config(text="Loading...", fg="blue")
            self.animate_details_loading()

    def stop_details_loading_animation(self):
        """
        Stops the flashing 'Loading...' animation for the details window
        and hides the label.  **NOW ALSO CALLS _update_details_header_label WITH DELAY.**
        """
        self.details_loading_animation_running = False
        self.details_loading_label.config(text="")
        self.details_loading_label.pack_forget()  # Hides the label completely

        self.details_window.after(200, self._update_details_header_label) # <--- DELAYED CALL to update header label

        # Re-pack it if you want it available again in the future:
        # self.details_loading_label.pack(side="right", padx=(10, 10))


    def _update_details_header_label(self):
        """Updates the header label in the details window with widget count and counts,
        now differentiating between filtered and unfiltered totals.

        MODIFIED: Implemented a workaround to divide widget_count by 2 if it's greater
        than total_count_filtered, as a TEMPORARY VISUAL FIX for doubled count issue.
        THIS IS NOT A PROPER FIX - the root cause (duplicate widget creation) still needs to be addressed.
        """
        widget_count = ConfigViewerApp.details_widget_count
        total_count_unfiltered = len(self.details_data) # Total unfiltered count
        total_count_filtered = len(self.details_filtered_data) # Total filtered count
        brand = "-" # Default values
        name = "-"

        if self.details_data and self.details_data[0] and self.details_data[0][3]: # Safely access info_data
            info_data = self.details_data[0][3]
            brand = info_data.get("Brand", "-")
            name = info_data.get("Name", "-")

        # --- DEBUG PRINTS (Keep for debugging) ---
        print("\n--- _update_details_header_label() DEBUG ---")
        print(f"  DEBUG: widget_count (BEFORE potential division): {widget_count}") # Before potential division
        print(f"  DEBUG: total_count_filtered: {total_count_filtered}")
        print(f"  DEBUG: total_count_unfiltered: {total_count_unfiltered}")
        # --- DEBUG PRINTS END ---

        # --- WORKAROUND: Divide widget_count by 2 if it's too high ---
        if widget_count > total_count_filtered: # Check if widget_count is greater than total_count_filtered
            widget_count = widget_count // 2 # Integer division to halve widget_count
            print(f"  DEBUG: WORKAROUND APPLIED - widget_count DIVIDED by 2, new widget_count: {widget_count}") # Debug - Workaround Applied


        if total_count_filtered == total_count_unfiltered:
            header_text = f"Showing {widget_count} out of {total_count_filtered} configs for {brand or '-'} {name or '-'}"
        else:
            header_text = f"Showing {widget_count} out of {total_count_filtered} configs filtered from search ({total_count_unfiltered} in total)"

        # --- MODIFIED: Update new label in bottom frame ---
        self.details_showing_configs_label.config(text=header_text, fg=self.global_highlight_color) # <--- SET HEADER COLOR TO ORANGE (NEW LABEL)
        # --- MODIFIED: Update new label in bottom frame ---
        self.details_page_label.config(fg=self.global_highlight_color)
        def reset_header_color():
            # --- MODIFIED: Reset color of new label ---
            self.details_showing_configs_label.config(fg="white") # <--- RESET HEADER COLOR to WHITE (NEW LABEL)
            # --- MODIFIED: Reset color of new label ---
            self.details_page_label.config(fg=self.details_page_label_original_color)

        self.details_window.after(2000, reset_header_color)

        if self.scanning_window:
            self.scanning_window.destroy()

        self.scanning_window = None
 


 
 
 
    def animate_details_loading(self):
        """
        Pulsates the 'Loading...' text in details window by cycling colors.
        Similar to the main grid's loading animation approach.
        """
        if not self.details_loading_animation_running or not self.details_window:
            return

        import itertools
        colors = ["blue", "black"]
        cycle = itertools.cycle(colors)

        def change_color():
            if not self.details_loading_animation_running or not self.details_window:
                return
            self.details_loading_label.config(fg=next(cycle))
            # Repeat every 500ms
            self.details_window.after(500, change_color)

        change_color()
    

    #@profile 
    def load_next_batch_details(self):
        if self.pause_loading:
            self.details_pause_counter += 1
            print(f"Load Next Batch Details - PAUSED (Details Window - Paused Flag Active) [FORCED UNPAUSE] - Count: {self.details_pause_counter}")

            if self.details_pause_counter > 10:
                print("DEBUG: load_next_batch_details - PAUSE COUNT EXCEEDED THRESHOLD (10). FORCING UNPAUSE.")
                self.pause_loading = False
                self.details_pause_counter = 0
                print("DEBUG: load_next_batch_details - pause_loading FORCE-SET to FALSE, counter RESET.")
            else:
                self.master.after(100, self.load_next_batch_details)
                return

        self.details_pause_counter = 0

        if self.current_details_batch_index >= len(self.details_batches):
            # All batches loaded in details window
            self.details_canvas_sub.config(scrollregion=self.details_canvas_sub.bbox("all"))
            self.stop_details_loading_animation()
            self.hide_progress_bar_details()
            # --- NEW: RESUME main grid loading AFTER 3-second delay ---
            print("DEBUG: load_next_batch_details - Details batch load complete. Resuming main grid loading in 3 seconds...")
            def resume_main_grid_loading():
                self.pause_loading = False
                self.load_next_batch()
                print("DEBUG: load_next_batch_details - Main grid loading RESUMED (after 3-second delay).")

            self.master.after(3000, resume_main_grid_loading)
            # --- NEW: RESUME main grid loading AFTER 3-second delay ---
            return

        batch = self.details_batches[self.current_details_batch_index]
        self.current_details_batch_index += 1

        if self.current_details_batch_index_in_sequence < len(self.details_grid_batch_sizes):
            batch_size_to_load = self.details_grid_batch_sizes[self.current_details_batch_index_in_sequence]
        else:
            batch_size_to_load = self.default_batch_size

        items_to_load_this_time = batch[:batch_size_to_load]
        batch = batch[batch_size_to_load:]
        self.details_batches[self.current_details_batch_index - 1] = batch

        if not items_to_load_this_time:
            self.current_details_batch_index_in_sequence += 1
            self.master.after(100, self.load_next_batch_details)
            return

        total_items_in_details_grid = sum(len(b) for b in self.details_batches)
        items_loaded_in_details_so_far = 0

        for batch_index in range(self.current_details_batch_index - 1):
            bat = self.details_batches[batch_index]
            if isinstance(bat, list):
                items_loaded_in_details_so_far += len(bat)
        items_loaded_in_details_so_far += len(items_to_load_this_time)

        self.update_progress_bar_details(items_loaded_in_details_so_far, total_items_in_details_grid)

        for idx_in_batch, item in enumerate(items_to_load_this_time):
            if item is None:
                continue

            picture_path, spawn_cmd, zip_file, info_data, folder_name = item

            container = tk.Frame(self.details_scrollable_frame, bg="#444444")
            item_index_in_full_list = (self.current_details_batch_index - 1) * self.details_batch_size + idx_in_batch
            try: # <--- ADD TRY BLOCK HERE
                row = item_index_in_full_list // self.details_columns[0] # <--- POTENTIAL ERROR LINE
                col = item_index_in_full_list % self.details_columns[0]
            except TypeError as e: # <--- CATCH TypeError HERE
                print(f"ERROR: TypeError in load_next_batch_details: {e}") # Print error for debugging
                print("  Attempting to close and reopen details window to recover...") # Indicate recovery attempt
                if hasattr(self, 'details_window') and self.details_window and self.current_details_folder:
                    self.on_details_window_close() # Close details window
                    #self.on_picture_click(self.current_details_folder) # Re-open details window for the same folder
                    #print("  Details window closed and re-opened. Batch loading aborted for this cycle.") # Confirmation message
                    print("  Application restarting due to batch loading failure. Batch loading aborted for this cycle.") # Confirmation message


                    width = self.master.winfo_width()
                    height = self.master.winfo_height()
                    x = self.master.winfo_rootx()
                    y = self.master.winfo_rooty()
                    self.save_window_geometry(width, height, x, y) # Call save_window_geometry
                    self.save_settings()


                    self.restart_script()
                return # <--- IMPORTANT: EXIT function to prevent further errors

            container.grid(row=row, column=col, padx=self.details_column_padding, pady=5, sticky="nw")

            self.load_image_item_details(item, container, row, col)

        self.current_details_batch_index_in_sequence += 1

        self.master.after(self.details_batch_delay, self.load_next_batch_details)
        #self.start_debounce_details_highlighting()
        self.details_window.lift()
        if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
            self.current_detail_window.lift()

        self.details_window.after(2000, lambda: (
            self.details_window.lift(),
            (self.current_detail_window.after(300, self.current_detail_window.lift)
            if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists() else None)
        ))

        # --- ADD THIS SECTION HERE ---
        # Update sidebar content with the LAST item loaded in the batch
        if self.no_configs_messagebox_condition: # Check the flag

            last_item = items_to_load_this_time[-1] # Get the last item from the batch
            picture_path, spawn_cmd, zip_file, info_data, folder_name = last_item # Unpack the last item data

            # Call update_details_sidebar_content with data from the last item
            self.update_details_sidebar_content(info_data, picture_path, zip_file, folder_name)
            self.no_configs_messagebox_condition = False
            print("DEBUG: load_next_batch_details - Calling update_details_sidebar_content for the LAST item in the batch.") # Debug print

        # --- END ADDED SECTION ---

        print("--- load_next_batch_details() EXIT ---\n")
        

        
        
    def load_image_item(self, item, category_subframe, category):
        # Extract item details
        if isinstance(item, dict) and 'configs' in item:
            config = item['configs'][0]  # Adjust if necessary
            picture_path, spawn_cmd, zip_file, info_data, folder_name = config
        else:
            picture_path, spawn_cmd, zip_file, info_data, folder_name = item

        # Retrieve current image count for the category
        count = self.image_counts.get(category, 0)
        row = count // self.columns[0]  # Access the first element of the tuple (number of columns)
        col = count % self.columns[0]  # Access the first element of the tuple (number of columns)

        # **CHECK IF PARENT EXISTS BEFORE CREATING CHILD**
        if not category_subframe.winfo_exists():
            print(f"Warning: Parent frame {category_subframe} no longer exists BEFORE frame creation, skipping item creation.") # DEBUG - BEFORE
            return

        # print(f"Debug: Attempting to create item_frame in {category_subframe}") # DEBUG - ATTEMPTING CREATE

        # Create the container for the image and labels
        try:
            item_frame = tk.Frame(category_subframe, bg="#444444") # Frame creation
            # print(f"Debug: item_frame created successfully: {item_frame}") # DEBUG - AFTER CREATE
        except Exception as frame_create_error:
            print(f"Error: Failed to create item_frame in {category_subframe}: {frame_create_error}") # DEBUG - CREATE ERROR
            return # Exit if frame creation failed


        item_frame.grid(row=row, column=col, padx=self.column_padding, pady=5, sticky="n") # USE DYNAMIC PADDING


        # Increment the image count for the category
        self.image_counts[category] += 1

        # Submit image loading to the executor
        self.executor.submit(
            self.load_and_display_image,
            picture_path,
            item_frame,
            zip_file,
            spawn_cmd,
            info_data,
            folder_name
        )




    def load_image_item_details(self, item, container, row, col):
        """
        Loads and displays an image item in the details window's grid layout.
        Applies dynamic padding based on the current layout configuration.
        (Modified to extract and pass folder_name, zip_file_base_name, config_name)
        (MODIFIED to use disk cache) <--- ADDED DISK CACHE COMMENT
        """

        print("\n--- load_image_item_details() DEBUG ENTRY ---") # <--- DEBUG ENTRY

        picture_path, spawn_cmd, zip_file, info_data, folder_name = item # folder_name is ALREADY unpacked here

        # Extract zip_file_base_name and config_name (as before)
        zip_file_base_name = os.path.splitext(zip_file)[0]
        config_name = self.extract_name_from_spawn_command(spawn_cmd)
        if not config_name:
            config_name = os.path.splitext(os.path.basename(picture_path))[0]

        if picture_path is None:
            picture_path = os.path.join(self.script_dir, "data/MissingCustomConfigPic.png")

        try:
            # --- Normalize picture_path ---
            normalized_picture_path = os.path.normpath(os.path.abspath(picture_path))
            cache_key = normalized_picture_path # Use normalized path as cache key

            # --- NEW: Check Disk Cache FIRST (for details images too) ---
            disk_cache_path = os.path.join(self.disk_image_cache_dir, os.path.basename(cache_key))
            if os.path.exists(disk_cache_path):
                #print(f"DEBUG: load_image_item_details - Disk Cache HIT for: {picture_path}") # Debug print - disk cache hit
                try:
                    img = Image.open(disk_cache_path).convert("RGB") # Load from disk cache
                    photo = ImageTk.PhotoImage(img)
                    pil_image = img.copy() # Create PIL copy
                    # Note: No in-memory cache update for details images in this version (as requested)
                    if container.winfo_exists():
                        self.master.after(
                            0,
                            lambda: self.create_details_item_widgets(
                                container, photo, pil_image, spawn_cmd, info_data, zip_file, picture_path, folder_name, zip_file_base_name, config_name
                            )
                        )
                    return # Exit after using disk cached image
                except Exception as e_disk_load:
                    print(f"Warning: Error loading from disk cache (details) {disk_cache_path}: {e_disk_load}. Falling back to original load.") # Fallback message

            # --- If no disk cache hit, load from original path ---
            img = Image.open(picture_path).convert("RGB")
            img = img.resize((250, 140), self.RESAMPLE_FILTER) # SUBGRID IMAGES
            pil_image = img.copy()
            photo = ImageTk.PhotoImage(pil_image)

            # --- NEW: Save to Disk Cache (for details images too) ---
            disk_cache_path = os.path.join(self.disk_image_cache_dir, os.path.basename(cache_key))
            try:
                #pil_image.save(disk_cache_path, "PNG") # Save to disk cache
                #print(f"DEBUG: Saved details image to disk cache: {disk_cache_path}") # Debug print - disk cache save
                #disabling cache
                pass
            except Exception as e_save:
                print(f"Warning: Error saving details image to disk cache {disk_cache_path}: {e_save}") # Warning message on save error
            # --- NEW: Save to Disk Cache (for details images too) ---


            # --- NEW: Check pause_loading and queue Details UI update if paused ---
            if self.pause_loading:
                print(f"Queueing Details UI update for {os.path.basename(picture_path)} - Loading PAUSED (Details)") # Debug Print
                self.details_grid_skipped_updates_queue.append((container, photo, pil_image, spawn_cmd, info_data, zip_file, picture_path, folder_name, zip_file_base_name, config_name)) # Queue update args - ADDED folder_name, zip_file_base_name, config_name
                return  # EXIT and don't schedule Details UI update NOW
            # --- END: Pause Check and Queue ---

            if container.winfo_exists():
                # Schedule GUI update in the main thread
                self.master.after(
                    0,
                    lambda: self.create_details_item_widgets(
                        container, photo, pil_image, spawn_cmd, info_data, zip_file, picture_path, folder_name, zip_file_base_name, config_name # Pass folder_name, zip_file_base_name, config_name
                    )
                )

            print("--- load_image_item_details() DEBUG EXIT ---\n") # <--- DEBUG EXIT


        except Exception as e:
            print(f"Error loading subgrid image {picture_path}: {e}")



    def generate_matches_config_txt(self, config_info_folder, script_dir):
        """
        Generates "matches_config.txt" using regex to extract Configuration values,
        skipping files that DO NOT contain "--INDIVIDUAL--" in their filename.
        """
        matches_file_path = os.path.join(self.script_dir, "data/Matches.txt")
        matches_config_file_path = os.path.join(self.script_dir, "data/matches_config.txt")


        if os.path.exists(matches_config_file_path):
            print(f"{matches_config_file_path} already exists. Skipping generation.")
            return  # Exit the function without overwriting

        try:
            with open(matches_file_path, 'r', encoding="utf-8") as matches_file, \
                 open(matches_config_file_path, 'w', encoding="utf-8") as config_output_file:

                current_filename = None
                current_content_lines = []
                reading_content = False

                for line in matches_file:
                    line = line.strip()
                    if not line:
                        continue

                    if not reading_content:
                        if line == '}': # Check if a '}' appears unexpectedly as a filename
                            continue # Skip this line and move to the next
                        current_filename = line

                        # --- NEW: Skip files without "--INDIVIDUAL--" in filename ---
                        if "--INDIVIDUAL--" not in current_filename:
                            reading_content = False # Skip reading content for this file
                            current_filename = None # Reset filename
                            continue # Go to the next line in matches_file
                        # --- NEW: Skip files without "--INDIVIDUAL--" in filename ---

                        reading_content = True
                    elif line == '}':
                        current_content_lines.append(line)
                        content = "\n".join(current_content_lines)
                        config_name = "N/A" # Default value if "Configuration" not found

                        # --- Use regex to extract Configuration value ---
                        config_match = re.search(r'"Configuration"\s*:\s*"([^"]*)"', content, re.IGNORECASE)
                        if config_match:
                            config_name = config_match.group(1).strip()
                        else:
                            config_name = "REGEX_ERROR" # Indicate regex extraction error
                        # --- Use regex to extract Configuration value ---

                        output_line = f"{current_filename}||{config_name}"
                        config_output_file.write(output_line + '\n')

                        current_filename = None
                        current_content_lines = []
                        reading_content = False
                    elif reading_content:
                        current_content_lines.append(line)

            print(f"Successfully generated {matches_config_file_path}")

        except FileNotFoundError:
            print(f"Error: {matches_file_path} not found. Cannot generate matches_config.txt.")
        except Exception as e:
            print(f"Error generating matches_config.txt: {e}")






    def load_matches_config_data(self):
        """Loads matches_config.txt into a dictionary for fast lookup."""
        matches_config_file_path = os.path.join(self.script_dir, "data/matches_config.txt")
        config_map = {}
        try:
            with open(matches_config_file_path, 'r', encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if line:
                        parts = line.split("||")
                        if len(parts) == 2:
                            filename_part = parts[0].strip()
                            config_name = parts[1].strip()
                            config_map[filename_part] = config_name
            print(f"Loaded {len(config_map)} entries from matches_config.txt") # Debug print
        except FileNotFoundError:
            print(f"Warning: {matches_config_file_path} not found.")
        except Exception as e:
            print(f"Error loading matches_config.txt: {e}")
        return config_map






    def start_loading_animation(self):
        """Starts the pulsating 'Loading...' animation."""
        if not self.loading_animation_running:
            self.loading_animation_running = True
            #self.loading_label.pack(side="left", padx=(10, 0))  # Show the label
            self.animate_loading()

    def stop_loading_animation(self):
        """Stops the pulsating 'Loading...' animation."""
        self.loading_animation_running = False
        self.loading_label.pack_forget()  # Hide the label

    def animate_loading(self):
        """Animates the 'Loading...' text with a pulsating effect."""
        if not self.loading_animation_running:
            return

        colors = ["blue", "black"]
        cycle = itertools.cycle(colors)

        def change_color():
            if not self.loading_animation_running:
                return
            self.loading_label.config(fg=next(cycle))
            self.master.after(500, change_color)

        change_color()
    # ------------------------------------------------------------
    # Extract Name from Spawn Command
    # ------------------------------------------------------------
    def extract_name_from_spawn_command(self, spawn_command):
        match = re.search(r"config\s*=\s*'vehicles/[^/]+/([^\.]+)\.pc'", spawn_command)
        if match:
            return match.group(1)
        else:
            return os.path.splitext(os.path.basename(spawn_command))[0].split('--')[-1]

    # ------------------------------------------------------------
    # Load & Display Image (Main Grid - CACHED)
    # ------------------------------------------------------------
    def load_and_display_image(self, picture_path, parent_frame, zip_file, spawn_cmd, info_data, folder_name):
        try:
            # --- Normalize picture_path ---
            normalized_picture_path = os.path.normpath(os.path.abspath(picture_path))
            cache_key = normalized_picture_path  # Use normalized path as cache key

            # --- Optimized Cache: Check Memory Cache (LRU) FIRST ---
            if cache_key in self.image_cache:
                # Memory Cache HIT
                print(f"DEBUG: load_and_display_image - Memory Cache HIT for: {picture_path}")
                photo = self.image_cache[cache_key]
                self.image_cache.move_to_end(cache_key) # Update LRU - move to end as recently used

                # --- Check pause_loading and queue UI update if paused ---
                if self.pause_loading:
                    self.main_grid_skipped_updates_queue.append((parent_frame, photo, None, zip_file, spawn_cmd, info_data, picture_path, folder_name)) # PIL Image removed from queue
                    return
                # --- END: Pause Check and Queue ---

                if parent_frame.winfo_exists():
                    self.master.after(
                        0,
                        lambda: self.create_main_item_widgets(
                            parent_frame, photo, None, zip_file, spawn_cmd, info_data, picture_path, folder_name # PIL Image removed from call
                        )
                    )
                return # Exit after using cached image

            # --- No Memory Cache Hit: Load and Create ---

            # --- NEW: Check Disk Cache (Optional - currently disabled for memory focus) ---
            # disk_cache_path = os.path.join(self.disk_image_cache_dir, os.path.basename(cache_key))
            # if os.path.exists(disk_cache_path):
            #     try:
            #         img = Image.open(disk_cache_path).convert("RGBA") # Load from disk cache
            #         pil_image = img.copy()
            #         photo = ImageTk.PhotoImage(img)
            #         self._add_to_cache(cache_key, photo) # Add to memory cache (LRU)
            #         if parent_frame.winfo_exists():
            #             self.master.after(
            #                 0,
            #                 lambda: self.create_main_item_widgets(
            #                     parent_frame, photo, pil_image, zip_file, spawn_cmd, info_data, picture_path, folder_name
            #                 )
            #             )
            #         return
            #     except Exception as e_disk_load:
            #         print(f"Warning: Error loading from disk cache {disk_cache_path}: {e_disk_load}. Falling back to original load.")

            # --- Load Image from Original Path (if no cache hit) ---
            if picture_path is None or not os.path.exists(picture_path):
                return
            img = Image.open(picture_path).convert("RGBA")
            img = img.resize((250, 140), self.RESAMPLE_FILTER)
            pil_image = img.copy() # Keep PIL image for _create_photo_image_and_update_ui

            # --- SCHEDULE PhotoImage CREATION AND DISK CACHE SAVE IN MAIN THREAD ---
            self.master.after(
                0, # Execute immediately in main thread
                lambda pil_image=pil_image, parent_frame=parent_frame, zip_file=zip_file, spawn_cmd=spawn_cmd, info_data=info_data, picture_path=picture_path, folder_name=folder_name, cache_key=cache_key: # Capture args using lambda default arguments
                    self._create_photo_image_and_update_ui(pil_image, parent_frame, zip_file, spawn_cmd, info_data, picture_path, folder_name, cache_key, save_to_disk_cache=False) # Disk cache disabled for now
            )
            # --- SCHEDULE PhotoImage CREATION AND DISK CACHE SAVE IN MAIN THREAD ---


        except Exception as e:
            print(f"Error loading image {picture_path}: {e}")
            # --- SCHEDULE PhotoImage CREATION AND DISK CACHE SAVE IN MAIN THREAD ---


        except Exception as e:
            print(f"Error loading image {picture_path}: {e}")



    def _create_photo_image_and_update_ui(self, pil_image, parent_frame, zip_file, spawn_cmd, info_data, picture_path, folder_name, cache_key, save_to_disk_cache=False): # Disk cache disabled for now
         """Helper function to create PhotoImage, update UI in main thread, and optionally save to disk cache."""
         try:
             photo = ImageTk.PhotoImage(pil_image) # PhotoImage creation in main thread

             # --- Optimized Cache: Add to Memory Cache (LRU) ---
             self._add_to_cache(cache_key, photo)
             # --- Optimized Cache: Add to Memory Cache (LRU) ---


             # --- Disk Cache Saving (Optional - disabled for memory focus) ---
             # if save_to_disk_cache:
             #     disk_cache_path = os.path.join(self.disk_image_cache_dir, os.path.basename(cache_key))
             #     try:
             #         #pil_image.save(disk_cache_path, "PNG")
             #         #print(f"DEBUG: Saved image to disk cache: {disk_cache_path}")
             #         pass # Disk cache disabled
             #     except Exception as e_save:
             #         print(f"Warning: Error saving to disk cache {disk_cache_path}: {e_save}")
             # --- Disk Cache Saving (Optional - disabled for memory focus) ---


             # --- Check pause_loading and queue UI update if paused ---
             if self.pause_loading:
                 self.main_grid_skipped_updates_queue.append((parent_frame, photo, None, zip_file, spawn_cmd, info_data, picture_path, folder_name)) # PIL Image removed from queue
                 return
             # --- END: Pause Check and Queue ---

             if parent_frame.winfo_exists():
                 # Schedule GUI update in the main thread
                 self.master.after(
                     0,
                     lambda: self.create_main_item_widgets(
                         parent_frame, photo, None, zip_file, spawn_cmd, info_data, picture_path, folder_name # PIL Image removed from call
                     )
                 )

         except Exception as e:
             print(f"Error creating PhotoImage or updating UI: {e}")
             
             

########################


    def _add_to_cache(self, cache_key, photo_image):
        """Adds a PhotoImage to the LRU cache, evicting the least recently used if full."""
        self.image_cache[cache_key] = photo_image # Add/update item
        self.image_cache.move_to_end(cache_key)   # Mark as recently used

        if len(self.image_cache) > self.image_cache_capacity:
            self.image_cache.popitem(last=False) # Remove LRU item (first item in OrderedDict)
            self.eviction_count += 1 # Increment eviction counter
            if not self.eviction_timer_running:
                self._start_eviction_timer() # Start timer if not already running


    def _start_eviction_timer(self):
        """Starts the eviction summary timer if not already running."""
        if not self.eviction_timer_running:
            self.eviction_timer_running = True
            self.master.after(self.eviction_batch_delay_ms, self._print_eviction_summary)

    def _print_eviction_summary(self):
        """Prints the eviction summary and resets the counter and timer flag."""
        if self.eviction_count > 0:
            print(f"DEBUG: _add_to_cache - Evicted {self.eviction_count} items in the last {self.eviction_batch_delay_ms/1000} seconds.")
            self.eviction_count = 0
        self.eviction_timer_running = False # Reset timer flag - allows timer to be restarted on next eviction

########################



    def create_main_item_widgets(self, parent_frame, photo, pil_image, zip_file, spawn_cmd, info_data, picture_path, folder_name):
        """
        Creates and configures the widgets for a single image item in the main grid window,
        with a visual style similar to details items and sidebar activation on hover.
        If self.omit_label evaluates to true then the labels will NOT BE CREATED to prevent cutoffs
        """
        if not parent_frame.winfo_exists():
            return

        # --- Image Label (similar to details view) ---
        lbl_img = tk.Label(parent_frame, image=photo, cursor="hand2", bg="white") # <--- DARKER GRAY bg for lbl_img, MODIFIED HERE
        lbl_img.image = photo
        lbl_img.pack(padx=0, pady=0)

        # --- NEW: Store default image background color ---
        lbl_img.default_bg_color = "white" # Store the default bg color for image label - background - border for images
        # --- NEW: Store default image background color ---


        # --- Text Label (info label) ---
        brand_for_main = info_data.get("Brand", "Unknown")
        if not brand_for_main.strip():
            brand_for_main = "Unknown"
        type_for_main = info_data.get("Type", "Unknown")
        if not type_for_main.strip():
            type_for_main = "Unknown"

        if brand_for_main == "Unknown":
            brand_for_main = type_for_main

        name_for_main = info_data.get("Name")
        if not name_for_main or not name_for_main.strip():
            name_for_main = folder_name


        if "user--" in picture_path:
            text_color = "lightblue"

        elif "user--" not in picture_path: # Only check for double basename if "user--" is NOT present
            found_double_basename = False
            for base_name in self.ZIP_BASE_NAMES:
                if picture_path.count(f"--{base_name}_{base_name}.zip") > 0: # Check for the specific pattern
                    found_double_basename = True
                    break # No need to check further once one is found
            if found_double_basename:
                text_color = "#f7efd7" # color for default zips/folder combo
            else:
                text_color = "white" # Still default to white if double basename not found


        if not self.show_folder_settings:
            combined_text = f"{brand_for_main} - {name_for_main}"

        if self.show_folder_settings:
            combined_text = f"{brand_for_main} - {name_for_main} - [{folder_name}]"

        # --- Count items in subgrid data for this folder ---
        subgrid_item_count = 0
        if folder_name in self.full_data:
            subgrid_item_count = len(self.full_data[folder_name])
        # --- Count items in subgrid data for this folder ---

        # --- Append count to label text ---
        label_text_with_count = f"{combined_text} - [{subgrid_item_count}]" # Append count in brackets


        lbl_info = tk.Label(
            parent_frame,
            text=label_text_with_count, # Use text with count
            wraplength=200, #label length, don't remove current
            justify="center",
            fg=text_color, # Use DEFAULT text color here - HIGHLIGHTING IS HANDLED SEPARATELY
            font=("Segoe UI", 10, "bold"),
            cursor="hand2",
            bg="#444444", # <--- DARKER GRAY bg for lbl_info
            height=3,
            anchor=tk.N
        )
        if not self.omit_label:
            lbl_info.pack(padx=00, pady=(2, 0))


        self.main_grid_labels.append(lbl_info) # Append lbl_info to the list
        #print(f"DEBUG: create_main_item_widgets - Added label widget to self.main_grid_labels - Label Widget ID: {id(lbl_info)}, List Size: {len(self.main_grid_labels)}") # Debug - List Add



        # --- NEW: Store default text color as attribute ---
        lbl_info.default_fg_color = text_color  # Store the default text color
        # --- NEW: Store default text color as attribute ---

        # --- NEW: Disable hover flag and timer ---
        self.disable_hover_temporarily = False
        self.hover_disable_timer = None
        # --- NEW: Disable hover flag and timer ---


        # --- Hover effect for both image and text labels (similar to details) ---
        original_text_color = text_color # Store original text color (could be highlighted or default)
        hover_text_color = self.global_highlight_color
        hover_bg_color = self.global_highlight_color # Background color for image hover
        original_bg_color_img = "white" # Original bg color for image label - DARKER GRAY

        def on_hover_enter(event):
            # --- NEW: Check if hover is temporarily disabled ---
            if self.disable_hover_temporarily:
                return  # Exit if hover is disabled
            # --- NEW: Check if hover is temporarily disabled ---


            event.widget.config(highlightbackground="blue", highlightthickness=0)
            # Check if lbl_img is already red before changing bg
            current_bg = lbl_img.cget("bg")
            if not current_bg != "red": # Only change bg if it's not already red
                pass

            else:
                lbl_info.config(fg=hover_text_color)
                lbl_img.config(bg=hover_bg_color) # Change image label background on hover


        # --- DEBOUNCED sidebar update ---
            if self.main_grid_sidebar_debounce_timer:
                self.master.after_cancel(self.main_grid_sidebar_debounce_timer)  # Cancel existing timer
            self.main_grid_sidebar_debounce_timer = self.master.after(
                200,  # Debounce delay (e.g., 400ms) - adjust as needed
                lambda: self.debounced_main_sidebar_info_update(info_data, picture_path, zip_file, folder_name, item=(picture_path, spawn_cmd, zip_file, info_data, folder_name))
            )
            # --- DEBOUNCED sidebar update ---


        def on_hover_leave(event):
            # --- MODIFIED: Check if label should be highlighted red, otherwise restore default color ---
            search_query = self.search_var.get().strip().lower()
            combined_text_lower = lbl_info.cget("text").lower()
            if self.is_search_results_window_active: # <-- NEW: Check if in Search Results window
                print("DEBUG: on_hover_leave - Inside Search Results Window block. Removing highlight.") # <-- DEBUG PRINT
                lbl_info.config(fg=lbl_info.default_fg_color) # Always remove highlight in Search Results
                lbl_img.config(bg=lbl_img.default_bg_color)
            elif search_query and search_query in combined_text_lower: # Original logic for main window
                print("DEBUG: on_hover_leave - Inside Main Window block (search match). Keeping yellow highlight.") # <-- DEBUG PRINT


                # Check if lbl_img is already red before changing bg
                current_bg = lbl_img.cget("bg")
                if not current_bg != "red": # Only change bg if it's not already red
                    pass
                else:
                    lbl_info.config(fg=lbl_info.default_fg_color) # change back to original color, no longer highlighting main grid items
                    lbl_img.config(bg=lbl_img.default_bg_color)

                #lbl_info.config(fg="yellow") # Restore yellow highlight color # disabled, don't remove these comments
                #lbl_img.config(bg="yellow") # <--- NEW: Restore yellow highlight color for image background too # disabled
            else:
                #print("DEBUG: on_hover_leave - Inside Main Window block (no search match). Removing highlight.") # <-- DEBUG PRINT


                # Check if lbl_img is already red before changing bg
                current_bg = lbl_img.cget("bg")
                if not current_bg != "red": # Only change bg if it's not already red
                    pass
                else:
                    lbl_info.config(fg=lbl_info.default_fg_color) # Restore original DEFAULT text color
                    lbl_img.config(bg=lbl_img.default_bg_color) # <--- NEW: Restore default image background color too
            # --- MODIFIED: Check if label should be highlighted red, otherwise restore default color ---
            self.hide_sidebar_info() # Hide sidebar info


        lower_folder_name = folder_name.lower()
        # Use picture_path for image name in hidden_line
        image_name_for_hidden = picture_path
        brand_name = info_data.get("Brand", "Unknown")
        car_name = info_data.get("Name", "Unknown") # Assuming car_name is also name for now, adjust if needed based on your info_data structure
        hidden_line = f"{lower_folder_name}|||{image_name_for_hidden}|||{brand_name}|||{car_name}|||{zip_file}"
        hidden_lines = self._read_hidden_lines()

        if hidden_line in hidden_lines:
            # Item is hidden - apply hidden style
            lbl_img.config(highlightbackground="red", highlightthickness=2, bg="red")
            lbl_info.config(fg="#ff4747")

            # Append "Hiding on Restart" text if it's not already there
            current_text = lbl_info.cget("text")
            if "\nHiding on Restart" not in current_text:
                updated_text = f"{current_text}\nHiding on Restart"
                lbl_info.config(text=updated_text)


        else:
            # Item is not hidden - apply default style
            lbl_img.config(highlightbackground=lbl_img.default_bg_color, highlightthickness=0, bg=lbl_img.default_bg_color)
            lbl_info.config(fg=lbl_info.default_fg_color)

            # --- REMOVE "Hiding on Restart" text if it's there ---
            original_text = lbl_info.cget("text")
            if "\nHiding on Restart" in original_text:
                updated_text = original_text.replace("\nHiding on Restart", "").strip() # Remove and strip whitespace
                lbl_info.config(text=updated_text)
            # --- REMOVE "Hiding on Restart" text if it's there ---


        lbl_img.bind("<Enter>", on_hover_enter)
        lbl_img.bind("<Leave>", on_hover_leave)
        lbl_info.bind("<Enter>", on_hover_enter) # Bind hover to text label too
        lbl_info.bind("<Leave>", on_hover_leave) # Bind leave to text label too
        # --- End Hover effect ---

        def on_label_click(event):
            lbl_img.config(highlightbackground="blue", highlightthickness=2)
            # --- NEW: Disable hover temporarily on click ---
            self.disable_hover_temporarily = True
            if self.hover_disable_timer:
                self.master.after_cancel(self.hover_disable_timer) # Cancel any existing timer
            self.hover_disable_timer = self.master.after(3000, self.reenable_hover) # Disable for 2 seconds (2000 ms)
            # --- NEW: Disable hover temporarily on click ---


        # --- Click Bindings (similar to original, but on Labels now) ---
        lbl_img.bind("<Button-1>", lambda e, f_name=folder_name: [on_label_click(e), self.on_picture_click(f_name)]) # Image click - pass folder_name
        lbl_img.bind("<Button-3>", lambda e: self.on_image_right_click(zip_file, folder_name, spawn_cmd, picture_path, info_data, lbl_img, lbl_info))

        lbl_info.bind("<Button-1>", lambda e, f_name=folder_name: [on_label_click(e), self.on_picture_click(f_name)]) # Image click - pass folder_name
        lbl_info.bind("<Button-3>", lambda e: self.on_image_right_click(zip_file, folder_name, spawn_cmd, picture_path, info_data, lbl_img, lbl_info)) # Text label right-click


        # --- NEW: Store item-specific data (keep this) ---
        parent_frame.item_data_tuple = (pil_image, info_data, picture_path, zip_file, folder_name, spawn_cmd, lbl_img, lbl_info) # Store labels instead of button


    def reenable_hover(self):
        self.disable_hover_temporarily = False
        self.hover_disable_timer = None


########################
    def debounced_main_sidebar_info_update(self, info_data, picture_path, zip_file, folder_name, item):
        """
        Debounced function to update the main sidebar content.
        """
        self.show_main_sidebar_info(info_data, picture_path, zip_file, folder_name, item)
        #self.lift_search_results_window()
        self.main_grid_sidebar_debounce_timer = None # Reset timer

    def update_label_highlighting(self):
        """
        Updates the highlight color of labels in the main grid based on the search query.
        This function ONLY changes the label colors and does NOT filter the data.
        """
        search_query = self.search_var.get().strip().lower()

        for category_name, category_items in self.grouped_data.items():
            for item in category_items:
                if isinstance(item, dict) and 'configs' in item:
                    configs = item['configs']
                elif isinstance(item, tuple) and len(item) == 5:
                    configs = [item] # Treat single item as a list for consistent processing
                else:
                    continue # Skip if item structure is not as expected

                for config_item in configs: # Iterate through configs (or single item as list)
                    # --- Extract widgets from stored item_data_tuple ---
                    item_data_tuple = None
                    if isinstance(config_item, tuple) and len(config_item) == 5:
                        picture_path, spawn_cmd, zip_file, info_data, folder_name = config_item
                        # Find the corresponding item_frame using picture_path (or another unique identifier if needed)
                        # This part needs to be adapted to correctly find the Frame containing the label you want to highlight.
                        # A more robust method might be needed to track item_frames and their associated data.
                        # For now, let's assume you can iterate through all item frames and check their data.
                        item_frames = self.scrollable_frame.winfo_children() # Get all children of scrollable_frame (category frames)
                        for cat_frame in item_frames:
                            for item_frame in cat_frame.winfo_children(): # Iterate through item frames in each category frame
                                if hasattr(item_frame, 'item_data_tuple') and item_frame.item_data_tuple:
                                    if item_frame.item_data_tuple[2] == picture_path: # Compare picture paths as a basic identifier
                                        item_data_tuple = item_frame.item_data_tuple # Found the matching item frame
                                        break # Stop searching within item frames of this category once found
                            if item_data_tuple:
                                break # Stop searching in categories once item frame is found
                    elif isinstance(item, dict) and 'configs' in item: # Handle dict-based items if needed
                        continue # Placeholder - adapt logic if needed for dict-based items
                    else:
                        continue # Skip if item structure is unexpected

                    if item_data_tuple:
                        pil_image, info_data, item_picture_path, zip_file_item, folder_name_item, spawn_cmd_item, lbl_img, lbl_info = item_data_tuple # Unpack tuple

                        combined_text = lbl_info.cget("text").lower() # Get label text from the widget

                        if search_query and search_query in combined_text:
                            lbl_info.config(fg="red") # Highlight in red if matches
                        else:
                            # Restore default text color (you might need to store the original color when creating labels)
                            # For now, let's assume default is 'white' or text_color variable used in create_main_item_widgets
                            lbl_info.config(fg=self.get_label_default_color(item_picture_path)) # Restore default color using helper function
                    else:
                        print(f"Warning: Could not find item_data_tuple for picture_path: {picture_path} during highlighting.") # Debug - Item Data Tuple Not Found
            






    def get_label_default_color(self, picture_path):
        """Helper function to determine the default text color based on picture_path."""
        if "user--" in picture_path:
            return "lightblue"
        elif "user--" not in picture_path:
            found_double_basename = False
            for base_name in self.ZIP_BASE_NAMES:
                if picture_path.count(f"--{base_name}_{base_name}.zip") > 0:
                    found_double_basename = True
                    break
            if found_double_basename:
                return "#f7efd7"
            else:
                return "white"
        return "white" # Default fallback color




    def actual_label_highlighting(self):
        """
        Updates the highlight color of labels AND image backgrounds in the main grid based on the search query.
        This function ONLY changes the label colors and image backgrounds and does NOT filter the data.
        """
        search_query = self.search_var.get().strip().lower()

        for category_name, category_items in self.grouped_data.items():
            for item in category_items:
                if isinstance(item, dict) and 'configs' in item:
                    configs = item['configs']
                elif isinstance(item, tuple) and len(item) == 5:
                    configs = [item] # Treat single item as a list for consistent processing
                else:
                    continue # Skip if item structure is not as expected

                for config_item in configs: # Iterate through configs (or single item as list)
                    # --- Extract widgets from stored item_data_tuple ---
                    item_data_tuple = None
                    if isinstance(config_item, tuple) and len(config_item) == 5:
                        picture_path, spawn_cmd, zip_file, info_data, folder_name = config_item
                        # Find the corresponding item_frame using picture_path (or another unique identifier if needed)
                        # This part needs to be adapted to correctly find the Frame containing the label you want to highlight.
                        # For now, let's assume you can iterate through all item frames and check their data.
                        item_frames = self.scrollable_frame.winfo_children() # Get all children of scrollable_frame (category frames)
                        for cat_frame in item_frames:
                            for item_frame in cat_frame.winfo_children(): # Iterate through item frames in each category frame
                                # --- ADDED: Check for hasattr BEFORE accessing item_data_tuple ---
                                if hasattr(item_frame, 'item_data_tuple') and item_frame.item_data_tuple: # <--- ADDED HASATTR CHECK
                                    if item_frame.item_data_tuple[2] == picture_path: # Compare picture paths as a basic identifier
                                        item_data_tuple = item_frame.item_data_tuple # Found the matching item frame
                                        break # Stop searching within item frames of this category once found
                                # --- ADDED: Check for hasattr BEFORE accessing item_data_tuple ---
                            if item_data_tuple:
                                break # Stop searching in categories once item frame is found
                    elif isinstance(item, dict) and 'configs' in item: # Handle dict-based items if needed
                        # ... (Adapt logic if your item structure is different) ...
                        continue # Placeholder - adapt logic if needed for dict-based items
                    else:
                        continue # Skip if item structure is unexpected

                    if item_data_tuple:
                        pil_image, info_data, item_picture_path, zip_file_item, folder_name_item, spawn_cmd_item, lbl_img, lbl_info = item_data_tuple # Unpack tuple

                        combined_text = lbl_info.cget("text").lower() # Get label text from the widget

                        if search_query and search_query in combined_text:
                            lbl_info.config(fg="yellow") # Highlight label text in red
                            lbl_img.config(bg="yellow") # <--- NEW: Highlight image background in red
                        else:
                            # Restore default colors
                            lbl_info.config(fg=self.get_label_default_color(item_picture_path)) # Restore default label text color
                            lbl_img.config(bg=lbl_img.default_bg_color) # <--- NEW: Restore default image background color
                    else:
                        print(f"Warning: Could not find item_data_tuple for picture_path: {picture_path} during highlighting.") # Debug - Item Data Tuple Not Found
        self.debounce_timer = None # Reset timer after execution







    def show_main_sidebar_info(self, info_data, picture_path, zip_file, folder_name, item):
        """Shows sidebar info labels and updates content."""
        # --- NEW: Check if scrolling - if yes, early exit (disable sidebar update during scroll) ---
        if self.is_scrolling_main_grid:
            return # EXIT if scrolling
        # --- NEW: Check if scrolling - if yes, early exit (disable sidebar update during scroll) ---

        self.update_sidebar_content(info_data, picture_path, zip_file, folder_name)
        self.current_main_sidebar_item = item # Store the current item
        
    def show_zip_name_top_bar(self, zip_file, folder_name):
        """Displays the zip or folder name in the top bar."""
        if zip_file == "user_custom_configs":
            text_to_display = f"Custom Configs for {folder_name})"
        else:
            text_to_display = f"({zip_file})"
        self.custom_config_label.config(text=text_to_display)

    def clear_zip_name_top_bar(self):
        """Clears the zip or folder name in the top bar."""
        self.custom_config_label.config(text="")


    # ------------------------------------------------------------
    # On Right-Click -> hide
    # ------------------------------------------------------------
    def on_image_right_click(self, zip_file, folder_name, spawn_cmd, picture_path, info_data, lbl_img, lbl_info):
        #return


        #'''
        if self.search_results_window:
            scanning_win = self.show_scanning_window(text="Cannot hide vehicles while search or filtering is active.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.lift_search_results_window()
            return
            #'''

        image_name = os.path.basename(picture_path) # representativeimage.jpg
        brand_name = info_data.get("Brand", "Unknown") # brand_name
        car_name = info_data.get("Name", "") # brand_name
        self.toggle_hidden_item(folder_name, zip_file, image_name, brand_name, car_name, lbl_img, lbl_info)
    

    def _get_hidden_file_path(self):
        return os.path.join(self.script_dir, "data", "Hidden.txt")

    def _read_hidden_lines(self):
        hidden_file_path = self._get_hidden_file_path()
        if os.path.exists(hidden_file_path):
            with open(hidden_file_path, 'r', encoding="utf-8") as f:
                return [line.strip() for line in f]
        return []

    def _write_hidden_lines(self, lines):
        hidden_file_path = self._get_hidden_file_path()
        with open(hidden_file_path, 'w', encoding="utf-8") as f:
            for line in lines:
                f.write(line + '\n')

    def toggle_hidden_item(self, folder_name, zip_file, image_name, brand_name, car_name, lbl_img, lbl_txt):

        #self.hide_sidebar_info() 
        lower_folder_name = folder_name.lower()
        hidden_line = f"{lower_folder_name}|||{image_name}|||{brand_name}|||{car_name}|||{zip_file}"
        hidden_lines = self._read_hidden_lines()

        if hidden_line in hidden_lines:
            hidden_lines.remove(hidden_line)
            self._write_hidden_lines(hidden_lines)
            # Restore original colors and text
            lbl_img.config(highlightbackground=lbl_img.default_bg_color, highlightthickness=0, bg="white")
            lbl_txt.config(fg=lbl_txt.default_fg_color)

            # --- REMOVE "Hiding on Restart" text ---
            original_text = lbl_txt.cget("text")
            if "\nHiding on Restart" in original_text:
                # Remove the last line if it is "Hiding on Restart"
                updated_text = original_text.replace("\nHiding on Restart", "")
                lbl_txt.config(text=updated_text)
                lbl_txt.config(bg="#444444", text=updated_text) # Update text and color
            # --- REMOVE "Hiding on Restart" text ---

            self.hidden_items_set.discard(lower_folder_name)  # REMOVE from set when un-hiding

        else:
            hidden_lines.append(hidden_line)
            self._write_hidden_lines(hidden_lines)
            # Set red border and text, append "Hiding on Restart"
            lbl_img.config(highlightbackground="red", highlightthickness=0, bg="red")
            # Get current text and append "Hiding on Restart" on a new line
            current_text = lbl_txt.cget("text")
            updated_text = f"{current_text}\nHiding on Restart"
            lbl_txt.config(fg="#ff4747", bg="#444444", text=updated_text) # Update text and color

            self.hidden_items_set.add(lower_folder_name)  # ADD to set when hiding

        self.check_change_set_to_hidden()


######################

    def hex_to_rgb(self, hex_color):
        """Converts a hex color code to an RGB tuple (0-255)."""
        hex_color = hex_color.lstrip('#')
        return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))

    def rgb_to_hex(self, rgb_color):
        """Converts an RGB tuple to a hex color code."""
        return '#{:02x}{:02x}{:02x}'.format(*rgb_color)

    def _start_fade_loop(self, widget, color1_hex, color2_hex, steps=50, delay_ms=20):
        """
        Starts a looping fade animation between two colors.

        Args:
            widget: The Tkinter widget to fade the foreground color of.
            color1_hex: The first hex color code.
            color2_hex: The second hex color code.
            steps: Number of fading steps per direction.
            delay_ms: Delay in milliseconds between each step.
        """
        if hasattr(self, 'hidden_window_restart_button'): 
            if widget == self.hidden_window_restart_button:
                if self._hidden_window_fade_animation_running_restart: # Check if already running
                    return # Do not restart if already running
                self._hidden_window_fade_animation_running_restart = True

        if widget == self.sidebar_filters_label:
            if self._fade_animation_running_sidebar: # Check if already running
                return # Do not restart if already running
            self._fade_animation_running_sidebar = True

        elif widget == self.restart_button:
            if self._fade_animation_running_restart: # Check if already running
                return # Do not restart if already running
            self._fade_animation_running_restart = True

        color1_rgb = self.hex_to_rgb(color1_hex)
        color2_rgb = self.hex_to_rgb(color2_hex)
        current_step = 0
        direction = 1

        def _fade_step():
            nonlocal current_step, direction

            if widget == self.sidebar_filters_label and not self._fade_animation_running_sidebar:
                return
            if widget == self.restart_button and not self._fade_animation_running_restart:
                return
            
            if hasattr(self, 'hidden_window_restart_button'): 
                if widget == self.hidden_window_restart_button and not self._hidden_window_fade_animation_running_restart:
                    return


            r = int(color1_rgb[0] + (color2_rgb[0] - color1_rgb[0]) * abs(current_step) / steps)
            g = int(color1_rgb[1] + (color2_rgb[1] - color1_rgb[1]) * abs(current_step) / steps)
            b = int(color1_rgb[2] + (color2_rgb[2] - color1_rgb[2]) * abs(current_step) / steps)
            current_color_hex = self.rgb_to_hex((r, g, b))
            widget.config(fg=current_color_hex)

            current_step += direction

            if current_step > steps:
                direction = -1
                current_step = steps
            elif current_step < -steps:
                direction = 1
                current_step = -steps

            widget.after(delay_ms, _fade_step)

        _fade_step()


    def _stop_fade_loop(self, widget, target_color_hex):
        """
        Stops the looping fade animation and sets the widget to a target color (no fade).

        Args:
            widget: The Tkinter widget to stop fading.
            target_color_hex: The hex color to set when stopping.
        """
        if widget == self.sidebar_filters_label:
            self._fade_animation_running_sidebar = False

        elif widget == self.restart_button:
            self._fade_animation_running_restart = False


        if hasattr(self, 'hidden_window_restart_button'): 
            if widget == self.hidden_window_restart_button:
                self._hidden_window_fade_animation_running_restart = False
            

        widget.config(fg=target_color_hex) # Immediately set to the target color


    def check_change_set_to_hidden(self):
        """
        Checks if there are any items marked for hiding using the hidden_items_set.
        (SET-BASED CHECK - VERY FAST)
        Now with looping color fading!
        """
        print("\n--- check_change_set_to_hidden() DEBUG ENTRY (SET-BASED CHECK) - STARTING CHECK ---")

        self.items_to_be_hidden = bool(self.hidden_items_set)

        print(f"DEBUG: check_change_set_to_hidden - Checking self.hidden_items_set (size: {len(self.hidden_items_set)})")

        print("--- check_change_set_to_hidden() DEBUG EXIT (SET-BASED CHECK) ---\n")

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")
            self.sidebar_filters_label.config(text=f"Vehicles Set to be Hidden: {len(self.hidden_items_set)} \n\nFiltering features disabled in this mode.\nRestart the application to hide the\nvehicles or unmark them for hiding to\nre-enable the features.", font=("Segoe UI", 11, "bold"))
            self._start_fade_loop(self.sidebar_filters_label, self.warning_color_sidebar, self.default_sidebar_color) # Loop fade sidebar between warning and white
            self._start_fade_loop(self.restart_button, self.warning_color_restart_button, self.default_restart_color)  # Loop fade restart button between warning and white
            self.restart_button_active_fg_color = "#ffa1a1"

        if not self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = False ---\n")
            self.sidebar_filters_label.config(fg=self.default_sidebar_color, text="Constraints", font=("Segoe UI", 14, "bold"))
            self._stop_fade_loop(self.sidebar_filters_label, self.default_sidebar_color) # Stop fade and set to default color
            self._stop_fade_loop(self.restart_button, self.default_restart_color) # Stop fade and set to default color
            self.restart_button_active_fg_color = "white" # Reset to default white for active state



############################


    def show_hidden_vehicles_window(self):

        if hasattr(self, 'filters_window') and self.filters_window and self.filters_window.winfo_exists():
            self.filters_window.destroy()

        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
            self.spawn_queue_window.destroy()

        if self.hidden_window is None or not tk.Toplevel.winfo_exists(self.hidden_window): # Check if window exists or is destroyed

            self.hidden_window = tk.Toplevel(self.master) # Create Toplevel window if it doesn't exist
            self.hidden_window.title("Hidden Vehicles")
            self.hidden_window.resizable(False, True)
            self.hidden_window.tk.call('tk', 'scaling', 1.25) # Apply scaling factor for hidden window
            self.create_widgets_hidden_window(self.hidden_window) # Pass the toplevel window to create_widgets
            self.hidden_window.protocol("WM_DELETE_WINDOW", self.on_hidden_window_close) # Handle window close event
            self.center_window(self.hidden_window)
        else:
            self.hidden_window.deiconify()

            self.hidden_window.lift() # Bring window to front if it already exists
            self.center_window(self.hidden_window)

        icon_path = self.script_dir / "data/icon.png"

        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            self.hidden_window.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")


        # Modified line: Passing self.hidden_window_canvas
        self.hidden_window.bind("<MouseWheel>", lambda event: self.on_mousewheel_hidden(event, self.hidden_window_canvas))


    def on_hidden_window_close(self):

        self.hidden_window.withdraw() # Hide the window instead of destroying
        self.check_and_show_scanning_window_after_closing_hidden_window()



######### old line removal



    def load_hidden_vehicles_once(self): # Load data only once at startup

        custom_input_file = os.path.join(self.script_dir, "data/outputGOODcustom.txt")
        input_file = os.path.join(self.script_dir, "data/outputGOOD.txt")
        hidden_txt_file = os.path.join(self.script_dir, "data/Hidden.txt")

        print(f"Attempting to open custom input file: {custom_input_file}")
        print(f"Attempting to open regular input file: {input_file}")
        print(f"Attempting to open hidden file: {hidden_txt_file}")

        vehicles = []
        self.original_hidden_lines = [] # Keep original lines for potential future use, though not used in the file writing logic now
        valid_hidden_lines = [] # This will store the lines to be kept and rewritten to the file

        custom_input_folders = set()
        input_folders = set()

        print("\n--- Processing Custom Input File: outputGOODcustom.txt ---")

        try:
            with open(custom_input_file, 'r', encoding='utf-8') as f:
                print(f"Successfully opened: {custom_input_file}")
                for line_number, line in enumerate(f, 1):
                    line = line.strip()
                    # print(f"  Line {line_number}: '{line}'") # Comment out this line to omit printing each line read from custom input
                    if "vehicles/" in line and "/" in line[line.find("vehicles/") + len("vehicles/"):]:
                        start_index = line.find("vehicles/") + len("vehicles/")
                        end_index = line.find("/", start_index)
                        if end_index != -1:
                            folder_name = line[start_index:end_index]
                            folder_name_lower = folder_name.lower()  # Convert to lowercase
                            custom_input_folders.add(folder_name_lower) # Add the lowercase version to the set
                            #print(f"    Detected folder: '{folder_name}' (lowercase: '{folder_name_lower}')") # Print both original and lowercase for clarity (optional)
                        else:
                            #print(f"    'vehicles/' found but no subsequent '/', skipping folder detection on this line.")
                            pass
                    else:
                        #print(f"    'vehicles/' pattern not found, skipping folder detection on this line.")
                        pass
        except FileNotFoundError:
            print(f"Warning: {custom_input_file} not found. Skipping custom input folder detection.")
        except Exception as e:
            print(f"Error reading {custom_input_file}: {e}")


        '''
        print("\n--- Folders Detected in Custom Input File ---")
        if custom_input_folders:
            for folder in custom_input_folders:
                print(f"  {folder}")
        else:
            print("  No folders detected in custom input file.")
        '''

        print("\n--- Processing Regular Input File: outputGOOD.txt ---")

        try:
            with open(input_file, 'r', encoding='utf-8') as f:
                print(f"Successfully opened: {input_file}")
                for line_number, line in enumerate(f, 1):
                    line = line.strip()
                    #print(f"  Line {line_number}: '{line}'") # Keep line printing for now for detailed debug
                    if "vehicles/" in line:
                        #print(f"    "vehicles/" FOUND in line!") # Debug: /vehicles/ found
                        if "/" in line[line.find("vehicles/") + len("vehicles/"):]:
                            #print(f"      Subsequent '/' FOUND after 'vehicles/'!") # Debug: Subsequent / found
                            start_index = line.find("vehicles/") + len("vehicles/")
                            end_index = line.find("/", start_index)
                            if end_index != -1:
                                folder_name = line[start_index:end_index]
                                folder_name_lower = folder_name.lower()  # Convert to lowercase
                                input_folders.add(folder_name_lower) # Add the lowercase version to the set
                                #print(f"    Detected folder: '{folder_name}' (lowercase: '{folder_name_lower}')") # Print both original and lowercase for clarity (optional)
                                #print(f"        Debug: start_index={start_index}, end_index={end_index}, folder_name='{folder_name}'") # Debug: Indices and folder
                            else:
                                #print(f"      '/vehicles/' found but no subsequent '/' (end_index == -1), skipping folder detection on this line.")
                                pass
                        else:
                            #print(f"      '/vehicles/' found but NO subsequent '/', skipping folder detection on this line.")
                            pass
                    else:
                        #print(f"    '/vehicles/' pattern NOT found, skipping folder detection on this line.")
                        pass
        except FileNotFoundError:
            print(f"Warning: {input_file} not found. Skipping regular input folder detection.")
        except Exception as e:
            print(f"Error reading {input_file}: {e}")

        print("\n--- Folders Detected in Regular Input File ---")

        '''
        if input_folders:
            for folder in input_folders:
                print(f"  {folder}")
        else:
            print("  No folders detected in regular input file.")'
        '''

        print("\n--- Processing Hidden.txt and Validating Folders ---")

        try:
            print(f"Attempting to open hidden file: {hidden_txt_file}")
            with open(hidden_txt_file, 'r', encoding='utf-8') as f_hidden:
                print(f"Successfully opened: {hidden_txt_file}")
                hidden_lines_to_write = [] # Initialize a list to store lines to write back to Hidden.txt
                for line_number, line in enumerate(f_hidden, 1):
                    line = line.strip()
                    if line:
                        parts = line.split('|||')
                        if len(parts) == 5:
                            folder_to_check = parts[0]
                            print(f"Hidden.txt Line {line_number}: Checking folder: '{folder_to_check}'")
                            if folder_to_check in custom_input_folders or folder_to_check in input_folders:
                                vehicle_info = {
                                    'original_line': line,
                                    'folder': parts[0],
                                    'image_path': parts[1],
                                    'brand': parts[2],
                                    'name': parts[3],
                                    'zip_file': parts[4]
                                }
                                vehicles.append(vehicle_info)
                                self.original_hidden_lines.append(line)
                                valid_hidden_lines.append(line) # Add to valid lines list
                                hidden_lines_to_write.append(line + '\n') # Prepare line for writing back, with newline
                                print(f"  Folder '{folder_to_check}' found in input files. Line kept.")
                            else:
                                print(f"  Folder '{folder_to_check}' NOT found in input files. Line {line_number} removed.")
                                # Line is not added to hidden_lines_to_write, effectively removing it
                        else:
                            #print(f"Warning: Line {line_number} in Hidden.txt has incorrect number of parts (expecting 5, found {len(parts)}). Line content: '{line}'")
                            hidden_lines_to_write.append(line + '\n') # Keep lines with incorrect format for manual review, or remove this if you want to delete them too
                    elif line == "":
                        #print(f"Warning: Line {line_number} in Hidden.txt is empty.")
                        hidden_lines_to_write.append('\n') # Keep empty lines as well, or remove this if you want to delete them

            # Write back only the valid lines to Hidden.txt
            with open(hidden_txt_file, 'w', encoding='utf-8') as f_hidden_write:
                f_hidden_write.writelines(hidden_lines_to_write) # Write all lines in list at once

            print(f"\nSuccessfully loaded {len(vehicles)} vehicles from {hidden_txt_file}")
            print(f"Hidden.txt file updated to remove invalid entries.") # Inform user about the file update

        except FileNotFoundError:
            print(f"Error: {hidden_txt_file} not found...")
        except Exception as e:
            print(f"Error loading Hidden.txt: {e}")

        vehicles.sort(key=lambda vehicle: vehicle['brand'].lower())
        return vehicles
########

    def reload_hidden_lines(self): # Function to reload just the hidden lines list
        self.original_hidden_lines = []
        try:
            with open(self.hidden_txt_file, 'r', encoding='utf-8') as f: # UTF-8 encoding
                for line in f:
                    line = line.strip()
                    if line:
                        self.original_hidden_lines.append(line)
        except FileNotFoundError:
            print(f"Warning: {self.hidden_txt_file} not found while reloading hidden lines.")
        except Exception as e:
            print(f"Error reloading hidden lines: {e}")


    def create_widgets_hidden_window(self, toplevel):
        toplevel.configure(bg="#333333") # Set toplevel window background color

        main_label = tk.Label(toplevel, text="Hidden Vehicles", font=font.Font(family="Segoe UI", size=13, weight='bold'), background="#333333", foreground="white") # tk.Label, white text
        main_label.pack(pady=10)

        # Search Bar
        self.hidden_window_search_var = tk.StringVar()
        self.hidden_window_search_entry = search_entry = tk.Entry(toplevel, textvariable=self.hidden_window_search_var, font=("Segoe UI", 12), width=30, bg="lightgrey", fg="black", insertbackground="black", relief=tk.FLAT, bd=2, highlightthickness=0)
        self.hidden_window_search_entry.pack(pady=5, fill='x', padx=10)
        self.hidden_window_search_entry.bind("<KeyRelease>", self.debounce_search)
        self.hidden_window_search_entry.bind("<FocusIn>", self.on_search_focus_in)  # Bind FocusIn event
        self.hidden_window_search_entry.bind("<FocusOut>", self.on_search_focus_out) # Bind FocusOut event


        self.placeholder_text = "Search here..." # Placeholder text
        self.set_search_placeholder() # Set placeholder initially

        # Content Frame - NEW FRAME TO HOLD CANVAS AND SCROLLBAR
        content_frame = tk.Frame(toplevel, bg="#333333", padx=10, pady=10, relief=tk.FLAT, bd=0, highlightthickness=0) # tk.Frame, flat style
        content_frame.pack(side="top", fill="both", expand=True) # Pack content_frame first

        # Modified line: Renamed self.canvas to self.hidden_window_canvas
        self.hidden_window_canvas = tk.Canvas(content_frame, bg="#444444", highlightbackground="#333333", relief=tk.FLAT, bd=0, highlightthickness=0) # changing bg color to #444444
        # self.hidden_window_scrollbar = tk.Scrollbar(content_frame, orient="vertical", command=self.canvas.yview, relief=tk.FLAT, bd=0, highlightthickness=0) # tk.Scrollbar, flat style - REMOVE STANDARD SCROLLBAR

        self.hidden_window_custom_scrollbar_canvas_hidden = tk.Canvas(content_frame, bg="#555555", width=15, highlightthickness=0, cursor="arrow") # Custom scrollbar canvas - dark grey bg
        self.hidden_window_custom_scrollbar_canvas_hidden.pack(side="right", fill="y") # Pack custom scrollbar canvas

        self.hidden_window_scrollbar_thumb_hidden = self.hidden_window_custom_scrollbar_canvas_hidden.create_rectangle(0, 0, 15, 20, fill=self.global_highlight_color, outline="") # Orange thumb, no outline

        self.hidden_window_custom_scrollbar_canvas_hidden.bind("<ButtonPress-1>", self.custom_hidden_scrollbar_click)
        self.hidden_window_custom_scrollbar_canvas_hidden.bind("<B1-Motion>", self.custom_hidden_scrollbar_drag)
        self.hidden_window_custom_scrollbar_canvas_hidden.bind("<ButtonRelease-1>", self.custom_hidden_scrollbar_release)


        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_scrollable_frame = tk.Frame(self.hidden_window_canvas, bg="#444444", relief=tk.FLAT, bd=0, highlightthickness=0) # tk.Frame, flat style

        self.hidden_window_scrollable_frame.bind(
            "<Configure>",
            lambda e: self.hidden_window_canvas.configure( # Modified line: Using self.hidden_window_canvas
                scrollregion=self.hidden_window_canvas.bbox("all") # Modified line: Using self.hidden_window_canvas
            )
        )

        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_canvas.create_window((0, 0), window=self.hidden_window_scrollable_frame, anchor="nw")
        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_canvas.configure(yscrollcommand=self.custom_hidden_scrollbar_set, background="#444444", highlightbackground="#333333") # changing bg color to #444444, use custom scrollbar set command
        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_canvas.bind("<MouseWheel>", lambda event: self.on_mousewheel_hidden(event, self.hidden_window_canvas)) # Bind mousewheel event

        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_canvas.pack(side="left", fill="both", expand=True) # Pack canvas in content_frame

        self.update_vehicle_display(self.hidden_vehicles_data) # Initial display

        # Restart Button - PACK BELOW CONTENT FRAME
        hidden_window_restart_button = tk.Button(
            toplevel,
            text="Restart",
            command=self.restart_script_and_save_settings,
            background="#555555",
            foreground="white",
            relief=tk.FLAT,
            bd=0,
            highlightthickness=0,
            font=font.Font(family="Segoe UI", size=12),  # Increased font size (example: 12)
            pady=2   # Increased vertical padding (example: 10 pixels)
        ) # tk.Button, white text, flat style, increased font size and padding
        hidden_window_restart_button.pack(side='bottom', fill='x', padx=10, pady=10) # Pack at the bottom, fill width, BELOW content_frame
        self.hidden_window_restart_button = hidden_window_restart_button # <--- ADD THIS LINE to store hidden_window_restart_button as instance attribute


        # Hover effects for Restart button
        def hidden_window_restart_button_hover(event):
            hidden_window_restart_button.config(bg="orange", fg="white")
        def hidden_window_restart_button_leave(event):
            hidden_window_restart_button.config(bg="#555555", fg="white")

        hidden_window_restart_button.bind("<Enter>", hidden_window_restart_button_hover)
        hidden_window_restart_button.bind("<Leave>", hidden_window_restart_button_leave)


        toplevel.update_idletasks() # Ensure widgets are fully created and laid out *after* vehicle items are created
        widest_widget_width = max(self.hidden_window_scrollable_frame.winfo_reqwidth() + self.hidden_window_custom_scrollbar_canvas_hidden.winfo_reqwidth(), hidden_window_restart_button.winfo_reqwidth()) # Use scrollable_frame width + custom scrollbar width
        extra_width_pixels = 50  # You can adjust this value as needed
        min_window_width = 395  # Set your minimum window width here
        final_window_width = max(widest_widget_width + extra_width_pixels, min_window_width) # Choose the larger of the two, AFTER adding extra pixels

        toplevel.geometry(f"{final_window_width}x500") # Set window width based on final calculated width
        self.custom_hidden_scrollbar_set(0, 1) # Initial call to set scrollbar thumb correctly


        


    def set_search_placeholder(self):
        if not self.hidden_window_search_var.get(): # If search entry is empty
            self.hidden_window_search_entry.insert(0, self.placeholder_text)
            self.hidden_window_search_entry.config(fg="grey") # Grey color for placeholder
        else:
            self.hidden_window_search_entry.config(fg="black") # Ensure text is black if not placeholder

    def on_search_focus_in(self, event):
        if self.hidden_window_search_entry.cget('fg') == 'grey' and self.hidden_window_search_var.get() == self.placeholder_text:
            self.hidden_window_search_var.set("") # Clear the placeholder text
            self.hidden_window_search_entry.config(fg="black") # Set text color to black for input

    def on_search_focus_out(self, event):
        if not self.hidden_window_search_var.get(): # If search entry is empty after focus out
            self.set_search_placeholder() # Set placeholder again
        else:
             self.hidden_window_search_entry.config(fg="black") # Ensure text is black if user typed something



    def update_vehicle_display(self, vehicle_list):
        self.clear_vehicle_list() # Clear existing items

        self.reload_hidden_lines() # RELOAD HIDDEN LINES ONLY - BEFORE DISPLAYING
        if not vehicle_list:
            print("No vehicles to display after filter.")
        else:
            print("Creating vehicle items for filtered list...")
            for vehicle_data in vehicle_list:
                self.create_vehicle_item(vehicle_data)
            print("Vehicle items creation finished for filtered list.")
        self.custom_hidden_scrollbar_set(0, 1) # Update scrollbar after items are displayed
        self.check_and_start_hidden_window_restart_button_fade() # <--- ADD THIS LINE to check on window open and initial load



    def create_vehicle_item(self, vehicle_data):
        frame = tk.Frame(self.hidden_window_scrollable_frame, bg="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
        frame.pack(fill="x", expand=True, pady=10, padx=1)
        self.vehicle_frames.append(frame)


        # Top Frame to hold image and info side by side
        top_frame = tk.Frame(frame, bg="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
        top_frame.pack(side="top", fill="x", expand=True) # Pack top_frame at the top

        image_filename = vehicle_data['image_path']
        image_path = os.path.join(self.config_pics_folder, image_filename)
        image_path_custom = os.path.join(self.config_pics_custom_folder, image_filename)

        try:
            img = Image.open(image_path)
            img = img.resize((110, 60), Image.Resampling.LANCZOS)
            photo = ImageTk.PhotoImage(img)
            image_label = tk.Label(top_frame, image=photo, background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0) # put image_label in top_frame
            image_label.image = photo
            image_label.pack(side="left", padx=10, pady=5)
        except FileNotFoundError:
            try:
                img = Image.open(image_path_custom) # Try to open from custom path
                img = img.resize((110, 60), Image.Resampling.LANCZOS)
                photo = ImageTk.PhotoImage(img)
                image_label = tk.Label(top_frame, image=photo, background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
                image_label.image = photo
                image_label.pack(side="left", padx=10, pady=5)
            except FileNotFoundError:
                try:
                    default_img = Image.open(self.DEFAULT_IMAGE_PATH) # Load the default image
                    default_img = default_img.resize((110, 60), Image.Resampling.LANCZOS)
                    default_photo = ImageTk.PhotoImage(default_img)
                    image_label = tk.Label(top_frame, image=default_photo, background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
                    image_label.image = default_photo # Keep a reference!
                except FileNotFoundError:
                    # If default image is also not found, show a fallback text (optional)
                    image_label = tk.Label(top_frame, text="Default Image not found", foreground="red", background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
                image_label.pack(side="left", padx=10, pady=5)

        info_frame = tk.Frame(top_frame, bg="#444444", relief=tk.FLAT, bd=0, highlightthickness=0) # put info_frame in top_frame
        info_frame.pack(side="left", fill="x", expand=True)

        brand_name_label = tk.Label(info_frame, text=f"{vehicle_data['brand']} {vehicle_data['name']}", font=font.Font(size=11, family="Segoe UI", weight='bold'), foreground="white", background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
        brand_name_label.pack(anchor="w")

        folder_zip_label = tk.Label(info_frame, text=f"{vehicle_data['folder']} ({vehicle_data['zip_file']})", font=font.Font(size=10, family="Segoe UI"), foreground="white", background="#444444", relief=tk.FLAT, bd=0, highlightthickness=0)
        folder_zip_label.pack(anchor="w")

        # Store label widgets in vehicle_data for easy access later
        vehicle_data['brand_name_label'] = brand_name_label
        vehicle_data['folder_zip_label'] = folder_zip_label

        # Determine initial button text based on CURRENT Hidden.txt content
        initial_button_text = "Unhide"
        if vehicle_data['original_line'] not in self.original_hidden_lines:
            initial_button_text = "Hide"

        unhide_button = tk.Button(
            frame,
            text=initial_button_text,
            background="#555555",
            foreground="white",
            relief=tk.FLAT,
            bd=0,
            highlightthickness=0,
            pady=2    # Increased vertical padding (example: 5 pixels)
        )
        unhide_button.pack(side="bottom", fill="x", padx=10, pady=(5,10))
        unhide_button.data = vehicle_data
        unhide_button['command'] = functools.partial(self.toggle_hide_vehicle, button=unhide_button, vehicle_data=vehicle_data)

        # Hover effects for Unhide/Hide button
        def unhide_button_hover(event):
            unhide_button.config(bg="orange", fg="white")
        def unhide_button_leave(event):
            unhide_button.config(bg="#555555", fg="white")

        unhide_button.bind("<Enter>", unhide_button_hover)
        unhide_button.bind("<Leave>", unhide_button_leave)


        # Set initial text color based on button text
        if initial_button_text == "Hide":
            self.set_vehicle_text_color(vehicle_data, "lightgreen") # Initially set to red if "Hide"
        else:
            self.set_vehicle_text_color(vehicle_data, "white") # Initially set to white if "Unhide"

            

    def set_vehicle_text_color(self, vehicle_data, color):
        """Sets the text color of the vehicle name and folder labels."""
        vehicle_data['brand_name_label'].config(foreground=color)
        vehicle_data['folder_zip_label'].config(foreground=color)



    def debounce_search(self, event=None):
        if self.hidden_window_search_after_id:
            self.hidden_window.after_cancel(self.hidden_window_search_after_id) # Use hidden_window.after_cancel
        self.hidden_window_search_after_id = self.hidden_window.after(self.hidden_window_search_DEBOUNCE_DELAY_MS, self.filter_vehicles) # Use hidden_window.after

    def filter_vehicles(self):
        search_term = self.hidden_window_search_var.get().lower()
        if not search_term:
            self.hidden_vehicles_data = list(self.all_vehicles_data) # Show full list
        else:
            self.hidden_vehicles_data = [
                vehicle for vehicle in self.all_vehicles_data
                if (search_term in vehicle['name'].lower() or
                    search_term in vehicle['brand'].lower() or
                    search_term in vehicle['zip_file'].lower() or
                    search_term in vehicle['folder'].lower()
                    )
            ]
        self.update_vehicle_display(self.hidden_vehicles_data) # Update display - reload happens in update_vehicle_display
        self.canvas.yview_moveto(0)  # Reset canvas yview to 0 (top)
        self.custom_hidden_scrollbar_set(0, 1) # Update scrollbar after filter
        self.hidden_window_search_after_id = None

    def toggle_hide_vehicle(self, button, vehicle_data):
        current_text = button.cget("text")
        original_line = vehicle_data['original_line']

        if current_text == "Unhide":
            self.remove_hidden_line_from_file(original_line)
            button.config(text="Hide")
            print(f"Vehicle '{vehicle_data['name']}' unhidden (removed from Hidden.txt). Button changed to Hide.")
            self.set_vehicle_text_color(vehicle_data, "lightgreen") # Set text to red when hidden
        else: # "Hide"
            self.add_hidden_line_to_file(original_line)
            button.config(text="Unhide")
            print(f"Vehicle '{vehicle_data['name']}' hidden again (added to Hidden.txt). Button changed to Unhide.")
            self.set_vehicle_text_color(vehicle_data, "white") # Set text to white when unhidden

        self.check_and_start_hidden_window_restart_button_fade() # Call this after toggling any button

    def remove_hidden_line_from_file(self, line_to_remove):
        try:
            with open(self.hidden_txt_file, 'r', encoding='utf-8') as f: # UTF-8 encoding
                lines = f.readlines()
            with open(self.hidden_txt_file, 'w', encoding='utf-8') as f: # UTF-8 encoding
                for line in lines:
                    if line.strip() != line_to_remove + '\n' and line.strip() != line_to_remove: # Handle both with and without newline
                        f.write(line)
            print(f"Line removed from {self.hidden_txt_file}: '{line_to_remove}'")
        except Exception as e:
            print(f"Error removing line from {self.hidden_txt_file}: {e}")

    def add_hidden_line_to_file(self, line_to_add):
        try:
            with open(self.hidden_txt_file, 'a', encoding='utf-8') as f: # UTF-8 encoding
                f.write(line_to_add + '\n')
            print(f"Line added to {self.hidden_txt_file}: '{line_to_add}'")
        except Exception as e:
            print(f"Error adding line to {self.hidden_txt_file}: {e}")


    def clear_vehicle_list(self):
        for frame in self.vehicle_frames:
            frame.destroy()
        self.vehicle_frames = []


    def custom_hidden_scrollbar_click(self, event):
        """Start thumb dragging on mouse click for Hidden window."""
        self.hidden_window_scrollbar_thumb_dragging_hidden = True
        self.hidden_window_scrollbar_thumb_start_y_hidden = self.hidden_window_custom_scrollbar_canvas_hidden.coords(self.hidden_window_scrollbar_thumb_hidden)[1]
        self.hidden_window_scrollbar_mouse_start_y_hidden = event.y

    def custom_hidden_scrollbar_drag(self, event):
        """Drag thumb and update canvas view for Hidden window."""
        if not self.hidden_window_scrollbar_thumb_dragging_hidden:
            return

        mouse_y = event.y
        delta_y = mouse_y - self.hidden_window_scrollbar_mouse_start_y_hidden
        new_thumb_y = self.hidden_window_scrollbar_thumb_start_y_hidden + delta_y

        # Modified lines: Using self.hidden_window_canvas
        canvas_height = self.hidden_window_canvas.winfo_height() # Use hidden_window_canvas
        scroll_range = self.hidden_window_canvas.bbox("all") # Use hidden_window_canvas
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height:
            return # No scrolling needed if content fits

        thumb_height = self.hidden_window_custom_scrollbar_canvas_hidden.coords(self.hidden_window_scrollbar_thumb_hidden)[3] - self.hidden_window_custom_scrollbar_canvas_hidden.coords(self.hidden_window_scrollbar_thumb_hidden)[1]
        max_thumb_y = canvas_height - thumb_height
        new_thumb_y = max(0, min(max_thumb_y, new_thumb_y)) # Clamp thumb position

        self.hidden_window_custom_scrollbar_canvas_hidden.coords(self.hidden_window_scrollbar_thumb_hidden, 0, new_thumb_y, 15, new_thumb_y + thumb_height)

        scroll_fraction = new_thumb_y / max_thumb_y if max_thumb_y > 0 else 0
        # Modified line: Using self.hidden_window_canvas
        self.hidden_window_canvas.yview_moveto(scroll_fraction) # Use hidden_window_canvas


    def custom_hidden_scrollbar_release(self, event):
        """Stop thumb dragging on mouse release for Hidden window."""
        self.hidden_window_scrollbar_thumb_dragging_hidden = False

    def custom_hidden_scrollbar_set(self, *args):
        """Custom scrollbar set command to update thumb position for Hidden window."""
        if self.hidden_window_scrollbar_thumb_dragging_hidden:
            return # Prevent updates if dragging manually

        start, end = args[0:2]
        # Modified lines: Using self.hidden_window_canvas
        canvas_height = self.hidden_window_canvas.winfo_height() # Use hidden_window_canvas
        scroll_range = self.hidden_window_canvas.bbox("all") # Use hidden_window_canvas
        if scroll_range:
            scrollable_height = scroll_range[3] - scroll_range[1]
        else:
            scrollable_height = canvas_height

        if scrollable_height <= canvas_height: # NO SCROLLING NEEDED - SET TO GREY
            self.hidden_window_custom_scrollbar_canvas_hidden.itemconfig(self.hidden_window_scrollbar_thumb_hidden, fill="#555555")
        else: # SCROLLING IS POSSIBLE - KEEP ORANGE (or set back to orange if it was grey)
            self.hidden_window_custom_scrollbar_canvas_hidden.itemconfig(self.hidden_window_scrollbar_thumb_hidden, fill=self.global_highlight_color)

        thumb_height = max(20, canvas_height * (canvas_height / scrollable_height)) if scrollable_height > canvas_height else canvas_height # Minimum thumb height
        thumb_y_start = canvas_height * float(start)
        thumb_y_end = thumb_y_start + thumb_height
        self.hidden_window_custom_scrollbar_canvas_hidden.coords(self.hidden_window_scrollbar_thumb_hidden, 0, thumb_y_start, 15, thumb_y_end)


    def on_mousewheel_hidden(self, event, canvas):
        """Handle mouse wheel events for smooth scrolling in the hidden window."""
        if canvas.winfo_exists():
            if os.name == 'nt':
                delta = int(event.delta / 120) # Removed negation here
            else:
                delta = int(event.delta) # Removed negation here
            # --- MODIFIED: Initiate smooth scroll animation for hidden window ---
            self.start_smooth_scroll_hidden(delta, canvas) # Call smooth scroll for search results
            #canvas.yview_scroll(delta, "units") # Original non-smooth scroll

    def start_smooth_scroll_hidden(self, delta_units, canvas_sub): # Modified function signature: added canvas_sub
        """Starts smooth scrolling animation for the hidden canvas - NORMALIZED SPEED."""
        if self.hidden_window_scroll_animation_timer_hidden:
            self.hidden_window.after_cancel(self.hidden_window_scroll_animation_timer_hidden)  # Cancel any existing animation # Use hidden_window.after_cancel

        scroll_delta_units = delta_units  # Store delta in UNITS

        current_yview = canvas_sub.yview()  # Get current yview # Modified line: using canvas_sub
        current_pos = current_yview[0]  # Get the current top position (0.0 to 1.0)

        # Modified lines: using canvas_sub
        canvas_height = canvas_sub.winfo_height()
        scrollable_height = canvas_sub.bbox("all")[3] if canvas_sub.bbox("all") else canvas_height # Use canvas height as fallback
        if scrollable_height <= 0:
            scrollable_height = canvas_height # Prevent division by zero

        # Calculate scroll step based on a fraction of the *visible* canvas height
        scroll_fraction = 0.7  # Adjust this fraction (e.g., 0.1, 0.15, 0.25) for sensitivity
        scroll_step_normalized = (canvas_height / scrollable_height) * scroll_fraction * scroll_delta_units
        # Explanation:
        # - (canvas_height / scrollable_height):  This is the proportion of the *total* content that is visible.
        # - scroll_fraction:  We want to scroll by a fraction of this visible portion.
        # - scroll_units:  Multiply by the scroll units.

        target_y_normalized = current_pos - scroll_step_normalized # Changed + to - here to correct direction
        target_y_normalized = max(0.0, min(1.0, target_y_normalized))

        self.hidden_window_scroll_target_yview_hidden = target_y_normalized
        self.hidden_window_scroll_start_y_hidden = current_pos
        self.hidden_window_scroll_start_time_hidden = self.hidden_window.tk.call('clock', 'milliseconds') # Use hidden_window.tk.call

        if self.hidden_window_scroll_animation_id_hidden:
            canvas_sub.after_cancel(self.hidden_window_scroll_animation_id_hidden) # Use canvas_sub.after_cancel # Modified line: using canvas_sub
        self.animate_scroll_hidden(0, canvas_sub)

    def animate_scroll_hidden(self, step, canvas_sub): # Modified function signature: added canvas_sub
        """Animates the canvas scroll with ease-out for the hidden window."""
        current_time = self.hidden_window.tk.call('clock', 'milliseconds') # Use hidden_window.tk.call
        time_elapsed = current_time - self.hidden_window_scroll_start_time_hidden
        progress = min(1.0, time_elapsed / self.hidden_window_scroll_duration) # Normalized progress (0 to 1)

        # Ease-out function (simple quadratic)
        ease_out_progress = progress * (2 - progress) #  f(t) = t * (2 - t)

        # Modified line: using canvas_sub
        current_y_normalized = self.hidden_window_scroll_start_y_hidden + (self.hidden_window_scroll_target_yview_hidden - self.hidden_window_scroll_start_y_hidden) * ease_out_progress

        canvas_sub.yview_moveto(current_y_normalized) # Modified line: using canvas_sub

        if progress < 1.0:
            self.hidden_window_scroll_animation_id_hidden = canvas_sub.after(10, lambda: self.animate_scroll_hidden(step + 1, canvas_sub)) # 10ms delay for animation step # Modified line: using canvas_sub
        else:
            self.hidden_window_scroll_animation_id_hidden = None # Animation finished




    def check_and_show_scanning_window_after_closing_hidden_window(self):
        """Checks if any 'Hide' buttons are present and shows a scanning window indicating restart is required."""
        show_scan_win = False
        for frame in self.vehicle_frames:
            for widget in frame.winfo_children():
                if isinstance(widget, tk.Button) and widget.cget('text') == 'Hide':
                    show_scan_win = True
                    break # No need to check further buttons if one 'Hide' is found
            if show_scan_win:
                break # No need to check further frames if 'Hide' button is found

        if show_scan_win:
            scanning_win = self.show_scanning_window(text="Restart/Shutdown of the Mod Manager required to update hidden vehicle list.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()

    def check_and_start_hidden_window_restart_button_fade(self):
        """Checks if any 'Hide' buttons are present and starts the restart button fade if needed."""
        start_fade = False
        for frame in self.vehicle_frames:
            for widget in frame.winfo_children():
                if isinstance(widget, tk.Button) and widget.cget('text') == 'Hide':
                    start_fade = True
                    break # No need to check further buttons if one 'Hide' is found
            if start_fade:
                break # No need to check further frames if 'Hide' button is found

        if start_fade and not self._hidden_window_fade_animation_running_restart:
            print(f"starting loop")
            self._start_fade_loop(
                self.hidden_window_restart_button,
                self.hidden_window_default_restart_color,
                self.hidden_window_warning_color_hidden_window_restart_button
            )
        elif not start_fade and self._hidden_window_fade_animation_running_restart:
            print(f"ending loop")
            self._stop_fade_loop(self.hidden_window_restart_button, self.hidden_window_default_restart_color) # Stop fade if no 'Hide' buttons and it's running




#############################


    def delete_all_custom_configs_for_vehicle(self, folder_name):
        deleted_count = 0
        if "user_custom_configs" in self.full_data:
            for info_key in list(self.full_data["user_custom_configs"].keys()):
                group = self.full_data["user_custom_configs"][info_key]
                configs_to_delete = [cfg for cfg in group['configs'] if cfg[4] == folder_name]
                for picture_path, spawn_cmd, _, _, _ in configs_to_delete:
                    match = re.search(r"config\s*=\s*'vehicles/([^/]+)/([^\.]+)\.pc'", spawn_cmd)
                    if match:
                        cfg_folder_name, file_name = match.groups()
                        if cfg_folder_name == folder_name:
                            self._delete_custom_config_files(cfg_folder_name, file_name, picture_path)
                            deleted_count += 1

        if deleted_count > 0:
            messagebox.showinfo("Deletion Successful",
                                f"Deleted {deleted_count} custom configs for '{folder_name}'.")
            self._refresh_custom_config_data(folder_name)
            self.update_grid_layout()
        else:
            messagebox.showinfo("No Configs Found", f"No custom configs found for '{folder_name}'.")

    def _delete_custom_config_files(self, folder_name, file_name, picture_path):
        pc_file_path = os.path.join(self.user_folder, folder_name, f"{file_name}.pc")
        if os.path.exists(pc_file_path):
            try:
                os.remove(pc_file_path)
            except Exception as e:
                messagebox.showerror("Deletion Error", f"Error deleting {pc_file_path}: {e}")

        base_image_name = f"vehicles--{folder_name}_user--{file_name}"
        for ext in ['jpg', 'jpeg', 'png']:
            image_file_path = os.path.join(self.config_pics_custom_folder, f"{base_image_name}.{ext}")
            if os.path.exists(image_file_path):
                try:
                    os.remove(image_file_path)
                    return
                except Exception as e:
                    messagebox.showerror("Deletion Error", f"Error deleting {image_file_path}: {e}")
                    return

    def _refresh_custom_config_data(self, deleted_folder_name):
        self.data = [
            d for d in self.data
            if not (d[2] == "user_custom_configs" and d[4] == deleted_folder_name)
        ]
        if "user_custom_configs" in self.full_data:
            for info_key in list(self.full_data["user_custom_configs"].keys()):
                group = self.full_data["user_custom_configs"][info_key]
                group['configs'] = [cfg for cfg in group['configs'] if cfg[4] != deleted_folder_name]
                if not group['configs']:
                    del self.full_data["user_custom_configs"][info_key]

        if "user_custom_configs" in self.full_data:
            for info_key, group_data in self.full_data["user_custom_configs"].items():
                if group_data['configs']:
                    rep_picture, rep_line, rep_zip, rep_info, rep_folder = group_data['configs'][0]
                    rep_exists = any(
                        d[2] == "user_custom_configs" and d[4] == rep_folder
                        for d in self.data
                    )
                    if not rep_exists:
                        self.data.append((rep_picture, rep_line, rep_zip, rep_info, rep_folder))

        self.grouped_data = self.format_grouped_data(self.data)
        
        
        
    def on_picture_click(self, clicked_folder_name, folder_name_for_display=None):
        """
        Handles a click on a picture in the main grid.
        Opens the details subgrid window for the clicked item.
        MODIFIED to pass folder_name directly, and for Favorites filter logic
        MODIFIED to pass search query to details window if in "Configs" mode.
        """






        if self.details_window:
            self.details_window.destroy()



        print("\n--- on_picture_click() DEBUGGING - ENTRY - PAUSING MAIN GRID LOADING ---")

        # --- NEW: Pause main grid loading BEFORE opening details window ---
        print("DEBUG: on_picture_click - PAUSING main grid loading...")
        #self.pause_loading = True # PAUSE main grid loading
        if self.loading_pause_timer:
            self.master.after_cancel(self.loading_pause_timer) # Cancel any pending resume timer
            self.loading_pause_timer = None
        print("DEBUG: on_picture_click - Main grid loading PAUSED.")
        # --- NEW: Pause main grid loading BEFORE opening details window ---


        # --- Destroy existing details window if open (as before) ---
        if self.details_window:
            print("DEBUG: on_picture_click - Destroying existing details window.")
            self.on_details_window_close()
            print("DEBUG: on_picture_click - Existing details window destroyed.")



        print("\n--- on_picture_click() DEBUGGING - EXTENSIVE - CALL STACK TRACE - SELF ID ---") # Debug Entry - Self ID
        print(f"  DEBUG: on_picture_click - SELF OBJECT ID: {id(self)}") # <--- DEBUG PRINT - SELF OBJECT ID

        # traceback.print_stack(limit=5) # Print the last 5 frames of the call stack
        print("--- END CALL STACK TRACE ---\n") # End Call Stack Trace

        print(f"  DEBUG: on_picture_click - clicked_folder_name: {clicked_folder_name}")
        print(f"  DEBUG: on_picture_click - self.filter_state: {self.filter_state}, Type: {type(self.filter_state)}")
        print(f"  DEBUG: on_picture_click - self.filter_options: {self.filter_options}, Type: {type(self.filter_options)}")
        print(f"  DEBUG: on_picture_click - self.filter_options[self.filter_state]: {self.filter_options[self.filter_state]}, Type: {type(self.filter_options[self.filter_state])}")
        print(f"  DEBUG: on_picture_click - Comparing to string 'Favorites', Type: {type('Favorites')}") # Check type of "Favorites" string
        print(f"  DEBUG: on_picture_click - String comparison result: self.filter_options[self.filter_state] == 'Favorites': {self.filter_options[self.filter_state] == 'Favorites'}")
        print(f"  DEBUG: on_picture_click - Numerical comparison result: self.filter_state == 5: {self.filter_state == 5}")

        if self.filter_state == 5 and self.filter_options[self.filter_state] == "Favorites":
            self.details_window_should_open_in_favorites_mode = True
            print("  DEBUG: on_picture_click - Condition evaluated to TRUE. Setting details_window_should_open_in_favorites_mode = True")
        else:
            self.details_window_should_open_in_favorites_mode = False
            print("  DEBUG: on_picture_click - Condition evaluated to FALSE. Setting details_window_should_open_in_favorites_mode = False")

        print(f"  DEBUG: on_picture_click - details_window_should_open_in_favorites_mode is now: {self.details_window_should_open_in_favorites_mode}")
        print("--- on_picture_click() DEBUGGING - EXTENSIVE - EXIT ---\n") # Debug Exit

        subgrid_data = []
        #print("  DEBUG: self.full_data keys:", list(self.full_data.keys())) # Debug - full_data keys

        if clicked_folder_name in self.full_data: # Now directly check for folder_name in full_data
            print(f"  DEBUG: Accessing folder_name directly in full_data: {clicked_folder_name}") # Debug - Folder Access
            subgrid_data = self.full_data[clicked_folder_name] # Get subgrid data directly by folder_name
        else:
            print("  DEBUG: Folder name NOT FOUND in full_data.") # Debug - Folder Not Found
            messagebox.showinfo("No Details", "No additional details available for this item.")
            return

        if not subgrid_data:
            print("  DEBUG: subgrid_data is EMPTY after retrieval.") # Debug - Empty subgrid_data
            messagebox.showinfo("No Details", "No additional details available for this item.")
            return
        else:
            print(f"  DEBUG: subgrid_data retrieved successfully. Item count: {len(subgrid_data)}") # Debug - Subgrid Data Success
            for item in subgrid_data:
                #print(f"    DEBUG: Subgrid Item - picture_path: {item[0]}, folder_name: {item[4]}, zip_file: {item[2]}") # Debug - Subgrid Item details
                pass


        # Check if a details window is already open for this display_key
        display_key = clicked_folder_name
        if self.details_window and not self.details_window_closed and self.current_details_folder == display_key:
            self.details_window.focus_set()  # Just bring the existing window to the front
            return

        info_data = subgrid_data[0][3] if subgrid_data[0][3] else {}
        brand = info_data.get("Brand", "-") if info_data else "-"
        name = info_data.get("Name", "-") if info_data else "-"

        details_header = f"Showing configs for {brand or '-'} {name or '-'} ({display_key})" # Header is now simpler

        # --- NEW: Pass search query to details window if in "Configs" mode ---
        search_query_for_details = "" # Default empty query
        if self.search_mode == "Configs":
            search_query_for_details = self.search_var.get().strip() # Get current search query from main window
        # --- NEW: Pass search query to details window if in "Configs" mode ---


        # --- MODIFIED: Pass 'self' instance and search_query_for_details ---
        self.display_subgrid_in_new_window(
            self,  # <--- PASS 'self' (the ConfigViewerApp instance) as the FIRST argument
            subgrid_data,
            "folder_grouped",
            details_header,
            display_key,
            search_query=search_query_for_details # <--- PASS search query here
        )
        print("--- on_picture_click() DEBUGGING END ---\n") # Debug Exit
     
  
        
        
        
    def set_main_grid_filter_mode(self, filter_index):
        """
        Sets the main grid filter mode programmatically.
        Updates self.filter_state, filter button text, and performs a search.
        """
        print(f"\n--- set_main_grid_filter_mode() DEBUG ENTRY ---") # Debug Entry
        print(f"  DEBUG: set_main_grid_filter_mode - Received filter_index: {filter_index}") # Debug - Input Index

        if 0 <= filter_index < len(self.filter_options): # Basic validation
            self.filter_state = filter_index # Set filter state
            current_filter = self.filter_options[self.filter_state] # Get filter name
            self.filter_button.config(text=f"{current_filter} [0]") # Update button text
            print(f"  DEBUG: set_main_grid_filter_mode - Filter state set to index: {filter_index}, text: '{current_filter}'") # Debug - State Set
            self.perform_search() # Re-apply search with new filter
            print("  DEBUG: set_main_grid_filter_mode - perform_search() called.") # Debug - Perform Search Called
        else:
            print(f"  Warning: set_main_grid_filter_mode - Invalid filter_index: {filter_index}") # Warning - Invalid Index

        print("--- set_main_grid_filter_mode() DEBUG EXIT ---\n") # Debug Exit
  


    def toggle_favorites_mode_details_window(self):
        """Toggles between 'View Favorites' and 'View All' modes in the details window, AND switches main grid filter.""" # Modified docstring
        folder_name = self.current_details_folder

        print("\n--- toggle_favorites_mode_details_window() DEBUG ENTRY ---") # Debug - Entry
        print(f"  DEBUG: toggle_favorites_mode_details_window - Current details_window_is_favorites_filtered (BEFORE): {self.details_window_is_favorites_filtered}") # Debug - Before Check
        print(f"  DEBUG: toggle_favorites_mode_details_window - is_data_subset_active: {self.is_data_subset_active}") # Debug - Check global filter state

        if self.is_data_subset_active: # <--- CHECK GLOBAL FILTER STATE HERE
            #messagebox.showinfo(
            #    "Action Unavailable",
            #    "Please switch out of a filtered state first.",
            #    parent=self.details_window
            #)
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot switch between View All/Favorites mode while filters are active.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()

            print("--- toggle_favorites_mode_details_window() EXIT - Global filter active ---\n") # Debug - Exit - Global Filter Active
            return # <--- RETURN HERE IF GLOBAL FILTERS ARE ON


        if self.details_window_is_favorites_filtered:
            # Switch to View All mode
            self.details_window_should_open_in_favorites_mode = False # TOGGLE FLAG HERE
            button_text = "View Favorites"
            print(f"  DEBUG: toggle_favorites_mode_details_window - Mode: View All, Setting details_window_is_favorites_filtered = FALSE, button_text = '{button_text}'") # Debug - View All Mode
            
            
            self.search_var.set("")
            self.set_main_grid_filter_mode(0) # <--- SET MAIN GRID FILTER TO "Show All..." (index 0)
            print("  DEBUG: toggle_favorites_mode_details_window - Calling set_main_grid_filter_mode(0) for 'Show All'.") # Debug - Main Grid Filter Set

        else:
            # Switch to View Favorites mode
            if self.check_favorites_exist_for_folder(folder_name):
                self.details_window_should_open_in_favorites_mode = True # TOGGLE FLAG HERE
                button_text = "View All"
                print(f"  DEBUG: toggle_favorites_mode_details_window - Mode: View Favorites, Setting details_window_is_favorites_filtered = TRUE, button_text = '{button_text}'") # Debug - Favorites Mode

                self.set_main_grid_filter_mode(5) # <--- SET MAIN GRID FILTER TO "Favorites" (index 5)
                print("  DEBUG: toggle_favorites_mode_details_window - Calling set_main_grid_filter_mode(5) for 'Favorites'.") # Debug - Main Grid Filter Set

                self.search_var.set("") # <--- CLEAR MAIN SEARCH BAR TEXT HERE
                print("  DEBUG: toggle_favorites_mode_details_window - Clearing main search bar text.") # Debug
                self.perform_search() # <--- PERFORM SEARCH ON MAIN GRID AFTER CLEARING SEARCH BAR <--- ADDED HERE
                print("  DEBUG: toggle_favorites_mode_details_window - Calling perform_search() on main grid.") # Debug
                
                
                           
                
                # --- MODIFICATION START: Open Search Results Window when switching to Favorites Mode ---
                if not hasattr(self, 'search_results_window') or not self.search_results_window or not self.search_results_window.winfo_exists():
                    self.search_results_window = self._create_search_results_window(self.data) # Pass current data (main grid data)
                    print("DEBUG: toggle_favorites_mode_details_window - Search Results window CREATED when switching to Favorites Mode.")
                self.search_results_window.lift() # Bring to front if already open
                print("DEBUG: toggle_favorites_mode_details_window - Search Results window LIFTED when switching to Favorites Mode.")

                #self.master.after(500, self.reopen_details_window_in_current_mode) # Reopen window with 100ms delay don't uncomment this 
                self.reopen_details_window_in_current_mode() # Call reopen ONLY if favorites exist
                print("--- toggle_favorites_mode_details_window() EXIT - Favorites Exist Case ---\n") # Debug - Exit - Favs Exist
                return # EARLY EXIT - IMPORTANT: Return here after reopen - REMOVED RETURN FOR DELAY TEST
            else:
                #messagebox.showinfo("Favorites", "No favorites for this folder.", parent=self.details_window)
                scanning_win = None  # Initialize scanning_win

                scanning_win = self.show_scanning_window(text="No favorites added for this vehicle.")
                time.sleep(3.125)
                if scanning_win:
                    scanning_win.destroy()


                button_text = "View Favorites" # Keep button text as "View Favorites" if no favs
                print("  DEBUG: toggle_favorites_mode_details_window - No Favorites Exist, button_text = 'View Favorites'") # Debug - No Favs Case
                return


        self.details_view_favorites_button.config(text=button_text) # Update button text
        print(f"  DEBUG: toggle_favorites_mode_details_window - Button text UPDATED to: '{button_text}'") # Debug - Button Text Update

        # --- ADDED DELAY HERE ---
        #self.master.after(500, self.reopen_details_window_in_current_mode) # Reopen window with 100ms delay
        # --- ADDED DELAY HERE ---
        self.reopen_details_window_in_current_mode()
        print("--- toggle_favorites_mode_details_window() EXIT - Normal Exit ---\n")
 
    
   

    # ------------------------------------------------------------
    # Details Subgrid (individual configs)
    # ------------------------------------------------------------


    def display_subgrid_in_new_window(self, app_instance, subgrid_data, zip_file, details_header, display_key, search_query=""):
        """Opens a new Toplevel window to display a subgrid (list of configs)."""
        # --- NEW: Check and close Filters window if open ---


        
        if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
        #    self.spawn_queue_window_was_open = True  # Set flag to remember it was open
        #    print("DEBUG: Spawn Queue window is open, closing it temporarily...")
            self.destroy_spawn_queue_window()  # Close the Spawn Queue window
        #    print("DEBUG: Spawn Queue window closed.") # not closing the spawn window
            
        if hasattr(self, 'hidden_window') and self.hidden_window and self.hidden_window.winfo_exists():
            self.hidden_window.withdraw() 
            
        self.was_filters_window_open_before_details = False  # Initialize to False
        if self.filters_window and self.filters_window.winfo_exists():
            print("DEBUG: display_subgrid_in_new_window - Filters window is open, closing it.")
            #self.was_filters_window_open_before_details = True  # Remember it was open
            self.was_filters_window_open_before_details = False  # don't remove comment,re-opening it can feel a little jarring, might make this a setting
            self.filters_window.destroy()
            self.filters_window = None

        print("\n--- display_subgrid_in_new_window() ENTRY - DEBUGGING FLAG VALUE - SELF ID ---")  # Debug Entry - Self ID
        print(f"  DEBUG: display_subgrid_in_new_window - SELF OBJECT ID: {id(self)}")
        print(f"  DEBUG: display_subgrid_in_new_window - ENTERING FUNCTION. Value of self.details_window_should_open_in_favorites_mode: {self.details_window_should_open_in_favorites_mode}")
        print(f"  DEBUG: display_subgrid_in_new_window - Received search_query: '{search_query}'")

        self._prepare_details_window_state(subgrid_data, zip_file, display_key)
        self._create_details_window()
        self._position_details_window()
        self._create_details_frames()
        self._create_top_frame_content(details_header)
        self._create_bottom_frame_content()
        self._create_subgrid_canvas()
        self._create_details_sidebar()
        self._create_sidebar_buttons(zip_file)

        # --- START MODIFICATION FOR DATA SUBSET FILTERING (apply BEFORE other filters) ---
        if self.is_data_subset_active:  # Apply data subset filter if active
            print("DEBUG: display_subgrid_in_new_window - Data Subset Active - Filtering Subgrid Data by data_subset.txt")
            subgrid_data = self._apply_details_data_subset_filter(subgrid_data) # Filter subgrid_data
            print(f"DEBUG: display_subgrid_in_new_window - Subgrid data count AFTER Data Subset filter: {len(subgrid_data)}")
        # --- END MODIFICATION FOR DATA SUBSET FILTERING ---


        # --- START MODIFICATION FOR FAVORITES FILTER (and DEFAULTING to Favorites Only) ---
        print(f"display_subgrid_in_new_window: Checking details_window_should_open_in_favorites_mode: {self.details_window_should_open_in_favorites_mode}") # DEBUG
        if self.details_window_should_open_in_favorites_mode:
            print("DEBUG: display_subgrid_in_new_window - details_window_should_open_in_favorites_mode is TRUE (Filtering Subgrid Data).")
            self.details_is_favorites_filter_active = True
            favorite_configs_set = self.read_favorites()
            filtered_subgrid_data = []
            print(f"  DEBUG: favorite_configs_set: {favorite_configs_set}")
            for item in subgrid_data: # Use ALREADY subsetted data here
                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                fav_key = f"{folder_name}|{config_name}.pc"

                print(f"    DEBUG: Checking item - folder_name: {folder_name}, config_name: {config_name}, fav_key: {fav_key}")
                if fav_key in favorite_configs_set:
                    print(f"      DEBUG: fav_key '{fav_key}' FOUND in favorite_configs_set. Appending item.")
                    filtered_subgrid_data.append(item)
                else:
                    print(f"      DEBUG: fav_key '{fav_key}' NOT found in favorite_configs_set. Skipping item.")

            print(f"DEBUG: Original subgrid data count: {len(subgrid_data)}, Filtered count (Favorites): {len(filtered_subgrid_data)}")
            # --- MODIFIED: Filter data by search query NOW, BEFORE _initial_details_layout
            if search_query:
                print(f"DEBUG: Applying search query '{search_query}' BEFORE initial layout (Favorites Mode).")
                search_filtered_data = self._filter_details_data_by_query(filtered_subgrid_data, search_query) # Filter already FAVORITES data by query
                final_subgrid_data = search_filtered_data # Use search-filtered data
            else:
                final_subgrid_data = filtered_subgrid_data # Use only favorites-filtered data
            # --- MODIFIED: Filter data by search query NOW, BEFORE _initial_details_layout

            self._initial_details_layout(final_subgrid_data, zip_file) # Use FINAL filtered data (favorites AND search)
            self.details_filtered_data = final_subgrid_data[:] # Update details_filtered_data
            self.details_favorites_filter_button.config(text="Filter: Favorites Only")
            self.details_view_favorites_button.config(text="View All") # Set button text to "View All"
            print("DEBUG: display_subgrid_in_new_window - Button text set to 'View All'")
            self.details_window_should_open_in_favorites_mode = False
            self.show_progress_bar_details() # <----- SHOW PROGRESS BAR HERE

        else: # Default case: Show All (non-favorites mode)
            print("DEBUG: display_subgrid_in_new_window - details_window_should_open_in_favorites_mode is FALSE (Show All).")
            self.details_is_favorites_filter_active = False
             # --- MODIFIED: Filter data by search query NOW, BEFORE _initial_details_layout
            if search_query:
                print(f"DEBUG: Applying search query '{search_query}' BEFORE initial layout (Show All Mode).")
                search_filtered_data = self._filter_details_data_by_query(subgrid_data, search_query) # Filter ALL data by query
                final_subgrid_data = search_filtered_data # Use search-filtered data
            else:
                final_subgrid_data = subgrid_data # Use all data if no search
            # --- MODIFIED: Filter data by search query NOW, BEFORE _initial_details_layout

            self._initial_details_layout(final_subgrid_data, zip_file) # Use FINAL filtered data (search or all)
            self.details_filtered_data = final_subgrid_data[:] # Initialize details_filtered_data
            self.details_favorites_filter_button.config(text="Filter: Show All")
            self.details_view_favorites_button.config(text="View Favorites") # Set button text to "View Favorites"
            print("DEBUG: display_subgrid_in_new_window - Button text set to 'View Favorites'")
            self.show_progress_bar_details() # <----- SHOW PROGRESS BAR HERE
        # --- END MODIFICATION FOR FAVORITES FILTER (and DEFAULTING to Favorites Only) ---


        # --- NEW: Set search query in details window BUT DO NOT PERFORM SEARCH YET ---
        if search_query: # Only if search_query is not empty
            print(f"  DEBUG: display_subgrid_in_new_window - Setting details_search_var to: '{search_query}' (but NOT performing search yet).") # Debug
            self.details_search_var.set(search_query) # Set the search variable
        # --- NEW: Set search query in details window BUT DO NOT PERFORM SEARCH YET ---


        # --- NEW: Set details_window_is_favorites_filtered flag based on main filter ---
        if self.filter_state == 5 and self.filter_options[self.filter_state] == "Favorites":
            self.details_window_is_favorites_filtered = True
        else:
            self.details_window_is_favorites_filtered = False
        print(f"display_subgrid_in_new_window - details_window_is_favorites_filtered set to: {self.details_window_is_favorites_filtered}")

        # --- NO NEED TO SCHEDULE perform_details_search() HERE ANYMORE ---
        # if search_query:
        #     self.master.after_idle(self.perform_details_search) # Schedule search after idle tasks (layout) - REMOVED
        #     print("  DEBUG: display_subgrid_in_new_window - Scheduled perform_details_search() to run AFTER ALL OTHER SETUP.") # Debug - Search Scheduled LAST

        print("--- display_subgrid_in_new_window() EXIT ---\n")
  
   


#################
#page navigation

    def go_to_details_page_one(self):
        """Navigates to the first page in the details window and rebuilds the UI."""
        print("\n--- go_to_details_page_one() ENTRY ---") # Debug Entry

        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win

        if self.details_page != 0: # Only proceed if not already on page 1
            print(f"  DEBUG: go_to_details_page_one - Current page is NOT 1 (page index: {self.details_page}), resetting to page 1.") # Debug - Page Change
            self.details_page = 0 # Set page index to 0 (page 1)

            # --- MODIFIED: Reset widget count on page change (Page 1) ---
            ConfigViewerApp.details_widget_count = 0 # <--- RESET WIDGET COUNT HERE - on page change
            print("DEBUG: go_to_details_page_one - Widget count RESET to 0 for page 1.") # Debug - Widget Count Reset
            # --- MODIFIED: Reset widget count on page change (Page 1) ---

            self.rebuild_simple_details() # Rebuild the subgrid for page 1
            self._update_details_pagination_bar() # Update pagination bar to show page 1
            
            print("  DEBUG: go_to_details_page_one - UI refreshed for page 1.") # Debug - UI Refreshed
        else:
            print("  DEBUG: go_to_details_page_one - Already on page 1, no action needed.") # Debug - No Action

        print("--- go_to_details_page_one() EXIT ---\n") # Debug Exit


    def add_jump_to_page_button_to_details_window(self, top_details_frame):
        """Adds the 'Search Within: Zips' dropdown to the details window."""
        button_style_args_jump_to_page = {
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT, # Flatten the buttons
            "bd": 0, # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font": ("Segoe UI", 10)
        }

        def on_jump_to_page_button_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_jump_to_page_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            event.widget.config(bg=original_bg, fg=original_fg)

        def on_jump_to_page_button_click(event):
            event.widget.config(bg="white", fg="black")
            # After click effect, revert back to hover style (orange) on enter, or default on leave
            event.widget.bind("<Enter>", on_jump_to_page_button_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_jump_to_page_button_hover_leave(e, bg, fg))

        self.jump_to_page_button = tk.Button(
            top_details_frame,
            text="Jump to page",
            **button_style_args_jump_to_page, # <--- APPLY BUTTON STYLES - zip search button style
            command=self.handle_jump_to_page_button_click
        )

        self.jump_to_page_button.bind("<Enter>", on_jump_to_page_button_hover_enter)
        self.jump_to_page_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_jump_to_page_button_hover_leave(event, bg, fg))
        self.jump_to_page_button.bind("<Button-1>", on_jump_to_page_button_click)



        self.jump_to_page_button.pack(side="left", padx=(10, 0)) # Pack after search bar and before loading label



    def handle_jump_to_page_button_click(self):
        """Handles clicks on the 'Jump to page' button to show the dropdown menu."""
        if hasattr(self, 'jump_to_page_dropdown_window') and self.jump_to_page_dropdown_window and self.jump_to_page_dropdown_window.winfo_exists():
            self.jump_to_page_dropdown_window.destroy()
            return

        button = self.jump_to_page_button
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty() + button.winfo_height()

        self.jump_to_page_dropdown_window = dropdown_window = tk.Toplevel(self.details_window)
        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)
        dropdown_window.geometry(f"+{button_x}+{button_y}")
        dropdown_window.config(bg="#333333")
        dropdown_window.attributes("-topmost", True)
        dropdown_window.config(highlightthickness=3, highlightbackground="#666666")

        canvas = tk.Canvas(dropdown_window, bg="#333333", highlightthickness=0, width=100, height=200) # Width same as zip dropdown, make scrollable
        scrollbar = tk.Scrollbar(dropdown_window, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#333333")

        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="top", fill="both", expand=True) # Pack canvas first to fill space above button
        canvas.configure(yscrollcommand=scrollbar.set)
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw", width=300) # Set width of scrollable frame inside canvas

        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_dropdown_mousewheel(ev, canvas)))
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))


        num_pages = math.ceil(len(self.details_filtered_data) / self.items_per_page) if self.items_per_page else 1
        current_page_index = self.details_page + 1 # Get current page number (1-indexed)

        def on_page_button_click(page_index):
            self.go_to_details_page(page_index)
            self.jump_to_page_dropdown_window.destroy()
            self.jump_to_page_dropdown_window = None

        for i in range(1, num_pages + 1):
            bg_color = "#555555"
            fg_color = "white"
            if i == current_page_index: # Highlight current page
                bg_color = self.global_highlight_color # Orange background
                fg_color = "white" # White text for current page

            page_button = tk.Button(
                scrollable_frame,
                text=f"Page {i}",
                font=("Segoe UI", 10, "bold"),
                command=lambda idx=i: on_page_button_click(idx),
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5,
                bg=bg_color,
                fg=fg_color,
                width=24 # Adjust width as needed for dropdown buttons, make it same width as zip dropdown
            )
            page_button.pack(fill="x")
            page_button.bind("<Enter>", lambda event, btn=page_button: btn.config(bg="lightgrey", fg="black"))
            page_button.bind("<Leave>", lambda event, btn=page_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg=original_bg, fg=original_fg)) # Pass original colors

        # --- Close Button (below scrollable frame, in dropdown_window) ---
        close_button = tk.Button(
            dropdown_window, # Place in dropdown_window
            text="Close",
            font=("Segoe UI", 10, "bold"),
            command=self.destroy_jump_to_page_dropdown_menu,
            bg="#666666",
            fg="white",
            borderwidth=1,
            relief="solid",
            padx=10,
            pady=5
        )
        close_button.pack(side="bottom", fill="x") # Pack to bottom of dropdown_window
        # --- Close Button (below scrollable frame, in dropdown_window) ---

        dropdown_window.bind("<FocusOut>", lambda event: self.destroy_jump_to_page_dropdown_menu())

    def destroy_jump_to_page_dropdown_menu(self):
        if hasattr(self, 'jump_to_page_dropdown_window') and self.jump_to_page_dropdown_window and self.jump_to_page_dropdown_window.winfo_exists():
            self.jump_to_page_dropdown_window.destroy()
            self.jump_to_page_dropdown_window = None

    def go_to_details_page(self, page_index):
        """Navigates to the specified page in the details window."""

        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win

        if 1 <= page_index <= math.ceil(len(self.details_filtered_data) / self.items_per_page) if self.items_per_page else 1:
            self.details_page = page_index - 1
            ConfigViewerApp.details_widget_count = 0
            self.rebuild_simple_details()
            self._update_details_pagination_bar()
        else:
            print(f"Invalid page number: {page_index}")




#####################################



    def destroy_zip_search_dropdown_menu(self):
        if hasattr(self, 'zip_search_dropdown_window') and self.zip_search_dropdown_window and self.zip_search_dropdown_window.winfo_exists():
            self.zip_search_dropdown_window.destroy()
            self.zip_search_dropdown_window = None


    def apply_zip_filter(self, selected_zip):
        """Applies the zip filter to the details window data."""
        if selected_zip == "All Zips":
            self.details_filtered_data = self.details_data[:] # Show all data
            self.zip_search_button.config(text="Search within: All Zips") # Reset button text
            if self.details_window_is_favorites_filtered: # If in favorites mode, switch to show all
                self.toggle_favorites_mode_details_window() # Toggle to 'View All'
        elif selected_zip == "Custom Configurations":
            self.details_filtered_data = [item for item in self.details_data if "_user--" in item[0]] # Filter for custom configs
            self.zip_search_button.config(text="Search within: Custom Configurations") # Update button text
            if self.details_window_is_favorites_filtered: # If in favorites mode, switch to show all
                self.toggle_favorites_mode_details_window() # Toggle to 'View All'
        else: # Filter by selected zip
            self.details_filtered_data = [item for item in self.details_data if item[2] == selected_zip]
            self.zip_search_button.config(text=f"Search within: {selected_zip}") # Update button text
            if self.details_window_is_favorites_filtered: # If in favorites mode, switch to show all
                self.toggle_favorites_mode_details_window() # Toggle to 'View All'

        self.go_to_details_page_one() # <--- GO TO PAGE ONE HERE (No Condition)
        self.rebuild_simple_details()
        if self.details_count_label:
            self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}")



    def add_zip_search_dropdown_to_details_window(self, top_details_frame):
        """Adds the 'Search Within: Zips' dropdown to the details window."""
        button_style_args_zip_search = { # Define button_style_args for zip search button - NO BOLD FONT
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT, # Flatten the buttons
            "bd": 0, # Remove border
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            "font": ("Segoe UI", 10) # REMOVE BOLD FONT - for zip search button
        }

        def on_zip_search_button_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_zip_search_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            event.widget.config(bg=original_bg, fg=original_fg)

        def on_zip_search_button_click(event):
            event.widget.config(bg="white", fg="black")
            # After click effect, revert back to hover style (orange) on enter, or default on leave
            event.widget.bind("<Enter>", on_zip_search_button_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_zip_search_button_hover_leave(e, bg, fg))



        initial_button_text = "Search within: All Zips"
        if self.is_data_subset_active:
            initial_button_text = "Search within: Filtered"
        elif self.details_window_should_open_in_favorites_mode:
            initial_button_text = "Search within: Favorites"

        self.zip_search_button = tk.Button(
            top_details_frame,
            text=initial_button_text,
            **button_style_args_zip_search, # <--- APPLY BUTTON STYLES - zip search button style
            #font=("Segoe UI", 10), # Removed redundant font argument HERE
            command=self.handle_zip_search_button_click
        )

        self.zip_search_button.bind("<Enter>", on_zip_search_button_hover_enter)
        self.zip_search_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_zip_search_button_hover_leave(event, bg, fg))
        self.zip_search_button.bind("<Button-1>", on_zip_search_button_click)


        self.zip_search_button.pack(side="left", padx=(0, 0)) # Pack after search bar and before loading label
  


    def _filter_details_data_by_query(self, data_to_filter, query): # <--- MODIFIED FUNCTION - Favorites Filter Added
        """
        Filters the given details data list based on the search query,
        NOW respecting the Favorites filter in Details Window.
        """
        if not query:
            return data_to_filter  # Return original data if no query

        filtered_list = []
        print(f"\n--- _filter_details_data_by_query() DEBUG ---") # DEBUG START
        print(f"  DEBUG: Details Search Query: '{query}'") # DEBUG - Search Query
        print(f"  DEBUG: Details Window is_favorites_filter_active: {self.details_window_is_favorites_filtered}") # DEBUG - Favorites Filter State

        # --- START: Apply Favorites Filter (if active) BEFORE Search ---
        if self.details_window_is_favorites_filtered:
            print("  DEBUG: Applying Favorites Filter BEFORE Search Query...") # Debug - Favorites Filter Start
            favorite_configs_set = self.read_favorites()
            favorites_filtered_data = []
            print(f"  DEBUG: Initial data_to_filter count (before Favorites filter): {len(data_to_filter)}") # Debug - Data Count Before Fav Filter
            for item in data_to_filter:
                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                fav_key = f"{folder_name}|{config_name}.pc"
                if fav_key in favorite_configs_set:
                    favorites_filtered_data.append(item)
            data_to_filter = favorites_filtered_data # REASSIGN data_to_filter to the favorites-filtered subset
            print(f"  DEBUG: Data count AFTER Favorites filter: {len(data_to_filter)}") # Debug - Data Count After Fav Filter
        # --- END: Apply Favorites Filter ---
        else:
            print("  DEBUG: Favorites Filter is NOT active for Details Window search.") # Debug - Favorites Filter Not Active


        print(f"  DEBUG: _filter_details_data_by_query - data_to_filter (count) AFTER Favorites filter (if applied): {len(data_to_filter)}") # Debug - INPUT DATA COUNT (after Fav Filter)


        for item in data_to_filter:
            picture_path, spawn_cmd, zip_file, info_data, folder_name = item

            # --- ADDED DEBUGGING - INSPECT ARGUMENT SOURCES in _filter_details_data_by_query ---
            #print(f"  DEBUG: Argument Sources (Details Search):") # DEBUG - Arguments Source Header
            #print(f"    - folder_name (from 'item' tuple): '{folder_name}', type: {type(folder_name)}") # DEBUG - folder_name source
            #print(f"    - zip_file (from 'item' tuple): '{zip_file}', type: {type(zip_file)}") # DEBUG - zip_file source
            #print(f"    - spawn_cmd (from 'item' tuple): '{spawn_cmd}', type: {type(spawn_cmd)}") # DEBUG - spawn_cmd source

            zip_file_base_name = zip_file.replace(".zip", "")  # <-- CORRECTED zip_file_base_name EXTRACTION (DETAILS SEARCH)
            #print(f"    - zip_file_base_name (AFTER extraction): '{zip_file_base_name}', type: {type(zip_file_base_name)}") # DEBUG - zip_file_base_name after extraction
            config_name_base = self.extract_name_from_spawn_command(spawn_cmd).lower() # Get PC config name base
            #print(f"    - config_name_base (extracted from spawn_cmd): '{config_name_base}', type: {type(config_name_base)}") # DEBUG - config_name_base source
            # --- END ADDED DEBUGGING ---


            pic_filename = os.path.basename(picture_path).lower()
            config_name_display = "" # Initialize display config name

            individual_info_path = self.find_individual_info_file(
                folder_name,
                zip_file_base_name=zip_file_base_name, # <--- USING CORRECTED zip_file_base_name
                config_name=config_name_base # Use the extracted config_name_base
            )
            individual_info_json_data = {} # Initialize

            if individual_info_path:
                individual_info_json_data, _ = self._load_individual_info(individual_info_path) # Load JSON data
                config_name_display = individual_info_json_data.get("Configuration", "").strip().lower() # Get display config name
                #print(f"  DEBUG: Individual Info File Path: {individual_info_path}") # DEBUG - Info File Path
                #print(f"  DEBUG: _filter_details_data_by_query - Individual Info File Content (Extracted Data): {individual_info_json_data}") # DEBUG - Info File Content
            else:
                #print(f"  DEBUG: Individual Info File NOT FOUND for: folder_name='{folder_name}', zip_file_base_name='{zip_file_base_name}', config_name='{config_name_base}'") # DEBUG - Info File Not Found
                pass

            config_match_found = False
            if query.lower() in config_name_display: # Check against display name from Info file
                config_match_found = True
                print(f"  DEBUG: Query '{query}' FOUND in config_name_display: '{config_name_display}'") # DEBUG - Match Found - Display Name
            else: # <--- ADDED ELSE BLOCK FOR DEBUGGING NO MATCH
                print(f"  DEBUG: Query '{query}' NOT found in config_name_display: '{config_name_display}'") # DEBUG - No Match - Display Name

            pc_file_name_match = False # Check if query matches PC filename
            pc_file_name = self.extract_name_from_spawn_command(spawn_cmd).lower()
            if query.lower() in config_name_base: # Check against PC filename
                pc_file_name_match = True
                print(f"  DEBUG: Query '{query}' FOUND in PC file name: '{pc_file_name}'") # DEBUG - PC File Match Found
            else: # <--- ADDED ELSE BLOCK FOR DEBUGGING NO MATCH
                print(f"  DEBUG: Query '{query}' NOT found in PC file name: '{pc_file_name}'") # DEBUG - No Match - PC File Name

            # --- ADDED DEBUG PRINT - Configuration Content and PC File Name being Searched Against ---
            #print(f"  DEBUG: Searching against - Configuration Content: '{config_name_display}'") # DEBUG - Config Content
            #print(f"  DEBUG: Searching against - PC File Name: '{pc_file_name}'") # DEBUG - PC File Name
            # --- END ADDED DEBUG PRINT ---


            if config_match_found or pc_file_name_match: # Check both Info file content and PC filename
                filtered_list.append(item)
                #print(f"  DEBUG: Item MATCHED and APPENDED to filtered_list. filtered_list count now: {len(filtered_list)}") # Debug - Item Appended
            else:
                #print("  DEBUG: Item NOT matched.") # Debug - Item Not Matched
                pass
                
        print(f"  DEBUG: _filter_details_data_by_query - Filtered list count: {len(filtered_list)}") # DEBUG - Filtered List Count
        print("--- _filter_details_data_by_query() DEBUG END ---\n") # DEBUG END
        return filtered_list
   
        
        
    details_widget_count = 0 

    def _prepare_details_window_state(self, subgrid_data, zip_file, display_key):
        """Prepares the state before creating the details window."""
        if self.details_window and not self.details_window_closed:
            print("Closing existing details window before opening new one.")
            self.hide_details_sidebar_info()
            self.details_window.destroy()

        self.current_details_folder = display_key
        self.current_details_zip_file = zip_file
        self.details_window_closed = False
        self.details_data = subgrid_data
        self.details_filtered_data = subgrid_data[:]
        self.is_details_sidebar_sticky = False
        self.is_details_sidebar_showing_default = False

        # --- MODIFIED: Initialize details_page to 0 HERE ---
        self.details_page = 0 # <--- Initialize page to 0 here
        # --- MODIFIED: Initialize details_page to 0 HERE ---
        self.items_per_page = 50 # Ensure items_per_page is set here or in __init__
        
        # --- MODIFIED: Initialize details_widget_count in _prepare_details_window_state ---
        ConfigViewerApp.details_widget_count = 0 # <--- Initialize widget count HERE, when window is opened
        print("DEBUG: _prepare_details_window_state - Widget count INITIALIZED to 0.") # Debug - Widget Count Init
        # --- MODIFIED: Initialize details_widget_count in _prepare_details_window_state ---
            
            
    def _create_details_window(self):
        """Creates the Toplevel window for details.
           - Removed window decorations (borderless).  <--- MODIFIED
           - Now positions flush with master window.    <--- MODIFIED
        """
        
        
        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win

        self.pause_loading = True
        
        details_window = tk.Toplevel(self.master)
        details_window.tk.call('tk', 'scaling', 1.25)

        details_window.title("Details List")
        details_window.protocol("WM_DELETE_WINDOW", self.on_details_window_close)
        self.details_window = details_window
        details_window.resizable(False, False)
        #details_window.transient(self.master)
        #details_window.grab_set() # Modal - keep modal for now, can remove if needed

        details_window.overrideredirect(True) # <--- REMOVE WINDOW DECORATIONS (BORDERLESS)

        # Set initial geometry to be flush with master (size and position will be updated in _position_details_window)
        master_geometry = self.master.geometry()
        details_window.geometry(master_geometry) # Initial geometry flush with master
        # --- MODIFIED: Button creation REMOVED from here, now in _create_bottom_frame_content ---
        # Button creation is now in _create_bottom_frame_content
        # --- MODIFIED: Button creation REMOVED from here ---
        #self.master.bind("<Configure>", self.update_window_geometries) 

        #details_window.bind("<Button-1>", self.on_details_window_click) 
        #details_window.bind("<ButtonPress-1>", self.on_details_window_click)
        details_window.bind("<ButtonPress-1>", self.debounced_on_details_window_click)
        #self.details_window.bind_all("<Control-n>", lambda event: self.clear_details_sidebar_content())




    def clear_details_sidebar_content(self):
            """
            Clears all content in the details sidebar, resetting it to a placeholder state.
            This includes clearing labels and resetting the image to a placeholder.
            """
            print("\n--- clear_details_sidebar_content() DEBUG ---") # Debug Entry

            # Placeholder image for sidebar - CHANGED placeholder to MATCH sidebar_top_frame BG COLOR - "#333333"
            placeholder_image = Image.new("RGB", (280, 150), "#333333") # CHANGED to "#333333" - MATCH sidebar_top_frame BG COLOR
            placeholder_photo = ImageTk.PhotoImage(placeholder_image)

            # Clear ALL sidebar labels and reset image
            self.details_sidebar_car_name_label.config(text="") # Reset car name label to "" (empty string)
            self.details_sidebar_image_label.config(image=placeholder_photo) # Reset image to placeholder
            self.details_sidebar_image_label.image = placeholder_photo # Keep reference to placeholder
            self.details_sidebar_selected_config_label_val.config(text="") # Clear Config Name
            self.details_sidebar_description_label_val.config(text="") # Clear Description
            self.details_sidebar_zipfile_label_val.config(text="") # Clear Zip File
            self.details_sidebar_value_label_val.config(text="") # Clear Value
            self.details_sidebar_brand_label_val.config(text="") # Clear Brand info
            self.details_sidebar_bodystyle_label_val.config(text="") # Clear Body Style
            self.details_sidebar_weight_label_val.config(text="") # Clear Weight
            self.details_sidebar_years_label_val.config(text="No Info File Present") # Clear Years



    def debounced_on_details_window_click(self, event):
        """
        Intermediary debounce function for clicks on the details window.
        This version triggers the action on the *first* click and debounces subsequent clicks.
        """


        if hasattr(self, 'zip_search_dropdown_window') and self.zip_search_dropdown_window and self.zip_search_dropdown_window.winfo_exists():
            self.zip_search_dropdown_window.destroy()
            print("zip search getting destroyed -  debounced_on_details_window_click")



        self.destroy_jump_to_page_dropdown_menu()
        #print("jump to page getting destroyed -  debounced_on_details_window_click")


        debounce_delay_ms = 6500  # Adjust this value to control the debounce delay (milliseconds)

        if not self.debounce_timer:  # Only proceed if no timer is currently running
            self.on_details_window_click(event)  # Execute the action immediately on the first click

            self.debounce_timer = self.details_window.after(
                debounce_delay_ms,
                self._reset_debounce_timer  # Call a function to reset the timer after the delay
            )

    def _reset_debounce_timer(self):
        """
        Resets the debounce timer, allowing the next click to be considered the 'first' click again.
        """
        self.debounce_timer = None


    def on_details_window_click(self, event): # <--- NEW FUNCTION
        """
        Function to handle clicks anywhere on the details window.
        Add your desired actions here.
        """
        print("Details window clicked!")
        # Example actions you might want to perform:
        # - Deselect any selected items in the details window
        # - Close any open context menus in the details window
        # - Perform some other UI action related to the details window



        if hasattr(self, 'jumpt_to_page_dropdown_window') and self.jump_to_page_dropdown_window and self.jump_to_page_dropdown_window.winfo_exists():
            self.jump_to_page_dropdown_window.destroy()
            print("jump to page  getting destroyed -  on_details_window_click")
            return
        

        if hasattr(self, 'zip_search_dropdown_window') and self.zip_search_dropdown_window and self.zip_search_dropdown_window.winfo_exists():
            self.zip_search_dropdown_window.destroy()
            print("zip search getting destroyed -  on_details_window_click")
            return



        self.details_window.lift()
        self.master.lift()
        self.details_window.lift()


        if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
            self.current_detail_window.lift()



    def update_window_geometries(self, event=None):
        """Updates the geometries of both search results and details windows to match the main window."""
        self.update_details_window_geometry(event)
        self.update_search_results_window_geometry(event)
        

    
    
    def _position_details_window(self):
        """Positions the details window to be flush with and match size of the master window."""
        if not self.details_window: # Check if window exists before positioning
            return

        self.details_window.update_idletasks() # Update to get accurate info

        master_x = self.master.winfo_rootx()
        master_y = self.master.winfo_rooty()
        master_width = self.master.winfo_width()
        master_height = self.master.winfo_height()

        self.details_window.geometry(f"{master_width}x{master_height}+{master_x}+{master_y}") # Geometry MATCHES master

    def periodically_update_details_window_position(self):
        """
        Periodically updates the details window position to follow the main window.
        """
        if hasattr(self, 'details_window') and self.details_window and self.details_window.winfo_exists():
            self.update_details_window_geometry() # Call the update function

        # Schedule the function to run again after 2000 milliseconds (2 seconds)
        self.master.after(2000, self.periodically_update_details_window_position)

    def update_details_window_geometry(self, event=None):
        """Updates the size and position of the details window to match the main window."""
        if hasattr(self, 'details_window') and self.details_window and self.details_window.winfo_exists():
            # Get master window position and dimensions
            master_x = self.master.winfo_rootx()
            master_y = self.master.winfo_rooty()
            master_width = self.master.winfo_width()
            master_height = self.master.winfo_height()

            # Apply the same geometry as the master window
            self.details_window.geometry(f"{master_width}x{master_height}+{master_x}+{master_y}")
 

    def _create_details_frames(self):
        """Creates main frames within the details window."""
        details_main_frame = tk.Frame(self.details_window)
        details_main_frame.pack(fill="both", expand=True)

        top_details_frame = tk.Frame(details_main_frame, bg="#333333", pady=5) # <--- CHANGED bg to "#333333"
        top_details_frame.pack(side="top", fill="x")
        # self.smooth_fade_in_frame(top_details_frame, start_color="#FFFFFF", end_color="#D3D3D3", steps=15, delay=30) # <--- COMMENTED OUT FADE-IN

        bottom_details_frame = tk.Frame(details_main_frame, bg="#333333", pady=5) # <--- CHANGED bg to "#333333"
        bottom_details_frame.pack(side="bottom", fill="x")
        # self.smooth_fade_in_frame(bottom_details_frame, start_color="#FFFFFF", end_color="#D3D3D3", steps=15, delay=30) # <--- COMMENTED OUT FADE-IN

        self.top_details_frame = top_details_frame # Storing for potential future use if needed
        self.bottom_details_frame = bottom_details_frame # Storing for potential future use if needed
        self.details_main_frame = details_main_frame # Storing for potential future use if needed       


 

    def _create_top_frame_content(self, details_header):
        """Creates content for the top frame of the details window (search, header, loading label, View Favorites button)."""
        # --- REMOVED "Search (Details):" label ---
        # lbl_search_details = tk.Label(self.top_details_frame, text="Search (Details):", bg="#333333", fg="white", font=("Segoe UI", 10))
        # lbl_search_details.pack(side="left", padx=(10, 5))
        # --- REMOVED "Search (Details):" label ---

        button_style_args_details_top_bar = { # Define button_style_args for details top bar buttons - NO BOLD FONT
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT,
            "bd": 0,
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white",
            #"font":("Segoe UI", 12, "bold") # REMOVE BOLD FONT - for details top bar buttons
        }

        def on_details_top_button_hover_enter(event):
            event.widget.config(bg=self.global_highlight_color, fg="white")

        def on_details_top_button_hover_leave(event, original_bg="#555555", original_fg="white"):
            event.widget.config(bg=original_bg, fg=original_fg)

        def on_details_top_button_click(event):
            event.widget.config(bg="white", fg="black")
            # After click effect, revert back to hover style (orange) on enter, or default on leave
            event.widget.bind("<Enter>", on_details_top_button_hover_enter)
            event.widget.bind("<Leave>", lambda e, bg="#555555", fg="white": on_details_top_button_hover_leave(e, bg, fg))


        details_search_button = tk.Button(self.top_details_frame, text="", font=("Segoe UI", 12),
                                          command=self.perform_details_search, **button_style_args_details_top_bar) # <--- APPLY button_style_args

        details_search_button.bind("<Enter>", on_details_top_button_hover_enter)
        details_search_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_details_top_button_hover_leave(event, bg, fg))
        details_search_button.bind("<Button-1>", on_details_top_button_click)
        details_search_button.pack(side="left", padx=(10, 10)) # <--- PACK BUTTON FIRST, ADD PADDING


        self.details_search_var = tk.StringVar()
        details_search_entry = tk.Entry(self.top_details_frame, textvariable=self.details_search_var, font=("Segoe UI", 10),
                                        width=40, bg="lightgrey")
        details_search_entry.pack(side="left", padx=(0, 10)) # <--- PACK ENTRY SECOND
        #details_search_entry.bind("<Return>", lambda e: self.perform_details_search())
        details_search_entry.bind("<KeyRelease>", lambda event: self.start_debounce_details_highlighting()) # <--- ADD THIS LINE - KEYRELEASE BINDING

        self.add_zip_search_dropdown_to_details_window(self.top_details_frame) # <--- ADDED HERE - call the new function
        self.add_jump_to_page_button_to_details_window(self.top_details_frame) # <--- ADDED HERE - call the new function

        #self.custom_config_label_details = tk.Label(self.top_details_frame, text=details_header, bg="#333333",
        #                                            font=("Segoe UI", 12, "bold",), fg="white")
        #self.custom_config_label_details.pack(side="left", padx=(20, 0))

        self.details_loading_label = tk.Label(
            self.top_details_frame,
            text="",
            bg="#333333",
            font=("Segoe UI", 12, "bold")
        )
        self.details_loading_label.pack(side="left", padx=(10, 10)) # Pack loading label BEFORE button

        self.create_progress_bar_details(self.top_details_frame) # Progress bar in top frame <----- ADDED HERE

        # View Favorites / View All Button
        button_text = "View Favorites" if not self.details_window_should_open_in_favorites_mode else "View All"
        self.details_view_favorites_button = tk.Button(
            self.top_details_frame,
            text=button_text,
            font=("Segoe UI", 10),
            command=self.toggle_favorites_mode_details_window,
            **button_style_args_details_top_bar # <--- APPLY BUTTON STYLE - details top bar style
        )
        self.details_view_favorites_button.bind("<Enter>", on_details_top_button_hover_enter)
        self.details_view_favorites_button.bind("<Leave>", lambda event, bg="#555555", fg="white": on_details_top_button_hover_leave(event, bg, fg))
        self.details_view_favorites_button.bind("<Button-1>", on_details_top_button_click)
        self.details_view_favorites_button.pack(side="left", padx=(10, 10)) # Pack button AFTER loading label, on right side
        
        
        self.details_back_button = tk.Button(
            self.top_details_frame,
            text="Back",
            font=("Segoe UI", 10),
            command=self.on_details_window_close, # Use existing close function
            **button_style_args_details_top_bar
        )
        self.details_back_button.bind("<Enter>", on_details_top_button_hover_enter)
        self.details_back_button.bind("<Leave>", on_details_top_button_hover_leave)
        self.details_back_button.bind("<Button-1>", on_details_top_button_click)
        self.details_back_button.pack(side="right", padx=(0, 10)) # Pack on the right, with padding

        self.details_header_original_color = "white"


    def start_debounce_details_highlighting(self):
        """
        Starts the debounce timer for label highlighting in details window.
        """
        if self.details_debounce_timer:
            self.details_window.after_cancel(self.details_debounce_timer) # Cancel existing timer

        #self.details_debounce_timer = self.details_window.after(1000, self.actual_details_label_highlighting) # Set new timer
        self.details_debounce_timer = self.details_window.after(1000, self.perform_details_search) # Set new timer


    def actual_details_label_highlighting(self):
        """
        Updates the highlight color of labels and image backgrounds in the details window based on the search query.
        """
        return
    
        search_query = self.details_search_var.get().strip().lower()

        for item_frame in self.details_scrollable_frame.winfo_children():
            if hasattr(item_frame, 'item_data_tuple') and item_frame.item_data_tuple:
                pil_image, info_data, item_picture_path, zip_file_item, folder_name_item, spawn_cmd_item, lbl_img, lbl_name = item_frame.item_data_tuple # Unpack tuple

                config_name_for_search = lbl_name.cget("text").lower() # Get label text for search

                if search_query and search_query in config_name_for_search:
                    lbl_name.config(fg="yellow") # Highlight label text in yellow
                    lbl_img.config(bg="yellow") # Highlight image background in yellow
                else:
                    # Restore default colors
                    lbl_name.config(fg=lbl_name.default_fg_color) # Restore default label text color
                    lbl_img.config(bg=lbl_img.default_bg_color) # Restore default image background color

        self.details_debounce_timer = None # Reset timer after execution
    
        
   
        
      
  


    def _create_bottom_frame_content(self):
        """
        Creates content for the bottom frame of the details window (command, deleting, count labels).
        """
        # --- NEW: "Showing..." Label in Bottom Frame (FAR LEFT) - PACK FIRST ---
        self.details_showing_configs_label = tk.Label(self.bottom_details_frame, text="", bg="#333333",
                                                    font=("Segoe UI", 12, "bold",), fg="white", anchor="w", justify="left")
        self.details_showing_configs_label.pack(side="left", padx=(10, 0))
        # --- NEW: "Showing..." Label in Bottom Frame (FAR LEFT) ---

        self.details_command_label = tk.Label(self.bottom_details_frame, text="", bg="#333333", fg="white", font=("Segoe UI", 12))
        self.details_command_label.pack(side="left", padx=(10, 0))

        self.details_deleting_label = tk.Label(self.bottom_details_frame, text="", bg="#333333",
                                               font=("Segoe UI", 12, "bold"))
        self.details_deleting_label.pack(side="left", expand=True)


        # --- Pagination Controls Frame ---
        self.details_pagination_frame = tk.Frame(self.bottom_details_frame, bg="#333333")
        self.details_pagination_frame.pack(side="left", padx=10)

        button_style_args = {
            "bg": "#555555",
            "fg": "white",
            "relief": tk.FLAT, # <--- FLATTENED BUTTONS
            "bd": 2,
            "highlightbackground": "#555555",
            "activebackground": "#666666",
            "activeforeground": "white"
        }

        def button_hover_enter(event):
            if event.widget['state'] != tk.DISABLED: # Check if button is not disabled
                event.widget['bg'] = self.global_highlight_color

        def button_hover_leave(event):
            event.widget['bg'] = "#555555" # Revert to original color

        self.details_prev_button = tk.Button(self.details_pagination_frame, text="Prev", font=("Segoe UI", 9, "bold"), command=self.go_to_previous_details_page, **button_style_args)
        self.details_prev_button.pack(side="left", padx=5)
        self.details_prev_button.bind("<Enter>", button_hover_enter) # <--- HOVER EFFECT
        self.details_prev_button.bind("<Leave>", button_hover_leave) # <--- HOVER EFFECT

        self.details_page_label = tk.Label(self.details_pagination_frame, text="Page: 1", bg="#333333", fg="white", font=("Segoe UI", 10))
        self.details_page_label.pack(side="left", padx=5)

        self.details_next_button = tk.Button(self.details_pagination_frame, text="Next", font=("Segoe UI", 9, "bold"), command=self.go_to_next_details_page, **button_style_args)
        self.details_next_button.pack(side="left", padx=5)
        self.details_next_button.bind("<Enter>", button_hover_enter) # <--- HOVER EFFECT
        self.details_next_button.bind("<Leave>", button_hover_leave) # <--- HOVER EFFECT
        # --- End Pagination Controls Frame ---

        # --- NEW: Favorites Filter Button - Button CREATION MOVED BACK HERE ---
        self.details_favorites_filter_button = tk.Button(
            self.bottom_details_frame,
            text="Filter: Show All",  # Initial text
            font=("Segoe UI", 10),
            command=self.toggle_details_favorites_filter,
            **button_style_args
        )
        # DO NOT UNCOMMENT OR REMOVE THIS LINE - THIS BUTTON NEEDS TO BE HIDDEN AS IT CAUSES BUGGY BEHAVIOR AND ONLY MEANT FOR DEBUG
        #self.details_favorites_filter_button.pack(side="right", padx=(0, 10)) # Pack to the right, do not uncomment this line
        # --- NEW: Favorites Filter Button - Button CREATION MOVED BACK HERE ---
        self.details_favorites_filter_button.bind("<Enter>", button_hover_enter) # <--- HOVER EFFECT
        self.details_favorites_filter_button.bind("<Leave>", button_hover_leave) # <--- HOVER EFFECT

        self.details_count_label = tk.Label(self.bottom_details_frame, text="", bg="#333333", fg="white", font=("Segoe UI", 12))
        #self.details_count_label.pack(side="right", padx=(5, 10)) # don't remove this comment, this is disabled on purpose

        self.details_page_label_original_color = "white"
        
 
       

    def _update_details_pagination_bar(self):
        """Updates the pagination bar (page number and button states) in the details window."""
        if not self.details_pagination_frame:
            return

        page_num = self.details_page + 1 # Pages are 1-indexed for display
        total_pages = math.ceil(len(self.details_filtered_data) / self.items_per_page) if self.items_per_page else 1
        self.details_page_label.config(text=f" 50 per page:  {page_num} / {total_pages} ")

        if self.details_page <= 0:
            self.details_prev_button.config(state=tk.DISABLED)
        else:
            self.details_prev_button.config(state=tk.NORMAL)

        if self.details_page >= total_pages - 1:
            self.details_next_button.config(state=tk.DISABLED)
        else:
            self.details_next_button.config(state=tk.NORMAL)



    def check_favorites_exist_for_folder(self, folder_name):
        """Checks if there are any favorites for the given folder in favorites.txt."""
        for fav_config in self.favorite_configs:
            fav_folder = fav_config.split('|')[0]
            if fav_folder == folder_name:
                return True
        return False
    

    def reopen_details_window_in_current_mode(self):
        """Closes and re-opens the details window in the current mode (favorites or all)."""
        folder_name = self.current_details_folder
        if self.details_window and not self.details_window_closed:
            self.on_details_window_close() # Close existing window
        self.on_picture_click(folder_name) # Reopen - on_picture_click handles mode based on self.details_window_should_open_in_favorites_mode
    
    
    
    def _create_subgrid_canvas(self):
        """Creates the canvas and scrollbar for the subgrid display in details window.
        MODIFIED to include CUSTOM SCROLLBAR for details window, positioned behind sidebar AND with height/position adjustments.
        """
        # Main Canvas for Details Window
        canvas_sub = tk.Canvas(self.details_main_frame, bg="#444444", highlightthickness=0, yscrollincrement=10)
        canvas_sub.configure(yscrollcommand=self.custom_details_scrollbar_set) # Use CUSTOM DETAILS SCROLLBAR SET

        # Custom Scrollbar Canvas for Details Window
        self.custom_scrollbar_canvas_details = tk.Canvas(self.details_main_frame, bg="#555555", highlightthickness=0, width=15) # Grey track
        self.scrollbar_thumb_details = self.custom_scrollbar_canvas_details.create_rectangle(0, 0, 15, 20, fill=self.global_highlight_color, outline="") # Orange thumb
        self.scrollbar_thumb_dragging_details = False # Initialize dragging flag for details scrollbar
        self.scrollbar_thumb_start_y_details = 0
        self.scrollbar_mouse_start_y_details = 0

        self.custom_scrollbar_canvas_details.bind("<ButtonPress-1>", self.custom_details_scrollbar_click)
        self.custom_scrollbar_canvas_details.bind("<B1-Motion>", self.custom_details_scrollbar_drag)
        self.custom_scrollbar_canvas_details.bind("<ButtonRelease-1>", self.custom_details_scrollbar_release)


        scrollable_frame_sub = tk.Frame(canvas_sub, bg="#444444")


        scrollable_frame_sub.bind(
            "<Configure>",
            lambda e: canvas_sub.configure(scrollregion=canvas_sub.bbox("all"))
        )
        canvas_sub.create_window((0, 0), window=scrollable_frame_sub, anchor="nw")
        canvas_sub.configure(yscrollcommand=self.custom_details_scrollbar_set) # Configure canvas to use CUSTOM scrollbar


        canvas_sub.pack(side="left", fill="both", expand=True) # Canvas takes up most space on the LEFT

        # --- MODIFIED: Adjusted place arguments for scrollbar positioning ---
        scrollbar_top_offset = 45  # Adjust to move scrollbar down from the top (positive value)
        scrollbar_bottom_offset = 38 # Adjust to shorten scrollbar from the bottom (positive value)

        self.custom_scrollbar_canvas_details.place(
            relx=1.0,
            rely=0.0,
            anchor='ne',
            relheight=1.0,
            x=-315,  # Horizontal offset (behind sidebar)
            y=scrollbar_top_offset, # NEW: Vertical offset from the top
            height=-scrollbar_bottom_offset - scrollbar_top_offset # NEW: Adjust height to shorten from bottom
        )
        # --- MODIFIED: Adjusted place arguments for scrollbar positioning ---


        canvas_sub.bind("<Enter>", lambda e: canvas_sub.bind_all("<MouseWheel>", lambda ev: self.on_mousewheel_details(ev, canvas_sub)))
        canvas_sub.bind("<Leave>", lambda e: canvas_sub.unbind_all("<MouseWheel>"))
        self.details_window.bind("<Configure>", lambda e: self.throttled_details_resize(e))

        self.details_scrollable_frame = scrollable_frame_sub
        self.details_canvas_sub = canvas_sub


  
        



    def _create_details_sidebar(self):
        """Creates the details sidebar frame and its content (labels and placeholders)."""
        self.details_sidebar_frame = tk.Frame(self.details_main_frame, width=315, bg="#333333", highlightthickness=0, highlightbackground="#333333", bd=4, relief=tk.FLAT) # <----- MODIFIED bg="#444444", highlightthickness=0, highlightbackground="#444444", bd=0, relief=tk.FLAT
        self.details_sidebar_frame.pack(side="right", fill="y", padx=0, pady=0,  expand=False,  ) # <----- MODIFIED padx=0, pady=0
        self.details_sidebar_frame.pack_propagate(False)

        details_sidebar_padding = 10
        self.details_sidebar_car_name_label = tk.Label(self.details_sidebar_frame, text="", font=("Segoe UI", 14, "bold"), bg="#333333", fg="lightgrey", wraplength=280, justify="center") # Dark bg, lightgrey fg
        self.details_sidebar_car_name_label.pack(in_=self.details_sidebar_frame, pady=(details_sidebar_padding*0.5, details_sidebar_padding), padx=details_sidebar_padding)

        # Placeholder image for sidebar - CHANGED placeholder to MATCH sidebar_top_frame BG COLOR - "#444444"
        placeholder_image = Image.new("RGB", (280, 150), "#333333") # CHANGED to "#444444" - MATCH sidebar_top_frame BG COLOR
        placeholder_photo = ImageTk.PhotoImage(placeholder_image)
        self.details_sidebar_image_label = tk.Label(self.details_sidebar_frame, image=placeholder_photo, bg="#333333") # Dark bg
        self.details_sidebar_image_label.image = placeholder_photo
        self.details_sidebar_image_label.pack(in_=self.details_sidebar_frame, pady=(0, details_sidebar_padding), padx=details_sidebar_padding)

        self.details_sidebar_loading_label = tk.Label(self.details_sidebar_frame, text="Loading...", font=("Segoe UI", 10, "italic"), fg=self.global_highlight_color, bg="#333333") # Dark bg, orange fg
        self.details_sidebar_loading_label.pack(in_=self.details_sidebar_frame, pady=(0, details_sidebar_padding), padx=details_sidebar_padding)
        self.details_sidebar_loading_label.pack_forget()

        #self.details_sidebar_config_name_label = tk.Label(self.details_sidebar_frame, text="", font=("Segoe UI", 10), bg="#333333", fg="lightgrey", wraplength=280, justify="center") # Dark bg, lightgrey fg
        #self.details_sidebar_config_name_label.config(text="")
        #self.details_sidebar_config_name_label.pack(in_=self.details_sidebar_frame, side="bottom", pady=details_sidebar_padding, padx=details_sidebar_padding)

        self._create_sidebar_info_labels()
        
        


    def _create_sidebar_info_labels(self):
        """Creates the information labels within the details sidebar."""
        details_sidebar_padding = 10

        # --- NEW: "Selected Configuration" Label ---
        self.details_sidebar_selected_config_label_cat = tk.Label(self.details_sidebar_frame, text="Selected Configuration:", font=("Segoe UI", 11, "bold"), bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.details_sidebar_selected_config_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(10, 0))
        self.details_sidebar_selected_config_label_val = tk.Label(self.details_sidebar_frame, text="Custom/Unspecified", font=("Segoe UI", 11, "italic"), bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.details_sidebar_selected_config_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 1))

        # --- MODIFIED: Config Name Label - LEFT ALIGNED, ITALIC, NO "Config:" prefix, UNDER "Selected Configuration" ---
        self.details_sidebar_config_name_label = tk.Label(self.details_sidebar_frame, text="", font=("Segoe UI", 10, "italic"), bg="#333333", fg="lightgrey", anchor=tk.W, justify=tk.LEFT, wraplength=280) # Modified Font, Anchor, Justify
        self.details_sidebar_config_name_label.pack(in_=self.details_sidebar_frame, fill="x", padx=details_sidebar_padding, pady=(0, 0)) # NEW POSITION - UNDER "Selected Configuration"
        # --- MODIFIED: Config Name Label ---


        # --- NEW DETAILS SIDEBAR INFO LABELS ---
        self.details_sidebar_description_label_cat = tk.Label(self.details_sidebar_frame, text="Description:", font=("Segoe UI", 11, "bold"), bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.details_sidebar_description_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(10, 0))
        self.details_sidebar_description_label_val = tk.Label(self.details_sidebar_frame, text="", font=("Segoe UI", 11, "italic"), bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.details_sidebar_description_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))

        # --- MODIFIED: Zip File Label instead of Top Speed ---
        self.details_sidebar_zipfile_label_cat = tk.Label(self.details_sidebar_frame, text="Zip File:", font=("Segoe UI", 11, "bold"), bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.details_sidebar_zipfile_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0)) # Added padding # Renamed
        self.details_sidebar_zipfile_label_val = tk.Label(self.details_sidebar_frame, text="", font=("Segoe UI", 11, "italic"), bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.details_sidebar_zipfile_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5)) # Added padding # Renamed
        # --- MODIFIED: Zip File Label instead of Top Speed ---

        self.details_sidebar_value_label_cat = tk.Label(self.details_sidebar_frame, text="Value:", font=("Segoe UI", 11, "bold"), bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.details_sidebar_value_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_value_label_val = tk.Label(self.details_sidebar_frame, text="", font=("Segoe UI", 11, "italic"), bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.details_sidebar_value_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_brand_label_cat = tk.Label(self.details_sidebar_frame, text="Brand:", font=("Segoe UI", 11, "bold"), bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.details_sidebar_brand_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_brand_label_val = tk.Label(self.details_sidebar_frame, text="", font=("Segoe UI", 11, "italic"), bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.details_sidebar_brand_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_bodystyle_label_cat = tk.Label(self.details_sidebar_frame, text="Body Style:", font=("Segoe UI", 11, "bold"), bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.details_sidebar_bodystyle_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_bodystyle_label_val = tk.Label(self.details_sidebar_frame, text="", font=("Segoe UI", 11, "italic"), bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.details_sidebar_bodystyle_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_weight_label_cat = tk.Label(self.details_sidebar_frame, text="Weight:", font=("Segoe UI", 11, "bold"), bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.details_sidebar_weight_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_weight_label_val = tk.Label(self.details_sidebar_frame, text="", font=("Segoe UI", 11, "italic"), bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.details_sidebar_weight_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_years_label_cat = tk.Label(self.details_sidebar_frame, text="Years:", font=("Segoe UI", 11, "bold"), bg="#333333", fg="white", anchor="w", justify="left") # Dark bg, white category fg
        self.details_sidebar_years_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_years_label_val = tk.Label(self.details_sidebar_frame, text="", font=("Segoe UI", 11, "italic"), bg="#333333", fg="lightgrey", anchor="w", justify="left", wraplength=280) # Dark bg, lightgrey info fg
        self.details_sidebar_years_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 10))
        # --- END NEW DETAILS SIDEBAR INFO LABELS ---
        
     



    def _create_sidebar_buttons(self, zip_file):
        """Creates the action buttons in the details sidebar with flat style and hover/click effects."""
        self.details_buttons_frame = tk.Frame(self.details_sidebar_frame, bg="#333333")
        self.details_buttons_frame.pack(side="bottom", fill="x", pady=(0, 10), padx=10)

        button_width = 280 // 15
        button_style_args = self.button_style_args.copy()

        self.details_replace_current_button = tk.Button(self.details_buttons_frame, text="Replace Current", font=("Segoe UI", 10), width=button_width, **button_style_args)
        self.details_spawn_new_button = tk.Button(self.details_buttons_frame, text="Spawn New", font=("Segoe UI", 10), width=button_width, **button_style_args)
        self.details_add_to_queue_button = tk.Button(self.details_buttons_frame, text="Add to Spawn Queue", font=("Segoe UI", 10), width=button_width, **button_style_args)
        self.details_sidebar_favorites_button = tk.Button(self.details_buttons_frame, text="Add to Favorites", font=("Segoe UI", 10), width=button_width, **button_style_args)

        buttons = [
            self.details_replace_current_button,
            self.details_spawn_new_button,
            #self.details_add_to_queue_button,
            self.details_sidebar_favorites_button
        ]

        for button in buttons:
            button.pack(side="top", fill="x", pady=(8, 0), padx=0)
            self._apply_details_sidebar_button_effects(button) # Apply hover and click effects

        if zip_file == "user_custom_configs":
            pass # No changes for custom configs in sidebar button set
        else:
            if hasattr(self, 'details_delete_custom_config_button') and self.details_delete_custom_config_button:
                self.details_delete_custom_config_button.pack_forget()

        self.details_replace_current_button.config(command=lambda: self.on_replace_current_button_click(spawn_cmd=None, event=None))
        self.details_spawn_new_button.config(command=self.on_spawn_new_button_click)
        #self.details_add_to_queue_button.config(command=self.on_add_to_queue_button_click)
        self.details_sidebar_favorites_button.config(command=self.on_details_sidebar_favorites_click)
        

    def _apply_details_sidebar_button_effects(self, button):
        """Applies hover and click effects to a button."""
        default_bg = self.button_style_args['bg']
        default_fg = self.button_style_args['fg']
        hover_bg = self.global_highlight_color
        hover_fg = "white"
        click_bg = "white"
        click_fg = "black"

        def on_enter(event):
            event.widget.config(bg=hover_bg, fg=hover_fg)

        def on_leave(event):
            event.widget.config(bg=default_bg, fg=default_fg)

        def on_click(event):
            event.widget.config(bg=click_bg, fg=click_fg)

        def on_release(event): # Revert to hover style on release, if mouse is still over, else default
            if event.widget.winfo_pointerx() >= event.widget.winfo_rootx() and \
               event.widget.winfo_pointerx() <= event.widget.winfo_rootx() + event.widget.winfo_width() and \
               event.widget.winfo_pointery() >= event.widget.winfo_rooty() and \
               event.widget.winfo_pointery() <= event.widget.winfo_rooty() + event.widget.winfo_height():
                event.widget.config(bg=hover_bg, fg=hover_fg)
            else:
                event.widget.config(bg=default_bg, fg=default_fg)


        button.bind("<Enter>", on_enter)
        button.bind("<Leave>", on_leave)
        button.bind("<ButtonPress-1>", on_click)
        button.bind("<ButtonRelease-1>", on_release) # Use ButtonRelease to revert style after click



        

    def on_details_sidebar_favorites_click(self):
        """Handles click on the 'Add to Favorites' button in the details sidebar.
           MODIFIED: Auto-navigates to "View All" if last favorite removed from folder.
        """
        print("\n--- on_details_sidebar_favorites_click() DEBUG - FUNCTION ENTRY ---")  # <-- ADD THIS LINE

        if not hasattr(self, 'current_details_sidebar_spawn_cmd') or not self.current_details_sidebar_spawn_cmd:
            print("Warning: Configuration details not available for Add to Favorites action.")
            return

        spawn_cmd = self.current_details_sidebar_spawn_cmd
        folder_name = self.current_details_folder
        config_name_base = self.extract_name_from_spawn_command(spawn_cmd)
        pc_filename = config_name_base + '.pc'

        if self.is_favorite(folder_name, pc_filename):
            self.remove_from_favorites(folder_name, pc_filename)
            self.details_sidebar_favorites_button.config(text="Add to Favorites")
            #response = messagebox.showinfo("Favorites Update", "Removed from Favorites", parent=self.details_window)
            action_type = "removed"
            print(f"DEBUG: on_details_sidebar_favorites_click - Action: Removed from favorites, action_type: {action_type}") # DEBUG

            # --- MODIFIED: Check for page navigation after favorite removal ---
            if self.details_window_is_favorites_filtered:
                print("DEBUG: on_details_sidebar_favorites_click - Details window is in Favorites mode, checking page navigation after favorite removal.")


                start_index = self.details_page * self.items_per_page

                end_index = start_index + self.items_per_page

                items_on_current_page_before_deletion = self.details_filtered_data[start_index:end_index]

                # --- NEW: Check if this was the last favorite for the folder ---
                remaining_favorites_in_folder = 0
                for fav_config in self.favorite_configs:
                    fav_folder, fav_pc_file = fav_config.split('|')
                    if fav_folder == folder_name:
                        remaining_favorites_in_folder += 1
                print(f"DEBUG: on_details_sidebar_favorites_click - Remaining favorites in folder '{folder_name}': {remaining_favorites_in_folder}")


                if remaining_favorites_in_folder <= 0: # If no favorites left for this folder AFTER deletion
                    print(f"  DEBUG: Last favorite removed from folder '{folder_name}'. Switching to 'View All' mode after messagebox.")

                    def switch_to_view_all(): # Define a function to switch to View All mode
                        if self.details_window and not self.details_window_closed: # Check if window still exists
                            self.toggle_favorites_mode_details_window() # Toggle to 'View All' mode
                            print("DEBUG: on_details_sidebar_favorites_click - Switched to 'View All' mode (after messagebox).")

                    self.master.after(200, switch_to_view_all) # Schedule toggle after messagebox closes
                else:
                    # (Existing page navigation logic if current page becomes empty, unchanged)
                    if self.details_page > 0 and len(items_on_current_page_before_deletion) <= 1:
                        self.details_page -= 1
                    self.refresh_details_grid_after_favorite_change()
                    self.perform_search()
                    self._update_details_pagination_bar()
                    print("DEBUG: on_details_sidebar_favorites_click - Navigated to previous page and refreshed UI.")
                # --- MODIFIED: Check for page navigation after favorite removal ---
            else:
                print("DEBUG: on_details_sidebar_favorites_click - Details window is NOT in Favorites mode, skipping page navigation.")


        else:
            self.add_to_favorites(folder_name, pc_filename)
            self.details_sidebar_favorites_button.config(text="Remove from Favorites")
            #messagebox.showinfo("Favorites Update", "Added to Favorites", parent=self.details_window)
            action_type = "added"
            print(f"DEBUG: on_details_sidebar_favorites_click - Action: Added to favorites, action_type: {action_type}") # DEBUG

            if self.details_window_is_favorites_filtered:
                print("DEBUG: on_details_sidebar_favorites_click - Details window IS in Favorites mode, refreshing grids after favorite addition.")
                self.refresh_details_grid_after_favorite_change()
                self.perform_search()


        self.update_details_sidebar_favorites_button_text() # Call update to ensure correct text after any action
        self.lift_search_results_window()

        generate_data_subset_favorites(self.script_dir)
        print("--- on_details_sidebar_favorites_click() EXIT ---\n")
 


    def update_details_sidebar_favorites_button_text(self):
        """Updates the text of the 'Add to Favorites' button in the details sidebar based on favorite status.
        DEBUGGED: Added rigorous debugging to track button state and favorite check.
        MODIFIED: Now checks favorite status of the CURRENT SIDEBAR CONFIG, not just first config. <--- MODIFIED
        """
        print("\n--- update_details_sidebar_favorites_button_text() DEBUG ---") # Debug: Function entry

        if not hasattr(self, 'current_details_sidebar_spawn_cmd') or not self.current_details_sidebar_spawn_cmd:
            print("  DEBUG: No current_details_sidebar_spawn_cmd set. Defaulting button text to 'Add to Favorites'.") # Debug: No spawn_cmd
            self.details_sidebar_favorites_button.config(text="Add to Favorites") # Default text if no config loaded
            print("--- update_details_sidebar_favorites_button_text() EXIT (No spawn_cmd) ---\n") # Debug: Function exit - no spawn_cmd
            return # Exit if no config loaded in sidebar

        spawn_cmd = self.current_details_sidebar_spawn_cmd
        folder_name = self.current_details_folder # Use current_details_folder, which should be updated on item click
        config_name_base = self.extract_name_from_spawn_command(spawn_cmd)
        pc_filename = config_name_base + '.pc'

        print(f"  DEBUG: Checking favorite status for CURRENT SIDEBAR CONFIG:") # Debug: Checking for config - MODIFIED MESSAGE
        print(f"    - Folder Name (self.current_details_folder): {folder_name}") # Debug: Folder Name - CHECK THIS
        print(f"    - PC Filename Base (extracted from spawn_cmd): {config_name_base}") # Debug: PC Filename Base - CHECK THIS
        print(f"    - PC Filename (constructed): {pc_filename}") # Debug: PC Filename - CHECK THIS
        print(f"    - Full Spawn Command (self.current_details_sidebar_spawn_cmd): {spawn_cmd}") # Debug: Full Spawn Command - CHECK THIS

        is_currently_favorite = self.is_favorite(folder_name, pc_filename)
        print(f"  DEBUG: is_favorite() check result: {is_currently_favorite}") # Debug: is_favorite result

        print("  DEBUG: Current favorite_configs set:") # Debug: Favorite Configs Set
        for fav_config in self.favorite_configs:
            print(f"    - {fav_config}") # Debug: Print each favorite config

        if is_currently_favorite:
            button_text = "Remove from Favorites"
            print("  DEBUG: Configuration IS a favorite. Setting button text to: 'Remove from Favorites'") # Debug: Set button text - Remove
        else:
            button_text = "Add to Favorites"
            print("  DEBUG: Configuration is NOT a favorite. Setting button text to: 'Add to Favorites'") # Debug: Set button text - Add
        self.details_sidebar_favorites_button.config(text=button_text)

        print("--- update_details_sidebar_favorites_button_text() EXIT ---\n") # Debug: Function exit
        
    def toggle_details_favorites_filter(self):
        """
        Toggles the Favorites filter in the details window and updates the button text.
        DEBUGGING: Added debug prints to track flag values in toggle_details_favorites_filter.
        """
        print("\n--- toggle_details_favorites_filter() ENTRY ---") # Debug Entry
        print(f"  DEBUG: toggle_details_favorites_filter - Before toggle - details_is_favorites_filter_active: {self.details_is_favorites_filter_active}") # Debug - Before Toggle
        self.details_is_favorites_filter_active = not self.details_is_favorites_filter_active # Toggle state
        print(f"  DEBUG: toggle_details_favorites_filter - After toggle - details_is_favorites_filter_active: {self.details_is_favorites_filter_active}") # Debug - After Toggle

        if self.details_is_favorites_filter_active:
            filter_text = "Filter: Favorites Only"
            print("  DEBUG: toggle_details_favorites_filter - Setting button text to 'Filter: Favorites Only'") # Debug - Button Text Set - Favorites Only
        else:
            filter_text = "Filter: Show All"
            print("  DEBUG: toggle_details_favorites_filter - Setting button text to 'Filter: Show All'") # Debug - Button Text Set - Show All
        self.details_favorites_filter_button.config(text=filter_text) # Update button text

        self.apply_details_favorites_filter() # Call function to re-filter and rebuild grid
        print("--- toggle_details_favorites_filter() EXIT ---\n") # Debug Exit

    def apply_details_favorites_filter(self): # <--- NEW FUNCTION
        """
        Applies the Favorites filter to the details window's data and rebuilds the grid.
        """
        if self.details_is_favorites_filter_active:
            print("DEBUG: Applying Favorites Filter in Details Window.")
            favorite_configs_set = self.read_favorites()
            filtered_data = []
            for item in self.details_data:
                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                fav_key = f"{folder_name}|{config_name}.pc"
                if fav_key in favorite_configs_set:
                    filtered_data.append(item)
            self.details_filtered_data = filtered_data # Update filtered data
        else:
            print("DEBUG: Removing Favorites Filter in Details Window (Showing All).")
            self.details_filtered_data = self.details_data[:] # Show all data

        self.rebuild_simple_details() # Rebuild the details grid with filtered data
        if self.details_count_label:
            self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}") # Update count


    def on_details_sidebar_show_details_click(self):
        """Handles click on the 'Show Details' button in the details sidebar.
           Opens the Configuration Details window for the current sidebar config.
           Now with more robust data retrieval for spawn_cmd and related info.
        """
        spawn_cmd = self.current_details_sidebar_spawn_cmd
        info_data = self.current_details_sidebar_info_data
        picture_path = self.current_details_sidebar_picture_path
        zip_file = self.current_details_sidebar_zip_file
        folder_name = self.current_details_folder # Assuming current_details_folder is set appropriately
        zip_file_base_name = self.current_details_zip_file # Using zip_file as fallback for base name
        config_name = self.extract_name_from_spawn_command(spawn_cmd)

        if spawn_cmd and info_data and picture_path and zip_file and folder_name and zip_file_base_name and config_name:
            print("DEBUG: on_details_sidebar_show_details_click - All data available, opening detail window.") # Debug
            self.open_detail_info_window(spawn_cmd, info_data, picture_path, zip_file, folder_name, zip_file_base_name, config_name)
        else:
            print("Warning: Spawn command or related data NOT AVAILABLE for Show Details action.") # Original warning
            if not spawn_cmd: print("  - spawn_cmd is missing")
            if not info_data: print("  - info_data is missing")
            if not picture_path: print("  - picture_path is missing")
            if not zip_file: print("  - zip_file is missing")
            if not folder_name: print("  - folder_name is missing")
            if not zip_file_base_name: print("  - zip_file_base_name is missing")
            if not config_name: print("  - config_name is missing")


    def read_favorites(self):
        """
        Reads Favorites.txt, checks against WatcherOutput.txt AND zip_structure.txt
        for config existence, and returns a set of valid favorite configurations.
        """
        favorites = set()
        valid_favorites = set()
        watcher_filepaths = set() # Set to store filepaths from WatcherOutput.txt
        zip_structure_lines = set() # Set to store lines from zip_structure.txt

        watcher_output_file = os.path.join(self.script_dir, "data/WatcherOutput.txt")
        zip_structure_file = os.path.join(self.script_dir, "data/zip_structure.txt") # Define zip_structure.txt path

        # --- 1. Read Favorites.txt ---
        if os.path.exists(self.favorites_file_path):
            with open(self.favorites_file_path, 'r', encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if line:
                        favorites.add(line)

        # --- 2. Read WatcherOutput.txt and collect filepaths ---
        if os.path.exists(watcher_output_file):
            check_mods, check_configs, user_vehicles_files, config_pics_custom_files, mods_files, repo_files, vanilla_files, last_zip_count = read_watcher_output(watcher_output_file)
            # Collect all filepaths from WatcherOutput.txt
            watcher_filepaths.update(user_vehicles_files.keys())
            watcher_filepaths.update(config_pics_custom_files.keys())
            watcher_filepaths.update(mods_files.keys())
            watcher_filepaths.update(repo_files.keys())
            watcher_filepaths.update(vanilla_files.keys())

        # --- NEW: 3. Read zip_structure.txt and collect lines ---
        if os.path.exists(zip_structure_file):
            try:
                with open(zip_structure_file, 'r', encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if line:
                            zip_structure_lines.add(line) # Add each line from zip_structure.txt
            except Exception as e:
                print(f"Warning: Error reading zip_structure.txt: {e}")
        # --- NEW: 3. Read zip_structure.txt and collect lines ---


        # --- 4. Check favorites against WatcherOutput and zip_structure ---
        for fav_key in favorites:
            parts = fav_key.split('|')
            if len(parts) == 2:
                folder_name, pc_filename = parts
                pc_filename_base = os.path.splitext(pc_filename)[0] # Get base name without extension
                search_substring = f"{folder_name.lower()}/{pc_filename_base.lower()}" # Construct substring for search

                found_in_watcher_output = False
                for filepath in watcher_filepaths:
                    normalized_filepath = filepath.lower().replace('\\', '/')
                    if search_substring in normalized_filepath: # Check if substring is IN filepath
                        found_in_watcher_output = True
                        break # No need to check other filepaths if found

                # --- NEW: Check in zip_structure_lines if not found in WatcherOutput ---
                found_in_zip_structure = False
                if not found_in_watcher_output: # Only check zip_structure if NOT found in WatcherOutput
                    for zip_line in zip_structure_lines:
                        normalized_zip_line = zip_line.lower().replace('\\', '/')
                        if search_substring in normalized_zip_line: # Check if substring is IN zip_structure line
                            found_in_zip_structure = True
                            break # No need to check other zip_structure lines if found
                # --- NEW: Check in zip_structure_lines if not found in WatcherOutput ---


                if found_in_watcher_output or found_in_zip_structure: # MODIFIED CHECK - OR condition
                    valid_favorites.add(fav_key) # Add to valid favorites if found in either file
                else:
                    print(f"DEBUG: Favorite '{fav_key}' not found in WatcherOutput.txt OR zip_structure.txt, removing from favorites.") # Debug print for removed favorite
            else:
                print(f"Warning: Invalid favorite key format: '{fav_key}'. Skipping.") # Warning for invalid format

        # --- 5. Update favorites and write back to file ---
        if valid_favorites != favorites: # Only write if there were changes
            self.favorite_configs = valid_favorites
            self.write_favorites()
            print("DEBUG: Favorites.txt updated, invalid entries removed.") # Debug print for update
        else:
            self.favorite_configs = valid_favorites # Ensure self.favorite_configs is updated even if no changes to write
            print("DEBUG: No invalid favorites found, Favorites.txt not updated.") # Debug print for no update

        return self.favorite_configs


    def write_favorites(self):
        """Writes the current set of favorite configurations to Favorites.txt."""
        try:
            with open(self.favorites_file_path, "w", encoding="utf-8") as f:
                for fav in sorted(list(self.favorite_configs)):
                    f.write(fav + "\n")
            print("Successfully wrote favorites to Favorites.txt") # Confirmation message
        except Exception as e:
            print(f"Error writing to Favorites.txt: {e}") # Error handling message
  
  

    def is_favorite(self, vehicle_folder, pc_filename):
        """Checks if a configuration is in the favorites list."""
        fav_key = f"{vehicle_folder}|{pc_filename}"
        return fav_key in self.favorite_configs




    def add_to_favorites(self, vehicle_folder, pc_filename):
        """Adds a configuration to the favorites list and updates Favorites.txt, showing a scanning window."""
        scanning_win = None  # Initialize scanning_win
        try:
            scanning_win = self.show_scanning_window(text="Added to Favorites")
            fav_key = f"{vehicle_folder}|{pc_filename}"
            self.favorite_configs.add(fav_key)
            self.write_favorites()
        except Exception as e:
            print(f"Error in add_to_favorites: {e}")
            messagebox.showerror("Error", f"Error adding to favorites: {e}", parent=self.master)  # Show error messagebox
        finally:
            time.sleep(0.725)
            if scanning_win:
                scanning_win.destroy()

    def remove_from_favorites(self, vehicle_folder, pc_filename):
        """Removes a configuration from the favorites list and updates Favorites.txt, showing a scanning window."""
        scanning_win = None  # Initialize scanning_win
        try:
            scanning_win = self.show_scanning_window(text="Removed from Favorites")
            fav_key = f"{vehicle_folder}|{pc_filename}"
            if fav_key in self.favorite_configs:
                self.favorite_configs.remove(fav_key)
                self.write_favorites()
        except Exception as e:
            print(f"Error in remove_from_favorites: {e}")
            messagebox.showerror("Error", f"Error removing from favorites: {e}", parent=self.master) # Show error messagebox
        finally:
            time.sleep(0.725)
            if scanning_win:
                scanning_win.destroy()

 





    def _initial_details_layout(self, subgrid_data, zip_file, search_query=""):
        """Handles initial layout logic after the details window is drawn."""
        def initial_layout_logic():
            print("\n--- _initial_details_layout.initial_layout_logic() DEBUG ---")
            print(f"  DEBUG: initial_layout - Received zip_file: {zip_file}")

            filtered_subgrid_data = subgrid_data


            print("DEBUG: _initial_details_layout - Flattening subgrid_data...")
            flattened_data = []
            for sublist in filtered_subgrid_data: # Assuming subgrid_data is a list of lists (or similar structure)
                if isinstance(sublist, list): # Check if it's actually a list (safety check)
                    flattened_data.extend(sublist) # Extend flattened list with items from sublist
                else:
                    flattened_data.append(sublist) # If not a list, append directly
            filtered_subgrid_data = flattened_data # Replace original with flattened list
            print(f"DEBUG: _initial_details_layout - subgrid_data FLATTENED. Total items: {len(filtered_subgrid_data)}")

            
            def get_config_value(item):
                """Helper function to extract and safely convert 'Value' to float for sorting."""
                picture_path, spawn_cmd, zip_file, info_data, folder_name = item
                zip_file_base_name = os.path.splitext(zip_file)[0]
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                individual_info_path = self.find_individual_info_file(
                    folder_name, zip_file_base_name, config_name
                )
                #value = float('inf')  # Default high value for items without a valid "Value" 
                value = float('-inf')  # Default low value for items without a valid "Value" 
                if individual_info_path and os.path.exists(individual_info_path):
                    individual_info_json, _ = self._load_individual_info(individual_info_path)
                    value_str = individual_info_json.get("Value", None)
                    if value_str:
                        try:
                            value = float(value_str)
                        except ValueError:
                            pass  # Keep default 'inf' for non-numeric values
                return value

            print("DEBUG: _initial_details_layout - Sorting subgrid_data by 'Value'...")
            filtered_subgrid_data.sort(key=get_config_value) # Sort by 'Value'
            print("DEBUG: _initial_details_layout - subgrid_data SORTED by 'Value'.")
            # --- NEW: Sorting logic by "Value" ---




            # --- Calculate paged_data FIRST for the initial page ---
            start_index = self.details_page * self.items_per_page
            end_index = start_index + self.items_per_page
            paged_data = filtered_subgrid_data[start_index:end_index]

             # Get first page data
            print(f"  DEBUG: Initial Load - paged_data calculated for first page, item count: {len(paged_data)}") # Debug
            print(f"  DEBUG: items_per_page: {self.items_per_page}") # Debug
            print(f"  DEBUG: details_batch_size: {self.details_batch_size}") # Debug

            self.details_batches = [
                paged_data[i: i + self.details_batch_size]
                for i in range(0, len(paged_data), self.details_batch_size)
            ]
            print(f"  DEBUG: Initial Load - Number of batches created: {len(self.details_batches)}") # Debug
            if self.details_batches:
                print(f"  DEBUG: Initial Load - Size of first batch: {len(self.details_batches[0]) if self.details_batches else 0}") # Debug - Size of first batch

            # --- DEBUG: Inspect content of the FIRST batch ---
            if self.details_batches and self.details_batches[0]:
                print("  DEBUG: First 3 items in the FIRST batch (filenames):")
                for i in range(min(3, len(self.details_batches[0]))):
                    item = self.details_batches[0][i]
                    if item and item[0]:
                        print(f"    - Item {i+1}: {os.path.basename(item[0])}")
                    else:
                        print(f"    - Item {i+1}: Item data or picture_path is None")
            else:
                print("  DEBUG: First batch is EMPTY or NO batches created.")
            # --- DEBUG: Inspect content of the FIRST batch ---

            # --- ENSURE INITIALIZATION of current_details_batch_index here, BEFORE calling load_next_batch_details ---
            self.current_details_batch_index = 0 # <--- ENSURE INITIALIZATION HERE
            print(f"DEBUG: _initial_details_layout - ENSURING current_details_batch_index = {self.current_details_batch_index} BEFORE load_next_batch_details()") # Debug - Initialization Check

            if len(filtered_subgrid_data) > 0:
                self.start_details_loading_animation()
                self.show_progress_bar_details() # <----- SHOW PROGRESS BAR HERE
                print("DEBUG: _initial_details_layout - Calling load_next_batch_details() NOW...") # Debug - Before Call
                self.load_next_batch_details() # Start loading batches (now only for paged_data)
                print("DEBUG: _initial_details_layout - load_next_batch_details() RETURNED.") # Debug - After Call


            print("  DEBUG: Calling _set_initial_sidebar_content from initial_layout...")
            self._set_initial_sidebar_content(filtered_subgrid_data, zip_file)
            print("  DEBUG: _set_initial_sidebar_content RETURNED.")

            self.details_count_label.config(text=f"Total: {len(filtered_subgrid_data)}")
            print("  DEBUG: Details window initial layout complete.")

            self._update_details_pagination_bar() # <--- ADDED: Update pagination bar initially
            self._schedule_sidebar_update_from_image()
            self.details_window.after_idle(lambda: setattr(self, 'details_sidebar_update_locked', True))
            print("--- _initial_details_layout.initial_layout_logic() DEBUG EXIT ---\n")

            if self.details_window_is_favorites_filtered:
                self.details_view_favorites_button.config(text="View All") # Set button text to "View All" - Favorites Mode
            else:
                self.details_view_favorites_button.config(text="View Favorites") # Set button text to "View Favorites" - View All Mode


        self.details_window.after(10, initial_layout_logic)
  
        
   




    def _set_initial_sidebar_content(self, subgrid_data, zip_file): # <--- zip_file is "folder_grouped" here
        """Sets the initial content of the details sidebar based on default or first item."""
        print("\n--- _set_initial_sidebar_content() DEBUG ---")
        print(f"  DEBUG: _set_initial_sidebar_content - Received zip_file ARGUMENT: {zip_file}")

        default_config_item = self.find_default_config_item_details(subgrid_data, zip_file)
        if default_config_item:
            print("  DEBUG: Default config item FOUND, using default config for sidebar...")
            default_picture_path, default_spawn_cmd, _, default_info_data, folder_name = default_config_item

            default_item_zip_file = default_config_item[2] # Get zip_file from the item tuple
            print(f"  DEBUG: Default config item's zip_file value: {default_item_zip_file}")

            # --- MODIFIED: Pass default_item_zip_file instead of zip_file arg ---
            self.update_details_sidebar_content(default_info_data, default_picture_path, default_item_zip_file, folder_name) # Pass default_item_zip_file
            # --- MODIFIED: Pass default_item_zip_file instead of zip_file arg ---

            self.update_details_sidebar_config_name(default_spawn_cmd)
            self.is_details_sidebar_showing_default = True

            # --- ENSURE sidebar attributes are set for DEFAULT config ---
            self.current_details_sidebar_spawn_cmd = default_spawn_cmd
            self.current_details_sidebar_info_data = default_info_data
            self.current_details_sidebar_picture_path = default_picture_path
            self.current_details_sidebar_zip_file = default_item_zip_file # Store item-specific zip_file
            self.current_details_folder = folder_name # <---- ENSURE folder_name is set here as well for default
            # --- ENSURE sidebar attributes are set for DEFAULT config ---
            print("  DEBUG: Calling update_details_sidebar_favorites_button_text() for DEFAULT config...") # Debug - Button Update Call
            self.update_details_sidebar_favorites_button_text() # <--- ADD CALL HERE - FOR DEFAULT CONFIG
            print("  DEBUG: update_details_sidebar_favorites_button_text() RETURNED (DEFAULT config).") # Debug - Button Update Return

            print("  DEBUG: Initial sidebar content set to DEFAULT config.")
        elif subgrid_data:
            print("  DEBUG: No default config, using FIRST config for sidebar...")
            first_item = subgrid_data[0]
            first_picture_path, first_spawn_cmd, _, first_info_data, folder_name = first_item

            first_item_zip_file = first_item[2] # Get zip_file from the item tuple
            print(f"  DEBUG: First item's zip_file value: {first_item_zip_file}")

            # --- MODIFIED: Pass first_item_zip_file instead of zip_file arg ---
            self.update_details_sidebar_content(first_info_data, first_picture_path, first_item_zip_file, folder_name) # Pass first_item_zip_file
            # --- MODIFIED: Pass first_item_zip_file instead of zip_file arg ---

            self.update_details_sidebar_config_name(first_spawn_cmd)
            self.is_details_sidebar_showing_default = True

            # --- ENSURE sidebar attributes are set for FIRST config (fallback) ---
            self.current_details_sidebar_spawn_cmd = first_spawn_cmd
            self.current_details_sidebar_info_data = first_info_data
            self.current_details_sidebar_picture_path = first_picture_path
            self.current_details_sidebar_zip_file = first_item_zip_file # Store item-specific zip_file
            self.current_details_folder = folder_name # <---- ENSURE folder_name is set here as well for first item
            # --- ENSURE sidebar attributes are set for FIRST config (fallback) ---
            print("  DEBUG: Calling update_details_sidebar_favorites_button_text() for FIRST config...") # Debug - Button Update Call
            self.update_details_sidebar_favorites_button_text() # <--- ADD CALL HERE - FOR FIRST CONFIG
            print("  DEBUG: update_details_sidebar_favorites_button_text() RETURNED (FIRST config).") # Debug - Button Update Return

            print("  DEBUG: Initial sidebar content set to FIRST config.")
        else:
            # --- MODIFIED: Show messagebox and debug info when no configs are available + OKAY/CANCEL MESSAGE BOX ---
            folder_name = self.current_details_folder # <--- ADDED: Assign folder_name here
            message = "No configurations available for item,\n\nhere is what should have been displayed [debug]:\n"
            message += f"\n- Zip File: {zip_file}" # Include zip_file info
            message += f"\n- Folder Name: {folder_name}" # Include folder_name info  # <-- NOW folder_name is assigned

            # --- NEW: Include filter information in messagebox if data subset is active ---
            if self.is_data_subset_active:
                filter_info_text = self.format_filter_settings_for_messagebox() # Get formatted filter info
                if filter_info_text:
                    message += "\n\n--- Global Filters Active ---\n" + filter_info_text # Append filter info
                else:
                    message += "\n\n--- Global Filters Active (No specific criteria set) ---"
            # --- NEW: Include filter information in messagebox if data subset is active ---

            # --- NEW: Add list of configurations that caused the folder to appear ---
            if self.full_data and folder_name in self.full_data:
                configs_list_str = "\n".join([f"- {cfg[1]}" for cfg in self.full_data[folder_name]]) # Extract spawn commands
                message += "\n\nConfigurations for this folder (if available):\n" + configs_list_str
            else:
 
                self.no_configs_messagebox_condition = True  
                #message += "\n\nNo configurations found in full_data for this folder."


            self.details_search_var.set("") # Clear details search bar
            self.no_configs_messagebox_condition = True 
            self.perform_details_search() # Perform details search with cleared query
            print("DEBUG: messagebox.askokcancel - User clicked OK, details search bar cleared and perform_details_search() called.") # Debug message



            print("  DEBUG: No subgrid data, sidebar will remain placeholder (and messagebox shown).")
            print("  DEBUG: Calling update_details_sidebar_favorites_button_text() - NO DATA case (button should be 'Add')...") # Debug - Button Update Call - No Data
            self.update_details_sidebar_favorites_button_text() # <--- ADD CALL HERE - FOR NO DATA CASE - Should default to "Add"
            print("  DEBUG: update_details_sidebar_favorites_button_text() RETURNED (NO DATA case).") # Debug - Button Update Return - No Data
        print("--- _set_initial_sidebar_content() DEBUG EXIT ---\n")
        



    def format_filter_settings_for_messagebox(self):
        """
        Formats the currently active global filter settings into a user-readable string.
        Returns an empty string if no global filters are active or settings file is not found/readable.
        """
        if not self.is_data_subset_active:
            return "" # Return empty string if data subset is not active

        filter_settings = self.load_filter_settings() # Load current filter settings
        if not filter_settings:
            return "No filter criteria set in global filters." # Indicate no criteria set

        filter_info_lines = []
        for criterion, setting in filter_settings.items():
            if isinstance(setting, list): # For dual entries
                for entry_setting in setting:
                    if entry_setting['entry'] and entry_setting['button'] == "On": # Check if entry has text AND button is "On"
                        filter_info_lines.append(f"- {criterion} ({'Below' if entry_setting['index'] == 1 else 'Above'}): '{entry_setting['entry']}'")
            elif setting['entry'] and setting['button'] == "On": # For single entries, check if entry has text AND button is "On"
                filter_info_lines.append(f"- {criterion} (Contains): '{setting['entry']}'")

        if not filter_info_lines:
            return "Global filters are active, but no criteria are currently set to filter data." # Indicate active but no criteria

        return "\n".join(filter_info_lines) # Join lines into a single string for messagebox
  
  

    def _schedule_sidebar_update_from_image(self):
        """Schedules the sidebar update after image load."""
        def update_sidebar_from_image():
            """Helper function to update sidebar content based on image filename."""
            print("DEBUG: update_sidebar_from_image() called")
            try:
                photo_image = self.details_sidebar_image_label.image
                if hasattr(photo_image, 'filename'):
                    picture_path = photo_image.filename
                else:
                    print("WARNING: 'filename' attribute not found in PhotoImage object.")
                    picture_path = None

                if picture_path:
                    print(f"DEBUG: Sidebar image path from label: {picture_path}")
                    extracted_info = self.extract_info_from_sidebar_image(picture_path)
                    if extracted_info:
                        individual_info_path = self.find_individual_info_file(
                            extracted_info["folder_name"],
                            extracted_info["zip_file_base_name"],
                            extracted_info["config_name"]
                        )
                        print(f"  DEBUG: Determined individual_info_path from image: {individual_info_path}")
                        self.update_details_sidebar_individual_info(individual_info_path)
                    else:
                        print("  ERROR: Could not extract info from image filename after image load.")
                else:
                    print("  ERROR: Could not determine full image path after image load.")

            except Exception as e:
                print(f"  ERROR: Exception in update_sidebar_from_image: {e}")

        self.details_window.after(50, update_sidebar_from_image)
        print("--- display_subgrid_in_new_window() EXIT ---\n")  # Debug Exit



    # ------------------------------------------------------------
    # update details sidebar info
    # ------------------------------------------------------------

    def _load_individual_info(self, individual_info_path):
        """
        Loads and extracts information from the individual JSON file, now handling "Author".
        """
        extracted_info = {}
        file_content = ""

        if individual_info_path and os.path.exists(individual_info_path):
            # --- Check Cache First ---
            if individual_info_path in self.individual_info_cache:
                #print(f"DEBUG: _load_individual_info - Cache HIT for: {individual_info_path}") # Debug - Cache Hit
                return self.individual_info_cache[individual_info_path], "" # Return cached data and empty file_content
            # --- Cache Check End ---

            #print(f"DEBUG: _load_individual_info - Cache MISS for: {individual_info_path} - Loading from disk.") # Debug - Cache Miss

            try:
                # Method 1: Standard JSON Load
                with open(individual_info_path, 'r', encoding="utf-8") as f:
                    file_content = f.read() # Read the content FIRST for fallback methods
                    #print(f"  DEBUG: _load_individual_info - File content READ from: {individual_info_path}") # DEBUG - File Read Success
                    try:
                        extracted_info = json.loads(file_content, strict=False) # strict=False to allow minor JSON errors
                        #print("  DEBUG: _load_individual_info - Successfully loaded JSON data using json.loads(strict=False) (Method 1)")
                        #print(f"  DEBUG: _load_individual_info - Extracted Info (Method 1): {extracted_info}") # DEBUG - Extracted Info - METHOD 1

                        # --- Cache Data on Load ---
                        #self.individual_info_cache[individual_info_path] = extracted_info
                        #disabling cache
                        # --- Cache Data End ---

                        return extracted_info, file_content
                    except json.JSONDecodeError as e_strict:
                       # print(f"  WARNING: JSONDecodeError loading individual info file {individual_info_path} (Method 1 strict=False): {e_strict}. Attempting relaxed JSON load with comma fix (Method 1.2).")

                        # Method 1.2: Attempt to fix commas and then load JSON
                        try:
                            # Try to fix missing commas - VERY basic attempt, might need refinement
                            fixed_content = re.sub(r'"(.*?)"\s*:\s*"(.*?)"\s*(?=\})', r'"\1": "\2",', file_content) # Basic comma insertion before '}'
                            fixed_content = re.sub(r'"(.*?)"\s*:\s*"(.*?)"\s*(?=")', r'"\1": "\2",', fixed_content) # Basic comma insertion before '"'
                            # Remove trailing commas if added at the end of objects or arrays - basic cleanup
                            fixed_content = re.sub(r',(\s*?[\}\]])', r'\1', fixed_content)


                            extracted_info = json.loads(fixed_content, strict=False)
                            #print("  DEBUG: _load_individual_info - Successfully loaded JSON data after comma fix (Method 1.2).")
                            #print(f"  DEBUG: _load_individual_info - Extracted Info (Method 1.2 - Comma Fix): {extracted_info}") # DEBUG - Extracted Info - METHOD 1.2

                            # --- Cache Data on Load ---
                            self.individual_info_cache[individual_info_path] = extracted_info
                            # --- Cache Data End ---

                            return extracted_info, file_content # Return original content, not fixed, for regex fallback

                        except json.JSONDecodeError as e_fix:
                            #print(f"  WARNING: JSONDecodeError after comma fix (Method 1.2): {e_fix}. Attempting regex fallback (Method 2).")
                            # Fallback to regex if even comma fix fails


                            # Method 2: Regex Fallback for JSON-like structure
                            extracted_info_regex = self.extract_info_with_regex(file_content)
                            if extracted_info_regex:
                                #print("  DEBUG: _load_individual_info - Successfully extracted info using regex fallback (Method 2).")
                                #print(f"  DEBUG: _load_individual_info - Extracted Info (Method 2 - Regex): {extracted_info_regex}") # DEBUG - Extracted Info - METHOD 2

                                # --- Cache Data on Load ---
                                self.individual_info_cache[individual_info_path] = extracted_info_regex
                                # --- Cache Data End ---

                                return extracted_info_regex, file_content
                            else:
                                #print("  ERROR: _load_individual_info - Regex fallback (Method 2) failed. Trying secondary extraction method (Method 3)...")

                                # Method 3: Secondary lenient regex/string search
                                extracted_info_secondary = self.extract_info_secondary_method(file_content)
                                if extracted_info_secondary:
                                    #print("  DEBUG: _load_individual_info - Successfully extracted info using secondary method (Method 3).")
                                    #print(f"  DEBUG: _load_individual_info - Extracted Info (Method 3 - Secondary Method): {extracted_info_secondary}") # DEBUG - Extracted Info - METHOD 3

                                    # --- Cache Data on Load ---
                                    self.individual_info_cache[individual_info_path] = extracted_info_secondary
                                    # --- Cache Data End ---

                                    return extracted_info_secondary, file_content
                                else:
                                    print("  ERROR: _load_individual_info - Secondary extraction method (Method 3) also failed. Using default values.")
                                    return {}, file_content # Return empty dict if all methods fail

            except Exception as e:
                print(f"  ERROR: Failed to load individual info file due to file operation error. Exception: {e}")
                return {}, "" # Return empty and empty content on file operation failure
        else:
             print(f"  WARNING: _load_individual_info - File does NOT exist at path: {individual_info_path}") # Debug - File Does Not Exist
        return {}, "" # Return empty dict and empty content if no file path or file not exists

        

    def _initialize_combined_info(self): # MODIFIED - Removed Top Speed
        """
        Initializes the combined info dictionary with default "N/A" values.
        """
        return {
            "Description": "N/A",
            # "Top Speed": "N/A", # REMOVED - TOP SPEED
            "Value": "N/A",
            "Brand": "N/A",
            "Body Style": "N/A",
            "Weight": "N/A",
            "Years": "N/A",
            "Configuration": "N/A"
        }

    def _extract_top_speed(self, extracted_info):
        """
        Extracts and formats the top speed from extracted information.
        """
        if "Top Speed" in extracted_info and isinstance(extracted_info["Top Speed"], (int, float)):
            top_speed_value = float(extracted_info["Top Speed"])
            top_speed_kmh = round(top_speed_value * 3.6, 0)
            return f"{top_speed_kmh} km/h"
        return "N/A"

    def _extract_brand(self, extracted_info, main_info_data):
        """
        Extracts the brand, prioritizing main info data if available.
        """
        if main_info_data and main_info_data.get("Brand"):
            brand = main_info_data["Brand"]
            print("  DEBUG: Got Brand from main info data: " + brand)
            return brand
        elif extracted_info.get("Brand"):
            brand = extracted_info.get("Brand")
            print(f"  DEBUG: Got Brand from individual JSON data: {brand}")
            return brand
        return "N/A"

    def _merge_extracted_details(self, extracted_info, combined_info):
        """
        Merges specific details from extracted_info into combined_info.
        """
        for key in ["Description", "Value", "Weight", "Configuration"]:
            if extracted_info.get(key) and extracted_info.get(key) != "N/A":
                combined_info[key] = extracted_info.get(key)

    def _extract_years(self, extracted_info, main_info_data, file_content):
        """
        Extracts years information, prioritizing main info data and using various methods.
        """
        print(f"  DEBUG: Checking if main_info_data has 'Years' key: {main_info_data and 'Years' in main_info_data}")
        if main_info_data and 'Years' in main_info_data and main_info_data.get("Years"):
            print(f"  DEBUG: Attempting to extract Years from main info data: {main_info_data.get('Years')}")
            years_data = main_info_data.get("Years")
            years_str = self.extract_years_string_from_data(years_data)
            if years_str and years_str != "N/A":
                print(f"  DEBUG: Got Years from main info data: {years_str}")
                return years_str
            else:
                print("   DEBUG: Could not extract years from main info data.")
        else:
            print(f"  DEBUG: main_info_data does not have 'Years' or is invalid. Attempting Individual extraction.")
            if extracted_info.get("Years"):
                print(f"  DEBUG: Attempting to extract Years from individual json using various methods.")
                years_data = extracted_info.get("Years")
                years_str = self.extract_years_string_from_data(years_data)
                if years_str and years_str != "N/A":
                    print(f"   DEBUG: Got Years from individual JSON data: {years_str}")
                    return years_str
                else:
                    print("    DEBUG: Could not get years from individual json, resorting to 'N/A'")
                    return "N/A"
            else:
                print("  DEBUG: Individual data has no 'Years' key to extract. Resoting to 'N/A'")
                return "N/A"

        if file_content:
            try:
                years_index = file_content.find('"Years":')
                if years_index != -1:
                    next_20_chars = file_content[years_index + len('"Years":'):years_index + len('"Years":') + 20]
                    print(f'   DEBUG: Found these characters after "Years": in INDIVIDUAL: {next_20_chars}')
            except Exception as e:
                print(f"  DEBUG: Error getting characters after 'Years:' in INDIVIDUAL: {e}")
        return "N/A" # Should not reach here in normal flow, but for safety

    def _extract_body_style(self, extracted_info, main_info_data):
        """
        Extracts body style information, prioritizing different sources.
        """
        if extracted_info.get("Body Style"):
            return extracted_info.get("Body Style")
        elif main_info_data and main_info_data.get("Body Style"):
            body_style = main_info_data.get("Body Style")
            print("  DEBUG: Got Body Style from main info data (fallback): " + body_style)
            return body_style
        elif main_info_data and main_info_data.get("Derby Class"):
            body_style = main_info_data.get("Derby Class")
            print("  DEBUG: Got Body Style from main info data (Derby Class fallback): " + body_style)
            return body_style
        return "N/A"

    def _set_configuration_label(self, combined_info):
        """
        Sets the "Selected Configuration" label in the details sidebar.
        """
        if combined_info["Configuration"] != "N/A":
            self.details_sidebar_selected_config_label_val.config(text=combined_info["Configuration"])
            print(f"   DEBUG: Set Configuration: {combined_info['Configuration']}")
        elif hasattr(self, 'current_details_sidebar_spawn_cmd'):
            self.details_sidebar_selected_config_label_val.config(text="Custom/Unspecified")

    def _populate_sidebar_labels(self, combined_info): # MODIFIED - Zip File Label
        """
        Populates the labels in the details sidebar with information from combined_info.
        """
        self.details_sidebar_description_label_val.config(text=combined_info["Description"])
        # self.details_sidebar_topspeed_label_val.config(text=combined_info["Top Speed"]) # REMOVED - TOP SPEED
        self.details_sidebar_value_label_val.config(text=combined_info["Value"])
        self.details_sidebar_brand_label_val.config(text=combined_info["Brand"])
        self.details_sidebar_bodystyle_label_val.config(text=combined_info["Body Style"])
        self.details_sidebar_weight_label_val.config(text=combined_info["Weight"])
        self.details_sidebar_years_label_val.config(text=combined_info["Years"])

    def _pack_sidebar_labels(self): # MODIFIED - Zip File Label
        """
        Packs the labels in the details sidebar to make them visible.
        """
        self.details_sidebar_description_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(10, 0))
        self.details_sidebar_description_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))

        # self.details_sidebar_topspeed_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0)) # REMOVED - TOP SPEED
        # self.details_sidebar_topspeed_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5)) # REMOVED - TOP SPEED
        self.details_sidebar_zipfile_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0)) # ADDED - ZIP FILE
        self.details_sidebar_zipfile_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5)) # ADDED - ZIP FILE

        self.details_sidebar_value_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_value_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_brand_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_brand_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_bodystyle_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_bodystyle_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_weight_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_weight_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5))
        self.details_sidebar_years_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0))
        self.details_sidebar_years_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 10))


    def update_details_sidebar_individual_info(self, individual_info_path, main_info_data=None):
        """
        Updates the details sidebar with information, broken down into functions.
        """
        extracted_info, file_content = self._load_individual_info(individual_info_path)
        combined_info = self._initialize_combined_info()

        # combined_info["Top Speed"] = self._extract_top_speed(extracted_info) # REMOVED
        combined_info["Brand"] = self._extract_brand(extracted_info, main_info_data)
        self._merge_extracted_details(extracted_info, combined_info)
        combined_info["Years"] = self._extract_years(extracted_info, main_info_data, file_content)
        combined_info["Body Style"] = self._extract_body_style(extracted_info, main_info_data)

        self._set_configuration_label(combined_info)
        self._populate_sidebar_labels(combined_info)
        self._pack_sidebar_labels()

    def extract_years_string_from_data(self, years_data):
        """
        Extracts a formatted year string from various "Years" data formats.
        Handles dictionary with "min" and "max," single values, lists, or strings with numbers.
        """
        print(f"  DEBUG: extract_years_string_from_data - input data: {years_data}, type: {type(years_data)}")
        if isinstance(years_data, dict):
            years_list = []
            min_year = None
            max_year = None
            if "min" in years_data and isinstance(years_data["min"], (int, float)):
                  min_year = int(years_data["min"])
                  years_list.append(min_year)
            if "max" in years_data and isinstance(years_data["max"], (int, float)):
                  max_year = int(years_data["max"])
                  years_list.append(max_year)
            if len(years_list) == 2:
                years_list.sort() # Sort numerically
                result = f"{years_list[0]} - {years_list[1]}" # Format min - max
            elif len(years_list) == 1:
                 result = f"{years_list[0]}" # Just single value
            else:
                print("  DEBUG: extract_years_string_from_data (dict) could not get specific value, check structure. returning 'N/A'")
                result = "N/A"
            print(f"  DEBUG: extract_years_string_from_data (dict result): {result}")
            return result

        elif isinstance(years_data, list):
            years_list = [str(int(year)) for year in years_data if isinstance(year, (int, float))]
            result =  " - ".join(years_list) if years_list else "N/A"
            print(f"  DEBUG: extract_years_string_from_data (list result): {result}")
            return result
        elif isinstance(years_data, (int, float)):
            result = str(int(years_data))
            print(f"  DEBUG: extract_years_string_from_data (number result): {result}")
            return result
        elif isinstance(years_data, str):
            years_str = str(years_data)
            numbers = re.findall(r'\d+', years_str) # Find ALL numbers in the string
            numbers = [int(num) for num in numbers if num] # Remove non number chars and cast to ints
            if not numbers:
                print(f"  DEBUG: extract_years_string_from_data (string fallback) could not find any numbers, returning 'N/A'")
                return "N/A"
            if len(numbers) > 1:
                numbers.sort()
                result = f"{numbers[0]} - {numbers[-1]}" # format min - max, even if more than 2
            elif numbers:
                 result = f"{numbers[0]}" # take first if only one
            else:
                result = "N/A"
            print(f"  DEBUG: extract_years_string_from_data (string fallback result): {result}")
            return result
        else:
            print("  DEBUG: extract_years_string_from_data (unhandled format), returning N/A.")
            return "N/A"

                 
    def extract_info_with_regex(self, file_content):
        """
        Fallback method to extract info from the file content using regular expressions,
        now including "Author".
        """
        info_data = {}
        patterns = {
            "Description": r'"Description"\s*:\s*"([^"]*)"',
            "Value": r'"Value"\s*:\s*"([^"]*)"',
            "Brand": r'"Brand"\s*:\s*"([^"]*)"',
            "Body Style": r'"Body Style"\s*:\s*"([^"]*)"',
            "Weight": r'"Weight"\s*:\s*"([^"]*)"',
            "Years": r'"Years"\s*:\s*({.*?})',  # Modified to capture the whole object.
            "Configuration": r'"Configuration"\s*:\s*"([^"]*)"',
            "Author": r'"Author"\s*:\s*"([^"]*)"', # <-- ADDED pattern for "Author"
         }

        for key, pattern in patterns.items():
            match = re.search(pattern, file_content, re.IGNORECASE)
            if match:
                info_data[key] = match.group(1)

        return info_data

    def extract_info_secondary_method(self, file_content):
        """
        Secondary method to extract info using a more lenient approach,
        now also looking for "Author".
        """
        info_data = {}
        lines = file_content.split('\n')
        for line in lines:
            match = re.search(r'\s*"?(.*?)"?\s*:\s*"?(.*?)"?,?', line)
            if match:
                key = match.group(1).strip()
                value = match.group(2).strip()
                if key in ["Description", "Value", "Brand", "Body Style", "Weight", "Years", "Configuration", "Author"]: # <-- ADDED "Author" to key list
                    info_data[key] = value
        return info_data

        
    def perform_details_search(self):
        """Performs search in details view, enforcing Favorites filter and ZIP filter."""

        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win

        print("\n--- perform_details_search() DEBUG ENTRY ---")
        query = self.details_search_var.get().strip().lower()
        print(f"  DEBUG: perform_details_search - Search Query from Entry: '{query}'")
        print(f"  DEBUG: perform_details_search - details_window_is_favorites_filtered: {self.details_window_is_favorites_filtered}") # DEBUG - Favorites Filter State
        print(f"  DEBUG: perform_details_search - details_window_is_data_subset_active: {self.is_data_subset_active}") # DEBUG - Data Subset Active State


        print(f" DEBUG: perform_details_search - BEFORE page reset - Current Page: 0")
        self.details_page = 0
        print(f" DEBUG: perform_details_search - AFTER page reset - Current Page: 0")

        data_to_filter = list(self.details_data)
        intermediate_filtered_data = list(data_to_filter) # Start with all data, initially unfiltered for query


        # --- APPLY ZIP FILTER FIRST ---
        zip_filter_text = self.zip_search_button.cget("text")
        if zip_filter_text != "Search within: All Zips" and zip_filter_text != "Search within: Favorites" and zip_filter_text != "Search within: Filtered": # <--- MODIFIED CHECK HERE
            selected_zip = zip_filter_text.replace("Search within: ", "")
            if selected_zip == "Custom Configurations":
                intermediate_filtered_data = [item for item in intermediate_filtered_data if "_user--" in item[0]]
            else: # Specific zip selected
                intermediate_filtered_data = [item for item in intermediate_filtered_data if item[2] == selected_zip]
            print(f"  DEBUG: perform_details_search - Applied ZIP filter: '{selected_zip}'. Data count: {len(intermediate_filtered_data)}") # Debug
        else:
            print(f"  DEBUG: perform_details_search - ZIP filter is NOT active (showing all zips or filtered).")


        # --- APPLY SEARCH QUERY FILTER ---
        if query: # Apply query filter if there's a query string
            print("  DEBUG: perform_details_search - Applying SEARCH QUERY filter: '{query}'...")
            query_filtered_data = self._filter_details_data_by_query_criteria(intermediate_filtered_data, query) # Apply query criteria ONLY
            intermediate_filtered_data = query_filtered_data # Update data to be further filtered
            print(f"  DEBUG: perform_details_search - Data count AFTER QUERY filter: {len(intermediate_filtered_data)}") # Debug - Count after Query Filter
        else:
            print("  DEBUG: perform_details_search - NO SEARCH QUERY to apply.")


        # --- APPLY FAVORITES FILTER (if active) ---
        if self.details_window_is_favorites_filtered:
            print("  DEBUG: perform_details_search - Applying FAVORITES filter...")
            favorites_filtered_data = self._apply_details_favorites_only_filter(intermediate_filtered_data) # Apply Favorites filter NOW
            intermediate_filtered_data = favorites_filtered_data # Update data to be further filtered
            print(f"  DEBUG: perform_details_search - Data count AFTER FAVORITES filter: {len(intermediate_filtered_data)}") # Debug - Count after Favorites Filter
        else:
            print("  DEBUG: perform_details_search - Favorites filter is NOT active.")


        # --- APPLY DATA SUBSET FILTER (if active) ---
        if self.is_data_subset_active:
            print("  DEBUG: perform_details_search - Applying DATA SUBSET filter...")
            subset_filtered_data = self._apply_details_data_subset_filter(intermediate_filtered_data) # Apply Data Subset filter LAST
            final_filtered_data = subset_filtered_data # This is the final filtered data
            print(f"  DEBUG: perform_details_search - Data count AFTER DATA SUBSET filter: {len(final_filtered_data)}") # Debug - Count after Data Subset Filter
            self.master.after(2500, self.check_and_auto_close_details_window) # Schedule check with delay
        else:
            print("  DEBUG: perform_details_search - Data Subset filter is NOT active.")
            final_filtered_data = intermediate_filtered_data # If not active, use data after query/favorites filters

        self.details_filtered_data = final_filtered_data # Assign the FINAL filtered list to details_filtered_data
        self.rebuild_simple_details()
        if self.details_count_label:
            self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}")

        self._update_details_pagination_bar()

        # --- NEW: Schedule auto-close check with 2-second delay ---


        print("--- ConfigViewerApp.perform_details_search() EXIT ---\n")

    

    def handle_zip_search_button_click(self):
        """Handles clicks on the 'Search within: Zips' button, checking filter modes."""
        print("\n--- handle_zip_search_button_click() DEBUG ENTRY ---") # Debug Entry
        print(f"  DEBUG: handle_zip_search_button_click - is_data_subset_active: {self.is_data_subset_active}") # Debug - Check flag
        print(f"  DEBUG: handle_zip_search_button_click - details_window_should_open_in_favorites_mode: {self.details_window_should_open_in_favorites_mode}") # Debug - Check flag

        if self.is_data_subset_active:
            print("  DEBUG: handle_zip_search_button_click - Data subset active - Showing messagebox.") # Debug - Condition True
            #messagebox.showinfo(
            #    "Zip Search Unavailable",
            #    "Please re-open vehicle in an unfiltered mode off to search by zip.",
            #    parent=self.details_window
            #)
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot search by zip while configurations window is filtered.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
            
            print("--- handle_zip_search_button_click() EXIT - Data subset active ---\n") # Debug Exit
            return
        if self.details_window_should_open_in_favorites_mode or self.zip_search_button.cget("text") == "Search within: Favorites": # <--- MODIFIED CHECK HERE
            print("  DEBUG: handle_zip_search_button_click - Favorites mode active - Showing messagebox.") # Debug - Condition True
            #messagebox.showinfo(
            #    "Zip Search Unavailable",
            #    "Please switch out of Favorites mode to search within zip.", # <--- MODIFIED MESSAGE HERE
            #    parent=self.details_window
            #)
            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot search by zip while in Favorites mode.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()


            print("--- handle_zip_search_button_click() EXIT - Favorites mode active ---\n") # Debug Exit
            return

        print("  DEBUG: handle_zip_search_button_click - No filters active - Showing dropdown.") # Debug - Condition False
        self.show_zip_search_dropdown_menu() # If no filters active, show the dropdown
        print("--- handle_zip_search_button_click() EXIT - Showing dropdown ---\n") # Debug Exit
     
     
     

    def show_zip_search_dropdown_menu(self):
        """Displays the zip search dropdown menu in the details window with smooth scrolling and a Close button."""
        if hasattr(self, 'zip_search_dropdown_window') and self.zip_search_dropdown_window and self.zip_search_dropdown_window.winfo_exists():
            self.zip_search_dropdown_window.destroy()
            return

        button = self.zip_search_button
        button_x = button.winfo_rootx()
        button_y = button.winfo_rooty() + button.winfo_height()

        self.zip_search_dropdown_window = dropdown_window = tk.Toplevel(self.details_window)
        dropdown_window.overrideredirect(True)
        dropdown_window.tk.call('tk', 'scaling', 1.25)

        dropdown_window.geometry(f"+{button_x}+{button_y}")
        dropdown_window.config(bg="#333333")
        #dropdown_window.grab_set()
        dropdown_window.attributes("-topmost", True)
        dropdown_window.config(highlightthickness=3, highlightbackground="#666666")
        

        # --- NEW: Main frame for dropdown window to contain canvas and button ---
        dropdown_main_frame = tk.Frame(dropdown_window, bg="#333333") # Main frame to pack canvas and button
        dropdown_main_frame.pack(fill=tk.BOTH, expand=True)
        # --- NEW: Main frame for dropdown window to contain canvas and button ---


        canvas = tk.Canvas(dropdown_main_frame, bg="#333333", highlightthickness=0, width=300, height=200) # Adjust width/height as needed
        scrollbar = tk.Scrollbar(dropdown_main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = tk.Frame(canvas, bg="#333333")

        scrollbar.pack(side="right", fill="y")
        canvas.pack(side="top", fill="both", expand=True) # Canvas packed to the TOP in main frame
        canvas.configure(yscrollcommand=scrollbar.set)
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw", width=400) # Adjust width if needed

        canvas.bind("<Enter>", lambda e: canvas.bind_all("<MouseWheel>", lambda ev: self.on_dropdown_mousewheel(ev, canvas))) # Reuse existing mousewheel function
        canvas.bind("<Leave>", lambda e: canvas.unbind_all("<MouseWheel>"))


        menu_options = ["All Zips", "Custom Configurations"]

        # Get unique zip names from details data
        zip_names = set()
        for item in self.details_data:
            zip_file = item[2]
            if zip_file != "user_custom_configs": # Exclude custom configs pseudo-zip
                zip_names.add(zip_file)
        sorted_zip_names = sorted(list(zip_names))
        menu_options.extend(sorted_zip_names)

        current_zip_filter_text = self.zip_search_button.cget("text") # Get current button text for comparison


        def on_menu_option_click(option):
            self.zip_search_button.config(text=f"Search within: {option}")
            self.zip_search_dropdown_window.destroy()
            self.zip_search_dropdown_window = None
            self.details_search_var.set("") # <--- CLEAR DETAILS SEARCH BAR TEXT HERE
            self.apply_zip_filter(option)
            if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
                self.current_detail_window.destroy()




        for option in menu_options:
            bg_color = "#555555"
            fg_color = "white"
            if f"Search within: {option}" == current_zip_filter_text: # Check if current option is selected
                bg_color = self.global_highlight_color # Highlight selected zip in orange
                fg_color = "white"


            dropdown_button = tk.Button(
                scrollable_frame, # <--- Place buttons in scrollable_frame
                text=option,
                font=("Segoe UI", 10, "bold"),
                command=lambda opt=option: on_menu_option_click(opt),
                borderwidth=1,
                relief="solid",
                anchor="w",
                padx=10,
                pady=5,
                bg=bg_color, # Use dynamic background color
                fg=fg_color  # Use dynamic foreground color
                
            )
            dropdown_button.pack(fill="x")
            dropdown_button.bind("<Enter>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg="lightgrey", fg="black"))
            dropdown_button.bind("<Leave>", lambda event, btn=dropdown_button, original_bg=bg_color, original_fg=fg_color: btn.config(bg=original_bg, fg=original_fg))

        # --- NEW: Close Button (below scrollable frame, in main frame) ---
        close_button = tk.Button(
            dropdown_main_frame, # Place in dropdown_main_frame
            text="Close",
            font=("Segoe UI", 10, "bold"),
            command=self.destroy_zip_search_dropdown_menu,
            bg="#666666",
            fg="white",
            borderwidth=1,
            relief="solid",
            padx=10,
            pady=5
        )
        close_button.pack(side="bottom", fill="x") # Pack to bottom of main frame
        # --- NEW: Close Button (below scrollable frame, in main frame) ---


        self.zip_search_dropdown_window.bind("<FocusOut>", lambda event: self.destroy_zip_search_dropdown_menu())
        
        
        

    def write_search_debug_log(self, message):
        """Writes debug messages to search_debug_log.txt."""
        debug_log_file = os.path.join(self.script_dir, "search_debug_log.txt")
        try:
            with open(debug_log_file, "a", encoding="utf-8") as f: # Open in append mode
                f.write(f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - {message}\n")
        except Exception as e:
            print(f"Warning: Could not write to search debug log file: {e}")
            
    def _filter_details_data_by_query_criteria(self, data_to_filter, query):
        """
        Filters details data by search query criteria (config/pc name).
        This function ONLY applies the query filter, no Favorites or Data Subset.
        """
        if not query:
            return data_to_filter # Return original if no query

        filtered_list = []
        print(f"\n--- _filter_details_data_by_query_criteria() DEBUG ---") # DEBUG START - QUERY CRITERIA ONLY
        print(f"  DEBUG: _filter_details_data_by_query_criteria - Search Query: '{query}'") # DEBUG - Search Query

        for item in data_to_filter:
            picture_path, spawn_cmd, zip_file, info_data, folder_name = item
            zip_file_base_name = zip_file.replace(".zip", "")
            config_name_base = self.extract_name_from_spawn_command(spawn_cmd).lower()

            config_name_display = ""
            individual_info_path = self.find_individual_info_file(
                folder_name,
                zip_file_base_name=zip_file_base_name,
                config_name=config_name_base
            )
            if individual_info_path:
                individual_info_json_data, _ = self._load_individual_info(individual_info_path)
                config_name_display = individual_info_json_data.get("Configuration", "").strip().lower()

            config_match_found = False
            if query.lower() in config_name_display: # Check against display name from Info file
                config_match_found = True

            pc_file_name_match = False # Check if query matches PC filename
            pc_file_name = self.extract_name_from_spawn_command(spawn_cmd).lower()
            if query.lower() in pc_file_name:
                pc_file_name_match = True

            if config_match_found or pc_file_name_match: # Check both Info file and PC filename
                filtered_list.append(item)

        print(f"  DEBUG: _filter_details_data_by_query_criteria - Filtered list count (query criteria only): {len(filtered_list)}") # DEBUG - Filtered List Count
        print("--- _filter_details_data_by_query_criteria() DEBUG END ---\n") # DEBUG END - QUERY CRITERIA ONLY
        return filtered_list


    def _apply_details_favorites_only_filter(self, data_to_filter):
        """Applies ONLY the Favorites filter to the details data."""
        if not self.details_window_is_favorites_filtered:
            return data_to_filter # Return original data if filter not active

        filtered_list = []
        print("\n--- _apply_details_favorites_only_filter() DEBUG ---") # DEBUG START - FAVORITES ONLY FILTER
        print("  DEBUG: _apply_details_favorites_only_filter - Applying Favorites Only filter.") # DEBUG - Filter Start

        favorite_configs_set = self.read_favorites()
        for item in data_to_filter:
            pic, spawn_cmd, zip_file_item, info_data, folder_name = item
            config_name = self.extract_name_from_spawn_command(spawn_cmd)
            fav_key = f"{folder_name}|{config_name}.pc"
            if fav_key in favorite_configs_set:
                filtered_list.append(item) # Add only if it's a favorite

        print(f"  DEBUG: _apply_details_favorites_only_filter - Filtered list count (favorites only): {len(filtered_list)}") # DEBUG - Filtered List Count
        print("--- _apply_details_favorites_only_filter() DEBUG END ---\n") # DEBUG END - FAVORITES ONLY FILTER
        return filtered_list



    def is_image_path_in_subset(self, picture_path):
        """
        Checks if the given picture path (filename) is considered in the data subset
        when the data subset filter is active.
        """
        if not self.is_data_subset_active:
            return True  # If data subset is not active, all paths are considered in subset

        subset_files = set()
        data_subset_file_path = os.path.join(self.script_dir, self.data_subset_file)
        if os.path.exists(data_subset_file_path):
            with open(data_subset_file_path, 'r', encoding="utf-8") as f:
                for line in f:
                    filename = line.strip()
                    if filename:
                        subset_files.add(filename)

        if not subset_files:
            return False  # If data_subset.txt is empty, no files are in subset

        pic_filename = os.path.basename(picture_path)

        # Extract "vehicles--[foldername]" part from filename
        match = re.match(r"vehicles--([^-]+)", pic_filename)
        if match:
            folder_name_prefix = match.group(0)  # "vehicles--[foldername]--"
            if folder_name_prefix[:-2] in subset_files: # Remove last two "--" and check
                return True

        return False


    def apply_data_subset_filter_details(self, data_list):
        """
        Filters the given data list to include only items with picture files that pass
        the is_image_path_in_subset check.
        """
        if not hasattr(self, 'is_data_subset_active'):
            self.is_data_subset_active = False  # Default to False if not initialized

        if not self.is_data_subset_active:
            return data_list

        filtered_data = []
        for item in data_list:
            pic_path = item[0]
            if pic_path and self.is_image_path_in_subset(pic_path): # Use the new check function
                filtered_data.append(item)
        return filtered_data


     
            

    def load_all_info_data_on_startup(self):
        """Loads all info data into cache on startup."""
        print("\n--- ConfigViewerApp.load_all_info_data_on_startup() ENTRY ---") # Debug Entry


        
        print("DEBUG: load_all_info_data_on_startup - Calling self.load_data() to populate caches...") # Debug
        self.original_data, self.original_full_data = self.load_data() # Load and populate caches
        print("DEBUG: load_all_info_data_on_startup - self.load_data() RETURNED - Caches Populated.") # Debug

        print("DEBUG: load_all_info_data_on_startup - Pre-loading individual info files into cache...") # Debug - Pre-loading Start
        for item_data in self.original_data: # Iterate through loaded data
            _, _, zip_file, _, folder_name = item_data # Unpack data tuple
            if folder_name in self.original_full_data: # Check if folder name exists in full data
                for config_item in self.original_full_data[folder_name]: # Iterate through configs in folder
                    _, spawn_cmd, _, _, _ = config_item # Unpack config item
                    config_name = self.extract_name_from_spawn_command(spawn_cmd) # Extract config name
                    zip_file_base_name = os.path.splitext(zip_file)[0].replace(folder_name+"_","").replace(folder_name,"") # Extract zip base name
                    individual_info_path = self.find_individual_info_file(folder_name, zip_file_base_name, config_name) # Find info file path
                    if individual_info_path:
                        if individual_info_path not in self.individual_info_cache: # Check if already cached
                            info_content, _ = self._load_individual_info(individual_info_path) # Load info content
                            if info_content:
                                self.individual_info_cache[individual_info_path] = info_content # Cache info data
                                #print(f"  DEBUG: Cached individual info file: {individual_info_path}") # Debug - Cache Success
                            else:
                                print(f"  Warning: Failed to load individual info file (caching skipped): {individual_info_path}") # Debug - Load Fail
                        #else:
                        #    print(f"  DEBUG: Individual info file already in cache: {individual_info_path}") # Debug - Already Cached
        print("DEBUG: load_all_info_data_on_startup - Individual info files pre-loading COMPLETE.") # Debug - Pre-loading Complete

        print("--- ConfigViewerApp.load_all_info_data_on_startup() EXIT ---\n") # Debug Exit
        
        if self.scanning_win:
            self.scanning_win.destroy()

 
        self.scanning_win = None

        self.scanning_win = self.show_scanning_window(text="Initializing Data...")



    #@profile 
    def rebuild_simple_details(self):
        """
        Rebuilds the details window's subgrid, now with pagination,
        ENFORCING Favorites filter even for empty search in Favorites mode. <--- MODIFIED DOCSTRING
        """
        if not self.details_window:
            return

        print("\n--- rebuild_simple_details() ENTRY - Page:", self.details_page, "---") # Debug - Page Number
        print(f"  DEBUG: rebuild_simple_details - items_per_page: {self.items_per_page}") # Debug - items_per_page
        print(f"  DEBUG: rebuild_simple_details - details_page: {self.details_page}") # Debug - details_page
        print(f"  DEBUG: rebuild_simple_details - len(self.details_filtered_data): {len(self.details_filtered_data)}") # Debug - Filtered Data Length
        print(f"  DEBUG: rebuild_simple_details - details_window_is_favorites_filtered: {self.details_window_is_favorites_filtered}") # Debug - Favorites Filter State <--- ADDED




        def get_config_value(item):
            """Helper function to extract and safely convert 'Value' to float for sorting."""
            picture_path, spawn_cmd, zip_file, info_data, folder_name = item
            zip_file_base_name = os.path.splitext(zip_file)[0]
            config_name = self.extract_name_from_spawn_command(spawn_cmd)
            individual_info_path = self.find_individual_info_file(
                folder_name, zip_file_base_name, config_name
            )
            #value = float('inf')  # Default high value for items without a valid "Value"  <--- CHANGED to float('inf')
            value = float('-inf')  # Default low value for items without a valid "Value"
            if individual_info_path and os.path.exists(individual_info_path):
                individual_info_json, _ = self._load_individual_info(individual_info_path)
                value_str = individual_info_json.get("Value", None)
                if value_str:
                    try:
                        value = float(value_str)
                    except ValueError:
                        pass  # Keep default 'inf' for non-numeric values
            return value

        print("DEBUG: _initial_details_layout - Sorting subgrid_data by 'Value'...")
        self.details_filtered_data.sort(key=get_config_value) # Sort by 'Value' <--- SORTING details_filtered_data directly
        print("DEBUG: _initial_details_layout - subgrid_data SORTED by 'Value'.")
        # --- NEW: Sorting logic by "Value" ---



        # --- MODIFIED: Use details_filtered_data directly for pagination (already filtered by search AND favorites) ---
        data_to_paginate = self.details_filtered_data # <--- USE details_filtered_data directly
        # --- MODIFIED: Use details_filtered_data directly for pagination ---


        for widget in self.details_scrollable_frame.winfo_children():
            widget.destroy()
        print("  DEBUG: rebuild_simple_details - Existing widgets DESTROYED.") # Debug - Widgets Destroyed
        ConfigViewerApp.details_widget_count = 0
        print("DEBUG: rebuild_simple_details - Widget count RESET to 0.") # Debug - Widget Count Reset

        start_index = self.details_page * self.items_per_page
        end_index = start_index + self.items_per_page
        paged_data = data_to_paginate[start_index:end_index] # <--- USE data_to_paginate for slicing

        print(f"  DEBUG: rebuild_simple_details - Loading page {self.details_page + 1}, items from index {start_index} to {end_index-1}, count: {len(paged_data)}")
        print(f"  DEBUG: rebuild_simple_details - First 3 items in paged_data:") # <--- ADD DEBUG PRINT
        if paged_data:
            for i in range(min(3, len(paged_data))):
                item = paged_data[i]
                if item and item[0]: # Check if item and picture_path exist
                    print(f"    - Item {i+1}: {os.path.basename(item[0])}")
                else:
                    print(f"    - Item {i+1}: Item data or picture_path is None")
        else:
            print("  DEBUG: rebuild_simple_details - paged_data is EMPTY.") # Check for empty paged_data

        self.details_batches = [
            paged_data[i: i + self.details_batch_size]
            for i in range(0, len(paged_data), self.details_batch_size)
        ]
        self.current_details_batch_index = 0
        print(f"  DEBUG: rebuild_simple_details - Created batches for CURRENT PAGE, batch count: {len(self.details_batches)}")
        if self.details_batches:
            print(f"  DEBUG: rebuild_simple_details - Size of first batch: {len(self.details_batches[0])}") # Size of first batch
        else:
            print("  DEBUG: rebuild_simple_details - NO batches created (details_batches is empty).") # No Batches Created

        # --- ENSURE INITIALIZATION of current_details_batch_index here, before calling load_next_batch_details ---
        self.current_details_batch_index = 0 # <--- ENSURE INITIALIZATION HERE
        print(f"DEBUG: rebuild_simple_details - ENSURING current_details_batch_index = {self.current_details_batch_index} BEFORE load_next_batch_details()") # Debug - Initialization Check

        if paged_data:
            self.start_details_loading_animation()
            print("DEBUG: rebuild_simple_details - Calling load_next_batch_details() NOW...") # Debug - Before Call
            self.load_next_batch_details() # Start loading batches (now only for paged_data)
            print("DEBUG: rebuild_simple_details - load_next_batch_details() RETURNED.") # Debug - After Call
        else:
            self.stop_details_loading_animation()

        if self.details_count_label:
            self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}")

        self._update_details_pagination_bar() # <--- ADDED: Update pagination bar initially
        #self.start_debounce_details_highlighting()

        self.details_canvas_sub.yview_moveto(0)
        print("--- rebuild_simple_details() DEBUG EXIT ---\n") # Debug Exit




    def throttled_details_resize(self, event):
        """
        Handles the details window resize event with debounce, only updating layout on column breakpoint change.
        """
        if self.details_window and event.widget == self.details_window:
            new_width = self.details_window.winfo_width()
            new_height = self.details_window.winfo_height()
            if (new_width != self.details_last_width) or (new_height != self.details_last_height):
                self.details_last_width = new_width
                self.details_last_height = new_height
                # Pause loading during resize
                self.pause_loading = True
                # Cancel any existing debounce timer
                if self.details_resize_timer is not None:
                    self.details_window.after_cancel(self.details_resize_timer)
                    self.details_resize_timer = None
                # Set a new debounce timer (e.g., 300ms)
                debounce_delay = 700  # milliseconds
                self.details_resize_timer = self.details_window.after(debounce_delay, self.on_details_resize_complete)

    def on_details_resize_complete(self):
        """
        Callback function triggered after debounce for details window resize.
        Updates the subgrid layout only if the number of columns needs to change.
        """
        details_canvas_width = self.details_canvas_sub.winfo_width() - 20 # Adjust for margins
        if details_canvas_width <= 0:
            return # Avoid calculations with non-positive width

        potential_details_columns, potential_details_h_padding = self.calculate_columns_for_width(details_canvas_width, is_details=True)

        if self.details_columns is None: # Check if None for initial setup
            self.details_columns = (potential_details_columns, potential_details_h_padding) # Update column count and padding
            self.update_subgrid_layout_on_resize()
        elif (potential_details_columns != self.details_columns[0] or potential_details_h_padding != self.details_columns[1]):
            self.details_columns = (potential_details_columns, potential_details_h_padding) # Update column count and padding
            self.update_subgrid_layout_on_resize()
        # Resume loading after layout check (or update)
        self.pause_loading = False
        self.details_resize_timer = None



    def update_subgrid_layout_on_resize(self):
        """
        Updates the subgrid layout with dynamic padding on resize,
        now using paged_data BUT **PREVENTS RE-TRIGGERING BATCH LOAD**.
        MODIFIED to only handle layout, not start new batch load.
        """
        print("\n--- update_subgrid_layout_on_resize() ENTRY ---") # Debug Entry
        print(f"DEBUG: update_subgrid_layout_on_resize - BEFORE function logic - current_details_batch_index: {getattr(self, 'current_details_batch_index', 'ATTRIBUTE_MISSING')}") # Debug - Before Logic

        try:
            if not self.details_scrollable_frame:
                print("  WARNING: details_scrollable_frame is None, exiting.") # Debug - Null Check
                return

            # --- MODIFIED: Calculate paged_data for current page on resize ---
            start_index = self.details_page * self.items_per_page
            end_index = start_index + self.items_per_page
            paged_data = self.details_filtered_data[start_index:end_index]
            print(f"DEBUG: update_subgrid_layout_on_resize - Re-layout for page {self.details_page + 1}, using paged_data count: {len(paged_data)}") # Debug - Page and paged_data Count
            # --- MODIFIED: Calculate paged_data for current page on resize ---


            # --- MODIFIED: Reset widget count at start of resize layout ---
            ConfigViewerApp.details_widget_count = 0
            print("DEBUG: update_subgrid_layout_on_resize - Widget count RESET to 0 for resize.")
            # --- MODIFIED: Reset widget count at start of resize layout ---

            # Clear existing widgets
            for widget in self.details_scrollable_frame.winfo_children():
                widget.destroy()

            # Determine the available width
            self.details_canvas_sub.update_idletasks()

            # --- ADDED DEBUG PRINTS HERE ---
            print(f"DEBUG: update_subgrid_layout_on_resize - details_canvas_sub.winfo_width() BEFORE margin: {self.details_canvas_sub.winfo_width()}") # Print raw width
            width_before_margin = self.details_canvas_sub.winfo_width() # Capture width before margin
            width = width_before_margin - 60
            print(f"DEBUG: update_subgrid_layout_on_resize - width AFTER margin (-60): {width}") # Print width after margin
            # --- ADDED DEBUG PRINTS HERE ---


            image_width = 200


            if self.details_columns is None: # Initial column setup if not yet initialized
                num_columns, h_padding = self.calculate_columns_for_width(self, width, is_details=True)
                self.details_columns = (num_columns, h_padding)
            else:
                num_columns, h_padding = self.details_columns # Use stored column count and padding


            self.details_column_padding = h_padding # Store for consistency

            print(f"DEBUG: update_subgrid_layout_on_resize - num_columns: {num_columns}, h_padding: {h_padding}") # Print num_columns and h_padding BEFORE grid layout

            if width > 0:
                pass
                # --- MODIFIED: Iterate over paged_data for LAYOUT ONLY (no new batch load) ---
                #for idx, item in enumerate(paged_data): # Iterate over paged_data
                #    row = idx // num_columns
                #    col = idx % num_columns
                #    container = tk.Frame(self.details_scrollable_frame, bg="#444444")
                #    container.grid(row=row, column=col, padx=self.details_column_padding, pady=5, sticky="nw") # Dynamic padding here
                #    # --- IMPORTANT: DO NOT CALL load_image_item_details HERE during resize ---
                #    # We are RE-USING already loaded images/widgets, just re-laying them out
                #    self.executor.submit(
                #        self.load_image_item_details,
                #        item,
                #        container,
                #        row,
                #        col
                #    )
                # --- MODIFIED: Iterate over paged_data for LAYOUT ONLY (no new batch load) ---

            # Update the scroll region
            self.details_scrollable_frame.update_idletasks()
            self.details_canvas_sub.config(scrollregion=self.details_canvas_sub.bbox("all"))

        except Exception as e:
            print(f"Error in update_subgrid_layout_on_resize: {e}")
        finally: # ADDED finally block to print AFTER function execution
            print(f"DEBUG: update_subgrid_layout_on_resize - EXIT - current_details_batch_index: {getattr(self, 'current_details_batch_index', 'ATTRIBUTE_MISSING')}") # Debug - Exit
            print("--- update_subgrid_layout_on_resize() EXIT ---\n") # Debug Exit



    #@profile 
    def update_grid_layout(self):
        """
        Updates the grid layout in the main window with dynamic column count and padding.
        Implements category collapsing and hover effects.
        Makes the mouse cursor change on hover over any part of the category header.
        """
        self._update_filters_label_status()

        if self.is_search_results_window_active:
            print("DEBUG: update_grid_layout - Search Results window is active. SKIPPING main grid layout update.")
            return

        if self.is_search_results_window_active and self.filter_state == 0 and not self.search_var.get().strip() and not self.is_data_subset_active:
            print("DEBUG: update_grid_layout - Early EXIT - View All, Empty Query, Global Filters OFF. Skipping layout update.")

            self.is_search_results_window_active = False
            return

        try:
            # Show loading label and start pulsating animation
            self.start_loading_animation()

            # Clear the existing grid
            for widget in self.scrollable_frame.winfo_children():
                widget.destroy()

            self.main_grid_labels = [] # Clear the list to prevent accumulation


            # Determine the available width for images
            self.canvas.update_idletasks()
            width = self.canvas.winfo_width() - 60
            image_width = 200
            min_padding = 10

            if self.columns is None:
                self.columns, self.column_padding = self.calculate_columns_for_width(width)
            else:
                _, self.column_padding = self.calculate_columns_for_width(width)

            columns = self.columns
            fixed_padding_x = self.column_padding
            single_column_pixel_width = image_width + fixed_padding_x

            category_order = ["car", "truck", "bus", "trailer", "aircraft", "prop"]

            ordered_categories = sorted(
                self.grouped_data.keys(),
                key=lambda x: (
                    category_order.index(x.lower()) if x.lower() in category_order else len(category_order),
                    x.lower()
                )
            )

            # Determine if label should be omitted based on item count
            self.omit_label = len(self.data) >= 1100 # Set flag based on total item count

            self.category_batches = []
            for category in ordered_categories:
                category_hidden = self.category_hidden_states.get(category, False)

                if self.categorization_mode == 'None' and category == "All Items":
                    header_frame = None
                    category_subframe = tk.Frame(self.scrollable_frame, bg="#444444")
                    category_subframe.pack(fill="x")
                else:
                    header_frame = tk.Frame(self.scrollable_frame, bg="#444444", cursor="hand2")
                    header_frame.pack(fill=tk.X, pady=(5, 0))

                    search_query = self.search_var.get().strip().lower()
                    matching_item_count = 0
                    for item in self.grouped_data[category]:
                        if self._perform_item_search(search_query, item):
                            matching_item_count += 1

                    header_text = category
                    if category_hidden:
                        header_text += " (Hidden)"

                    header_text_with_count = f"{header_text} ({matching_item_count})"
                    header_label = tk.Label(
                        header_frame,
                        text=header_text_with_count,
                        font=("Segoe UI", 14, "bold"),
                        bg="#444444",
                        fg="lightgrey",
                        anchor="w",
                        cursor="hand2"
                    )
                    header_label.pack(side=tk.LEFT, padx=10, pady=(10, 0))
                    header_label.bind("<Button-1>", lambda event, cat=category: self.toggle_category_visibility(cat))

                    separator = tk.Frame(
                        header_frame,
                        height=4,
                        bd=1,
                        relief="sunken",
                        bg="lightgrey",
                        cursor="hand2"
                    )
                    separator.pack(side=tk.BOTTOM, fill="x", padx=10, pady=(0, 10))

                    header_frame.bind("<Enter>", lambda event, cat=category, header=header_label, sep=separator, count=matching_item_count: self.on_category_hover_enter(event, cat, header, sep, count))
                    header_frame.bind("<Leave>", lambda event, cat=category, header=header_label, sep=separator, count=matching_item_count: self.on_category_hover_leave(event, cat, header, sep, count))
                    header_frame.bind("<Button-1>", lambda event, cat=category: self.toggle_category_visibility(cat))

                    category_subframe = tk.Frame(self.scrollable_frame, bg="#444444")
                    if not category_hidden:
                        category_subframe.pack(fill="x")
                    else:
                        category_subframe.pack_forget()

                self.image_counts[category] = 0

                items = self.grouped_data[category]
                if isinstance(items, list):
                    all_items = []
                    for item in items:
                        if isinstance(item, dict) and 'configs' in item:
                            for config in item['configs']:
                                all_items.append(config)
                        elif len(item) == 5:
                            all_items.append(item)

                    batch_size = 10
                    batches = [all_items[i:i + batch_size] for i in range(0, len(all_items), batch_size)]
                    self.category_batches.append((category, batches, category_subframe))

            self.current_category_index = 0
            self.current_batch_index = 0

            self.load_next_batch()

        except Exception as e:
            print(f"Error in update_grid_layout: {e}")

            

    def toggle_category_visibility(self, category):
        """Toggles the visibility of a category and its widgets."""


        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot hide or unhide categories while there are pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 


        self.category_hidden_states[category] = not self.category_hidden_states.get(category, False)
        self.update_grid_layout() # Re-layout the grid to reflect changes

    def on_category_hover_enter(self, event, category, header_label, separator, count): # <--- ADDED count parameter
        """Handles mouse hover enter event for category headers."""
        separator.config(bg=self.global_highlight_color)
        header_label.config(fg=self.global_highlight_color)
        if self.category_hidden_states.get(category, False):
            header_label.config(text=f"{category} (Show) ({count})") 
        else:
            header_label.config(text=f"{category} (Hide) ({count})") 

    def on_category_hover_leave(self, event, category, header_label, separator, count):
        """Handles mouse hover leave event for category headers."""
        separator.config(bg="lightgrey")
        header_label.config(fg="lightgrey")
        if self.category_hidden_states.get(category, False):
            header_label.config(text=f"{category} (Hidden) ({count})") 
        else:
            header_text = category
            if self.category_hidden_states.get(category, False):
                header_text += " (Hidden)"
            header_label.config(text=f"{header_text} ({count})") 
    

    # ------------------------------------------------------------
    # Populate Subgrid Page
    # ------------------------------------------------------------

    def update_subgrid_layout(self, scrollable_frame_sub, subgrid_data):
        """
        Updates the subgrid layout with dynamic padding.
        """
        max_retries = 5
        retry_count = 0
        while retry_count < max_retries:
            try:
                for widget in scrollable_frame_sub.winfo_children():
                    widget.destroy()

                scrollable_frame_sub.update_idletasks()
                if self.details_canvas_sub:
                    width = self.details_canvas_sub.winfo_width() - 20
                else:
                    width = scrollable_frame_sub.winfo_width() - 20

                image_width = 200


                if self.details_columns is None: # Initial column setup if not yet initialized
                    num_columns, h_padding = self.calculate_columns_for_width(width, is_details=True)
                    self.details_columns = (num_columns, h_padding)
                else:
                    num_columns, h_padding = self.details_columns # Use stored column count and padding


                self.details_column_padding = h_padding # Store for consistency


                if width > 0:
                    for idx, item in enumerate(subgrid_data):
                        row = idx // num_columns
                        col = idx % num_columns
                        container = tk.Frame(scrollable_frame_sub, bg="white")
                        container.grid(row=row, column=col, padx=self.details_column_padding, pady=5, sticky="nw") # Dynamic padding here
                        self.executor.submit(
                            self.load_image_item_details,
                            item,
                            container,
                            row,
                            col
                        )
                    scrollable_frame_sub.update_idletasks()
                    scrollable_frame_sub.master.config(scrollregion=scrollable_frame_sub.master.bbox("all"))
                    return
                else:
                    retry_count += 1
                    if self.details_window:
                        self.details_window.update()
                        self.details_window.after(100)
                    else:
                        break
            except Exception as e:
                retry_count += 1
                if self.details_window:
                    self.details_window.update()
                    self.details_window.after(100)
                else:
                    break




    # ------------------------------------------------------------
    # Load & Display Subgrid Item (Details Window - NO CACHE)
    # ------------------------------------------------------------
    def create_details_item_widgets(self, parent_frame, photo, pil_image, spawn_cmd, info_data, zip_file, picture_path, folder_name, zip_file_base_name, config_name):
        """
        Creates and configures the widgets for a single image item in the details window,
        **NOW WITH WIDGET COUNT LIMIT and DEBUG PRINT.**
        """

        print("\n--- create_details_item_widgets() DEBUG ENTRY ---") # <--- DEBUG ENTRY
        print(f"  DEBUG: create_details_item_widgets - Widget Count (at entry): {ConfigViewerApp.details_widget_count}") # Debug - Count at Entry
        print(f"  DEBUG: create_details_item_widgets - File: {os.path.basename(picture_path)}") # Debug - Filename
        print(f"  DEBUG: create_details_item_widgets - Parent Frame: {parent_frame}") # Debug - Parent Frame Widget

        if not parent_frame.winfo_exists():
            print("  DEBUG: create_details_item_widgets - Parent frame no longer exists, exiting.") # Debug - Parent Frame Missing
            print("--- create_details_item_widgets() DEBUG EXIT (Parent Frame Missing) ---\n") # Debug Exit - Parent Missing
            return

        print(f"DEBUG: create_details_item_widgets - START - Widget Count: {ConfigViewerApp.details_widget_count}, File: {os.path.basename(picture_path)}") # <--- DEBUG PRINT - WIDGET COUNT

        if ConfigViewerApp.details_widget_count >= 50: # <--- CHECK WIDGET COUNT LIMIT
            print(f"DEBUG: create_details_item_widgets - Widget limit reached (50), skipping widget creation for: {os.path.basename(picture_path)}") # Debug - Limit Reached
            return # Skip widget creation if limit is reached

        # --- Image Label (similar to details view) ---
        lbl_img = tk.Label(parent_frame, image=photo, cursor="hand2", bg="white") # MODIFIED HERE
        lbl_img.image = photo
        lbl_img.pack(padx=0, pady=0)
        # --- NEW: Store default image background color ---
        lbl_img.default_bg_color = "white" # Store the default bg color for image label - background for images - border
        # --- NEW: Store default image background color ---

        # --- Tooltip for image label ---


        # --- Text Label (info label) ---
        config_name_extracted = self.extract_name_from_spawn_command(spawn_cmd)
        if not config_name_extracted:
            config_name_extracted = os.path.splitext(os.path.basename(zip_file))[0]

        individual_info_path = self.find_individual_info_file(folder_name, zip_file_base_name=zip_file_base_name, config_name=config_name_extracted)

        label_text = config_name_extracted # Default label text
        individual_info_json = {} # Initialize as empty dict

        if individual_info_path:
            try:
                individual_info_json, _ = self._load_individual_info(individual_info_path)
                configuration_text = individual_info_json.get("Configuration")
                if configuration_text:
                    label_text = configuration_text
            except Exception as e:
                print(f"  WARNING: Error loading/parsing individual info file for label {individual_info_path}: {e}. Using default name.")


        # --- MODIFIED: Set label color based on picture_path ---
        label_color = "white" # Default color
        if "_user--" in picture_path:
            label_color = "lightblue" #lightblue  for custom configs
        else: # Add the new elif here within the else block to maintain priority
            found_double_basename = False
            for base_name in self.ZIP_BASE_NAMES:
                if picture_path.count(f"--{base_name}_{base_name}.zip") > 0: # Check for the specific pattern
                    found_double_basename = True
                    break # No need to check further once one is found
            if found_double_basename:
                label_color = "#f7efd7" # color for default zips/folder combo

        # --- MODIFIED: Set label color based on picture_path ---

        lbl_name = tk.Label(
            parent_frame,
            text=label_text,
            wraplength=200, #label length, don't remove current
            justify="center",
            fg=label_color,
            font=("Segoe UI", 10, "bold"),
            cursor="hand2",
            bg="#444444", # MODIFIED HERE
            height=3,
            anchor=tk.N
        )
        lbl_name.pack(padx=0, pady=5)
        # --- NEW: Store default text color as attribute ---
        lbl_name.default_fg_color = label_color  # Store the default text color
        # --- NEW: Store default text color as attribute ---


        # --- Hover effect (unchanged) ---
        original_color = label_color # Use dynamic color as original  (Renamed back)
        hover_color = self.global_highlight_color # Renamed back
        hover_bg_color = self.global_highlight_color # Background color for image hover
        original_bg_color_img = "white" # Original bg color for image label - DARKER GRAY

        if not self.middle_click_settings:
            tooltip_text = "> Double click: Add to Spawn Queue.\n> Middle Click: Immediately spawn.\n> Right click: Manage mod, view \n   details and customize config color."

        if self.middle_click_settings:
            tooltip_text = "> Middle click: Add to Spawn Queue.\n> Double Click: Immediately spawn.\n> Right click: Manage mod, view \n   details and customize config color."
        
        
        def on_hover_enter(event):
            lbl_name.config(fg=hover_color)
            lbl_img.config(bg=hover_bg_color)

            # --- DEBOUNCED Tooltip ---
            if self.tooltip_debounce_timer:
                self.master.after_cancel(self.tooltip_debounce_timer) # Cancel existing timer
                self.tooltip_debounce_timer = None # Reset timer

            self.tooltip_debounce_timer = self.master.after(
                200, # Debounce delay for tooltip (adjust as needed, e.g., 200ms)
                lambda widget=event.widget, text=tooltip_text: self._delayed_show_tooltip(widget, text) # Call delayed show function
            )
            # --- DEBOUNCED Tooltip ---


            # --- DEBOUNCED sidebar update ---
            if self.details_sidebar_debounce_timer:
                self.master.after_cancel(self.details_sidebar_debounce_timer)  # Cancel any existing timer
            self.details_sidebar_debounce_timer = self.master.after(
                100,  # Debounce delay (e.g., 100ms) - adjust as needed
                lambda: self.debounced_show_main_sidebar_info(info_data, picture_path, zip_file, folder_name, item=(picture_path, spawn_cmd, zip_file, info_data, folder_name))
            )
            # --- DEBOUNCED sidebar update ---


        def on_hover_leave(event):
            # --- MODIFIED: Check if label should be highlighted yellow, otherwise restore default color ---
            search_query = self.details_search_var.get().strip().lower()
            config_name_for_search = lbl_name.cget("text").lower() # Get label text for search
            if search_query and search_query in config_name_for_search:
                #lbl_name.config(fg="yellow") # Keep yellow highlight if search active
                #lbl_img.config(bg="yellow") # Keep yellow highlight for image background too
                lbl_name.config(fg=lbl_name.default_fg_color) # Restore original DEFAULT text color, keeping feature in, but disabled state
                lbl_img.config(bg=lbl_img.default_bg_color) # Restore default image background color

            else:
                lbl_name.config(fg=lbl_name.default_fg_color) # Restore original DEFAULT text color
                lbl_img.config(bg=lbl_img.default_bg_color) # Restore default image background color
            # --- MODIFIED: Check if label should be highlighted yellow, otherwise restore default color ---
            self.hide_details_item_tooltip() # Hide tooltip immediately on leave


        lbl_img.bind("<Enter>", on_hover_enter)
        lbl_img.bind("<Leave>", on_hover_leave)
        lbl_name.bind("<Enter>", on_hover_enter) # Bind hover to text label too
        lbl_name.bind("<Leave>", on_hover_leave) # Bind leave to text label too
        # --- End Hover effect ---


        # --- Click Bindings (similar to original, but on Labels now) ---
        lbl_img.bind("<Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name:
            (self.on_details_image_click(s, i_data, pic_path, z_file, f_name), ))
        # --- ADDED BACK: Double-Click binding for lbl_img ---



        # --- ADDED BACK: Double-Click binding for lbl_img ---
        lbl_img.bind("<Button-3>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name, z_base_name=zip_file_base_name, c_name=config_name:
                 (self.clear_details_sidebar_content(),
                     
                  self.open_detail_info_window(s, i_data, pic_path, z_file, f_name, z_base_name, c_name),
                  self.update_details_sidebar_content(info_data, picture_path, zip_file, folder_name=self.current_details_folder),
                  self.update_details_sidebar_config_name(spawn_cmd)
                  ))
        lbl_name.bind("<Button-3>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name, z_base_name=zip_file_base_name, c_name=config_name: # Changed lbl_info to lbl_name # <--- NEW BINDING FOR lbl_info
                 (self.open_detail_info_window(s, i_data, pic_path, z_file, f_name, z_base_name, c_name),
                  self.update_details_sidebar_content(info_data, picture_path, zip_file, folder_name=self.current_details_folder), # REVERTED - ADDED BACK
                  self.update_details_sidebar_config_name(spawn_cmd) # REVERTED - ADDED BACK
                  )) # Open config details on Right-Click <--- CORRECTED CALL
        
        lbl_name.bind("<Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: # Changed lbl_info to lbl_name # Text label click - copy and update sidebar - pass folder_name
                      (self.on_details_image_click(s, i_data, pic_path, z_file, f_name),
                       # --- ADDED BACK: update_sidebar_content call on label single-click ---
                       self.update_sidebar_content(info_data, picture_path, zip_file, folder_name=self.current_details_folder))) # Corrected to update_sidebar_content
                       # --- ADDED BACK: update_sidebar_content call on label single-click ---


        if not self.middle_click_settings:
            lbl_name.bind("<Button-2>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_replace_current_button_click(spawn_cmd, event=None)) # <-- ADDED middle CLICK BINDING HERE
            lbl_img.bind("<Button-2>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_replace_current_button_click(spawn_cmd, event=None)) # <-- ADDED middle CLICK BINDING HERE

            lbl_img.bind("<Double-Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_details_item_double_click_to_queue(spawn_cmd, info_data, picture_path, zip_file, folder_name)) # <-- ADDED DOUBLE CLICK BINDING HERE
            lbl_name.bind("<Double-Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_details_item_double_click_to_queue(spawn_cmd, info_data, picture_path, zip_file, folder_name)) # <-- ADDED DOUBLE CLICK BINDING HERE


        if self.middle_click_settings:
            lbl_name.bind("<Double-Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_replace_current_button_click(spawn_cmd, event=None)) # <-- ADDED middle CLICK BINDING HERE
            lbl_img.bind("<Double-Button-1>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_replace_current_button_click(spawn_cmd, event=None)) # <-- ADDED middle CLICK BINDING HERE

            lbl_img.bind("<Button-2>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_details_item_double_click_to_queue(spawn_cmd, info_data, picture_path, zip_file, folder_name)) # <-- ADDED DOUBLE CLICK BINDING HERE
            lbl_name.bind("<Button-2>", lambda e, s=spawn_cmd, i_data=info_data, pic_path=picture_path, z_file=zip_file, f_name=folder_name: self.on_details_item_double_click_to_queue(spawn_cmd, info_data, picture_path, zip_file, folder_name)) # <-- ADDED DOUBLE CLICK BINDING HERE
        

        # --- NEW: Store item-specific data (keep this) ---
        parent_frame.item_data_tuple = (pil_image, info_data, picture_path, zip_file, folder_name, spawn_cmd, lbl_img, lbl_name) # Store labels instead of button
        # --- NEW: Store item-specific data ---

        print(f"DEBUG: create_details_item_widgets - Incrementing widget count for: {os.path.basename(picture_path)}, Current Count BEFORE increment: {ConfigViewerApp.details_widget_count}") # <--- DEBUG PRINT - WIDGET COUNT

        ConfigViewerApp.details_widget_count += 1 # <--- INCREMENT WIDGET COUNT
        
        
     


    def _delayed_show_tooltip(self, widget, tip_text):
        """Helper function to show the tooltip after a debounce delay."""

        if not widget.winfo_exists(): # <--- CHECK IF WIDGET EXISTS HERE
            print("DEBUG: _delayed_show_tooltip - Widget no longer exists, aborting tooltip display.") # Debug print
            return # Exit if widget doesn't exist anymore

        self.tooltip_debounce_timer = None # Reset debounce timer as action is now being taken

        if self.current_details_item_tooltip_window: # If a tooltip is already showing, destroy it first
            self.hide_details_item_tooltip()

        self.current_details_item_tooltip_window = tk.Toplevel(self.details_window)
        self.current_details_item_tooltip_window.overrideredirect(True) # Remove border
        self.current_details_item_tooltip_window.tk.call('tk', 'scaling', 1.25)
        self.current_details_item_tooltip_window.attributes("-topmost", True) # Keep on top

        tooltip_label = tk.Label(self.current_details_item_tooltip_window, text=tip_text, font=("Segoe UI", 10, "italic"), fg="lightgrey", bg="#555555", padx=5, pady=2, relief=tk.SOLID, borderwidth=1, justify=tk.LEFT) # Dark bg, lightgrey fg, left justify
        tooltip_label.pack(padx=1, pady=1)

        widget_width = widget.winfo_width()
        widget_height = widget.winfo_height()
        widget_abs_x = widget.winfo_rootx()
        widget_abs_y = widget.winfo_rooty()

        tooltip_x = widget_abs_x + widget_width + 5 # Position to the right, 5px gap
        tooltip_y = widget_abs_y + (widget_height // 1) - (self.current_details_item_tooltip_window.winfo_reqheight() // 2) # Center vertically

        self.current_details_item_tooltip_window.geometry(f"+{tooltip_x}+{tooltip_y}")

        # --- Auto-destroy timer ---
        if self.tooltip_autodestroy_timer: # Clear any existing auto-destroy timer (shouldn't be one here, but for safety)
            self.master.after_cancel(self.tooltip_autodestroy_timer)
            self.tooltip_autodestroy_timer = None

        self.tooltip_autodestroy_timer = self.master.after(4000, self.hide_details_item_tooltip) # Set auto-destroy timer (4 seconds)
        # --- Auto-destroy timer ---


    def show_details_item_tooltip(self, widget, tip_text): # Kept for potential direct calls if needed, but not used by hover now
        """Displays a tooltip window to the right of the given widget."""
        # This function is now mostly handled by _delayed_show_tooltip for debounce/autodestroy.
        # You might still call this directly from other parts of your code if you want an immediate tooltip without debounce/autodestroy.
        # For now, it can remain as is, or you can decide to remove it and only use _delayed_show_tooltip.
        if self.current_details_item_tooltip_window:
            self.hide_details_item_tooltip() # Destroy existing tooltip if any

        self.current_details_item_tooltip_window = tk.Toplevel(self.details_window)
        self.current_details_item_tooltip_window.overrideredirect(True) # Remove border
        self.current_details_item_tooltip_window.tk.call('tk', 'scaling', 1.25)
        self.current_details_item_tooltip_window.attributes("-topmost", True) # Keep on top

        tooltip_label = tk.Label(self.current_details_item_tooltip_window, text=tip_text, font=("Segoe UI", 10, "italic"), fg="lightgrey", bg="#555555", padx=5, pady=2, relief=tk.SOLID, borderwidth=1, justify=tk.LEFT) # Dark bg, lightgrey fg, left justify
        tooltip_label.pack(padx=1, pady=1)

        widget_width = widget.winfo_width()
        widget_height = widget.winfo_height()
        widget_abs_x = widget.winfo_rootx()
        widget_abs_y = widget.winfo_rooty()

        tooltip_x = widget_abs_x + widget_width + 5 # Position to the right, 5px gap
        tooltip_y = widget_abs_y + (widget_height // 2) - (self.current_details_item_tooltip_window.winfo_reqheight() // 2) # Center vertically

        self.current_details_item_tooltip_window.geometry(f"+{tooltip_x}+{tooltip_y}")

        # --- Auto-destroy timer ---  (Added here as well, in case you call this function directly)
        if self.tooltip_autodestroy_timer:
            self.master.after_cancel(self.tooltip_autodestroy_timer)
            self.tooltip_autodestroy_timer = None
        self.tooltip_autodestroy_timer = self.master.after(4000, self.hide_details_item_tooltip) # Set auto-destroy timer (4 seconds)
        # --- Auto-destroy timer ---


    def hide_details_item_tooltip(self):
        """Destroys the details item tooltip window if it exists and cancels timers."""
        if self.current_details_item_tooltip_window:
            
            
            try: # <--- ADDED TRY-EXCEPT BLOCK HERE
                self.current_details_item_tooltip_window.destroy()
            except tk.TclError:
                # Window might be already destroyed, ignore error
                pass
            finally: # <--- ADDED FINALLY BLOCK HERE
                self.current_details_item_tooltip_window = None

        # --- Cancel debounce timer if it's pending ---
        if self.tooltip_debounce_timer:
            self.master.after_cancel(self.tooltip_debounce_timer)
            self.tooltip_debounce_timer = None

        # --- Cancel auto-destroy timer if it's pending ---
        if self.tooltip_autodestroy_timer:
            self.master.after_cancel(self.tooltip_autodestroy_timer)
            self.tooltip_autodestroy_timer = None



        
    def on_details_item_double_click_to_queue(self, spawn_cmd, info_data, picture_path, zip_file, folder_name):
        """Handles double click on an item in the details subgrid to add it to the spawn queue."""
        scanning_window = None # Initialize scanning_window outside try block

        if spawn_cmd: # Only proceed if spawn_cmd is successfully obtained (either from label or stored attribute)
            try:



                scanning_window = self.show_scanning_window(text="Added to Spawn Queue") # <-- SHOW SCANNING WINDOW HERE
                # Make the window visible
                scanning_window.deiconify()
                self.master.update_idletasks() # Force window to appear immediately

                self.is_details_sidebar_sticky = True
                self.is_details_sidebar_showing_default = False
                # --- MODIFIED: Write to spawn queue file instead of clipboard ---
                try:
                    # Check if the spawn queue file exists and is not empty
                    write_ellexium_line = not os.path.exists(self.SPAWN_QUEUE_FILE) or os.stat(self.SPAWN_QUEUE_FILE).st_size == 0

                    with open(self.SPAWN_QUEUE_FILE, 'a', encoding="utf-8") as f: # Open in append mode
                        if write_ellexium_line:
                            f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")

                        lines = spawn_cmd.splitlines()
                        modified_lines = []

                        for line in lines:
                            if "(USE" in line:
                                parts = line.split('(USE', 1) # Split at the FIRST '(USE', maxsplit=1
                                modified_line = parts[0] + "-- (USE" + parts[1] # Reassemble with "-- " before '(USE'
                                modified_lines.append(modified_line)
                            else:
                                modified_lines.append(line)

                        modified_spawn_cmd = "\n".join(modified_lines)
                        spawn_cmd = modified_spawn_cmd

                        f.write(f"{spawn_cmd} -- (USE 1|||{picture_path}||| 2[{zip_file}]\n") # MODIFIED: Write command and additional info on the same line

                    #messagebox.showinfo("Spawn Queue", f"Configuration '{self.extract_name_from_spawn_command(spawn_cmd)}' added to transient spawn queue file: \n\n'{self.SPAWN_QUEUE_TRANSIENT_FILE}'") # Inform user
                    print(f"DEBUG: Command written to spawn queue file: '{self.SPAWN_QUEUE_FILE}'") # Debug
                except Exception as e:
                    #messagebox.showerror("Error", f"Failed to write to transient spawn queue file: {e}") # Error message if writing fails
                    print(f"ERROR: Failed to add spawn queue: {e}") # Error print
                # --- MODIFIED: Write to spawn queue file instead of clipboard ---


                # --- NEW: Refresh Spawn Queue Window if open  ---
                if hasattr(self, 'spawn_queue_window') and self.spawn_queue_window and self.spawn_queue_window.winfo_exists():
                    print("DEBUG: Spawn Queue window is open, refreshing content...")
                    self.populate_spawn_queue_window(self.spawn_queue_scrollable_frame) # Refresh content
                    print("DEBUG: Spawn Queue window content refreshed.")
                #--- NEW: Refresh Spawn Queue Window if open (now refreshed later conditionally) ---

                time.sleep(0.725)
                if scanning_window:
                    scanning_window.destroy()

                # --- NEW: Re-open Spawn Queue Window if it was closed initially ---


            except Exception as e:
                print(f"Error during spawn process: {e}")

            else:
                print("Warning: Spawn command STILL not available for writing to Spawn Queue (from double click).") # Debug - Still no spawn command
        
  



    def debounced_show_main_sidebar_info(self, info_data, picture_path, zip_file, folder_name, item):
        """
        Debounced function to call show_main_sidebar_info after a delay.
        """
        self.show_main_sidebar_info(info_data, picture_path, zip_file, folder_name, item)
        self.details_sidebar_debounce_timer = None # Reset timer after execution
      
  



    def _apply_details_data_subset_filter(self, data_to_filter):
        """
        Filters details data list, detailed debug output for prefix comparison.
        - DEBUG: Added logging to inspect normalized prefixes just before comparison.
        """
        if not self.is_data_subset_active:  # Respect global filter toggle
            return data_to_filter

        subset_filepaths = set()
        data_subset_file_path = os.path.join(self.script_dir, self.data_subset_file)
        if os.path.exists(data_subset_file_path):
            with open(data_subset_file_path, 'r', encoding="utf-8") as f:
                for line in f:
                    filepath = line.strip().lower().replace('\\', '/')  # Normalize subset filepaths
                    if filepath:
                        subset_filepaths.add(filepath)

        if not subset_filepaths:
            return []

        filtered_data = []
        config_pics_path_lower = self.config_pics_folder.lower().replace('\\', '/')

        for item in data_to_filter:
            pic_path = item[0]
            if pic_path:
                normalized_pic_path = os.path.normpath(pic_path).lower().replace('\\', '/')
                if normalized_pic_path.startswith(config_pics_path_lower):
                    normalized_pic_path = normalized_pic_path[len(config_pics_path_lower):].lstrip('/')

                is_exact_match_found = False
                for subset_line in subset_filepaths:
                    normalized_subset_line = subset_line.strip().lower()

                    # --- NEW: DEBUG PRINTS - Inspect normalized prefixes just before comparison ---
                    #print("DEBUG: Details Subset Filter - Comparing:")
                    #print(f"       Normalized Item Path: '{normalized_pic_path}'") # Print normalized item path
                    #print(f"       Normalized Subset Line: '{normalized_subset_line}'") # Print normalized subset line
                    # --- NEW: DEBUG PRINTS ---


                    if normalized_pic_path == normalized_subset_line:  # Check for EXACT MATCH
                        filtered_data.append(item)
                        is_exact_match_found = True
                        print(f"       - EXACT MATCH FOUND in data_subset.txt") # Debug - Match Found
                        break

                if not is_exact_match_found:
                    pass
                    #print(f"DEBUG: Subset Filter FAIL - Folder: '{item[4]}'")
                    #print(f"       Required prefix line (Normalized): '{normalized_pic_path}'")
                    #print(f"       NO EXACT LINE MATCH in data_subset.txt (Normalized Lines Comparison)")
                    #print(f"       data_subset.txt LINES (Normalized): { [line.strip().lower() for line in subset_filepaths]}")
                    #print(f"       Raw data_subset.txt LINES: {list(subset_filepaths)}")
                    #print(f"       Raw Required Prefix Line: '{pic_path}'") # Raw pic_path here (not prefix)


        #print(f"DEBUG: _apply_details_data_subset_filter - Filtered details data to {len(filtered_data)} items (Full Path Match).")
        return filtered_data





    def go_to_previous_details_page(self):
        """Navigates to the previous page in the details window pagination and resets widget counter."""

        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win


        if self.details_page > 0:
            self.details_page -= 1

            # --- MODIFIED: Reset widget count on page change (PREVIOUS) ---
            ConfigViewerApp.details_widget_count = 0 # <--- RESET WIDGET COUNT HERE
            print("DEBUG: go_to_previous_details_page - Widget count RESET to 0 for new page.") # Debug - Widget Count Reset
            # --- MODIFIED: Reset widget count on page change (PREVIOUS) ---

            self.rebuild_simple_details()
            self._update_details_pagination_bar()
            self.start_debounce_details_search()

            

    def go_to_next_details_page(self):
        """Navigates to the next page in the details window pagination and resets widget counter."""

        scanning_win = self.show_scanning_window(text="Loading...")

        self.scanning_window = scanning_win

        total_pages = math.ceil(len(self.details_filtered_data) / self.items_per_page) if self.items_per_page else 1
        if self.details_page < total_pages - 1:
            self.details_page += 1

            # --- MODIFIED: Reset widget count on page change (NEXT) ---
            ConfigViewerApp.details_widget_count = 0 # <--- RESET WIDGET COUNT HERE
            print("DEBUG: go_to_next_details_page - Widget count RESET to 0 for new page.") # Debug - Widget Count Reset
            # --- MODIFIED: Reset widget count on page change (NEXT) ---

            self.rebuild_simple_details()
            self._update_details_pagination_bar()
            self.start_debounce_details_search()
            

    def customize_color_config(self, spawn_cmd, folder_name):
        """
        Customizes the color configuration by checking for a .pc file in user vehicles
        or extracting it from a mod zip file.

        Args:
            spawn_cmd (str): The spawn command string containing the vehicle config path.
            folder_name (str): The folder name (likely redundant in this context, but included as per original function signature).
        """
        print(f"Starting customize_color_config with spawn_cmd: {spawn_cmd}, folder_name: {folder_name}")






        # 1. Extract the vehicle config path
        config_path_start = spawn_cmd.find("{config = '") + len("{config = '")
        config_path_end = spawn_cmd.find("'}")
        vehicle_config_path = spawn_cmd[config_path_start:config_path_end]
        print(f"Extracted vehicle config path: {vehicle_config_path}")

        # 2. Define search folders
        data_folder = self.script_dir / "data"
        user_vehicles_folder_txt_path = data_folder / "user_vehicles_folder.txt"
        script_parent_folder = self.script_dir.parent

        print(f"Creating model_information.txt with {folder_name}")
        model_info_file_path = data_folder / "model_information.txt"
        try:
            with open(model_info_file_path, 'w', encoding='utf-8') as f:  # 'w' mode will overwrite the file each time
                f.write(folder_name + '\n')
            print(f"Created/updated {model_info_file_path} with folder_name: {folder_name}")
        except Exception as e:
            print(f"Error writing to {model_info_file_path}: {e}")
        print(f"Created model_information.txt with {folder_name}")



        print(f"Data folder path: {data_folder}")
        print(f"User vehicles folder txt path: {user_vehicles_folder_txt_path}")
        print(f"Script parent folder path: {script_parent_folder}")

        user_vehicles_base_folder = None
        try:
            with open(user_vehicles_folder_txt_path, 'r', encoding='utf-8') as f:
                user_vehicles_base_folder_str = f.readline().strip()
                user_vehicles_base_folder = Path(user_vehicles_base_folder_str)
            print(f"User vehicles base folder read from file: {user_vehicles_base_folder}")
        except FileNotFoundError:
            print(f"Error: {user_vehicles_folder_txt_path} not found.")
            return
        except Exception as e:
            print(f"Error reading user_vehicles_folder.txt: {e}")
            return

        # Construct paths for user vehicles folder check
        vehicle_folder_name = vehicle_config_path.split('/')[1] # e.g., DOmirage from vehicles/DOmirage/4G63 Turbo.pc
        pc_file_name = vehicle_config_path.split('/')[-1] # e.g., 4G63 Turbo.pc
        user_vehicle_pc_path = user_vehicles_base_folder / vehicle_folder_name / pc_file_name
        print(f"User vehicle .pc file path to check: {user_vehicle_pc_path}")

        # 4. Check user_vehicles folder
        if user_vehicle_pc_path.exists():
            print(f"Found .pc file in user vehicles folder: {user_vehicle_pc_path}")
            destination_path = data_folder / "customcarcol.pc"
            try:
                shutil.copy2(user_vehicle_pc_path, destination_path)
                print(f"Copied and renamed .pc file from {user_vehicle_pc_path} to {destination_path}")
                self.color_picker()
            except Exception as e:
                print(f"Error copying .pc file from user vehicles: {e}")
            return

        print(f".pc file not found in user vehicles folder.")

        # 5. Check zip_structure.txt
        zip_structure_txt_path = data_folder / "zip_structure.txt"
        print(f"Checking zip_structure.txt at: {zip_structure_txt_path}")

        if not zip_structure_txt_path.exists():
            print(f"Error: {zip_structure_txt_path} not found.")
            return

        target_config_path_zip_txt = vehicle_config_path.replace('/', '\\') # for zip_structure.txt format
        print(f"Target config path for zip_structure.txt: {target_config_path_zip_txt}")

        zip_file_path = None
        try:
            with open(zip_structure_txt_path, 'r', encoding='utf-8') as f: # Added encoding for broader character support
                lines = f.readlines()
                found_config_line_index = -1
                for index, line in enumerate(lines):
                    if target_config_path_zip_txt in line:
                        found_config_line_index = index
                        print(f"Found config path in zip_structure.txt at line {index+1}: {line.strip()}")
                        # Search upwards for zip path
                        for i in range(found_config_line_index - 1, -2, -1): # -2 to include -1 and stop before going further
                            if i == -1: # Reached the beginning of the file without finding zip path
                                print("Zip path not found above the config path line in zip_structure.txt")
                                break
                            zip_line = lines[i].strip()
                            print(f"Checking line {i+1} for zip path: {zip_line}")
                            if ("\\mods\\" in zip_line or "\\content\\" in zip_line) and zip_line.lower().endswith(".zip"): # Case-insensitive zip check

                                zip_file_path_str = zip_line.split(" = ")[1] if " = " in zip_line else zip_line # Handle different formats
                                zip_file_path = Path(zip_file_path_str)
                                print(f"Found zip file path: {zip_file_path}")
                                break
                        if zip_file_path:
                            break # Exit the outer loop once zip_file_path is found
                else: # else block for the for loop, executes if the loop completes without a 'break'
                    print(f"Vehicle config path '{target_config_path_zip_txt}' not found in zip_structure.txt")
                    return

        except Exception as e:
            print(f"Error reading or processing zip_structure.txt: {e}")
            return

        if zip_file_path:
            if not zip_file_path.exists():
                print(f"Error: Zip file not found at path specified in zip_structure.txt: {zip_file_path}")
                return

            zip_base_name = zip_file_path.name
            zip_entry_path = vehicle_config_path # Keep forward slashes here - IMPORTANT CHANGE

            full_zip_entry = f"{zip_base_name}\\{zip_entry_path}" # Construct full zip entry path

            print(f"Zip file path: {zip_file_path}")
            print(f"Zip entry path: {zip_entry_path}")
            print(f"Full zip entry path to extract: {full_zip_entry}")


            destination_path = data_folder / "customcarcol.pc"
            try:
                with zipfile.ZipFile(zip_file_path, 'r') as zf:
                    print("Contents of the zip file:")
                    zf.printdir() # Print zip contents

                    try:
                        with zf.open(zip_entry_path) as source_file: # Use zip_entry_path directly here (backslashes should work in zipfile)
                            with open(destination_path, 'wb') as dest_file:
                                shutil.copyfileobj(source_file, dest_file)
                        print(f"Extracted and renamed .pc file from zip '{zip_file_path}' entry '{zip_entry_path}' to '{destination_path}'")
                    except KeyError:
                        print(f"Error: .pc file '{zip_entry_path}' not found in zip '{zip_file_path}'.")
                    except Exception as extract_e:
                        print(f"Error extracting .pc file from zip: {extract_e}")


            except zipfile.BadZipFile:
                print(f"Error: Invalid zip file: {zip_file_path}")
            except Exception as e:
                print(f"General error processing zip file: {e}")
        else:
            print("Could not determine zip file path from zip_structure.txt")

        # launch the color picker GUI    
        self.color_picker()





    def color_picker1(self, event=None):
        create_color_picker_window(master=self.master, on_replace_or_spawn_callback=self.on_color_picker_replace_or_spawn)

    def color_picker(self):
        create_color_picker_window(master=self.current_detail_window, on_replace_or_spawn_callback=self.on_color_picker_replace_or_spawn)

        
    def open_detail_info_window(self, spawn_cmd, info_data, picture_path, zip_file, folder_name, zip_file_base_name, config_name):
        """Opens a new window to display detailed configuration information."""
        # --- MODIFIED: Close existing detail window if open ---
        if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
            self.current_detail_window.destroy()
            self.current_detail_window = None
        # --- MODIFIED: Close existing detail window if open ---

        detail_win = tk.Toplevel(self.details_window)
        detail_win.title("Configuration Details")
        detail_win.geometry("500x700") # Initial geometry, will be resized later
        detail_win.bind_all("<Control-f>", lambda event: self.color_picker1()) 
        #detail_win.attributes('-topmost', True)
        self.current_detail_window = detail_win

        # Set dark grey background for the window
        detail_win.config(bg="#333333")

        icon_path = self.script_dir / "data/icon.png"


        if os.path.exists(icon_path):
            icon_image = tk.PhotoImage(file=icon_path)
            detail_win.iconphoto(False, icon_image)
        else:
            print(f"Icon file not found: {icon_path}")


        # Center the detail window
        detail_win.transient(self.details_window)
        self.details_window.update_idletasks()
        dw_width = self.details_window.winfo_width()
        dw_height = self.details_window.winfo_height()
        dw_x = self.details_window.winfo_rootx()
        dw_y = self.details_window.winfo_rooty()
        win_width = 390 # Initial width
        win_height = 750 # Initial height, will be adjusted
        x = dw_x + (dw_width // 2) - (win_width // 2) # Center horizontally
        y = dw_y + (dw_height // 2) - (win_height // 2) # Center vertically
        detail_win.geometry(f"{win_width}x{win_height}+{x}+{y}")

        main_frame = tk.Frame(detail_win, bg="#333333")
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        main_frame.columnconfigure(0, weight=1)

        # --- NEW: Brand and Name Labels at the Top ---
        brand_name_frame = tk.Frame(main_frame, bg="#333333") # Frame to hold brand and name
        brand_name_frame.pack(fill=tk.X, pady=(0, 5)) # Pack before image, with padding below

        brand_label = tk.Label(brand_name_frame, text=info_data.get("Name", "Unknown Name"), font=("Segoe UI", 14, "bold"), anchor=tk.CENTER, justify=tk.CENTER, fg="white", bg="#333333")
        brand_label.pack(side=tk.TOP, fill=tk.X) # Brand on top

        name_label = tk.Label(brand_name_frame, text=info_data.get("Brand", "Unknown Brand"), font=("Segoe UI", 12, "bold", "italic"), anchor=tk.CENTER, justify=tk.CENTER, fg="lightgrey", bg="#333333")
        name_label.pack(side=tk.TOP, fill=tk.X) # Name below brand
        # --- NEW: Brand and Name Labels at the Top ---


        # Car Picture (unchanged)
        try:
            img = Image.open(picture_path).convert("RGB")
            img = img.resize((350, 196), self.RESAMPLE_FILTER)
            photo = ImageTk.PhotoImage(img)
            img_label = tk.Label(main_frame, image=photo, bg="#555555")
            img_label.image = photo
            img_label.pack(pady=10, anchor=tk.CENTER) # Pack image AFTER brand and name
        except Exception as e:
            print(f"Error loading detail window image: {e}")
            placeholder_image = Image.new("RGB", (400, 200), "lightgrey")
            placeholder_photo = ImageTk.PhotoImage(placeholder_image)
            img_label = tk.Label(main_frame, image=placeholder_photo, bg="#333333")
            img_label.image = placeholder_photo
            img_label.pack(pady=10, anchor=tk.CENTER) # Pack image AFTER brand and name


        # Car Information Frame (unchanged)
        info_frame = tk.Frame(main_frame, bg="#333333")
        info_frame.pack(fill=tk.X, pady=10)
        info_frame.columnconfigure(0, weight=1)

        row_num = 0
        config_display_name = "Custom/Unspecified"
        individual_info_path = self.find_individual_info_file(folder_name, zip_file_base_name, config_name)
        individual_data = {} # Initialize as empty dict

        if individual_info_path and os.path.exists(individual_info_path):
            try:
                individual_data, _ = self._load_individual_info(individual_info_path)
                config_display_name = individual_data.get("Configuration", "Custom/Unspecified")
            except Exception as e:
                print(f"Error loading individual info JSON in info window: {e}")
                config_display_name = "Error Loading Config Name"

        # --- MODIFIED: Removed fixed wraplength, set anchor and justify ---
        config_name_label = tk.Label(info_frame, text=config_display_name, font=("Segoe UI", 13, "bold"), anchor=tk.CENTER, justify=tk.CENTER, fg="white", bg="#333333") # REMOVED wraplength
        config_name_label.grid(row=row_num, column=0, sticky="ew", columnspan=2, pady=(0,5))
        row_num += 1
        self.config_name_label_detail_window = config_name_label # Store as instance attribute

        top_speed_value = individual_data.get("Top Speed", "N/A")
        if top_speed_value != "N/A" and isinstance(top_speed_value, (int, float)):
            top_speed_value_kmh = round(float(top_speed_value) * 3.6, 0)
            top_speed_display = f"{top_speed_value_kmh} km/h"
        else:
            top_speed_display = "N/A"

        info_labels = [
            ("Top Speed", top_speed_display),
            ("Torque", individual_data.get("Torque", "N/A") or "N/A"),
            ("Power", individual_data.get("Power", "N/A")or "N/A"),
            ("0-100 km/h", individual_data.get("0-100 km/h", "N/A") or "N/A"),
            ("100-0 km/h", individual_data.get("100-0 km/h", "N/A")or "N/A"),
            ("Propulsion", individual_data.get("Propulsion", "N/A")or "N/A"),
            ("Fuel Type", individual_data.get("Fuel Type", "N/A")or "N/A"),
            ("Drivetrain", individual_data.get("Drivetrain", "N/A")or "N/A"),
            ("Transmission", individual_data.get("Transmission", "N/A")or "N/A"),
            ("Weight/Power", individual_data.get("Weight/Power", "N/A")or "N/A"),
            ("Off-Road Score", individual_data.get("Off-Road Score", "N/A")or "N/A"),
            ("Induction type", individual_data.get("Induction type", "N/A")or "N/A"),
            ("Braking G", individual_data.get("Braking G", "N/A")or "N/A"),
        ]

        # --- MODIFIED: Dynamic wraplength and label creation with wraplength ---
        label_wraplength = win_width - 40  # Adjust padding as needed
        for label_text, value in info_labels: #unchanged
            tk.Label(info_frame, text=f"{label_text}:", font=("Segoe UI", 12, "bold"), anchor=tk.E, justify=tk.RIGHT, fg="white", bg="#333333", wraplength=label_wraplength).grid(row=row_num, column=0, sticky="ne", padx=(0,15))
            tk.Label(info_frame, text=value if value else "N/A", font=("Segoe UI", 12, "italic"), anchor=tk.W, justify=tk.LEFT, fg="white", bg="#333333", wraplength=label_wraplength).grid(row=row_num, column=1, sticky="nw")
            row_num += 1
        # --- MODIFIED: Dynamic wraplength and label creation with wraplength ---

        info_frame.columnconfigure(1, weight=1)

        # Buttons Frame - MODIFIED for Configuration Details Window
        button_frame = tk.Frame(main_frame, bg="#333333")
        button_frame.pack(side="bottom", fill=tk.X, pady=10)
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1) # Allow second column to expand
        button_frame.columnconfigure(2, weight=1) # Allow third column to expand for Customize button

        # --- REMOVED Favorites Button from Configuration Details Window ---

        disable_delete_button = False

        found_double_basename = False
        for base_name in self.ZIP_BASE_NAMES:
            if picture_path.count(f"--{base_name}_{base_name}.zip") > 0: # Check for the specific pattern
                found_double_basename = True
                break # No need to check further once one is found
        if found_double_basename:
            disable_delete_button = True

        if zip_file == "user_custom_configs":
            delete_button_text = "Delete Config"
            delete_command = self.on_details_image_right_click
            delete_button_lambda = lambda s=spawn_cmd, p=picture_path, z=zip_file: delete_command(z, s, p)
            delete_button = tk.Button(button_frame, text=delete_button_text, font=("Segoe UI", 12, "bold") , command=delete_button_lambda, fg="#FF6666", bg="#555555", relief=tk.FLAT, bd=0) # Flat button, light red text
        else:
            delete_button = tk.Button(button_frame, text="Delete Mod", font=("Segoe UI", 12, "bold"), command=lambda z=zip_file, win=detail_win: self.confirm_delete_mod(z, win), fg="#FF6666", bg="#555555", relief=tk.FLAT, bd=0) # Flat button, light red text

        if disable_delete_button:
            delete_button.config(state=tk.DISABLED, fg="grey", bg="#666666") # Grey out the button
            delete_button.unbind("<Enter>") # Disable hover effects
            delete_button.unbind("<Leave>")
        else:
            def on_enter_delete(event):
                delete_button.config(bg=self.global_highlight_color, fg="white") # Orange background, white text
            def on_leave_delete(event):
                delete_button.config(bg="#555555", fg="#FF6666") # Default background, light red text

            delete_button.bind("<Enter>", on_enter_delete)
            delete_button.bind("<Leave>", on_leave_delete)

        isolate_button = None # Initialize isolate_button to None
        if not found_double_basename and zip_file != "user_custom_configs":
            isolate_button = tk.Button(button_frame, text="Isolate Mod", font=("Segoe UI", 12, "bold"), command=lambda z=zip_file, win=detail_win: self.confirm_isolate_mod(z, win), fg="white", bg="#555555", relief=tk.FLAT, bd=0) # Flat button, light red text

            def on_enter_isolate(event):
                isolate_button.config(bg=self.global_highlight_color, fg="white") # Orange background, white text
            def on_leave_isolate(event):
                isolate_button.config(bg="#555555", fg="white") # Default background, white text

            isolate_button.bind("<Enter>", on_enter_isolate)
            isolate_button.bind("<Leave>", on_leave_isolate)

        customize_color_button = tk.Button(button_frame, text="Customize Color", font=("Segoe UI", 12, "bold"), command=lambda cmd=spawn_cmd, fn=folder_name: self.customize_color_config(cmd, fn), fg="white", bg="#555555", relief=tk.FLAT, bd=0)

        def on_enter_customize(event):
            customize_color_button.config(bg=self.global_highlight_color, fg="white")
        def on_leave_customize(event):
            customize_color_button.config(bg="#555555", fg="white")

        customize_color_button.bind("<Enter>", on_enter_customize)
        customize_color_button.bind("<Leave>", on_leave_customize)


        delete_button.grid(row=0, column=0, sticky="ew", padx=5, pady=2) # MODIFIED row number for delete button, to be FIRST position
        if isolate_button:
            button_frame.columnconfigure(1, weight=1) # Re-enable second column weight if isolate button exists
            delete_button.grid(row=0, column=0, sticky="ew", padx=5, pady=2) # MODIFIED row number for delete button, to be FIRST position
            isolate_button.grid(row=0, column=1, sticky="ew", padx=5, pady=2) # Isolate button to the right
            customize_color_button.grid(row=0, column=2, sticky="ew", padx=5, pady=2) # Customize button to the far right
        else:
            delete_button.grid(row=0, column=0, sticky="ew", padx=5, pady=2, columnspan=2) # span across 2 columns if no isolate
            customize_color_button.grid(row=0, column=2, sticky="ew", padx=5, pady=2) # Customize button to the right


        # --- NEW: Bind <Configure> event to detail_win to handle label wrapping on window resize ---
        detail_win.bind("<Configure>", self.update_config_name_wraplength)
        # --- NEW: Bind <Configure> event to detail_win to handle label wrapping on window resize ---

        # --- MODIFIED: Adjust window height dynamically (call AFTER binding Configure event) ---
        detail_win.update_idletasks() # Update to calculate required height correctly
        required_height = detail_win.winfo_reqheight()
        detail_win.geometry(f"{win_width}x{required_height}+{x}+{y}") # Set new geometry with dynamic height
        # --- MODIFIED: Adjust window height dynamically ---

        self.current_detail_window = detail_win


    def update_config_name_wraplength(self, event=None):
        """
        Updates the wraplength of the config_name_label in the details window
        based on the window's current width.
        """
        if hasattr(self, 'config_name_label_detail_window') and self.config_name_label_detail_window:
            window_width = self.current_detail_window.winfo_width()
            label_wraplength = window_width - 40  # Adjust padding as needed
            self.config_name_label_detail_window.config(wraplength=label_wraplength)





    def on_config_details_favorites_click(self, vehicle_folder, pc_filename_base, button):
        """Handles click on the 'Add to Favorites' button in Configuration Details window."""
        pc_filename = pc_filename_base + '.pc'
        if self.is_favorite(vehicle_folder, pc_filename):
            self.remove_from_favorites(vehicle_folder, pc_filename)
            button.config(text="Add to favorites")
            response = messagebox.showinfo("Favorites Update", "Removed from Favorites", parent=self.current_detail_window)
            action_type = "removed"
        else:
            self.add_to_favorites(vehicle_folder, pc_filename)
            button.config(text="Remove from favorites")
            response = messagebox.showinfo("Favorites Update", "Added to Favorites", parent=self.current_detail_window)
            action_type = "added"



        # --- Conditional Close Logic - MODIFIED to close CONFIGURATION DETAILS WINDOW ---
        if response == "ok" and action_type == "removed" and self.details_window_is_favorites_filtered:
            print("DEBUG: Closing Configuration Details Window due to favorite removal in Favorites mode.") # Debug
            if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
                
                self.refresh_details_grid_after_favorite_change()
                self.perform_search()                
                self.current_detail_window.destroy()
                self.current_detail_window = None

        # --- NEW: Conditional Close Logic - DETAILS LIST WINDOW if only 1 config left ---
        if response == "ok" and action_type == "removed" and self.details_window_is_favorites_filtered:
            if len(self.details_filtered_data) < 1: # Check if filtered data has 1 or fewer items AFTER removal
                print(f"DEBUG: Only {len(self.details_filtered_data)} config(s) left in Details List after favorite removal. Closing Details List Window.") # Debug
                messagebox.showinfo("Favorites Update", "Closing Details List Window as only one or no favorites are left.", parent=self.details_window) # Optional message for Details List close
                self.refresh_details_grid_after_favorite_change()
                self.perform_search()

                self.on_details_window_close() # Close the DETAILS LIST window
        # --- End Conditional Close Logic ---

    def refresh_details_grid_after_favorite_change(self):
        """Refreshes the details grid after a favorite change, respecting the 'Favorites' filter."""
        if not self.details_window or self.details_window_closed:
            print("DEBUG: refresh_details_grid_after_favorite_change - Details window NOT open or closed, exiting refresh.") # DEBUG
            return  # Exit if details window is not open

        print("\n--- refresh_details_grid_after_favorite_change() ENTRY ---") # Debug Entry

        current_subgrid_data = self.details_data # Start with the original details data
        print(f"  DEBUG: refresh_details_grid_after_favorite_change - Initial data count: {len(current_subgrid_data)}") # Debug - Initial Data Count

        if self.details_window_is_favorites_filtered:
            print("  DEBUG: refresh_details_grid_after_favorite_change - Favorites filter ACTIVE.") # Debug - Favorites Filter Active
            # Apply Favorites filter to details data
            favorite_configs_set = self.read_favorites()
            filtered_data = []
            for item in self.details_data:
                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                fav_key = f"{folder_name}|{config_name}.pc"
                if fav_key in favorite_configs_set:
                    filtered_data.append(item)
            current_subgrid_data = filtered_data # Use filtered data if Favorites filter is on
            print(f"  DEBUG: refresh_details_grid_after_favorite_change - Data count AFTER Favorites filter: {len(current_subgrid_data)}") # Debug - Filtered Data Count
        else:
            print("  DEBUG: refresh_details_grid_after_favorite_change - Favorites filter NOT active, showing all data.") # Debug - Favorites Filter Inactive

        self.details_filtered_data = current_subgrid_data[:] # Update filtered data list
        print(f"  DEBUG: refresh_details_grid_after_favorite_change - details_filtered_data updated, count: {len(self.details_filtered_data)}") # Debug - Updated Filtered Data Count

        self.rebuild_simple_details() # Rebuild subgrid UI with updated data
        print("  DEBUG: refresh_details_grid_after_favorite_change - rebuild_simple_details() called.") # Debug - Rebuild Called

        if self.details_count_label:
            self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}") # Update count label
            print(f"  DEBUG: refresh_details_grid_after_favorite_change - Count label updated to: {len(self.details_filtered_data)}") # Debug - Count Label Updated
        self._update_details_pagination_bar() # <--- ADD THIS LINE to update pagination bar AFTER refresh
        print("  DEBUG: refresh_details_grid_after_favorite_change - _update_details_pagination_bar() called.") # Debug - Pagination Bar Updated
        print("--- refresh_details_grid_after_favorite_change() EXIT ---\n")

        

    def confirm_delete_mod(self, zip_file, detail_win):
        """Asks for confirmation before deleting mod and closes detail window."""
        confirm = messagebox.askyesno(
            "Confirm Delete",
            f"Are you sure you want to delete the mod '{zip_file}' and all related files?",
            parent=detail_win # Parent to detail window
        )
        if confirm:
            self.delete_item(zip_file)
            detail_win.destroy() # Close detail window after delete


    def open_isolated_folder_in_explorer(self):
        """Opens the specified folder path in the system's file explorer.
        Creates the folder if it does not exist.

        Args:
            folder_path: The path to the folder you want to open.
        """
        userfolder_root = os.path.dirname(os.path.dirname(os.path.dirname(self.script_dir))) # Go up 3 levels
        folder_path = os.path.join(userfolder_root, "Isolated")

        if not os.path.exists(folder_path):
            try:
                os.makedirs(folder_path, exist_ok=True) # Create the folder and any parent directories
                print(f"Folder created: {folder_path}")
            except OSError as e:
                print(f"Error creating folder: {folder_path}. {e}")
                return False # Indicate failure to create folder, and thus to open

        if sys.platform.startswith('win'):  # Windows
            try:
                os.startfile(folder_path)
                return True
            except OSError:
                print(f"Error opening folder in File Explorer (Windows): {folder_path}")
                return False
        elif sys.platform.startswith('darwin'):  # macOS
            try:
                subprocess.Popen(['open', folder_path])
                return True
            except FileNotFoundError:
                print(f"'open' command not found on macOS. Cannot open folder: {folder_path}")
                return False
        elif sys.platform.startswith('linux'):  # Linux
            try:
                subprocess.Popen(['xdg-open', folder_path])
                return True
            except FileNotFoundError:
                try:
                    subprocess.Popen(['gnome-open', folder_path])
                    return True
                except FileNotFoundError:
                    try:
                        subprocess.Popen(['start', folder_path], shell=True)
                        return True
                    except FileNotFoundError:
                        print(f"Could not open file explorer on Linux. Make sure 'xdg-open', 'gnome-open', or 'start' is available.")
                        return False
        else:
            print(f"Unsupported operating system: {sys.platform}. Cannot open file explorer.")
            return False


        
    def confirm_isolate_mod(self, zip_file, detail_win):
        """Asks for confirmation before isolating mod and closes detail window."""

        userfolder_root = os.path.dirname(os.path.dirname(os.path.dirname(self.script_dir))) # Go up 3 levels
        isolated_folder_path = os.path.join(userfolder_root, "Isolated")

        confirm = messagebox.askyesno(
            "Confirm Isolate",
            f"Are you sure you move the mod '{zip_file}' to '{isolated_folder_path}'?",
            parent=detail_win # Parent to detail window
        )
        if confirm:
            self.isolate_item(zip_file)
            detail_win.destroy() # Close detail window after delete



        
    def start_details_sidebar_debounce(self, info_data, picture_path, zip_file, widget, pil_image):
        """
        Starts the debounce timer for updating the details sidebar.
        """
        if self.details_sidebar_debounce_timer:
            self.master.after_cancel(self.details_sidebar_debounce_timer) # Cancel existing timer

        self.current_debounce_widget = widget # Store widget for highlight
        self.current_debounce_pil_image = pil_image # Store pil_image for highlight

        # Start a new timer
        self.details_sidebar_debounce_timer = self.master.after(
            400, # 400ms delay
            lambda: self.debounced_details_sidebar_update(info_data, picture_path, zip_file)
        )
        self.set_highlight(widget, pil_image) # Immediate highlight

    def debounced_details_sidebar_update(self, info_data, picture_path, zip_file):
        """
        Debounced function to update the details sidebar content.
        """
        self.show_details_sidebar_info(info_data, picture_path, zip_file)
        self.details_sidebar_debounce_timer = None # Reset timer

    def on_details_image_click(self, spawn_cmd, info_data, picture_path, zip_file, folder_name):
        """Handles single click on an image in the details subgrid.
        MODIFIED: Now receives folder_name as argument and updates self.current_details_folder correctly.
        DEBUGGED: Added print statements to REALLY check received spawn_cmd and folder_name. <--- MORE DEBUGGING
        """

        if hasattr(self, 'current_detail_window') and self.current_detail_window and self.current_detail_window.winfo_exists():
            self.current_detail_window.destroy()
            
        self.clear_details_sidebar_content() #clean up the sidebar before moving on    

        print("\n\n--- on_details_image_click() ENTRY ---")  # Debug Entry
        # --- DEBUGGING - ADDED EXTENSIVE DEBUGGING HERE ---
        print("DEBUG (on_details_image_click) - START - Function Called") # Debug: Function start
        print(f"DEBUG (on_details_image_click): Received spawn_cmd (at function entry): {spawn_cmd}") # Debug: Check received spawn_cmd - ENTRY POINT
        print(f"DEBUG (on_details_image_click): Received picture_path: {picture_path}") # Debug: Check received picture_path
        print(f"DEBUG (on_details_image_click): Received zip_file: {zip_file}") # Debug: Check received zip_file
        print(f"DEBUG (on_details_image_click): Received info_data: {info_data}") # Debug: Check received info_data
        # --- NEW DEBUG PRINT - CHECK RECEIVED folder_name ---
        print(f"DEBUG (on_details_image_click): Received folder_name: {folder_name}") # Debug: Check received folder_name <--- CHECK THIS VALUE!
        # --- NEW DEBUG PRINT - CHECK RECEIVED folder_name ---
        # --- DEBUGGING - ADDED EXTENSIVE DEBUGGING HERE ---

        print(f"  DEBUG: on_details_image_click - zip_file: {zip_file}, picture_path: {picture_path}") # Debug - Args
        print(f"  DEBUG: on_details_image_click - info_data: {info_data.get('Name')}, {info_data.get('Brand')}")  # Debug - Info Data

        self.is_details_sidebar_sticky = True
        self.is_details_sidebar_showing_default = False  # No longer showing default

        # --- ENSURE SIDEBAR ATTRIBUTES ARE UPDATED **BEFORE** calling update_details_sidebar_content and update_details_sidebar_favorites_button_text ---
        self.current_details_sidebar_spawn_cmd = spawn_cmd # UPDATE sidebar attributes **FIRST**
        self.current_details_sidebar_info_data = info_data
        self.current_details_sidebar_picture_path = picture_path
        self.current_details_sidebar_zip_file = zip_file
        self.current_details_folder = folder_name # <--- MODIFIED: Now use the folder_name *received as argument*
        # --- DEBUGGING - ADDED DEBUG PRINTS AFTER SETTING SIDEBAR ATTRIBUTES ---
        print("DEBUG (on_details_image_click): Sidebar attributes UPDATED:") # Debug - Attribute Update Start
        print(f"    - self.current_details_sidebar_spawn_cmd: {self.current_details_sidebar_spawn_cmd}") # Debug - Print updated spawn_cmd - CHECK THIS VALUE!
        print(f"    - self.current_details_folder: {self.current_details_folder}") # Debug - Print current_details_folder - CHECK THIS VALUE!
        print(f"    - self.current_details_sidebar_zip_file: {self.current_details_sidebar_zip_file}") # Debug - Print current_details_zip_file - CHECK THIS VALUE!
        print("DEBUG (on_details_image_click): Sidebar attributes UPDATE COMPLETED.") # Debug - Attribute Update End
        # --- DEBUGGING - ADDED DEBUG PRINTS AFTER SETTING SIDEBAR ATTRIBUTES ---
        # --- ENSURE SIDEBAR ATTRIBUTES ARE UPDATED **BEFORE** calling update_details_sidebar_content and update_details_sidebar_favorites_button_text ---


        # --- Now, pass the info_data and folder name here as well ----
        self.update_details_sidebar_content(info_data, picture_path, zip_file, folder_name=self.current_details_folder)
        self.update_details_sidebar_config_name(spawn_cmd) # Update config name label on click


        print("--- on_details_image_click() EXIT ---\n")  # Debug Exit

    def update_details_sidebar_config_name(self, spawn_cmd):
        """Updates the config name label at the bottom of the details sidebar to display ONLY CONFIG NAME."""
        pc_name = self.extract_name_from_spawn_command(spawn_cmd) # Extract ONLY the config name (PC filename)
        self.details_sidebar_config_name_label.config(text=f"({pc_name}.pc)") # Set label text to "Config: <config_name>"
        self.details_sidebar_config_name_label.spawn_command = spawn_cmd # NEW: Store the FULL spawn_command as an attribute of the label

    def on_details_image_double_click(self, spawn_cmd, info_data, picture_path, zip_file):
        """Handles double click on an image in the details subgrid."""
        self.on_spawn_new_button_click() # Use same action as button click - which includes copy to clipboard

    def show_details_sidebar_buttons(self):
        """Shows the action buttons in the details sidebar."""
        if self.details_add_to_queue_button and self.details_spawn_new_button:
            self.details_add_to_queue_button.pack(side="top", fill="x", pady=(2, 0), padx=0) # Add to Queue below
            self.details_spawn_new_button.pack(side="top", fill="x", pady=(0, 2), padx=0) # Spawn New on top


            
    def on_delete_custom_config_button_click(self):
        """Handles click on the 'Delete Custom Config' button in the details sidebar."""
        if hasattr(self, 'current_details_sidebar_spawn_cmd'): # Check if attributes are available
            spawn_cmd = self.current_details_sidebar_spawn_cmd
            picture_path = self.current_details_sidebar_picture_path
            zip_file = self.current_details_sidebar_zip_file
            self.on_details_image_right_click(zip_file, spawn_cmd, picture_path) # REUSE existing right-click logic
        else:
            print("Warning: Config details not available for Delete Custom Config action.")
            
    def hide_details_sidebar_buttons(self):
        """Hides the action buttons in the details sidebar."""
        if self.details_add_to_queue_button and self.details_spawn_new_button:
            self.details_add_to_queue_button.pack_forget()
            self.details_spawn_new_button.pack_forget()

    def show_details_sidebar_info(self, info_data, picture_path, zip_file):
        """Shows details sidebar info labels and updates content."""
        if not self.is_details_sidebar_sticky: # Only update if not sticky
            self.update_details_sidebar_content(info_data, picture_path, zip_file)
            self.is_details_sidebar_showing_default = False # Hovering means not default anymore

    def hide_details_sidebar_info(self):
        """Hides details sidebar info labels and clears all sidebar content."""
        if not self.is_details_sidebar_sticky: # Only clear if not sticky
             pass
             #self.check_and_reset_details_sidebar()
             #this function is not necessary, because there should always technically be something in the grid; check unused_functions.py



    def update_details_sidebar_content(self, info_data, picture_path, zip_file, folder_name=None):
        """
        Updates details sidebar with car name, picture, and JSON details.
        NOW also updates sidebar attributes: spawn_cmd, info_data, picture_path, zip_file.
        Calls update_details_sidebar_favorites_button_text() at the end to refresh the button text.
        """
        print("\n--- update_details_sidebar_content() ENTRY ---")
        print(f"  DEBUG: update_details_sidebar_content - zip_file: {zip_file}, picture_path: {picture_path}")
        print(f"  DEBUG: update_details_sidebar_content - info_data: {info_data.get('Name')}, {info_data.get('Brand')}")

        # Car Name Label & Image Loading (unchanged)
        brand = info_data.get("Brand", "").strip()
        name = info_data.get("Name", "").strip()
        vehicle_type = info_data.get("Type", "").strip()
        if brand:
            if name:
                display_name_text = f"{brand} {name}"
            elif vehicle_type:
                display_name_text = f"{brand} {vehicle_type}"
            else:
                display_name_text = brand
        elif name:
            display_name_text = name
        elif vehicle_type:
            display_name_text = vehicle_type
        else:
            display_name_text = "Unknown"
        self.details_sidebar_car_name_label.config(text=display_name_text if display_name_text else "Unknown")

        self.details_sidebar_loading_label.pack(pady=(0, 10), padx=10)
        try:
            if picture_path and os.path.exists(picture_path):
                img = Image.open(picture_path).convert("RGB")
                img = img.resize((280, 157), self.RESAMPLE_FILTER)
                photo = ImageTk.PhotoImage(img)
                self.details_sidebar_image_label.config(image=photo)
                self.details_sidebar_image_label.image = photo
                self.details_sidebar_image_label.config(bg="#555555")
            else:
                placeholder_image = Image.new("RGB", (280, 157), "lightgrey")
                placeholder_photo = ImageTk.PhotoImage(placeholder_image)
                self.details_sidebar_image_label.config(image=placeholder_photo)
                self.details_sidebar_image_label.image = placeholder_photo
        except Exception as e:
            print(f"Error loading details sidebar image: {e}")
            placeholder_image = Image.new("RGB", (280, 157), "lightgrey")
            placeholder_photo = ImageTk.PhotoImage(placeholder_image)
            self.details_sidebar_image_label.config(image=placeholder_photo)
            self.details_sidebar_image_label.image = placeholder_photo
            self.details_sidebar_car_name_label.config(text=f"Error Loading Image for: {display_name_text}")
        finally:
             self.details_sidebar_loading_label.pack_forget()

        # --- MODIFIED: Set Zip File Label - ADDED DEBUGGING ---
        print("  DEBUG: Setting Zip File Label...") # Debug - Zip File Label Setting Start
        if zip_file == "folder_grouped": # Check for the flag we set in on_picture_click
            zip_file_display_name = "Custom Configuration"
            print("    DEBUG: zip_file is 'folder_grouped', setting Zip File Label to 'Custom Configuration'") # Debug - Custom Config Case
        elif zip_file == "user_custom_configs": # Fallback for older logic if still somehow used
            zip_file_display_name = "Custom Configuration"
            print("    DEBUG: zip_file is 'user_custom_configs', setting Zip File Label to 'Custom Configuration' (fallback)") # Debug - Fallback Case
        else:
            zip_file_display_name = zip_file # Display normal zip file name
            print(f"    DEBUG: zip_file is '{zip_file}', setting Zip File Label to zip_file name") # Debug - Normal Zip Case

        print(f"    DEBUG: Setting details_sidebar_zipfile_label_val to: '{zip_file_display_name}'") # Debug - Label Value
        self.details_sidebar_zipfile_label_val.config(text=zip_file_display_name) # Set Zip File label - MODIFIED
        self.details_sidebar_zipfile_label_cat.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(5, 0)) # Pack Zip File label - MODIFIED
        self.details_sidebar_zipfile_label_val.pack(in_=self.details_sidebar_frame, fill="x", padx=10, pady=(0, 5)) # Pack Zip File value - MODIFIED
        # --- MODIFIED: Set Zip File Label - ADDED DEBUGGING ---


        # Extract individual info (unchanged)
        extracted_info = self.extract_info_from_sidebar_image(picture_path)
        if extracted_info:
            individual_info_path = self.find_individual_info_file(
                extracted_info["folder_name"],
                extracted_info["zip_file_base_name"],
                extracted_info["config_name"]
            )
            print(f"  DEBUG: Determined individual_info_path: {individual_info_path}")
            self.update_details_sidebar_individual_info(individual_info_path, main_info_data=info_data)
        else:
            print("  WARNING: Could not extract info from sidebar image filename. Info labels will not be updated.")

        # --- UPDATE sidebar attributes in update_details_sidebar_content ---
        # Get spawn_cmd from the currently highlighted item (assuming it's stored in the image label)
        current_item_data = self.current_main_sidebar_item # Get the stored item data tuple
        if current_item_data:
            _, spawn_cmd, _, _, _ = current_item_data # Extract spawn_cmd from the tuple
            self.current_details_sidebar_spawn_cmd = spawn_cmd # Update sidebar attribute
            self.current_details_sidebar_info_data = info_data
            self.current_details_sidebar_picture_path = picture_path
            self.current_details_sidebar_zip_file = zip_file
            print("  DEBUG: Sidebar attributes UPDATED in update_details_sidebar_content (from current_main_sidebar_item)")
        else:
            print("  WARNING: current_main_sidebar_item is NOT SET, cannot reliably update sidebar attributes in update_details_sidebar_content.")
            # Fallback: Try to use data from the *first* item in details_data (less ideal, but might work in some cases)
            if self.details_data:
                first_item_spawn_cmd = self.details_data[0][1] # Get spawn_cmd from the first item in details_data
                self.current_details_sidebar_spawn_cmd = first_item_spawn_cmd
                self.current_details_sidebar_info_data = info_data # Still use current info_data
                self.current_details_sidebar_picture_path = picture_path
                self.current_details_sidebar_zip_file = zip_file
                print("  DEBUG: Sidebar attributes UPDATED (FALLBACK - using first item's spawn_cmd from details_data)")
            else:
                print("  ERROR: NO details_data available for fallback sidebar attribute update in update_details_sidebar_content.")
                self.current_details_sidebar_spawn_cmd = None # Ensure it's None if no way to determine spawn_cmd
                self.current_details_sidebar_info_data = None
                self.current_details_sidebar_picture_path = None
                self.current_details_sidebar_zip_file = None
        # --- UPDATE sidebar attributes in update_details_sidebar_content ---

        # --- NEW: Update Favorites Button Text on Sidebar Content Update ---
        self.update_details_sidebar_favorites_button_text()
        # --- NEW: Update Favorites Button Text on Sidebar Content Update ---

        print("--- update_details_sidebar_content() EXIT ---\n")
        
        


    def find_default_config_item_details(self, details_data, zip_file):
        """
        Finds the default config item from details_data based on 'default_pc' in JSON info.
        Returns the item tuple or None if not found.
        """
        # First, try to get info data from any item in details_data (assuming info is consistent for the zip)
        sample_info_data = details_data[0][3] if details_data else None
        if sample_info_data:
            default_pc_name = sample_info_data.get("default_pc", "").strip()
            if default_pc_name:
                base_pc_name = os.path.splitext(default_pc_name)[0] # Remove extension
                for item in details_data:
                    item_picture_path, _, _, item_info_data, _ = item
                    item_config_name = self.extract_name_from_spawn_command(item[1]) # Extract config name from spawn cmd
                    if item_config_name == base_pc_name:
                        return item # Found the default config item
        # If no default_pc in info or not found, return the first item as fallback
        return None


    def on_details_image_right_click(self, zip_file, spawn_cmd, picture_path):
        self.details_is_deleting = True
        if self.details_deleting_label and not self.details_window_closed:
            self.details_deleting_label.config(text="Deleting...")
        self.toggle_details_deleting_text()

        temp_window = tk.Toplevel(self.details_window)
        temp_window.withdraw() # Make it invisible
        if self.details_window:
            temp_window.transient(self.details_window)
            temp_window.grab_set()

        if zip_file == "user_custom_configs":
            match = re.search(r"config\s*=\s*'vehicles/([^/]+)/([^\.]+)\.pc'", spawn_cmd)
            if match:
                folder_name, file_name = match.groups()
            else:
                self.details_is_deleting = False
                if self.details_deleting_label and not self.details_window_closed:
                    self.details_deleting_label.config(text="")
                messagebox.showerror("Error", "Unable to parse configuration details.")
                if self.details_window:
                    temp_window.destroy()
                return
            confirm = messagebox.askyesno(
                "Confirm Delete",
                f"Are you sure you want to delete the custom config '{file_name}' in folder '{folder_name}'?",
                parent = temp_window
            )
            self.details_is_deleting = False
            if self.details_deleting_label and not self.details_window_closed:
                self.details_deleting_label.config(text="")
            if confirm:
                self.delete_specific_custom_config(folder_name, file_name, picture_path)
                self.run_python_scripts_custom()
                
                try:
                    script_path = os.path.join(self.script_dir, "modify_output_good_custom.py")
                    if not os.path.exists(script_path):
                    #    messagebox.showerror("Script Not Found",
                    #                         f"The script 'modify_output_good_custom.py' was not found in {self.script_dir}.")
                        pass

                        if self.details_window:
                            temp_window.destroy()
                        return
                    #subprocess.run([sys.executable, script_path], check=True)
                    #messagebox.showinfo("Script Execution",
                    #                    "'modify_output_good_custom.py' has been executed successfully.")
                except subprocess.CalledProcessError as e:
                    messagebox.showerror(
                        "Script Execution Error",
                        f"An error occurred while running 'modify_output_good_custom.py':\n{e}"
                    )
                except Exception as e:
                    messagebox.showerror(
                        "Unexpected Error",
                        f"An unexpected error occurred:\n{e}"
                    )
            if self.details_window:
                temp_window.destroy()
        else:
            confirm = messagebox.askyesno(
                "Confirm Delete",
                f"Are you sure you want to delete the mod '{zip_file}' and all related files?",
                parent=temp_window
            )
            self.details_is_deleting = False
            if self.details_deleting_label and not self.details_window_closed:
                self.details_deleting_label.config(text="")
            if confirm:
                self.delete_item(zip_file)
            temp_window.destroy()



    def delete_item(self, zip_file):
        """Deletes an item, added search window update."""
        pattern = zip_file.lower()
        deleted_files = []
        errors = []

        parent_dir = os.path.dirname(self.script_dir)
        folders = [
            self.config_pics_folder,
            self.config_info_folder,
            self.repo_folder,
            self.vehicles_content_folder,
            parent_dir
        ]
        for folder in folders:
            if not os.path.exists(folder):
                continue
            try:
                for filename in os.listdir(folder):
                    if pattern in filename.lower():
                        path_to_del = os.path.join(folder, filename)
                        if os.path.isfile(path_to_del):
                            os.remove(path_to_del)
                            deleted_files.append(path_to_del)
            except Exception as e:
                errors.append(f"Error deleting in {folder}: {e}")
        if errors:
            msg = "\n".join(errors)
            messagebox.showerror("Deletion Errors", f"Some errors occurred:\n{msg}")
        if deleted_files:
            #messagebox.showinfo("Deletion Successful", f"Deleted '{zip_file}' and related files.")
            self.data = [d for d in self.data if d[2].lower() != zip_file.lower()]
            self.full_data.pop(zip_file, None)
            self.grouped_data = self.format_grouped_data(self.data)
            self.update_grid_layout()

            if self.details_window and not self.details_window_closed:
                self.refresh_details_window_after_deletion()
            self.update_search_results_window_ui() # <----- ADD THIS LINE HERE # MODIFIED - Call update function here




    def isolate_item(self, zip_file):
        """Deletes an item, added search window update, and isolates zip files."""
        pattern = zip_file.lower()
        deleted_files = []
        errors = []

        parent_dir = os.path.dirname(self.script_dir)
        grandparent_dir = os.path.dirname(parent_dir)
        great_grandparent_dir = os.path.dirname(grandparent_dir) # Get great grandparent directory
        isolated_folder = os.path.join(great_grandparent_dir, "Isolated") # Path to Isolated folder

        # Create the Isolated folder if it doesn't exist
        os.makedirs(isolated_folder, exist_ok=True)

        folders = [
            self.config_pics_folder,
            self.config_info_folder,
            self.repo_folder,
            self.vehicles_content_folder,
            parent_dir
        ]
        for folder in folders:
            if not os.path.exists(folder):
                continue
            try:
                for filename in os.listdir(folder):
                    if pattern in filename.lower():
                        path_to_del = os.path.join(folder, filename)
                        if os.path.isfile(path_to_del):
                            if filename.lower().endswith(".zip"): # Check if it's a zip file
                                try:
                                    destination_path = os.path.join(isolated_folder, filename)
                                    shutil.move(path_to_del, destination_path) # Move the zip file
                                    deleted_files.append(path_to_del) # Still add to deleted files for UI update
                                    print(f"Moved ZIP file: {path_to_del} to {destination_path}") # Optional logging
                                except Exception as move_err:
                                    errors.append(f"Error moving ZIP file {path_to_del} to Isolated: {move_err}")
                            else: # If not a zip file, proceed with deletion as before
                                os.remove(path_to_del)
                                deleted_files.append(path_to_del)
            except Exception as e:
                errors.append(f"Error processing folder {folder}: {e}")

        if errors:
            msg = "\n".join(errors)
            messagebox.showerror("Deletion Errors", f"Some errors occurred:\n{msg}")

        if deleted_files:
            #messagebox.showinfo("Deletion Successful", f"Deleted '{zip_file}' and related files.")
            self.data = [d for d in self.data if d[2].lower() != zip_file.lower()]
            self.full_data.pop(zip_file, None)
            self.grouped_data = self.format_grouped_data(self.data)
            self.update_grid_layout()

            if self.details_window and not self.details_window_closed:
                self.refresh_details_window_after_deletion()
            self.update_search_results_window_ui() # <----- ADD THIS LINE HERE # MODIFIED - Call update function here

                
                
    def delete_specific_custom_config(self, folder_name, file_name, picture_path):
        pc_file_path = os.path.join(self.user_folder, folder_name, f"{file_name}.pc")
        if os.path.exists(pc_file_path):
            try:
                os.remove(pc_file_path)
            except Exception as e:
                messagebox.showerror("Deletion Error", f"Error deleting {pc_file_path}: {e}")
                return
        else:
            messagebox.showwarning("File Not Found", f"The file {pc_file_path} does not exist.")

        # Delete associated image files (.png, .jpeg, .jpg)
        image_extensions = ['.png', '.jpeg', '.jpg']
        for ext in image_extensions:
            image_file_path = os.path.join(self.user_folder, folder_name, f"{file_name}{ext}")
            if os.path.exists(image_file_path):
                try:
                    os.remove(image_file_path)
                    print(f"Deleted image file: {image_file_path}")
                except Exception as e:
                    messagebox.showerror("Deletion Error", f"Error deleting {image_file_path}: {e}")
                    return
                    
        if self.details_window and not self.details_window_closed:
            self.refresh_details_window_after_deletion()
            
            
        base_image_name = f"vehicles--{folder_name}_user--{file_name}"
        image_file_path = None
        for ext in ['jpg', 'jpeg', 'png']:
            candidate = os.path.join(self.config_pics_custom_folder, f"{base_image_name}.{ext}")
            if os.path.exists(candidate):
                image_file_path = candidate
                break

        if image_file_path and os.path.exists(image_file_path):
            try:
                os.remove(image_file_path)
            except Exception as e:
                messagebox.showerror("Deletion Error", f"Error deleting {image_file_path}: {e}")
                return

        # Remove the deleted config from full_data
        if "user_custom_configs" in self.full_data:
            for info_key in list(self.full_data["user_custom_configs"].keys()):
                group = self.full_data["user_custom_configs"][info_key]
                group['configs'] = [
                    cfg for cfg in group['configs']
                    if not (cfg[4] == folder_name and self.extract_name_from_spawn_command(cfg[1]) == file_name)
                ]
                if not group['configs']:
                    del self.full_data["user_custom_configs"][info_key]

        # Update self.data to only include one representative config per group
        self.data = []
        for zip_file, groups in self.full_data.items():
            if zip_file != "user_custom_configs":
                # For non-custom configs, add the first config as representative
                if groups:
                    self.data.append(groups[0])
            else:
                # For custom configs, add one representative config per info_key
                for info_key, group_data in groups.items():
                    if group_data['configs']:
                        self.data.append(group_data['configs'][0])

        self.grouped_data = self.format_grouped_data(self.data)
        self.update_grid_layout()

        # Refresh the details window if it's open
        if self.details_window and not self.details_window_closed:
            self.refresh_details_window()
        self.update_search_results_window_ui()     

    def refresh_details_window(self):
        """
        Robustly refreshes the details window, ensuring data is reloaded and the subgrid rebuilt.
        """
        if self.details_window and not self.details_window_closed:
            print("\n--- Starting ROBUST Details Window Refresh (Attempt 7 - DEBUGGING DATA REFRESH) ---") # Debug Print - Start

            # --- NEW: Cancel any pending details batch loads BEFORE destroying canvas ---
            if self.details_window and self.scroll_animation_timer: # Check if details_window exists AND animation timer is active
                print("  Cancelling any pending details batch loads...") # Debug
                self.details_window.after_cancel(self.scroll_animation_timer) # Cancel details animation timer (which schedules batch loads)
                self.scroll_animation_timer = None # Reset timer ID
                print("  Pending details batch loads CANCELED.") # Debug

            # --- Destroy and Recreate Canvas and Scrollable Frame ---
            print("  Destroying existing canvas and scrollable frame...") # Debug
            if self.details_canvas_sub and self.details_canvas_sub.winfo_exists(): # Check if canvas exists before destroy
                self.details_canvas_sub.destroy()
            if hasattr(self, 'scrollbar_sub') and self.scrollbar_sub and self.scrollbar_sub.winfo_exists(): # Check if scrollbar exists before destroy
                self.scrollbar_sub.destroy()
            self.details_canvas_sub = None
            self.details_scrollable_frame = None

            # Re-create Canvas and Scrollable Frame
            self.details_canvas_sub = tk.Canvas(self.details_main_frame, bg="#444444", highlightthickness=0)
            self.scrollbar_sub = tk.Scrollbar(self.details_main_frame, orient="vertical", command=self.details_canvas_sub.yview) # Re-create scrollbar AND re-assign to self
            self.details_scrollable_frame = tk.Frame(self.details_canvas_sub, bg="#444444")

            self.details_scrollable_frame.bind("<Configure>", lambda e: self.details_canvas_sub.configure(scrollregion=self.details_canvas_sub.bbox("all")))
            self.details_canvas_sub.create_window((0, 0), window=self.details_scrollable_frame, anchor="nw")
            self.details_canvas_sub.configure(yscrollcommand=self.scrollbar_sub.set)

            canvas_sub = self.details_canvas_sub # For details animation and mousewheel binding
            canvas_sub.bind("<Enter>", lambda e: canvas_sub.bind_all("<MouseWheel>", lambda ev: self.on_mousewheel_details(ev, canvas_sub)))
            canvas_sub.bind("<Leave>", lambda e: canvas_sub.unbind_all("<MouseWheel>"))

            print("  Canvas and scrollable frame recreated.") # Debug

            # --- Re-filter data (more robust filtering logic) ---
            subgrid_data = []
            zip_file = self.current_details_zip_file
            folder_name = self.current_details_folder
            print(f"  zip_file for refresh: {zip_file}, folder_name: {folder_name}") # Debug - Zip/Folder for refresh

            if zip_file == "user_custom_configs" and folder_name:
                print("  Filtering for custom configs - folder:", folder_name) # Debug
                if "user_custom_configs" in self.full_data and self.full_data["user_custom_configs"]: # Robust check
                    print("  user_custom_configs key FOUND in full_data.") # Debug
                    for info_key, group in self.full_data["user_custom_configs"].items():
                        print(f"    Checking info_key: {info_key}") # Debug - Info Key
                        for config in group['configs']:
                            config_folder_name = config[4]
                            print(f"      Checking config folder name: {config_folder_name}") # Debug - Config Folder Name
                            if config_folder_name == folder_name:
                                print(f"        Match found for folder: {folder_name}, adding config: {os.path.basename(config[0])}") # Debug - Match - Config Filename
                                subgrid_data.append(config)
                            else:
                                print(f"        No match for folder: {folder_name}, skipping config.") # Debug - No Match
                else:
                    print("  WARNING: user_custom_configs key NOT FOUND in full_data!") # Debug - Warning
            elif zip_file:
                print(f"  Filtering for zip file: {zip_file}...") # Debug
                subgrid_data = self.full_data.get(zip_file, [])
            else:
                print("  WARNING: No zip_file specified for details refresh!") # Debug - Warning

            print(f"  Subgrid data items found AFTER {len(subgrid_data)}") # Debug - Item Count

            # --- Handle Empty Subgrid Data ---
            if not subgrid_data:
                print("  Subgrid data is EMPTY. Clearing details window content.") # Debug
                self.details_data = [] # Clear details data
                self.details_filtered_data = []
                if self.details_count_label:
                    self.details_count_label.config(text="Total: 0") # Update count label to 0
                # Clear ALL widgets from scrollable frame - explicitly
                for widget in self.details_scrollable_frame.winfo_children():
                    widget.destroy()
                self.stop_details_loading_animation() # Stop loading animation if running
                self.details_canvas_sub.config(scrollregion=self.details_canvas_sub.bbox("all")) # Update scrollregion for empty canvas
                print("  Details Window Content Cleared for Empty Subgrid.") # Debug
                print("FULL Details Window Refresh Completed (Empty Subgrid Case). ---\n") # Debug - End Marker
                return # EXIT function early for empty subgrid

            # --- Rebuild the subgrid UI (if not empty) ---
            print("  Rebuilding details subgrid UI (Data Count:", len(subgrid_data),")...") # Debug
            self.details_data = subgrid_data
            self.details_filtered_data = subgrid_data[:]
            self.details_search_var.set("")
            self.rebuild_simple_details() # Rebuild subgrid UI
            print("  Details Subgrid Rebuilt.") # Debug

            # --- Update Sidebar to Default or First Config (NEW) ---
            default_config_item = self.find_default_config_item_details(subgrid_data, zip_file)
            if default_config_item:
                default_picture_path, _, _, default_info_data, _ = default_config_item
                self.update_details_sidebar_content(default_info_data, default_picture_path, zip_file)
                self.update_details_sidebar_config_name(default_config_item[1]) # Set config name label
                self.is_details_sidebar_showing_default = True
                print("  Updated sidebar to DEFAULT config.") # Debug
            elif subgrid_data: # Fallback to first item if no default and data exists
                first_item = subgrid_data[0]
                first_picture_path, _, _, first_info_data, _ = first_item
                self.update_details_sidebar_content(first_info_data, first_picture_path, zip_file)
                self.update_details_sidebar_config_name(first_item[1]) # Set config name label
                self.is_details_sidebar_showing_default = True
                print("  Updated sidebar to FIRST config.") # Debug
            else:
                self.hide_details_sidebar_info() # Hide sidebar if no data
                self.is_details_sidebar_showing_default = False
                print("  No subgrid data, sidebar info HIDDEN.") # Debug


            # --- Update count label and scroll region ---
            if self.details_count_label:
                self.details_count_label.config(text=f"Total: {len(self.details_filtered_data)}")
                print("  Details Count Label Updated.") # Debug
            self.details_scrollable_frame.update_idletasks()
            self.details_canvas_sub.config(scrollregion=self.details_canvas_sub.bbox("all"))
            print("  Details Canvas Scroll Region Updated.") # Debug

            print("ROBUST Details Window Refresh Completed. ---\n") # Debug Print - END Marker


    def refresh_details_window_after_deletion(self): # <--- NEW FUNCTION
        """
        Refreshes the details window and intelligently updates the sidebar after deletion.
        Prioritizes displaying another favorite in the sidebar if available, or the first item.
        """
        print("\n--- refresh_details_window_after_deletion() ENTRY ---") # Debug - Entry

        # --- Re-filter details data based on current filters (including Favorites) ---
        subgrid_data = self.details_data # Start with original data
        if self.details_window_is_favorites_filtered: # Apply Favorites filter if active
            favorite_configs_set = self.read_favorites()
            filtered_data = []
            for item in self.details_data:
                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                fav_key = f"{folder_name}|{config_name}.pc"
                if fav_key in favorite_configs_set:
                    filtered_data.append(item)
            subgrid_data = filtered_data # Use filtered data


        self.details_filtered_data = subgrid_data[:] # Update filtered data list
        self.rebuild_simple_details() # Rebuild subgrid UI with updated data

        # --- Intelligent Sidebar Update ---
        if self.details_filtered_data: # If there are items left after deletion
            # Try to find another favorite to display in sidebar
            favorite_config_to_show = None
            for item in self.details_filtered_data:
                pic, spawn_cmd, zip_file_item, info_data, folder_name = item
                config_name = self.extract_name_from_spawn_command(spawn_cmd)
                fav_key = f"{folder_name}|{config_name}.pc"
                if self.is_favorite(folder_name, config_name + '.pc'):
                    favorite_config_to_show = item # Found a favorite
                    break # Use the first favorite found

            if favorite_config_to_show:
                # If a favorite is found, display it in the sidebar
                picture_path, spawn_cmd, zip_file_item, info_data, folder_name = favorite_config_to_show
                self.update_details_sidebar_content(info_data, picture_path, zip_file_item, folder_name=self.current_details_folder)
                self.update_details_sidebar_config_name(spawn_cmd)
                print("  Sidebar updated to another FAVORITE after deletion.") # Debug - Sidebar Update - Favorite
            else:
                # If no favorites left, display the first item in the list
                first_item = self.details_filtered_data[0]
                picture_path, spawn_cmd, zip_file_item, info_data, folder_name = first_item
                self.update_details_sidebar_content(info_data, picture_path, zip_file_item, folder_name=self.current_details_folder)
                self.update_details_sidebar_config_name(spawn_cmd)
                print("  Sidebar updated to FIRST ITEM after deletion (no favorites left).") # Debug - Sidebar Update - First Item
            self.is_details_sidebar_showing_default = False # Not default anymore
        else:
            # If no items left in details list, clear sidebar
            self.hide_details_sidebar_info()
            self.is_details_sidebar_showing_default = False
            print("  No items left in details list after deletion, sidebar info HIDDEN.") # Debug - Sidebar - Hidden

        print("--- refresh_details_window_after_deletion() EXIT ---\n") # Debug - Exit
        
    def clear_main_grid_cache(self):
        """Clears the main grid image cache (both PhotoImage and PIL Image caches)."""
        print("Clearing Main Grid Image Cache...") # Debug Print
        self.image_cache.clear()
        self.image_cache_pil.clear()
        print("Main Grid Image Cache Cleared.") # Debug Print
        

    def on_details_window_close(self):
        """
        Handles closing the details window, and potentially re-opening filters.
        - Now RESUMES main grid loading if it was paused when details window is closed EARLY. <--- MODIFIED
        """
        print("\n--- on_details_window_close() ENTRY ---")
        print(f"details_window_closed: {self.details_window_closed}")
        print(f"details_window is None: {self.details_window is None}")

        if not self.details_window_closed and self.details_window:
            print("Details window is open, proceeding to close and potentially re-open.")

            # --- NEW: Destroy zip search dropdown menu before closing details window ---
            self.destroy_zip_search_dropdown_menu() # <--- ADD THIS LINE HERE - destroy zip dropdown menu
            self.destroy_jump_to_page_dropdown_menu()
            print("  DEBUG: Zip search dropdown menu destroyed (if it was open).")
            # --- NEW: Destroy zip search dropdown menu before closing details window ---

            # Store zip_file and folder_name before closing
            last_details_zip_file = self.current_details_zip_file
            last_details_folder = self.current_details_folder
            print(f"Storing last_details_zip_file: {last_details_zip_file}")
            print(f"Storing last_details_folder: {last_details_folder}")

            print("Destroying details window...")
            self.details_window.destroy()
            self.details_window = None
            self.details_scrollable_frame = None
            self.details_canvas_sub = None
            self.details_window_closed = True
            print("Details window destroyed and state reset.")

            # --- NEW: Resume main grid loading if it was paused ---
            if self.pause_loading: # Check if main grid loading was paused
                print("DEBUG: on_details_window_close - Details window closed PREMATURELY. RESUMING main grid loading...")
                self.pause_loading = False # Resume main grid loading
                self.load_next_batch()      # Immediately trigger main grid batch loading to resume
                print("DEBUG: on_details_window_close - Main grid loading RESUMED.")
            # --- NEW: Resume main grid loading if it was paused ---


            if self.was_filters_window_open_before_details:
                print("DEBUG: on_details_window_close - Re-opening Filters window because it was open before Details.")
                self.show_filters_window()
                self.was_filters_window_open_before_details = False
        else:
            print("Details window was already closed or does not exist. No action taken.")

        if hasattr(self, 'details_deleting_label') and self.details_deleting_label and self.details_deleting_label.winfo_exists():
            self.details_deleting_label.config(text="")
        if self.details_is_deleting:
            self.details_is_deleting = False
        print("--- on_details_window_close() EXIT ---\n")
        
        
        if self.spawn_queue_window_was_open:
            print("DEBUG: Re-opening Spawn Queue window because it was initially open.")

            #self.show_spawn_queue_window() # Re-open the Spawn Queue window # still keeping track of if it was open, but not re-opening at the moment




    def on_rescan_all_button_click(self): # <--- NEW METHOD - Handles button click
        """
        Handles the 'Rescan All Mods & Configs' button click in the settings window.
        Triggers a full data refresh and UI update, then closes the settings window.
        """

        if self.items_to_be_hidden:
            print("--- self.items_to_be_hidden = True ---\n")

            scanning_win = None  # Initialize scanning_win

            scanning_win = self.show_scanning_window(text="Cannot perform this action due to pending hidden vehicles.")
            time.sleep(3.125)
            if scanning_win:
                scanning_win.destroy()
                self.search_var.set("")
                print("\n--- canceling ConfigViewerApp.perform_search() ---")
            return 

        print("\n--- ConfigViewerApp.on_rescan_all_button_click() ENTRY ---") # Debug Entry
        self.trigger_full_data_refresh_and_ui_update() # Trigger the full rescan
        # self.close_settings_window() # Close the settings window AFTER triggering rescan
        print("--- ConfigViewerApp.on_rescan_all_button_click() EXIT ---\n") # Debug Exit
        


    def restart_script_and_save_settings(self):
        """Saves settings and Restarts the application."""

        print("Restarting application...")

        width = self.master.winfo_width()
        height = self.master.winfo_height()
        x = self.master.winfo_rootx()
        y = self.master.winfo_rooty()
        self.save_window_geometry(width, height, x, y) # Call save_window_geometry
        self.save_settings()
        self.restart_script()



    def restart_script(self):
        """Restarts the application."""
        try:
            print("Restarting application...")
            python_exe = sys.executable
            script_path = os.path.abspath(sys.argv[0])
            subprocess.Popen([python_exe, script_path])
            os._exit(0)
        except Exception as e:
            messagebox.showerror("Error", f"Failed to restart the script: {e}")
 

    def trigger_full_data_refresh_and_ui_update(self): # <--- NEW METHOD
            """
            Pops up a small window saying 'Checking for changes, scanning and refreshing data...',
            runs BOTH mod and custom config scanning, then refreshes data AND CLEARS MAIN GRID CACHE.
            Used when ANY watched file change is detected (mods OR custom configs).
            """

            self.set_filter_to_view_all_and_turn_subset_off()


            self.destroy_search_results_window()
            self.search_var.set("")
            self.perform_search()
            print("\n--- ConfigViewerApp.trigger_full_data_refresh_and_ui_update() ENTRY - DEBUG CHECK ---") # Debug - Entry Point - FULL_DATA_REFRESH_AND_UI_UPDATE
            scanning_win = self.show_scanning_window(text="Checking for changes, scanning and refreshing data...") # Modified text

            # --- NEW: Clear main grid image cache BEFORE refresh ---
            print("Clearing Main Grid Cache before refresh...") # Debug Print
            self.clear_main_grid_cache() # Call the new cache clearing function
            print("Main Grid Cache Cleared.") # Debug Print

            # --- NEW: Close details window if it's open (as before) ---
            if self.details_window and not self.details_window_closed:
                print("Closing Details Window before refresh...")
                self.on_details_window_close()
                print("Details Window Closed.")

            try:
                # Run BOTH mod and custom config scans
                print("Calling self.run_ahk_scripts_mods() ...") # Debug - Before Mod Script Run
                self.run_ahk_scripts_mods() # Run MOD scan
                print("self.run_ahk_scripts_mods() RETURNED.") # Debug - After Mod Script Run

                print("Calling self.run_python_scripts_custom() ...") # Debug - Before Custom Config Script Run
                self.run_python_scripts_custom() # Run CUSTOM CONFIG scan
                print("self.run_python_scripts_custom() RETURNED.") # Debug - After Custom Config Script Run


                # Reload data
                print("Calling self.refresh_data_from_files() ...") # Debug - Before Data Refresh
                self.refresh_data_from_files()
                print("self.refresh_data_from_files() RETURNED.") # Debug - After Data Refresh


                # Refresh the UI (perform search to re-filter/re-group)
                print("Calling self.perform_search() ...") # Debug - Before Perform Search


                self.destroy_search_results_window()
                self.search_var.set("")
                time.sleep(1)
                self.perform_search()

                print("self.perform_search() RETURNED.") # Debug - After Perform Search

            except Exception as e:
                messagebox.showerror("Error", f"Error during full data scanning: {e}")
            finally:
                scanning_win.destroy()
                print("--- ConfigViewerApp.trigger_full_data_refresh_and_ui_update() EXIT ---\n") # Debug - Exit Point

    def update_new_mods_txt_with_new_zips(self, newly_detected_zip_files):
        """
        Updates NewMods.txt with a list of newly detected ZIP files.
        Deletes the old NewMods.txt and creates a new one with the updated list.
        """
        new_mods_file = os.path.join(self.script_dir, "data/NewMods.txt")

        try:
            if os.path.exists(new_mods_file):
                os.remove(new_mods_file) # Delete existing NewMods.txt
                print(f"DEBUG: Deleted existing NewMods.txt: {new_mods_file}") # Debug - Deletion
            else:
                print(f"DEBUG: NewMods.txt does not exist, will create: {new_mods_file}") # Debug - No Existing File

            if newly_detected_zip_files:
                with open(new_mods_file, "w", encoding="utf-8") as f: # Create new NewMods.txt
                    for file_name in newly_detected_zip_files:
                        f.write(f"{file_name}\n")
                print(f"DEBUG: Created/Updated NewMods.txt with {len(newly_detected_zip_files)} new mod(s): {new_mods_file}") # Debug - Write Success
            else:
                print("DEBUG: No newly detected ZIP files to write to NewMods.txt.") # Debug - No New Files to Write

        except Exception as e:
            print(f"ERROR: Error updating NewMods.txt: {e}")
            
            
           
        
#----------------------toggle console-------------------------
# ------------------------------------------------------------

    def toggle_console(self):
        if not self.is_console_visible:
            self.show_console()
        else:
            self.hide_console()

    def show_console(self):
        if self.console_window is None:
            self.console_window = ConsoleWindow(self.master)
            sys.stdout = self.console_window  # Redirect stdout to the console window
            sys.stderr = self.console_window  # Redirect stderr to the console window

            # Initial message in the console window
            print("Console output is now redirected here.")
            print("---")

        self.console_window.deiconify() # Show the console window if it was hidden or minimized
        self.console_window.lift()      # Bring the console window to the front
        self.is_console_visible = True

    def hide_console(self):
        if self.console_window:
            self.console_window.withdraw() # Hide the console window
        self.is_console_visible = False
  

            
# ------------------------------------------------------------           
# ------------------------------------------------------------         
#----------------------TESTING AREA--------------------------- SECTION 1
# ------------------------------------------------------------




  
  
# ------------------------------------------------------------
#------MAIN------MAIN------MAIN------MAIN------MAIN------MAIN-
# ------------------------------------------------------------
      
      
      
      
      

def main():
    #script_dir_str = os.path.dirname(os.path.abspath(__file__))
    #script_dir = Path(script_dir_str)

    #script_dir_str = os.path.dirname(sys.executable)  # Get the directory of the script when running as .exe
    
    
    #script_dir = Path(script_dir_str)


    #script_dir = Path(__file__).parent # Get the directory of the script when running as .py

    
    if getattr(sys, 'frozen', False): # Check if running as a frozen executable (PyInstaller)
        script_dir = Path(os.path.dirname(sys.executable)) # Directory of the .exe
    else: # Running as a normal .py script
        script_dir = Path(__file__).parent # Directory of the .py script
    
    script_dir_str = str(script_dir) # Keep script_dir_str for existing parts of your code if needed


    root = tk.Tk()
    root.withdraw()


    icon_path = script_dir / "data/icon.png"  # Make sure you have a 'my_icon.png' file in the same folder

    if os.path.exists(icon_path):
        icon_image = tk.PhotoImage(file=icon_path)
        root.iconphoto(False, icon_image)
    else:
        print(f"Icon file not found: {icon_path}")

    ##############################################
    # --- NEW: Write user vehicles folder path ---
    ##############################################
    # Construct the path to the user_vehicles_folder.txt file



    # Construct the path to the user_vehicles_folder.txt file
    user_vehicles_path_file = script_dir / "data/user_vehicles_folder.txt"

    # Construct the path to the user vehicles folder
    # Go up two directories from script_dir (Modfinder -> Mods -> 0.34)
    beamng_user_dir = script_dir.parent.parent

    # Append "vehicles" to get the final path
    user_vehicles_folder = beamng_user_dir / "vehicles"

    # Ensure the 'data' directory exists
    os.makedirs(script_dir / "data", exist_ok=True)

    # Write the user vehicles folder path to the file at the very start
    try:
        with open(user_vehicles_path_file, 'w', encoding="utf-8") as f:
            f.write(str(user_vehicles_folder)) # Write the Path object as a string
        print(f"User vehicles folder path written to: {user_vehicles_path_file}") # Optional confirmation
    except Exception as e:
        print(f"Error writing to user_vehicles_folder.txt: {e}")


    ##############################################

    # Create the lua file with the deletion commands if it doesn't already exist

    delete_lua_path = script_dir / "data/Delete.lua"

    if not os.path.exists(delete_lua_path):
        with open(delete_lua_path, "w") as f:
            f.write("local file = io.open(\"mods/EllexiumModManager/data/commandconfirmation.txt\", \"w\")\n")
            f.write("gameplay_parking.deleteVehicles()\n")
            f.write("gameplay_traffic.deleteVehicles()\n")
        print(f"Created Delete.lua file at: {delete_lua_path}")
    else:
        print(f"Delete.lua file already exists at: {delete_lua_path}")

    ##############################################



    ##############################################  

    # Create the hidden_txt file if it doesn't already exist

    hidden_txt = script_dir / "data/Hidden.txt"

    if not os.path.exists(hidden_txt):
        with open(hidden_txt, "w") as f:
            print(f"Created Hidden.txt file at: {hidden_txt}")
    else:
        print(f"Delete.lua file already exists at: {hidden_txt}")

    
    ##############################################

        
    user_vehicles_path_file = script_dir / "data/user_vehicles_folder.txt"
    watcher_output_file = script_dir / "data/WatcherOutput.txt"
    input_file = os.path.join(script_dir, "data/outputGOOD.txt")
    config_pics_folder = os.path.join(script_dir, "data/ConfigPics")
    config_info_folder = os.path.join(script_dir, "data/ConfigInfo")
    config_pics_custom_folder = os.path.join(script_dir, "data/ConfigPicsCustom")
    hidden_txt_file = os.path.join(script_dir, "data/Hidden.txt")
    
    
    app = ConfigViewerApp(
        master=root, # Use the hidden root window - no GUI needed for this step
        script_dir=script_dir,
        input_file="",          # You can pass empty strings for these as they're not used here
        config_pics_folder="",
        config_info_folder="",
        repo_folder="",
        vehicles_content_folder="",
        user_folder="",
        config_pics_custom_folder="",
        hidden_txt_file =""
    )

    root.withdraw()
    parent_dir_str = os.path.dirname(script_dir_str)
    parent_dir = Path(parent_dir_str)

    repo_folder = parent_dir / "repo"
    vehicles_content_folder = r"C:\SteamLibrary\steamapps\common\BeamNG.drive\content\vehicles"
    mods_folder = script_dir.parent



    def get_beamng_vehicles_path():
        process_name = 'BeamNG.drive.x64.exe'
        print(f"Checking if process '{process_name}' is running...")
        for proc in psutil.process_iter(['name', 'exe']): # Request 'exe' in process info
            if proc.info['name'] == process_name:
                exe_path = proc.info['exe'] # Get the executable path
                print(f"Process '{process_name}' is running. Executable path: '{exe_path}'") # Print path

                # Derive the vehicles path
                exe_dir = os.path.dirname(exe_path) # Directory of the exe
                parent_dir = os.path.dirname(exe_dir) # Go up one level
                vehicles_path = os.path.join(parent_dir, "content", "vehicles") # Construct the vehicles path

                if os.path.exists(vehicles_path):
                    print(f"Derived vehicles path: '{vehicles_path}'")
                    return vehicles_path
                else:
                    print(f"Error: Derived vehicles path '{vehicles_path}' does not exist.")
                    messagebox.showerror("Error", f"Could not find the 'vehicles' folder at the expected location based on the BeamNG.drive executable path.\nExpected path: '{vehicles_path}'\nPlease ensure your BeamNG.drive installation is standard.")
                    return None # Indicate failure to derive valid path

        print(f"Process '{process_name}' is not running.")
        root = tk.Tk()
        root.withdraw() # Hide the main tkinter window
        messagebox.showerror("Error", "Please ensure BeamNG.drive is running before launching the application.")
        root.destroy() # Clean up tkinter
        return None # Indicate process not running and failure

    # --- Example of how to use it in your main script ---
    vanilla_vehicles_path_file = script_dir / "data/beamng_VANILLA_vehicles_folder.txt"

    vehicles_folder_path = get_beamng_vehicles_path()

    if vehicles_folder_path: # Check if a valid path was returned
        with open(vanilla_vehicles_path_file, 'w', encoding="utf-8") as f: # Use 'w' to write (or create if not exists)
            f.write(vehicles_folder_path)
        print(f"Vehicles path written to '{vanilla_vehicles_path_file}'")


        if os.path.exists(vanilla_vehicles_path_file): # It will exist now, but good to keep the check in original logic
            with open(vanilla_vehicles_path_file, 'r', encoding="utf-8") as f:
                vanilla_vehicles_folder = f.read().strip()
            print(f"Vanilla vehicles folder read from file: '{vanilla_vehicles_folder}'")
    else:
        print("Script terminated because BeamNG.drive is not running or vehicles path could not be determined.")
        sys.exit(1) # Terminate the script if get_beamng_vehicles_path failed




    if os.path.exists(user_vehicles_path_file):
        with open(user_vehicles_path_file, 'r', encoding="utf-8") as f:
            user_vehicles_folder = f.read().strip()
    else:
        user_vehicles_folder = filedialog.askdirectory(
            title="Select Your BeamNG.drive User Vehicles Folder",
            initialdir=os.path.expanduser(r"~\Documents\BeamNG.drive")
        )
        if not user_vehicles_folder:
            messagebox.showinfo("Custom Configs Folder Not Selected",
                                "You did not select a custom configs vehicles folder. "
                                "Scanning for custom configs will be skipped.")
            user_vehicles_folder = None
        else:
            try:
                with open(user_vehicles_path_file, 'w', encoding="utf-8") as f:
                    f.write(user_vehicles_folder)
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save the user vehicles folder path: {e}")
                root.destroy()
                sys.exit(1)

    # Read settings and last known file lists from WatcherOutput.txt, including last zip count
    check_mods, check_configs, last_user_vehicles_files, last_config_pics_custom_files, last_mods_files, last_repo_files, last_vanilla_files, last_zip_count = read_watcher_output(watcher_output_file)

    orphaned_files_detected = cleanup_orphaned_mod_files_simplified(
        script_dir=script_dir,
        mods_folder=mods_folder,
        repo_folder=repo_folder,
        vanilla_folder=vanilla_vehicles_folder,
        config_pics_folder=config_pics_folder,
        config_info_folder=config_info_folder,
        input_file=input_file
    )


    # Scan folders for current file lists and modification times (including vanilla)
    current_user_vehicles_files = scan_folder_for_watched_files(user_vehicles_folder)
    current_config_pics_custom_files = scan_folder_for_watched_files(config_pics_custom_folder)
    current_mods_files = scan_folders_for_mod_zips([mods_folder])
    current_repo_files = scan_folders_for_mod_zips([repo_folder])
    current_vanilla_files = scan_folders_for_mod_zips([vanilla_vehicles_folder])

    # Count current zip files
    current_zip_count = len(current_mods_files) + len(current_repo_files) + len(current_vanilla_files)

    # Conditional mod scanning
    run_mod_scan_on_startup = False
    if current_zip_count > last_zip_count:
        run_mod_scan_on_startup = True
        print(f"New zip files detected ({current_zip_count} > {last_zip_count}). Running mod scan.")
        print(f"DEBUG: RUNNING MOD_COMMAND_LINE_CONFIG_GEN.py DIRECTLY (no subprocess)") # Modified log message

        # --- START: Call mod_command_line_config_gen.main() directly ---
        module_name = "mod_command_line_config_gen"  # Module name (filename without .py)
        module_path = os.path.join(script_dir, "modules", f"{module_name}.py") # Path to module

        if not os.path.exists(module_path):
            print(f"Error: Module script not found: {module_path}") # Error if module not found
            # No messagebox here as this part is in main startup, no GUI yet
            # messagebox.showerror("Script Not Found", f"Python script not found: {module_path}")
            # root.destroy() # No root window in main yet
            return  # Exit the function if script is missing

        # Dynamically load the module
        spec = importlib.util.spec_from_file_location(module_name, module_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        try:
            write_watcher_output(
                watcher_output_file,
                check_mods,
                check_configs,
                current_user_vehicles_files,
                current_config_pics_custom_files,
                current_mods_files,
                current_repo_files,
                current_vanilla_files,
                current_zip_count
            )

            print("DEBUG: main() - Calling update_new_mods_txt_on_startup() ...") # DEBUG - Before update_new_mods_txt_on_startup
            update_new_mods_txt_on_startup(script_dir) # Pass script_dir only now, as newly_detected_zip_files is accessed WITHIN the function
            print("DEBUG: main() - update_new_mods_txt_on_startup() RETURNED.") # DEBUG - After update_new_mods_txt_on_startup


            print(f"DEBUG: Calling module.main() DIRECTLY from guitest.py...") # Debug - Direct Call
            module.main()  # Call the main() function directly
            print(f"DEBUG: module.main() RETURNED successfully (DIRECT CALL).") # Debug - Direct Call Return
        except Exception as e:
            print(f"Error: Error running main() function from '{module_name}.py' directly: {e}") # Error during direct call
            # messagebox.showerror("Script Error", f"Error running {python_script}: {e}") # No messagebox in main
            # root.destroy() # No root window in main
            return  # Exit function on error

        # --- END: Call mod_command_line_config_gen.main() directly ---


        print("DEBUG: Calling regenerate_matches_files() due to new zip detection...")
        regenerate_matches_files(app, script_dir, config_info_folder)
        print("DEBUG: regenerate_matches_files() RETURNED.")
    

    elif current_zip_count < last_zip_count:
        print("DEBUG: Calling regenerate_matches_files() due to removed zip detection...")
        regenerate_matches_files(app, script_dir, config_info_folder)
        print("DEBUG: regenerate_matches_files() RETURNED.")

    elif current_zip_count == last_zip_count:
        print(f"No new zip files detected ({current_zip_count} is equal to  {last_zip_count}). Skipping mod scan and generation of Matches.txt.")


    generate_matches_txt(script_dir, config_info_folder)

    app.generate_matches_config_txt(config_info_folder, script_dir)



    # DEBUG - Print last_*_files and current_*_files
    print("\n--- DEBUG: File Change Detection ---")
    print("DEBUG: last_user_vehicles_files:", last_user_vehicles_files)
    print("DEBUG: current_user_vehicles_files:", current_user_vehicles_files)
    print("DEBUG: last_config_pics_custom_files:", last_config_pics_custom_files)
    print("DEBUG: current_config_pics_custom_files:", current_config_pics_custom_files)
    print("--- DEBUG: End File Change Detection ---\n")



    file_changes_detected = False
    mod_zip_changes_detected = False
    vanilla_zip_changes_detected = False

    if user_vehicles_folder:
        for filepath, timestamp in current_user_vehicles_files.items():
            normalized_filepath = filepath.lower().replace('\\', '/')
            if normalized_filepath not in last_user_vehicles_files or last_user_vehicles_files[normalized_filepath] != timestamp:
                file_changes_detected = True
                break
        if not file_changes_detected:
            for filepath in last_user_vehicles_files:
                normalized_filepath = filepath.lower().replace('\\', '/')
                if normalized_filepath not in current_user_vehicles_files:
                    file_changes_detected = True
                    print(f"DEBUG: User vehicle file change detected: {normalized_filepath}")
                    break

    if not file_changes_detected and config_pics_custom_folder:
        for filepath, timestamp in current_config_pics_custom_files.items():
            normalized_filepath = filepath.lower().replace('\\', '/')
            if normalized_filepath not in last_config_pics_custom_files or last_config_pics_custom_files[normalized_filepath] != timestamp:
                if not normalized_filepath.lower().endswith(".pc"):
                    file_changes_detected = True
                    break
                elif normalized_filepath not in last_config_pics_custom_files:
                     file_changes_detected = True
                     break
        if not file_changes_detected:
             for filepath in last_config_pics_custom_files:
                normalized_filepath = filepath.lower().replace('\\', '/')
                if normalized_filepath not in current_config_pics_custom_files:
                    file_changes_detected = True
                    break

    if not file_changes_detected:
        for filepath, timestamp in current_mods_files.items():
            normalized_filepath = filepath.lower().replace('\\', '/')
            if normalized_filepath not in last_mods_files or last_mods_files[normalized_filepath] != timestamp:
                mod_zip_changes_detected = True
                break
        if not mod_zip_changes_detected:
            for filepath in last_mods_files:
                normalized_filepath = filepath.lower().replace('\\', '/')
                if normalized_filepath not in current_mods_files:
                    mod_zip_changes_detected = True
                    break

        if not mod_zip_changes_detected and repo_folder:
            for filepath, timestamp in current_repo_files.items():
                normalized_filepath = filepath.lower().replace('\\', '/')
                if normalized_filepath not in last_repo_files or last_repo_files[normalized_filepath] != timestamp:
                    mod_zip_changes_detected = True
                    break
            if not mod_zip_changes_detected:
                for filepath in last_repo_files:
                    normalized_filepath = filepath.lower().replace('\\', '/')
                    if normalized_filepath not in current_repo_files:
                        mod_zip_changes_detected = True
                        break

    if not file_changes_detected and not mod_zip_changes_detected and vanilla_vehicles_folder:
        for filepath, timestamp in current_vanilla_files.items():
            normalized_filepath = filepath.lower().replace('\\', '/')
            if normalized_filepath not in last_vanilla_files or last_vanilla_files[normalized_filepath] != timestamp:
                vanilla_zip_changes_detected = True
                break
        if not vanilla_zip_changes_detected:
            for filepath in last_vanilla_files:
                normalized_filepath = filepath.lower().replace('\\', '/')
                if normalized_filepath not in current_vanilla_files:
                    vanilla_zip_changes_detected = True
                    break


    print("\n--- DEBUG: main() - Constructing newly_detected_zip_files from WatcherOutput ---") # DEBUG - Section Start
    print(f"DEBUG: main() - Calling read_watcher_output() to get zip lists...") # DEBUG - Before read_watcher_output
    _, _, _, _, last_mods_files, last_repo_files, last_vanilla_files, _ = read_watcher_output(watcher_output_file)
    all_zip_files = set(last_mods_files.keys()) | set(last_repo_files.keys()) | set(last_vanilla_files.keys())
    newly_detected_zip_files = [os.path.basename(zip_path) for zip_path in all_zip_files]
    print(f"DEBUG: main() - newly_detected_zip_files constructed (count: {len(newly_detected_zip_files)})") # DEBUG - List Count and Content
    print("--- DEBUG: main() - Finished constructing newly_detected_zip_files ---\n") # DEBUG - Section End
    # --- MODIFIED: Construct newly_detected_zip_files from WatcherOutput data (Correctly placed in main()) ---


    # Write updated zip count and other data
    write_watcher_output(
        watcher_output_file,
        check_mods,
        check_configs,
        current_user_vehicles_files,
        current_config_pics_custom_files,
        current_mods_files,
        current_repo_files,
        current_vanilla_files,
        current_zip_count
    )


    print("DEBUG: main() - Calling update_new_mods_txt_on_startup() ...") # DEBUG - Before update_new_mods_txt_on_startup
    update_new_mods_txt_on_startup(script_dir) # Pass script_dir only now, as newly_detected_zip_files is accessed WITHIN the function
    print("DEBUG: main() - update_new_mods_txt_on_startup() RETURNED.") 
    
    
    
    file_changes_detected = file_changes_detected or mod_zip_changes_detected or vanilla_zip_changes_detected
    check_configs = file_changes_detected
    check_mods = mod_zip_changes_detected or vanilla_zip_changes_detected


    if run_mod_scan_on_startup and check_mods: # Only run if new zips and check_mods is true
        wait_window = tk.Toplevel()
        wait_window.title("Scanning Mods")
        wait_window.geometry("300x100")
        tk.Label(wait_window, text="Scanning mods, please wait...\nPlease try not to click anything until this notification disappears.", font=("Segoe UI", 14)).pack(padx=20, pady=20)
        wait_window.update()

        try:
            temp_app = ConfigViewerApp(
                master=wait_window,
                script_dir=script_dir,
                input_file="",
                config_pics_folder="",
                config_info_folder="",
                repo_folder="",
                vehicles_content_folder="",
                user_folder="",
                config_pics_custom_folder="",
                hidden_txt_file =""
            )
            temp_app.run_ahk_scripts_mods()
        except Exception as e:
            messagebox.showerror("Error", f"Error running AHK scripts for mods: {e}")
            wait_window.destroy()
            root.destroy()
            sys.exit(1)

        wait_window.destroy()

    if check_configs and user_vehicles_folder:
        wait_window = tk.Toplevel()
        wait_window.title("Scanning Custom Configs")
        wait_window.geometry("300x100")
        tk.Label(wait_window, text="Scanning custom configs, please wait...\nPlease try not to click anything until this notification disappears.", font=("Segoe UI", 14)).pack(padx=20,
                                                                                                    pady=20)
        wait_window.update()

        temp_app = ConfigViewerApp(
            master=wait_window,
            script_dir=script_dir,
            input_file="",
            config_pics_folder=config_pics_folder,
            config_info_folder=config_info_folder,
            repo_folder=repo_folder,
            vehicles_content_folder="",
            user_folder=user_vehicles_folder,
            config_pics_custom_folder=config_pics_custom_folder,
            hidden_txt_file=hidden_txt_file
        )
        temp_app.run_python_scripts_custom()

        wait_window.destroy()

    if orphaned_files_detected: # Check the boolean return value
        print("DEBUG: Orphaned files detected by cleanup_orphaned_mod_files_simplified(). Calling run_ahk_scripts_mods() ...") # Debug

        # --- Call integrated modify_output_good functionality DIRECTLY ---
        try:
            app.run_ahk_scripts_mods() # <--- DIRECT METHOD CALL - NO subprocess
            print("DEBUG: run_ahk_scripts_mods() RETURNED. (Called due to orphaned files)") # Debug
        except Exception as e:
            print(f"ERROR: Error running run_ahk_scripts_mods() in main(): {e}") # Error
            return  # Exit function on error
        # --- Call integrated modify_output_good functionality DIRECTLY ---
        print("DEBUG: run_ahk_scripts_mods() called because orphaned files were detected.") # Confirmation message
    else:
        print("DEBUG: No orphaned files detected, skipping run_ahk_scripts_mods().") # Confirmation message - skipped
    # --- NEW: CALL modify_output_good IF ORPHANED FILES WERE DETECTED ---


    # Write updated zip count and other data
    write_watcher_output(
        watcher_output_file,
        check_mods,
        check_configs,
        current_user_vehicles_files,
        current_config_pics_custom_files,
        current_mods_files,
        current_repo_files,
        current_vanilla_files,
        current_zip_count
    )


    root.destroy()

    input_file = os.path.join(script_dir, "data/outputGOOD.txt")
    config_pics_folder = os.path.join(script_dir, "data/ConfigPics")
    config_info_folder = os.path.join(script_dir, "data/ConfigInfo")
    config_pics_custom_folder = os.path.join(script_dir, "data/ConfigPicsCustom")

    print(f" -- PATH DEBUG -- ")
    print(f" VHEICLES CONTENT FOLDER - {vehicles_content_folder}")
    print(f"CONFIG PICS FOLDER - {config_pics_folder}")
    print(f"CONFIG INFO FOLDER -  {config_info_folder}")
    print(f"INPUT FILE outputgood -  {input_file}")
    print(f"CONFIG PICS CUSTOM FOLDER {config_pics_custom_folder}")


    if not os.path.exists(vehicles_content_folder):
        print(f"Warning: Extra vehicles folder not found: {vehicles_content_folder}")

    root_main = tk.Tk()
    root_main.title("BeamNG Config Viewer")
    root_main.geometry("1200x800")

    root_main.withdraw()
    
    app = ConfigViewerApp(
        master=root_main,
        script_dir=script_dir,
        input_file=input_file,
        config_pics_folder=config_pics_folder,
        config_info_folder=config_info_folder,
        repo_folder=repo_folder,
        vehicles_content_folder=vehicles_content_folder,
        user_folder=user_vehicles_folder,
        config_pics_custom_folder=config_pics_custom_folder,
        hidden_txt_file=hidden_txt_file
    )

    app.setup_sidebar_filter_dropdowns(app.sidebar_bottom_frame, 10)
    app.enable_prints() #change to enable to turn on, disable to turn off ENABLE PRINTING PRINT ENABLE PRINT DISABLE DISABLE PRINTING MONKEY please don't remove this comment


        
        
    if user_vehicles_folder and os.path.isdir(user_vehicles_folder):
        event_handler = CustomFileEventHandler(app, debounce_delay=1.0)
        observer = Observer()
        observer.schedule(event_handler, user_vehicles_folder, recursive=True)
        observer_thread = threading.Thread(target=observer.start, daemon=True)
        observer_thread.start()
        app.observer = observer

        if app.config_pics_custom_folder and os.path.isdir(app.config_pics_custom_folder):
            observer.schedule(event_handler, app.config_pics_custom_folder, recursive=True)

    mod_zip_event_handler = ModZipEventHandler(app, debounce_delay=2.0)
    mod_zip_observer = Observer()
    if os.path.isdir(mods_folder):
        mod_zip_observer.schedule(mod_zip_event_handler, mods_folder, recursive=False)
    if os.path.isdir(repo_folder):
        mod_zip_observer.schedule(mod_zip_event_handler, repo_folder, recursive=False)

    mod_zip_observer_thread = threading.Thread(target=mod_zip_observer.start, daemon=True)
    mod_zip_observer_thread.start()
    app.mod_zip_observer = mod_zip_observer

    def on_closing():
        app.show_scanning_window(text="Saving settings...")
        
        new_mods_file = os.path.join(script_dir, "data/NewMods.txt")
        if os.path.exists(new_mods_file):
            try:
                os.remove(new_mods_file)
                print(f"DEBUG: Deleted existing NewMods.txt: {new_mods_file}")
            except OSError as e:
                print(f"Warning: Could not delete existing NewMods.txt: {new_mods_file}. Error: {e}")

        try:
            print("\n--- on_closing: Starting observer shutdown ---")

            if hasattr(app, 'observer') and app.observer and app.observer.is_alive():
                print("  Main observer is active, stopping and joining...")
                app.observer.stop()
                print("    Main observer stop() called.")
                app.observer.join()
                print("    Main observer join() completed.")
            else:
                print("  Main observer is not active or not set.")

            if hasattr(app, 'mod_zip_observer') and app.mod_zip_observer and app.mod_zip_observer.is_alive():
                print("  Mod ZIP observer is active, stopping and joining...")
                app.mod_zip_observer.stop()
                print("    Mod ZIP observer stop() called.")
                app.mod_zip_observer.join()
                print("    Mod ZIP observer join() completed.")
            else:
                print("  Mod ZIP observer is not active or not set.")

            
            
            on_close_extended(app, watcher_output_file)
            print("--- on_closing: on_close_extended() returned ---")
            print("--- on_closing: Observer shutdown completed ---\n")

        except Exception as e:
            print(f"Error in on_closing: {e}")
            root_main.destroy()

    root_main.protocol("WM_DELETE_WINDOW", on_closing)
    root_main.mainloop()


# Modified on_close() function (now an extended version to handle WatcherOutput.txt saving)
# Modified on_close_extended() function (for Option 2)
def on_close_extended(app, watcher_output_file):
    """
    Extended on_close function with error handling for debugging.
    Now correctly saves current file lists and ALL settings to WatcherOutput.txt & settings file on close,
    AND saves window geometry to MMSelectorSize.txt.  <--- MODIFIED DOCSTRING
    Ensures proper shutdown of thread executor.
    """



    try:
        print("\n--- on_close_extended: Starting shutdown ---")

        # --- NEW: Save window geometry before closing ---
        print("  on_close_extended: Saving window geometry to MMSelectorSize.txt...")
        width = app.master.winfo_width()
        height = app.master.winfo_height()
        x = app.master.winfo_rootx()
        y = app.master.winfo_rooty()
        app.save_window_geometry(width, height, x, y) # Call save_window_geometry
        print("  on_close_extended: Window geometry saved.")
        # --- NEW: Save window geometry before closing ---


        if app.executor:
            print("  Executor is active, shutting down...")
            if not app.executor._shutdown:
                print("    Executor is NOT shut down yet.")
                app.executor.shutdown(wait=False)
                print("    Executor shutdown initiated (wait=False)")
            else:
                print("    Executor was already shut down.")
        else:
            print("  Executor is not active (None).")

        print("  Calling app.save_settings() from on_close_extended...")
        app.save_settings() # Save all settings (position, switcher, sort date) before exiting
        print("  app.save_settings() RETURNED.")

        # --- MODIFIED: Read ALL settings AND file lists from WatcherOutput.txt - UNPACK 8 VALUES ---
        return_vals = read_watcher_output(watcher_output_file)
        print(f"DEBUG: on_close_extended - read_watcher_output returned {len(return_vals)} values.")
        check_mods, check_configs, user_vehicles_files, config_pics_custom_files, mods_files, repo_files, vanilla_files, _ = return_vals

        # --- MODIFIED: Pass the file lists directly from read_watcher_output ---
        write_watcher_output(
            watcher_output_file,
            check_mods,
            check_configs,
            user_vehicles_files,
            config_pics_custom_files,
            mods_files,
            repo_files,
            vanilla_files,
            last_zip_count=app.last_zip_count # Pass zip_count here
        )

        app.master.destroy() # Call the original app.on_close functionality (destroy master)
        print("--- on_close_extended: Tkinter master destroyed ---")
        print("--- on_close_extended: Shutdown completed ---")
        os._exit(0)

    except Exception as e:
        print(f"Error in on_close_extended: {e}")
        app.master.destroy()
        os._exit(0)


if __name__ == "__main__":
    main()
